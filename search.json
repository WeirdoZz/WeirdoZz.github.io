[{"title":"DDG-DA:Data Distribution Generation for Predictable Concept Drift Adaptation","url":"/2022/03/28/DDG-DA-Data-Distribution-Generation-for-Predictable-Concept-Drift-Adaptation/","content":"<h2 id=\"摘要\">摘要</h2>\n<p>文章作者并不是顺着前人的思路做漂移检测和漂移适应，而是提出一个DDG-DA方法直接预测数据分布的变化并且改善模型的表现。具体来说就是，先训练一个预测器来估计未来的数据分布，然后使用它来生成样本，最后在生成的数据集上训练模型。</p>\n<p><a href=\"https://github.com/microsoft/qlib/tree/main/examples/benchmarks_dynamic/DDG-DA\">github链接</a></p>\n<span id=\"more\"></span>\n<h2 id=\"引言\">引言</h2>\n<p>之前的方法都是在检测到概念漂移之后对模型进行调整，但是这样的话就始终和概念漂移之间差了一个时间步，总是会慢半拍。但是其实实际上概念漂移的发生往往也是有迹可循的并不是完全随机。比如下图，作者绘制了三个现实任务的数据流轨迹：股价、电力负荷和太阳辐射照度。每个点都表示数据分布，其中按照时间对每个点进行了连线，我们发现大部分情况下数据分布的变化还是有规律的，不规律的漂移只是偶然发生。这样其实就是说存在预测概念漂移趋势的可能性。</p>\n<p><img src=\"https://i.imgur.com/HWf0230.png\" alt=\"picture 15\"></p>\n<p>本文注重于预测未来的数据分布，使用DDG-DA方法来预测下个时间步的数据分布，这样模型的下游学习任务能够在预测分布的数据样本上训练而不仅仅是知道要发生概念漂移。在实操中，DDG-DA被设计成一个动态的数据生成器，能够从过去数据中生成服从分布的数据。但是在现实中训练一个这样的能够最大化预测数据和真实数据相似度的数据生成器是难度很大的。为了解决这个问题，作者首先通过在数据分布下学习一个模型来表示数据分布，然后创建一个可微的分布距离来训练数据生成器。为了验证方法的有效性，作者还做了一个完整的理论分析来证明传统分布距离（比如kl散度）和本方法的等价。</p>\n<h2 id=\"方法设计\">方法设计</h2>\n<p><img src=\"https://i.imgur.com/M59yAlD.png\" alt=\"picture 1\"></p>\n<h3 id=\"总体设计\">总体设计</h3>\n<p>在上图中，训练数据和测试数据随着时间发生改变。对于每一个时间步t，任务$task^{(t)}:=(D_{train}^{(t)},D_{test}^{(t)})$目的是学习一个新的模型以调整当前在历史数据上训练的模型并且最小化$D_{test}^{(t)}$上的损失。模型可以根据内存大小在时间步t使用一个有限的$D_{train}^{(t)}$，它是从训练分布为$p_{train}^{t}(x,y)$的训练数据中取样来的，$D_{test}^{(t)}$是从分布为$p_{test}^{(t)}$的测试数据中取样来的。这两个分布可能是不同的，因此会对预测精度有不好的影响。</p>\n<p><strong>DDG-DA学习</strong>。 为了减小这种差距，DDG-DA(表示为$M_{\\Theta}$)尝试对概念漂移建模并且预测测试数据的分布$p_{test}^{(t)}(x,y)$。DDG-DA的框架已经在上图中解释了。DDG-DA就像一个加权数据采样器在$D_{train}^{(t)}$上进行重新采样并且创建一个新的训练数据集$D_{resam}^{(t)}(\\Theta)$，它的数据分布为$p_{resam}^{(t)}(x,y;\\Theta)$（也就是我们假设的测试集的数据分布）。DDG-DA会去最小化这个分布和真实的测试分布之间的差距。</p>\n<p>在DDG-DA的训练过程中，$M_{\\Theta}$在$task^{(t)} \\in Task_{train}$通过最小化预测分布和实际分布的差距来进行学习。从$Task_{train}$中学来的知识是用于转变成$Task_{Test}$中的新任务的。</p>\n<p><strong>DDG-DA预测</strong>。 预测模型是在训练数据上重新采样后的数据集上训练的，然后放到测试数据集上进行测试。训练集分布概率对于这个模型的精度是至关重要的，由于我们前面DDG-DA已经学到了一个最小化测试数据和重新采样数据分布之间差距的模式，所以该重新采样的数据相比于训练集应该更像测试集，所以在测试集上会有一个比较好的结果。</p>\n<p><strong>一个例子</strong>。作者举了一个股价趋势预测的场景。为了解决概念漂移，每个月都基于过去两年的历史数据重新训练一个模型。每次重新训练模型以解决概念漂移被称作一个task。比如，第一个任务$task^{(2011/01)}$包含了训练数据$D_{train}^{(2011/01)}$（包含2009/01-2010/12的数据）和一个月的测试数据$D_{test}^{(2011/01)}$。DDG-DA会在$D_{train}^{(2011/01)}$基础上创建一个$D_{resam}^{(2011/01)}(\\Theta)$用于训练预测模型。每个月都会产生一个新的task，这些task按照时间顺序排序并且以2016年作为分割，前面的相当于训练集，后面的相当于测试集。</p>\n<h3 id=\"模型设计和学习过程\">模型设计和学习过程</h3>\n<p><img src=\"https://i.imgur.com/CiLLHSG.png\" alt=\"picture 2\"></p>\n<h4 id=\"特征设计\">特征设计</h4>\n<p>历史数据的分布信息对于预测$D_{test}^{(t)}$的分布是很有用的，因此将他作为DDG-DA的输入。DDG-DA可以表示为$q_{train}^{(t)}=M_{\\Theta}(g(D_{train}^{(t)}))$。g是一个特征提取器，它将$D_{train}^{(t)}$作为输入并且输出历史数据分布信息。$M_{\\Theta}$使用提取后的信息然后输出重新采样的分布概率用于在$D_{train}^{(t)}$上采样。</p>\n<h4 id=\"目标函数\">目标函数</h4>\n<p>$M_{\\Theta}$接收提取后的特征然后输出分布概率。DDG-DA的学习目的就是最小化预测分布和真实分布差距。作者注重于最重要的漂移主体$p(y|x)$并且认为测试数据分布和重新采样的数据分布的差距次之。DDG-DA的损失可以表示为：</p>\n<p><img src=\"https://i.imgur.com/D4vfGYw.png\" alt=\"picture 3\"></p>\n<p>其中$D_{KL}$是KL散度。</p>\n<p>对于未知变量假设正态分布是合理的并且经常用于最大似然估计。在这种估计下，$p_{test}^{(t)}(y|x)=N(y_{test}^{(t)}(x),\\sigma)$并且$p_{resam}^{(t)}(y|x)=N(y_{resam}^{(t)}(x;\\Theta),\\sigma)$，其中$\\sigma$是常量。</p>\n<p>公式1中的resample的数据集的估计期望可以描述为</p>\n<p><img src=\"https://i.imgur.com/cUcBhVS.png\" alt=\"picture 4\"></p>\n<p>结合所有的训练任务的损失，DDG-DA的优化目标能够描述为</p>\n<p><img src=\"https://i.imgur.com/rf2t4TR.png\" alt=\"picture 5\"></p>\n<h4 id=\"优化\">优化</h4>\n<p>这一部分主要讲解公式2的优化过程。为了能够近似估计$y_{resam}^{(t)}(x;\\Theta)$，DDG-DA在$D_{sample}^{(t)(\\Theta)}$建立了一个回归代理模型$y_{proxy}(x;\\phi)^{(t)}$。代理模型的优化可以描述为</p>\n<p><img src=\"https://i.imgur.com/iZ5adHj.png\" alt=\"picture 6\"></p>\n<p>DDG-DA的学习过程就是一个两层优化问题。上层的目标是用$y_{proxy}(x;\\phi)^{(t)}$代替$y_{resam}^{(t)}(x;\\Theta)$。下层的优化公式4可以被视作一个约束项。</p>\n<p>DDG-DA的总体双层优化公式：</p>\n<p><img src=\"https://i.imgur.com/NDZeZhZ.png\" alt=\"picture 7\"></p>\n<p>其中$\\Theta$是DDG-DA的参数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">对于上面这些公式，其感性的理解就是，我们有一个DDG-DA模型，从已有的训练集中抽取一部分样本用它们的分布表示测试集的分布，</span><br><span class=\"line\"></span><br><span class=\"line\">然后怎么判断这个模型抽取的样本是不是准确呢？这时候就需要第二个模型，它学习我们重采样的数据的x-y的映射关系，</span><br><span class=\"line\"></span><br><span class=\"line\">这样将测试集中的所有的x输入得到y_hat，然后用y_hat和y放入损失函数，求得损失，再进行反向传播优化。</span><br></pre></td></tr></table></figure>\n<p>优化公式2的阻碍主要在于公式4的下级部分无法以封闭的形式解决。argmin通常来说是不可微的，这使得许多的优化算法（比如梯度下降）无法在公式4上进行优化。</p>\n<p>DDG-DA采用了一个使用封闭式解法的模型作为$y_{proxy}(x;\\phi)^{(t)}$。为了简单，作者选用了线性模型$h(x;\\phi_{(t)})=x\\phi^{(t)}$。$M_\\Theta$输出的$q_{train}^{(t)}$可以被视为学习预测模型时的重采样权重。公式4的损失函数就可以描述为：</p>\n<p><img src=\"https://i.imgur.com/ifbPBgr.png\" alt=\"picture 8\"></p>\n<p>其中$X^{(t)},y^{(t)},Q^{(t)}$是将多个样本连接起来的特征，标签和$D_{train}^{(t)}$上的重采样概率。</p>\n<p>这等价于一个权重线性回归，$\\phi^{(t)}$有一个正规化闭式解</p>\n<p><img src=\"https://i.imgur.com/rUC2pR1.png\" alt=\"picture 9\"></p>\n<p>这样公式4的闭式解使得分布距离可微。这样简单有效的优化算法就可以用来训练DDG-DA了。</p>\n<h2 id=\"实验\">实验</h2>\n<p>实验主要是回答两个问题：</p>\n<ol>\n<li>该模型在预测概念漂移上能够超过SOTA方法</li>\n<li>该模型能否在不同场景下生成不同的预测模型</li>\n</ol>\n<h3 id=\"实验结果\">实验结果</h3>\n<p>针对第一个问题，对于模型无关的方法，作者使用的是相同模型不同方法，得出实验结果如下</p>\n<p><img src=\"https://i.imgur.com/XkiqMMU.png\" alt=\"picture 10\"></p>\n<p>针对第二个问题，作者尝试了很多模型无关的方法进行不同场景和不同模型的预测比较，结果如下</p>\n<p><img src=\"https://i.imgur.com/5caxUkX.png\" alt=\"picture 11\"></p>\n","categories":["概念漂移"]},{"title":"GORM学习","url":"/2022/03/06/GORM%E5%AD%A6%E4%B9%A0/","content":"<h2 id=\"使用docker快速创建MySql实例\">使用docker快速创建MySql实例</h2>\n<p>首先需要安装docker，具体安装方法已经在<a href=\"https://weirdozz.github.io/2022/01/28/%E4%BD%BF%E7%94%A8golang+postgres+docker%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/\">使用golang+postgres+docker进行开发</a>中进行过讲述了。</p>\n<p>用如下命令创建一个容器环境</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run --name mysql8019 -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root1234 -d mysql:8.0.19</span><br></pre></td></tr></table></figure>\n<p>然后再启动一个<code>MySQL Client</code>连接到上面的环境</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -it --network host --rm mysql mysql -h127.0.0.1 -P13306 --default-character-set=utf8mb4 -uroot -p</span><br></pre></td></tr></table></figure>\n<p>然后在环境中创建一个数据库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE DATABASE db1;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<h2 id=\"使用GORM操作MySQL\">使用GORM操作MySQL</h2>\n<p>以下是对数据库中表的增删改查</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    db, err := gorm.Open(<span class=\"string\">&quot;mysql&quot;</span>, <span class=\"string\">&quot;root:123@(127.0.0.1:13306)/db1?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> db.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建表 自动迁移（把结构体和数据表进行对应）</span></span><br><span class=\"line\">    db.AutoMigrate(&amp;UserInfo&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建记录</span></span><br><span class=\"line\">    u1 := UserInfo&#123;</span><br><span class=\"line\">        <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;weirdo&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;male&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;guitar&quot;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    db.Create(&amp;u1)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 查询数据,查询第一条数据 保存到u</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> u UserInfo</span><br><span class=\"line\">    db.First(&amp;u)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%#v\\n&quot;</span>, u)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新数据</span></span><br><span class=\"line\">    db.Model(&amp;u).Update(<span class=\"string\">&quot;hobby&quot;</span>, <span class=\"string\">&quot;双色球&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除</span></span><br><span class=\"line\">    db.Delete(&amp;u)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"GORM-Model定义\">GORM Model定义</h2>\n<p>我们需要在代码中定义模型与数据库中的数据表进行映射，在GORM中模型通常是正常定义的结构体、基本的go类型或者他们的指针。</p>\n<h3 id=\"gorm-Model\">gorm.Model</h3>\n<p>为了方便模型的定义，GORM内置了一个gorm.Model结构体。其中包含了<code>ID</code>,<code>CreatedAt</code>,<code>UpdateAt</code>,<code>DeleteAt</code>字段</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// gorm.Model 定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Model <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  ID        <span class=\"keyword\">uint</span> <span class=\"string\">`gorm:&quot;primary_key&quot;`</span></span><br><span class=\"line\">  CreatedAt time.Time</span><br><span class=\"line\">  UpdatedAt time.Time</span><br><span class=\"line\">  DeletedAt *time.Time</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以将他嵌入到我们自己的模型中</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将 `ID`, `CreatedAt`, `UpdatedAt`, `DeletedAt`字段注入到`User`模型中</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  gorm.Model</span><br><span class=\"line\">  Name <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>模型定义的示例</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  gorm.Model</span><br><span class=\"line\">  Name         <span class=\"keyword\">string</span></span><br><span class=\"line\">  Age          sql.NullInt64</span><br><span class=\"line\">  Birthday     *time.Time</span><br><span class=\"line\">  Email        <span class=\"keyword\">string</span>  <span class=\"string\">`gorm:&quot;type:varchar(100);unique_index&quot;`</span></span><br><span class=\"line\">  Role         <span class=\"keyword\">string</span>  <span class=\"string\">`gorm:&quot;size:255&quot;`</span> <span class=\"comment\">// 设置字段大小为255</span></span><br><span class=\"line\">  MemberNumber *<span class=\"keyword\">string</span> <span class=\"string\">`gorm:&quot;unique;not null&quot;`</span> <span class=\"comment\">// 设置会员号（member number）唯一并且不为空</span></span><br><span class=\"line\">  Num          <span class=\"keyword\">int</span>     <span class=\"string\">`gorm:&quot;AUTO_INCREMENT&quot;`</span> <span class=\"comment\">// 设置 num 为自增类型</span></span><br><span class=\"line\">  Address      <span class=\"keyword\">string</span>  <span class=\"string\">`gorm:&quot;index:addr&quot;`</span> <span class=\"comment\">// 给address字段创建名为addr的索引</span></span><br><span class=\"line\">  IgnoreMe     <span class=\"keyword\">int</span>     <span class=\"string\">`gorm:&quot;-&quot;`</span> <span class=\"comment\">// 忽略本字段</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"主键、表名、列名的约定\">主键、表名、列名的约定</h2>\n<h3 id=\"主键\">主键</h3>\n<p>gorm默认会使用名为ID的字段作为表的主键，如果我们想要设置主键的话就用结构体tag进行设置</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  ID   <span class=\"keyword\">string</span> <span class=\"comment\">// 名为`ID`的字段会默认作为表的主键</span></span><br><span class=\"line\">  Name <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用`AnimalID`作为主键</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  AnimalID <span class=\"keyword\">int64</span> <span class=\"string\">`gorm:&quot;primary_key&quot;`</span></span><br><span class=\"line\">  Name     <span class=\"keyword\">string</span></span><br><span class=\"line\">  Age      <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"表名\">表名</h3>\n<p>表名默认是结构体的复数形式，如果想要修改表的名字的话可以通过对结构体设置一个<code>TableName()</code>函数进行设置。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;&#125; <span class=\"comment\">// 默认表名是 `users`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 User 的表名设置为 `profiles`</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(User)</span> <span class=\"title\">TableName</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;profiles&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(u User)</span> <span class=\"title\">TableName</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> u.Role == <span class=\"string\">&quot;admin&quot;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;admin_users&quot;</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;users&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 禁用默认表名的复数形式，如果置为 true，则 `User` 的默认表名是 `user`</span></span><br><span class=\"line\">db.SingularTable(<span class=\"literal\">true</span>)</span><br></pre></td></tr></table></figure>\n<p>也可以通过<code>Table()</code>指定表名</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用User结构体创建名为`deleted_users`的表</span></span><br><span class=\"line\">db.Table(<span class=\"string\">&quot;deleted_users&quot;</span>).CreateTable(&amp;User&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> deleted_users []User</span><br><span class=\"line\">db.Table(<span class=\"string\">&quot;deleted_users&quot;</span>).Find(&amp;deleted_users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM deleted_users;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Table(<span class=\"string\">&quot;deleted_users&quot;</span>).Where(<span class=\"string\">&quot;name = ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>).Delete()</span><br><span class=\"line\"><span class=\"comment\">//// DELETE FROM deleted_users WHERE name = &#x27;jinzhu&#x27;;</span></span><br></pre></td></tr></table></figure>\n<p>gorm还支持更改默认的表名称规则,自己指定的表名不受影响</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">gorm.DefaultTableNameHandler = <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(db *gorm.DB, defaultTableName <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span>  &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;prefix_&quot;</span> + defaultTableName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"列名\">列名</h3>\n<p>默认命名规则和表名是一样的，由下划线分割连接并且全部小写。同样也可以用结构体tag进行修改。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  AnimalId    <span class=\"keyword\">int64</span>     <span class=\"string\">`gorm:&quot;column:beast_id&quot;`</span>         <span class=\"comment\">// set column name to `beast_id`</span></span><br><span class=\"line\">  Birthday    time.Time <span class=\"string\">`gorm:&quot;column:day_of_the_beast&quot;`</span> <span class=\"comment\">// set column name to `day_of_the_beast`</span></span><br><span class=\"line\">  Age         <span class=\"keyword\">int64</span>     <span class=\"string\">`gorm:&quot;column:age_of_the_beast&quot;`</span> <span class=\"comment\">// set column name to `age_of_the_beast`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"GORM的增删改查\">GORM的增删改查</h2>\n<h3 id=\"创建记录\">创建记录</h3>\n<p>先要定义模型</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ID           <span class=\"keyword\">int64</span></span><br><span class=\"line\">    Name         <span class=\"keyword\">string</span></span><br><span class=\"line\">    Age          <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后把模型和数据库的表对应起来</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.AutoMigrate(&amp;User&#123;&#125;)</span><br></pre></td></tr></table></figure>\n<p>最后创建记录并且存到表中</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">user:=User&#123;</span><br><span class=\"line\">    Name:<span class=\"string\">&quot;weirdo&quot;</span>,</span><br><span class=\"line\">    Age:<span class=\"number\">18</span>，</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">db.Create(&amp;user)</span><br></pre></td></tr></table></figure>\n<p>可以通过tag定义字段的默认值</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  ID   <span class=\"keyword\">int64</span></span><br><span class=\"line\">  Name <span class=\"keyword\">string</span> <span class=\"string\">`gorm:&quot;default:&#x27;小王子&#x27;&quot;`</span></span><br><span class=\"line\">  Age  <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是：创建记录的时候所有字段的零值不会存入到数据库中，但是会使用他们的默认值。如果想避免这种情况的话就使用指针或者<code>Scanner.Valuer</code>接口。</p>\n<ul>\n<li>指针方式</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用指针</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  ID   <span class=\"keyword\">int64</span></span><br><span class=\"line\">  Name *<span class=\"keyword\">string</span> <span class=\"string\">`gorm:&quot;default:&#x27;小王子&#x27;&quot;`</span></span><br><span class=\"line\">  Age  <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">user := User&#123;Name: <span class=\"built_in\">new</span>(<span class=\"keyword\">string</span>), Age: <span class=\"number\">18</span>&#125;</span><br><span class=\"line\">db.Create(&amp;user)  <span class=\"comment\">// 此时数据库中该条记录name字段的值就是&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>Scanner/Valuer方式</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 Scanner/Valuer</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ID <span class=\"keyword\">int64</span></span><br><span class=\"line\">    Name sql.NullString <span class=\"string\">`gorm:&quot;default:&#x27;小王子&#x27;&quot;`</span> <span class=\"comment\">// sql.NullString 实现了Scanner/Valuer接口</span></span><br><span class=\"line\">    Age  <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">user := User&#123;Name: sql.NullString&#123;<span class=\"string\">&quot;&quot;</span>, <span class=\"literal\">true</span>&#125;, Age:<span class=\"number\">18</span>&#125;</span><br><span class=\"line\">db.Create(&amp;user)  <span class=\"comment\">// 此时数据库中该条记录name字段的值就是&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查询\">查询</h3>\n<p>一般查询</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据主键查询第一条记录</span></span><br><span class=\"line\">db.First(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 随机获取一条记录</span></span><br><span class=\"line\">db.Take(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users LIMIT 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据主键查询最后一条记录</span></span><br><span class=\"line\">db.Last(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询所有的记录</span></span><br><span class=\"line\">db.Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询指定的某条记录(仅当主键为整型时可用)</span></span><br><span class=\"line\">db.First(&amp;user, <span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE id = 10;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"where-条件\">where 条件</h4>\n<p>普通sql查询</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Get first matched record</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name = ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; limit 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Get all matched records</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name = ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &lt;&gt;</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name &lt;&gt; ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IN</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name IN (?)&quot;</span>, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;jinzhu&quot;</span>, <span class=\"string\">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name in (&#x27;jinzhu&#x27;,&#x27;jinzhu 2&#x27;);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// LIKE</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name LIKE ?&quot;</span>, <span class=\"string\">&quot;%jin%&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name LIKE &#x27;%jin%&#x27;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AND</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>, <span class=\"string\">&quot;22&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; AND age &gt;= 22;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Time</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;updated_at &gt; ?&quot;</span>, lastWeek).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE updated_at &gt; &#x27;2000-01-01 00:00:00&#x27;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// BETWEEN</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;created_at BETWEEN ? AND ?&quot;</span>, lastWeek, today).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE created_at BETWEEN &#x27;2000-01-01 00:00:00&#x27; AND &#x27;2000-01-08 00:00:00&#x27;;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>struct map查询</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Struct</span></span><br><span class=\"line\">db.Where(&amp;User&#123;Name: <span class=\"string\">&quot;jinzhu&quot;</span>, Age: <span class=\"number\">20</span>&#125;).First(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20 LIMIT 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Map</span></span><br><span class=\"line\">db.Where(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;jinzhu&quot;</span>, <span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">20</span>&#125;).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主键的切片</span></span><br><span class=\"line\">db.Where([]<span class=\"keyword\">int64</span>&#123;<span class=\"number\">20</span>, <span class=\"number\">21</span>, <span class=\"number\">22</span>&#125;).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE id IN (20, 21, 22);</span></span><br></pre></td></tr></table></figure>\n<p>同样的，通过结构体查询时，GORM会只通过非零值字段查询，即字段如果为零值，将不会被用于查询。这一点同样可以通过Scanner/Valuer解决。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Where(&amp;User&#123;Name: <span class=\"string\">&quot;jinzhu&quot;</span>, Age: <span class=\"number\">0</span>&#125;).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Not条件\">Not条件</h4>\n<p>就是与where相反，取非我们给出条件的数据</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Not(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; LIMIT 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Not In</span></span><br><span class=\"line\">db.Not(<span class=\"string\">&quot;name&quot;</span>, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;jinzhu&quot;</span>, <span class=\"string\">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name NOT IN (&quot;jinzhu&quot;, &quot;jinzhu 2&quot;);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Not In slice of primary keys</span></span><br><span class=\"line\">db.Not([]<span class=\"keyword\">int64</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;).First(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE id NOT IN (1,2,3);</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Not([]<span class=\"keyword\">int64</span>&#123;&#125;).First(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Plain SQL</span></span><br><span class=\"line\">db.Not(<span class=\"string\">&quot;name = ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE NOT(name = &quot;jinzhu&quot;);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Struct</span></span><br><span class=\"line\">db.Not(User&#123;Name: <span class=\"string\">&quot;jinzhu&quot;</span>&#125;).First(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Or条件\">Or条件</h4>\n<p>就是同时满足几个条件的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Where(<span class=\"string\">&quot;role = ?&quot;</span>, <span class=\"string\">&quot;admin&quot;</span>).Or(<span class=\"string\">&quot;role = ?&quot;</span>, <span class=\"string\">&quot;super_admin&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE role = &#x27;admin&#x27; OR role = &#x27;super_admin&#x27;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Struct</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(User&#123;Name: <span class=\"string\">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Map</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"内联条件\">内联条件</h4>\n<p>当内联条件和多个立即执行方法一起使用的时候不会传递给后面的立即执行方法，即只对当前方法的条件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据主键获取记录 (只适用于整形主键)</span></span><br><span class=\"line\">db.First(&amp;user, <span class=\"number\">23</span>)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE id = 23 LIMIT 1;</span></span><br><span class=\"line\"><span class=\"comment\">// 根据主键获取记录, 如果它是一个非整形主键</span></span><br><span class=\"line\">db.First(&amp;user, <span class=\"string\">&quot;id = ?&quot;</span>, <span class=\"string\">&quot;string_primary_key&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE id = &#x27;string_primary_key&#x27; LIMIT 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Plain SQL</span></span><br><span class=\"line\">db.Find(&amp;user, <span class=\"string\">&quot;name = ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Find(&amp;users, <span class=\"string\">&quot;name &lt;&gt; ? AND age &gt; ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; AND age &gt; 20;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Struct</span></span><br><span class=\"line\">db.Find(&amp;users, User&#123;Age: <span class=\"number\">20</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE age = 20;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Map</span></span><br><span class=\"line\">db.Find(&amp;users, <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">20</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"额外查询选项\">额外查询选项</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为查询 SQL 添加额外的 SQL 操作</span></span><br><span class=\"line\">db.Set(<span class=\"string\">&quot;gorm:query_option&quot;</span>, <span class=\"string\">&quot;FOR UPDATE&quot;</span>).First(&amp;user, <span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE id = 10 FOR UPDATE;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"FirstOrInit\">FirstOrInit</h4>\n<p>获取匹配到的第一个数据，如果不存在的话，用给定条件初始化一个新的对象（仅支持struct和map条件）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 未找到</span></span><br><span class=\"line\">db.FirstOrInit(&amp;user, User&#123;Name: <span class=\"string\">&quot;non_existing&quot;</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// user -&gt; User&#123;Name: &quot;non_existing&quot;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找到</span></span><br><span class=\"line\">db.Where(User&#123;Name: <span class=\"string\">&quot;Jinzhu&quot;</span>&#125;).FirstOrInit(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span></span><br><span class=\"line\">db.FirstOrInit(&amp;user, <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;jinzhu&quot;</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Attrs\">Attrs</h4>\n<p>如果记录没有找到的话，就用参数初始化struct</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 未找到</span></span><br><span class=\"line\">db.Where(User&#123;Name: <span class=\"string\">&quot;non_existing&quot;</span>&#125;).Attrs(User&#123;Age: <span class=\"number\">20</span>&#125;).FirstOrInit(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM USERS WHERE name = &#x27;non_existing&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">//// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Where(User&#123;Name: <span class=\"string\">&quot;non_existing&quot;</span>&#125;).Attrs(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">20</span>).FirstOrInit(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM USERS WHERE name = &#x27;non_existing&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">//// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找到</span></span><br><span class=\"line\">db.Where(User&#123;Name: <span class=\"string\">&quot;Jinzhu&quot;</span>&#125;).Attrs(User&#123;Age: <span class=\"number\">30</span>&#125;).FirstOrInit(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM USERS WHERE name = jinzhu&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Assign\">Assign</h4>\n<p>不管记录是否找到，都会用参数初始化struct</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 未找到</span></span><br><span class=\"line\">db.Where(User&#123;Name: <span class=\"string\">&quot;non_existing&quot;</span>&#125;).Assign(User&#123;Age: <span class=\"number\">20</span>&#125;).FirstOrInit(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找到</span></span><br><span class=\"line\">db.Where(User&#123;Name: <span class=\"string\">&quot;Jinzhu&quot;</span>&#125;).Assign(User&#123;Age: <span class=\"number\">30</span>&#125;).FirstOrInit(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM USERS WHERE name = jinzhu&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 30&#125;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>另外，还有<code>FirstOrCreate</code>和<code>Attrs</code>、<code>Assign</code>相结合，它就是比上面的多一个向数据库中添加或者修改数据的动作。</p>\n<h4 id=\"高级查询\">高级查询</h4>\n<ul>\n<li><strong>子查询</strong></li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Where(<span class=\"string\">&quot;amount &gt; ?&quot;</span>, db.Table(<span class=\"string\">&quot;orders&quot;</span>).Select(<span class=\"string\">&quot;AVG(amount)&quot;</span>).Where(<span class=\"string\">&quot;state = ?&quot;</span>, <span class=\"string\">&quot;paid&quot;</span>).SubQuery()).Find(&amp;orders)</span><br><span class=\"line\"><span class=\"comment\">// SELECT * FROM &quot;orders&quot;  WHERE &quot;orders&quot;.&quot;deleted_at&quot; IS NULL AND (amount &gt; (SELECT AVG(amount) FROM &quot;orders&quot;  WHERE (state = &#x27;paid&#x27;)));</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>选择字段</strong></li>\n</ul>\n<p>指定我们想要检索出的字段，默认是选择全部字段</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Select(<span class=\"string\">&quot;name, age&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT name, age FROM users;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Select([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;age&quot;</span>&#125;).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT name, age FROM users;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Table(<span class=\"string\">&quot;users&quot;</span>).Select(<span class=\"string\">&quot;COALESCE(age,?)&quot;</span>, <span class=\"number\">42</span>).Rows()</span><br><span class=\"line\"><span class=\"comment\">//// SELECT COALESCE(age,&#x27;42&#x27;) FROM users;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>排序</strong></li>\n</ul>\n<p>指定从数据库中检索出记录的顺序。设置第二个参数 reorder 为 true ，可以覆盖前面定义的排序条件。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Order(<span class=\"string\">&quot;age desc, name&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 多字段排序</span></span><br><span class=\"line\">db.Order(<span class=\"string\">&quot;age desc&quot;</span>).Order(<span class=\"string\">&quot;name&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 覆盖排序</span></span><br><span class=\"line\">db.Order(<span class=\"string\">&quot;age desc&quot;</span>).Find(&amp;users1).Order(<span class=\"string\">&quot;age&quot;</span>, <span class=\"literal\">true</span>).Find(&amp;users2)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users ORDER BY age desc; (users1)</span></span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users ORDER BY age; (users2)</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>数量</strong></li>\n</ul>\n<p>指定从数据库检索出的最大记录数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Limit(<span class=\"number\">3</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users LIMIT 3;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -1 取消 Limit 条件</span></span><br><span class=\"line\">db.Limit(<span class=\"number\">10</span>).Find(&amp;users1).Limit(<span class=\"number\">-1</span>).Find(&amp;users2)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users LIMIT 10; (users1)</span></span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users; (users2)</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>偏移</strong></li>\n</ul>\n<p>指定开始返回记录前要跳过的记录数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Offset(<span class=\"number\">3</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users OFFSET 3;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -1 取消 Offset 条件</span></span><br><span class=\"line\">db.Offset(<span class=\"number\">10</span>).Find(&amp;users1).Offset(<span class=\"number\">-1</span>).Find(&amp;users2)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users OFFSET 10; (users1)</span></span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users; (users2)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"更新\">更新</h3>\n<h4 id=\"更新所有字段\">更新所有字段</h4>\n<p><code>Save()</code>会更新该对象的所有字段，即使没有赋值</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.First(&amp;user)</span><br><span class=\"line\"></span><br><span class=\"line\">user.Name = <span class=\"string\">&quot;七米&quot;</span></span><br><span class=\"line\">user.Age = <span class=\"number\">99</span></span><br><span class=\"line\">db.Save(&amp;user)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">////  UPDATE `users` SET `created_at` = &#x27;2020-02-16 12:52:20&#x27;, `updated_at` = &#x27;2020-02-16 12:54:55&#x27;, `deleted_at` = NULL, `name` = &#x27;七米&#x27;, `age` = 99, `active` = true  WHERE `users`.`deleted_at` IS NULL AND `users`.`id` = 1</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"更新修改字段\">更新修改字段</h4>\n<p><code>Update</code> <code>Updates</code>只会修改指定字段。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 更新单个属性，如果它有变化</span></span><br><span class=\"line\">db.Model(&amp;user).Update(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据给定的条件更新单个属性</span></span><br><span class=\"line\">db.Model(&amp;user).Where(<span class=\"string\">&quot;active = ?&quot;</span>, <span class=\"literal\">true</span>).Update(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111 AND active=true;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 map 更新多个属性，只会更新其中有变化的属性</span></span><br><span class=\"line\">db.Model(&amp;user).Updates(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">18</span>, <span class=\"string\">&quot;active&quot;</span>: <span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27;, age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 struct 更新多个属性，只会更新其中有变化且为非零值的字段</span></span><br><span class=\"line\">db.Model(&amp;user).Updates(User&#123;Name: <span class=\"string\">&quot;hello&quot;</span>, Age: <span class=\"number\">18</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id = 111;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 警告：当使用 struct 更新时，GORM只会更新那些非零值的字段</span></span><br><span class=\"line\"><span class=\"comment\">// 对于下面的操作，不会发生任何更新，&quot;&quot;, 0, false 都是其类型的零值</span></span><br><span class=\"line\">db.Model(&amp;user).Updates(User&#123;Name: <span class=\"string\">&quot;&quot;</span>, Age: <span class=\"number\">0</span>, Active: <span class=\"literal\">false</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"更新选定字段或者忽略选定字段\">更新选定字段或者忽略选定字段</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Model(&amp;user).Select(<span class=\"string\">&quot;name&quot;</span>).Updates(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">18</span>, <span class=\"string\">&quot;active&quot;</span>: <span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Model(&amp;user).Omit(<span class=\"string\">&quot;name&quot;</span>).Updates(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">18</span>, <span class=\"string\">&quot;active&quot;</span>: <span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"无hooks更新\">无hooks更新</h4>\n<p>上面的更新操作都会默认执行<code>BeforeUpdate</code>和<code>AfterUpdate</code>方法，用于更新<code>UpdatedAt</code>时间戳，如果不想使用这些方法的话，可以使用<code>UpdateColumn</code>、<code>UpdateColumns</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 更新单个属性，类似于 `Update`</span></span><br><span class=\"line\">db.Model(&amp;user).UpdateColumn(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27; WHERE id = 111;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更新多个属性，类似于 `Updates`</span></span><br><span class=\"line\">db.Model(&amp;user).UpdateColumns(User&#123;Name: <span class=\"string\">&quot;hello&quot;</span>, Age: <span class=\"number\">18</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id = 111;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"批量更新\">批量更新</h4>\n<p>批量更新的时候hook函数是不会执行的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Table(<span class=\"string\">&quot;users&quot;</span>).Where(<span class=\"string\">&quot;id IN (?)&quot;</span>, []<span class=\"keyword\">int</span>&#123;<span class=\"number\">10</span>, <span class=\"number\">11</span>&#125;).Updates(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">18</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id IN (10, 11);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 struct 更新时，只会更新非零值字段，若想更新所有字段，请使用map[string]interface&#123;&#125;</span></span><br><span class=\"line\">db.Model(User&#123;&#125;).Updates(User&#123;Name: <span class=\"string\">&quot;hello&quot;</span>, Age: <span class=\"number\">18</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27;, age=18;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 `RowsAffected` 获取更新记录总数</span></span><br><span class=\"line\">db.Model(User&#123;&#125;).Updates(User&#123;Name: <span class=\"string\">&quot;hello&quot;</span>, Age: <span class=\"number\">18</span>&#125;).RowsAffected</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用SQL表达式更新\">使用SQL表达式更新</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//先获取表中的第一条数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> user User</span><br><span class=\"line\">db.First(&amp;user)</span><br><span class=\"line\"></span><br><span class=\"line\">db.Model(&amp;user).Update(<span class=\"string\">&quot;age&quot;</span>, gorm.Expr(<span class=\"string\">&quot;age * ? + ?&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">100</span>))</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE `users` SET `age` = age * 2 + 100, `updated_at` = &#x27;2020-02-16 13:10:20&#x27;  WHERE `users`.`id` = 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Model(&amp;user).Updates(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;age&quot;</span>: gorm.Expr(<span class=\"string\">&quot;age * ? + ?&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">100</span>)&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age * &#x27;2&#x27; + &#x27;100&#x27;, &quot;updated_at&quot; = &#x27;2020-02-16 13:05:51&#x27; WHERE `users`.`id` = 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Model(&amp;user).UpdateColumn(<span class=\"string\">&quot;age&quot;</span>, gorm.Expr(<span class=\"string\">&quot;age - ?&quot;</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age - 1 WHERE &quot;id&quot; = &#x27;1&#x27;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Model(&amp;user).Where(<span class=\"string\">&quot;age &gt; 10&quot;</span>).UpdateColumn(<span class=\"string\">&quot;age&quot;</span>, gorm.Expr(<span class=\"string\">&quot;age - ?&quot;</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age - 1 WHERE &quot;id&quot; = &#x27;1&#x27; AND quantity &gt; 10;</span></span><br></pre></td></tr></table></figure>\n<p>这里需要注意，要对整个表修改的话Model()的括号中必须是对应的空结构体，否则只对对应的数据进行修改。</p>\n<h3 id=\"删除\">删除</h3>\n<h4 id=\"删除记录\">删除记录</h4>\n<p>注意：删除记录的时候，要确保主键字段有值，GORM会通过主键去删除记录，如果主键为空，GORM会删除该model的所有记录。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除现有记录</span></span><br><span class=\"line\">db.Delete(&amp;email)</span><br><span class=\"line\"><span class=\"comment\">//// DELETE from emails where id=10;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为删除 SQL 添加额外的 SQL 操作</span></span><br><span class=\"line\">db.Set(<span class=\"string\">&quot;gorm:delete_option&quot;</span>, <span class=\"string\">&quot;OPTION (OPTIMIZE FOR UNKNOWN)&quot;</span>).Delete(&amp;email)</span><br><span class=\"line\"><span class=\"comment\">//// DELETE from emails where id=10 OPTION (OPTIMIZE FOR UNKNOWN);</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"批量删除\">批量删除</h4>\n<p>删除全部匹配的记录</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Where(<span class=\"string\">&quot;email LIKE ?&quot;</span>, <span class=\"string\">&quot;%jinzhu%&quot;</span>).Delete(Email&#123;&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Delete(Email&#123;&#125;, <span class=\"string\">&quot;email LIKE ?&quot;</span>, <span class=\"string\">&quot;%jinzhu%&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"软删除\">软删除</h4>\n<p>当一个表中有<code>DeletedAt</code>字段，它将会自动获得软删除功能。删除时会记录删除时间而不会真正从表中移除数据。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Delete(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE id = 111;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 批量删除</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;age = ?&quot;</span>, <span class=\"number\">20</span>).Delete(&amp;User&#123;&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE age = 20;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询记录时会忽略被软删除的记录</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;age = 20&quot;</span>).Find(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Unscoped 方法可以查询被软删除的记录</span></span><br><span class=\"line\">db.Unscoped().Where(<span class=\"string\">&quot;age = 20&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"物理删除\">物理删除</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Unscoped 方法可以物理删除记录</span></span><br><span class=\"line\">db.Unscoped().Delete(&amp;order)</span><br><span class=\"line\"><span class=\"comment\">//// DELETE FROM orders WHERE id=10;</span></span><br></pre></td></tr></table></figure>","categories":["后端"],"tags":["sql docker gorm"]},{"title":"EvolveGCN:Evolving Graph Convolutional Networks for Dynamic Graphs","url":"/2022/03/16/EvolveGCN-Evolving-Graph-Convolutional-Networks-for-Dynamic-Graphs/","content":"<h2 id=\"摘要-2\">摘要</h2>\n<p>归功于对于欧几里得数据（排列整齐，能够很容易找到邻居节点，就在旁边不偏不倚，如图片、视频、语音等）的深度学习的广泛使用，在非欧几里得领域出现了许多有创造性的神经网络，作为其中的代表，图表示学习慢慢回到主流研究方向。随着图神经网络在静态场景下应用的成功，作者更进一步接近实际应用场景，其中的图是动态变化的。现存的方法主要是应用节点嵌入并且用RNN来规范嵌入从而学习时间动态性。这些方法需要知道节点在整个时间跨度上的信息而且不能用于频繁变化的节点集。在一些极端场景下，节点集在不同的时间步上可能是完全不同的。</p>\n<p>为了解决这个问题，作者提出EvolveGCN，跟着时间维度调节图卷积网络而不需要使用节点嵌入。该方法通过RNN来获取图序列的动态从而调整GCN的参数。参数的调整考虑到了两种结构。</p>\n<p>作者在连接预测、边分类和节点分类三个任务上评估了提出的方法，效果相当好。<a href=\"https://github.com/IBM/EvolveGCN\">github开源代码链接</a></p>\n<h2 id=\"引言-2\">引言</h2>\n<p>图是无处不在的数据结构，用于对实体间的成对交互进行建模。相较于欧几里得数据，通过图进行学习会遭遇很多独特的问题，包括他们的组合性质和可扩展性瓶颈。</p>\n<p>目前使用图学习的神经网络主要集中于给定的静态图。而在现实应用中，图结构通常是动态的（比如一个人的社交网络是会随着时间不断改变的）。这种情况下需要更新节点嵌入来获取其变化。</p>\n<p>作者基于用于静态图的图神经网络，通过引入循环机制来更新网络参数从而应用于动态场景。<strong>大量的 GNN 通过递归地聚合来自单跳邻域的节点嵌入来执行信息融合</strong>。网络的大部分参数是每一层中节点嵌入的线性变换。</p>\n<p>许多相近的方法都是使用GNN来提取特征然后使用RNN来学习提取到的特征（节点嵌入）中的序列信息。最后为时间轴上所有的图学习到一个单一的GNN模型。这些模型的缺点在于他们需要获取节点在整个时间跨度上的信息并且难以保证在未来某个新节点上的表现。</p>\n<p>实际应用中，除了会在训练之后产生新的节点之外，节点本身也可能频繁地出现或者消失，这使得节点嵌入的方法是有问题的因为RNN难以学习到这种无规律的行为。</p>\n<p>为了解决这些问题，作者提出了在每一个时间步上使用RNN来调节GCN模型的参数。这个方法能够高效地执行模型调整，集中于模型本身而非节点嵌入。因此，不限制节点位置的改变。此外，对于未来图中会出现的新节点EvolceGCN仍然很敏感。</p>\n<p>注意，GCN的参数是不训练的，他们是根据RNN得来的，因此只有RNN的参数是训练得来的。通过这种方式，参数的数量不会随着时间增加而增加而且模型就像一个经典RNN一样可控。</p>\n<span id=\"more\"></span>\n<h2 id=\"方法\">方法</h2>\n<p>作者用下标$t$作为时间索引，上标$l$作为GCN层索引。为了避免符号混乱，作者假设所有的图都有n个节点。在时间步$t$上，输入数据由一对$(A_t \\in R^{n \\times n},X_t \\in R^{n \\times d})$组成，其中前者是图邻接矩阵，后者是输入节点的特征矩阵。$X_t$的每一行都是一个相应节点的d维特征向量。</p>\n<h3 id=\"图卷积神经网络（GCN）\">图卷积神经网络（GCN）</h3>\n<p>一个GCN由多个图卷积层构成，和感知器类似，但是额外多一个由频谱卷积驱动的邻域聚合步骤。在时间步t时，第l层获取到邻接矩阵$A_t$和节点嵌入矩阵$H_t^{(l)}$作为输入，然后使用权重矩阵$W_t^{(l)}$来更新节点嵌入矩阵，使其变为$H_t^{(l+1)}$作为输出。数学上可以表示为</p>\n<p><img src=\"https://i.imgur.com/JWHAXje.png\" alt=\"picture 19\"></p>\n<p>其中$\\widehat{A}_{t}$是$A_t$的正规化，其定义为</p>\n<p>$$<br>\n\\widehat{A}=\\widetilde{D}^{-\\frac{1}{2} } \\widetilde{A} \\widetilde{D}^{-\\frac{1}{2} }, \\quad \\widetilde{A}=A+I, \\quad \\widetilde{D}=\\operatorname{diag}\\left(\\sum_{j} \\widetilde{A}_{i j}\\right)<br>\n$$</p>\n<p>$\\sigma$是激活函数（比如ReLU），要添加到除了输出层之外的所有层。嵌入矩阵的初始值维节点特征，比如（$H_t^{(0)}$=X_t）。如果存在L个图卷积层，对于输出层而言，$\\sigma$是恒等函数，不做任何变换，此时$H_t^{(L)}$包含了图节点从初始特征开始的变换的高级表示；或者也可以是softmax函数，$H_t^{(L)}$是预测概率。</p>\n<p>下图是EvolveGCN的示意图，每一个时间步都包含一个由时间索引的GCN。GCN的参数是权重矩阵$W_t^{(l)}$，不同时间步t和不同层其值会不同。</p>\n<p><img src=\"https://i.imgur.com/fpWN55x.png\" alt=\"picture 1\"></p>\n<p>图卷积会在特定时间发生但是会沿着卷积层生成新的信息。下图解释了每一层的计算过程。$H_t^{(l)}$,$W_t^{(l)}$和$H_t{(l+1)}$的关系在图的中间部分有解释。</p>\n<p><img src=\"https://i.imgur.com/rT6G3TJ.png\" alt=\"picture 2\"></p>\n<h3 id=\"GCN参数的调节\">GCN参数的调节</h3>\n<p>本文方法的核心在于GCN的参数（也就是变换矩阵$W_t^{(l)}$）在时间步t上基于现在和历史信息的更新。为了实现这个目标，有两种使用RNN的选择：</p>\n<ol>\n<li>将$W_t^{l}$视为动态系统的隐藏层。作者使用GRU来更新隐藏层。输入信息是节点嵌入矩阵$H_t^{l}$。可以解释为：</li>\n</ol>\n<p><img src=\"https://i.imgur.com/p6Tx3VC.png\" alt=\"picture 21\"></p>\n<p>这里的GRU可以替换为其他的RNN结构，只要对于$W_t^{l}$,$H_t^{l}$和$W_{t-1}^{(l)}$的定义是清晰的就可以。上图中的-H版本就是这个方法。</p>\n<ol start=\"2\">\n<li>将$W_t^{(l)}$作为动态系统的输出（在下一个时间步又会变成输入）。作者在这里使用的是LSTM。LSTM通过使用context cell本身就包含了系统信息，类似于GRU中的隐藏层。在这个RNN结构中，节点嵌入矩阵是用不到的，可以解释为：</li>\n</ol>\n<p><img src=\"https://i.imgur.com/CBDoEIg.png\" alt=\"picture 22\"></p>\n<p>同样这里LSTM也可以替换成别的结构。</p>\n<h3 id=\"进化图卷积单元\">进化图卷积单元</h3>\n<p>将上面两小节的结构相结合就得到最总的EGCU。基于GCN中变换矩阵的变化方式，可以有两种版本：</p>\n<p><img src=\"https://i.imgur.com/QtUQb8v.png\" alt=\"picture 3\"></p>\n<p>将这些EGCU从下至上地进行连接，就能获得一个时间步上多层的GCN。之后随着时间变化再水平铺开，这些EGCU就会形成一个$H_t^{(l)}$和$W_t^{(l)}$的变化信息流。</p>\n<h3 id=\"GRU版本的实现\">GRU版本的实现</h3>\n<p>可以使用标准GRU实现，但是需要做两个扩展：</p>\n<ol>\n<li>将输入从向量扩展为矩阵（因为隐藏层是GCN的参数）</li>\n<li>将输入的列数和隐藏层的列数相匹配</li>\n</ol>\n<p>扩展为矩阵很直接：只需要简单地将列向量一个接一个排在一起形成矩阵。换句话说，用相同的GRU来处理GCN参数的每一列。作者通过以下算法实现这个功能，其中所有的变量都是局部变量。</p>\n<p><img src=\"https://i.imgur.com/lHkt56O.png\" alt=\"picture 4\"></p>\n<p>假设隐状态的列数为k，作者的方法是将所有节点嵌入向量汇总为k个代表向量。下方的算法给出了一个比较常用的汇总方法。通过这个方法将矩阵$X_t$视为输入并且产生一个只有k行的矩阵$Z_t$。该方法需要一个参数向量p，并且要独立于时间轴t。这个向量用于计算行的权重，其中有着最高权重的k行被选为输出</p>\n<p><img src=\"https://i.imgur.com/VEr6QwK.png\" alt=\"picture 3\"></p>\n<p>通过上面两个函数g和summarize我们就可以总结出RNN结构的具体工作内容</p>\n<p><img src=\"https://i.imgur.com/KDVVeck.png\" alt=\"picture 23\"></p>\n<h4 id=\"GRU基本原理\">GRU基本原理</h4>\n<p><img src=\"https://i.imgur.com/oLQtJQv.png\" alt=\"picture 12\"></p>\n<p>如上图所示是一个基本的GRU工作中的一环，GRU本身有两个门重置门和更新门。</p>\n<p>可以这么理解，每个门中有三个参数，对当前输入做变换的变换矩阵$W_1$，对上一时刻传过来的隐状态做变换的变换矩阵$W_2$,和一个偏置值。此外还有一个候选隐状态的控制参数，也是由这三个类型的数据组成的。</p>\n<p>经过这两个门的转换之后，可以得到两个矩阵重置门矩阵R和更新门矩阵U。</p>\n<p>然后对于重置门矩阵，再将他放到候选隐状态参数中做一个变换，得到一个和应该要输出的隐状态相同的候选隐状态。</p>\n<p>然后结合上一层的隐状态和这一层的候选隐状态得到这一层真正传递下去的隐状态。这时结合就需要用到更新门矩阵Z了，本质上Z是一个行向量或者说列向量，公式为：</p>\n<p><img src=\"https://i.imgur.com/e1U0iWX.png\" alt=\"picture 2\"></p>\n<h3 id=\"LSTM版本的实现\">LSTM版本的实现</h3>\n<p>该版本的实现基本与上面是相同的，见下面的伪代码</p>\n<p><img src=\"https://i.imgur.com/n9qGXgg.png\" alt=\"picture 4\"></p>\n<h3 id=\"版本的选用\">版本的选用</h3>\n<p>实际应用中需要根据数据集选用不同的版本。如果节点特征矩阵包含很多信息，GRU版本就会更加有效，因为他在rnn结构中包含了额外的节点嵌入；相反，如果节点特征包含信息较少而图结构相对而言比较重要的话，LSTM版本就会更加有效。</p>\n<h2 id=\"个人理解\">个人理解</h2>\n<p>本质上就是每个时刻的GCN每层的模型作为一个序列，这样就可以用RNN学习这个序列的变化，所以本文的重点就是GCN模型中的各层权重W的学习和演化。</p>\n<p>而两个版本的不同之处在于，GRU同时需要两个矩阵：当前的节点嵌入矩阵和当前时刻GCN的权重W。而LSTM只需要权重W不需要考虑节点嵌入矩阵的信息。</p>\n","categories":["异常检测"],"tags":["GCN GNN"]},{"title":"Learning under Concept Drift : A Review","url":"/2022/03/26/Learning-under-Concept-Drift-A-Review/","content":"<h2 id=\"摘要-3\">摘要</h2>\n<p>概念漂移描述的是数据流随时间的潜在分布的不可预见的变化。概念漂移研究的包括漂移检测、理解和适应的方法技术。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-3\">引言</h2>\n<p>概念漂移是指模型要预测的目标变量的静态属性会随着时间以一种不可预见的方式变化。一旦概念漂移发生，过去数据所产生的模式将不再适用于新数据，会产生糟糕的性能表现。</p>\n<p>概念漂移在现实场景中很常见。比如手机使用行为的变化，如下图，可以看出手机用户使用的分布已经从“打电话”向“照相”再到“联网”做出了变动。</p>\n<p><img src=\"https://i.imgur.com/n1NjFiv.png\" alt=\"picture 1\"></p>\n<p>近些年的研究致力于更加有挑战性的问题，比如，如何准确地在非结构化并且噪声很强的数据集上检测概念漂移，如何有效地以可解释性的方式理解概念漂移，如何通过相关知识对概念漂移做出反应。解决这些问题能够赋予预测和决定任务在变化场景下的适应能力。</p>\n<p>传统机器学习有两个主要组成部分：训练和预测。在概念漂移下进行学习有三个新组成部分：漂移检测（是否发生漂移）、漂移理解（什么时间，因为什么，在哪里发生漂移）、漂移适应（对已经发生的漂移做出反应），如下图。</p>\n<p><img src=\"https://i.imgur.com/ErsAUKE.png\" alt=\"picture 2\"></p>\n<h2 id=\"问题描述\">问题描述</h2>\n<h3 id=\"概念漂移的定义和来源\">概念漂移的定义和来源</h3>\n<p>概念漂移的首次提出是有学者指出噪音数据在不同的时间会转变成非噪音数据。这些变化可能是由于不可直接衡量的隐变量的变化引起的。通常来说，概念漂移定义如下：<br>\nneq<br>\n给定时间周期[0,t]，一组样本，表示为 $S_{0,t}=\\left{d_0,\\dots,d_t\\right}$ ，其中 $d_i=(X_i,y_i)$ 是一个观测（或者一个数据样本），$X_i$是特征向量，$y_i$是标签，$S_{0,t}$服从特定分布$F_{0,t}(X,y)$。概念漂移发生在时间步t+1，如果$F_{0,t}(X,y)\\neq F_{t+1,\\infin }(X,y)$，表示为$\\exists t:P_t(X,y)\\neq P_{t+1}(X,y)$。</p>\n<p>由于概念漂移是由X和y在时间t的联合概率决定的，可以表示为$P_t(X,y)=P_t(X)\\times P_{t+1}(y|X)$，那么概念漂移的发生就会有三种原因：</p>\n<ul>\n<li>$P_t(y|X) = P_{t+1}(y|X) \\And P_t(X) \\neq P_{t+1}(X)$，这种情况下发生变化的仅仅是$P_t(X)$，由于$P_t(X)$的变化不会影响决策边界，这也被认为是虚拟漂移</li>\n<li>$P_t(y|X) \\neq P_{t+1}(y|X) \\And P_t(X) = P_{t+1}(X)$，这种情况下会导致决策边界的改变并且引发学习进度的下降，被称为事实漂移</li>\n<li>$P_t(y|X) \\neq P_{t+1}(y|X) \\And P_t(X) \\neq P_{t+1}(X)$，概念漂移对两者的改变都比较关注，因为两者的改变都会传递出学习环境的重要信息</li>\n</ul>\n<p><img src=\"https://i.imgur.com/FRjYUEJ.png\" alt=\"picture 3\"></p>\n<p>上图展示了这三种漂移的区别。第一种是特征空间的漂移，第二种是决策边界的漂移，而在现实世界中往往两者是同时发生的。</p>\n<h3 id=\"概念漂移的类型\">概念漂移的类型</h3>\n<p>概念漂移通常分为四类，如下图所示：</p>\n<p>对类型1-3的概念漂移适应的研究注重于如何最小化精度下降并且在概念转换的过程中获得最快的恢复速度。相反的，类型4强调使用历史概念，即如何用最短时间找到最佳匹配的历史概念。</p>\n<p><img src=\"https://i.imgur.com/wBD6Kkr.png\" alt=\"picture 6\"></p>\n<p>中间概念这个词被用来描述概念之间转变的过程。因为概念漂移的发生并不是在某个精确时间点，它是一个长期的过程。因此中间概念就在这个过程中产生了，他可能是两个概念的混合，比如增量漂移，也可以是其中一个概念，比如渐进漂移。</p>\n<h2 id=\"概念漂移检测\">概念漂移检测</h2>\n<h3 id=\"漂移检测的总体框架\">漂移检测的总体框架</h3>\n<p>漂移检测指的是通过识别变化点或者变化时间间隔描述和量化概念漂移的技术和机制。总体框架包含4个阶段：</p>\n<ol>\n<li><strong>数据检索</strong>。从数据流中检索数据块。一个单独的数据样本不足以推断数据整体分布，知晓如何组织数据块来形成一个有意义的模式或者知识在数据流分析任务中是非常重要的。</li>\n<li><strong>数据建模</strong>。抽象检索的数据并且提取包含敏感信息的关键特征，即一旦漂移对系统影响比较大的特征。这一阶段是非必须的，因为其主要是降维或者降采样来满足内存和在线速度的需求。</li>\n<li><strong>测试统计数据计算</strong>。不相似度或者距离估计的衡量。量化漂移的严重性并且为假设形成测试统计数据。这是概念漂移检测面临的最有挑战性的方面。</li>\n<li><strong>假设测试</strong>。使用一个特定的假设测试来估计变化的统计学显著性或者p-value。能够判断变化是由于概念漂移造成的而不是噪音或者随机采样的偏差。</li>\n</ol>\n<p><img src=\"https://i.imgur.com/Qz83MTV.png\" alt=\"picture 7\"></p>\n<h3 id=\"概念漂移检测算法\">概念漂移检测算法</h3>\n<h4 id=\"基于错误率的漂移检测\">基于错误率的漂移检测</h4>\n<p>引用量最多的算法是Drift Detection Method（DDM）。这是首个定义了警告等级和漂移等级的算法。</p>\n<p><img src=\"https://i.imgur.com/aSJI8Bu.png\" alt=\"picture 8\"></p>\n<p>阶段一通过一个时间窗实现的，如上图所示。当新的数据样本能够评估时，DDM会检测时间窗内总体的错误率是否有显著增加。如果观察到的错误率变化达到警告等级，DDM就会开始构建一个新的学习器同时使用旧学习器做预测。如果变化达到漂移等级，旧的学习器就会被新学习器取代。为了获取在线错误率，DDM需要一个分类器来做预测。这个过程将训练数据转变为学习模型，这是第二阶段。阶段3的测试统计数据构成在线错误率。假设检验阶段(第四阶段)通过估计在线错误率的分布，计算预警级别和漂移阈值进行假设检验。</p>\n<p>其他还有很多算法变体，这里就不一一赘述。</p>\n<h4 id=\"基于数据分布的漂移检测\">基于数据分布的漂移检测</h4>\n<p>用一个距离函数来量化历史数据和新数据的分布的差异度。如果度在统计学上存在明显不同，系统就会触发模型升级过程。这些算法不仅能够准确识别漂移时间，也能够提供漂移的位置信息。但是，这些算法往往会需要较高的算力。此外，该类算法还会需要用户预定义历史数据窗口和新数据窗口。通常采用的方法是两个滑动窗口，历史数据的窗口固定而新数据的窗口不断滑动。</p>\n<p><img src=\"https://i.imgur.com/39QZ3bH.png\" alt=\"picture 9\"></p>\n<h2 id=\"漂移的适应\">漂移的适应</h2>\n<h3 id=\"训练一个新的模型\">训练一个新的模型</h3>\n<p><img src=\"https://i.imgur.com/t8j9ydc.png\" alt=\"picture 10\"></p>\n<p>也许应对概念漂移最直接的方法是用最新的数据重新训练一个新的模型来代替过时的模型，如图所示。需要一个明确的概念漂移检测器来决定何时重新训练模型（漂移检测）。该方法通常采用窗口策略来保存最新的数据用于再训练和/或保留旧数据用于分布变化测试。配对学习者遵循这一策略，使用两个学习者：稳定学习者和反应性学习者。如果稳定学习者经常对反应性学习者正确分类的实例进行错误分类，则会检测到一个新的概念，并将稳定学习者替换为反应性学习者。该方法简单易懂，易于实现，可应用于数据流中的任何一点。</p>\n<p>当采用基于窗口的策略时，必须进行权衡，以确定合适的窗口大小。小窗口可以更好地反映最新的数据分布，但大窗口为训练新模型提供了更多的数据。ADWIN是一种流行的窗口方案算法，旨在缓解这一问题。与大多数早期的工作不同，它不需要用户预先猜测正在比较的窗口的固定大小；相反，它检查窗口的所有可能的剪切，并根据两个子窗口之间的变化率计算最佳子窗口大小。找到最优窗口切割后，删除包含旧数据的窗口，并用最新的窗口数据训练新模型。</p>\n<p>研究人员并没有直接对模型进行再训练，而是尝试将漂移检测过程与特定机器学习算法的再训练过程结合起来。DELM扩展了传统的ELM算法，通过自适应地调整隐藏层节点的数量来处理概念漂移。当分类错误率增加时（这可能表明概念漂移的出现），更多的节点被添加到网络层以提高其逼近能力。同样，FP-ELM是一种ELM扩展方法，它通过在ELM模型中引入遗忘参数来适应漂移。基于ELM的方法的并行版本也被开发用于概念漂移下的高速分类任务。OS-ELM是另一种在线学习的抑制因子模型集成，它使用有序聚合（OA）技术集成ELM，克服了定义最佳集成规模的问题。</p>\n<h3 id=\"模型聚合（用于recurring-drift）\">模型聚合（用于recurring drift）</h3>\n<p>在重复出现的概念漂移的情况下，保留和重用旧模型可以节省为重复概念重新训练新模型所做的大量工作。这是使用集成方法处理概念漂移的核心思想。近年来，集成方法在流数据挖掘领域受到了广泛的关注。集成方法包括一组可能具有不同类型或不同参数的基本分类器。每个基地的产量分类器是利用一定的投票规则组合起来预测新到达的数据。许多自适应集成方法已经被开发出来，目的是通过扩展经典集成方法或创建特定的自适应投票规则来处理概念漂移。图14示出了一个例子，其中当概念漂移发生时，新的基本分类器被添加到集成中。</p>\n<p><img src=\"https://i.imgur.com/sLtI8UF.png\" alt=\"picture 11\"></p>\n","categories":["概念漂移"],"tags":["综述"]},{"title":"Human-level concept learning through probabilistic program induction","url":"/2022/03/25/Human-level-concept-learning-through-probabilistic-program-induction/","content":"<h2 id=\"摘要-4\">摘要</h2>\n<p>人类学习一个新的概念通常只需要从极其少量的实例中就能进行概括归纳，但是机器学习算法则需要大量的样本才能达到相同的精度。</p>\n<p>此外人类学习的比机器学习的具有更丰富更广泛的拓展，人类可以基于现有的类创建新的抽象对象类别，而机器分类器不会执行这些额外的功能，即便要执行，也会需要一个专门的新算法。</p>\n<p><img src=\"https://i.imgur.com/eytNsjy.png\" alt=\"picture 1\"></p>\n<p>对于这些新算法面临的挑战在于：</p>\n<ul>\n<li>人们如何从少量例子学习新的概念？</li>\n<li>人们如何学习抽象、丰富、灵活的表示？</li>\n<li>如何从稀疏的数据中成功学习，同时产生如此丰富的表示？</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"引言-4\">引言</h2>\n<p>本文介绍了一个贝叶斯程序学习（BPL）框架，能够仅从一个示例中学习一大类视觉概念，并且以人类几乎无法区分的方式进行泛化。</p>\n<p>概念用简单的概率程序进行表示。这样，丰富的概念就可以从更简单的概念组合构成。</p>\n<p>学习则是通过构建最能解释贝叶斯标准下的观察结果的程序来进行的，而模型去学会学习是通过开发层次鲜艳，允许之前对相关概念的经验来简化新概念的学习。简单来说就是，该框架可以通过重用现有的程序片段来构建新的程序，捕捉因果和组合。</p>\n<h2 id=\"贝叶斯程序学习\">贝叶斯程序学习</h2>\n<p>BPL通过学习简单的随机程序来表示概念，通过下图中的part(A,iii),subpart(A,ii)和空间关系(A,iv)来构建他们。</p>\n<p>BPL定义了一个生成模型，可以通过新的方式组合part和subpart来对新类型的概念进行采样。</p>\n<p>每个新的类型也被表示为一个生成模型，并且产生了新概念的实例(A,v)，这样BPL就成为了生成模型的生成模型。最后用原始数据的格式对生成的实例进行展示。</p>\n<p>在随后的评估任务中，既不使用产生的数据，也不使用该集合中的任何字母，这些任务只提供新字符的原始图像。</p>\n<p>手写字符的类型$\\Psi$是part、subpart和空间关系的抽象模式。字符的part$S_i$是按下笔开始到提起笔结束的笔画，而subpart则是由短暂的停笔所分隔的更原始的动作。</p>\n<p>首先是type层面的内容：</p>\n<p>为了构建一个新的字符类型，首先需要采样k个parts并且对于每一个part i=1…k取$n_i$个subparts。一个part $S_i$的模板是通过从一组离散原始的动作中采样来的subpart构成的,这些原始动作是从背景集中学来的，这样下一个动作的概率会依赖上一个动作。然后通过对每一个subparts之间的控制点和尺度参数进行取样将parts表示成参数化的曲线。最后parts之间的位置关系由$R_i$决定。</p>\n<p>到这一步的时候就已经得到字符的解析结构了，接下来就要进入到token层面的过程了：</p>\n<p>首先引入适当的噪声来生成笔画曲线S(m)，然后从背景集中得到笔画空间位置关系结合上一笔，取样就能得到part的开始位置。然后进行放射变换A(m)并加入适当噪声。最后通过随机补偿函数得到二值图像，画出轨迹。</p>\n<p><img src=\"https://i.imgur.com/RqMOnN2.png\" alt=\"picture 2\"></p>\n<p>字符的token$\\theta^{(m)}$是通过执行part和关系并且对墨迹流向建模产生的。</p>\n"},{"title":"Distilling the Knowledge in a Neural Network","url":"/2022/01/16/KnowledgeDistill/","content":"<h2 id=\"摘要-5\">摘要</h2>\n<p>提升机器学习算法性能的最简单方式就是在相同数据集上训练足够多的模型然后对他们的预测取平均值。但是使用多个模型的组合相当繁琐，而且对于大部分使用者来说其计算代价太大，尤其是每个模型都是大型的神经网络的时候。Caruana提出可以将集合模型的知识压缩到一个单独模型中，这会使得知识更容易使用。Hinton使用了一个不同的压缩技术对这一方法进行了改进发展。该方法在MNIST数据集上获取了很好的表现，并且Hinton证明了通过蒸馏一组模型中的知识到一个单独模型中，能够极大提升大量应用在商业系统中传统模型的性能。Hinton还提出了由一个或者多个完整模型和专家模型组合而成的集合，该集合能够分辨更细的类，这是完整模型所无法做到的。这些专家模型可以快速并行训练</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-5\">引言</h2>\n<p>许多昆虫在年幼时为了获取营养往往是一种形态，而成年后为了繁殖和迁徙往往又是另外一种形态。在大规模机器学习中，我们在训练和部署阶段往往会使用非常相似的模型，即便他们的需求不同：对于语音和目标识别任务，训练过程必须在相当大的、高度冗余的数据集中提取结构，但他不必进行实时处理并且有很大的计算量。但是，在部署到大量的用户阶段，就会在计算资源和一些潜在方面由更严格的限制。从昆虫中可以得到启发，我们在训练阶段可以用一个非常复杂的模型，它可以是多个模型的组合也可以本身是一个强正则化的大模型。一旦模型训练好了之后，我们就可以通过以中心的训练方法：蒸馏，来讲繁琐模型中的知识转移到更适合部署的小模型上。</p>\n<p>阻挡这一有前景的方法继续深入的一大问题是我们往往使用模型中参数的值来定义知识，而这时的我们很难去知道如何才能改变模型的结构而不改变其中的知识。将知识从任何实例化中解放出来的更加抽象的观点是它知识一个输入向量到输出向量的映射关系。对于大型的分类模型，正常的目标是去最大化正确类别的平均对数概率，但是这样的副作用是其他类的可能性的值差距不大（比如正确答案是猫，而预测成老虎的概率理应比海豚的概率大的多，但是在这种情况下，会使得这两者差距很小）。</p>\n<p>目前一个广泛接受的观点是，用于训练的目标函数应当尽可能地反映使用者真实的目的。尽管如此，当真实目标是更好地泛化到新数据的时候，训练模型通常是为了优化在训练集上的性能。训练模型以很好地泛化显然会更好，但这需要有关正确泛化方法的信息，而这种信息往往是比较难以获取到的。但是，当我们将大模型中的知识蒸馏到小模型中的时候，我们能够训练小模型以大模型的方式进行泛化。</p>\n<p>一个简单的将繁琐模型的繁华能力转移到小模型中的方法是使用大模型产生的类别概率作为“软目标”训练小模型。在转移阶段，我们可以使用相同的训练集或者转移集。如果繁琐模型是由许多简单模型组成的，可以去这些小模型的算术或者集合平均值作为软目标。当软目标有着较高的熵的时候，每一个训练样本都会比硬目标提供更多的信息，并且每个样本之间的梯度变化较小，因此小模型可以在一个更少的数据集上用更大的学习率进行训练。</p>\n<p>对于MNIST这种繁琐模型能够获得超高准确率的分类任务来说，有许多信息是藏在模型学习到的函数中的。比如，某一种2的写法被预测成3的概率是 $10^{-6}$ 而预测成3的概率是 $10^{-9}$ 而另一种写法可能由另外一种概率。这是一个能够定义数据上更加丰富的相似度结构的信息，但是在转移阶段他对交叉熵损失函数的影响非常小因为它的值非常接近于0。Hinton提出的蒸馏方法通过不断提高最终softmax层的temperature参数直到繁琐模型产生一个合适的软目标输出。然后在训练小模型的时候使用相同的温度参数来匹配软目标。</p>\n<p>用来训练小模型的转移集可以完全由无标签数据组成，当然我们也可以使用原始数据集。Hinton发现使用原始训练集效果也不错，尤其是当我们在目标函数中加一小项，使小模型同时利用真实标签和软目标进行预测的时候。</p>\n<h2 id=\"蒸馏\">蒸馏</h2>\n<p>神经网络通过softmax层将logits $z_i$ 计算转变为一个类别概率 $q_i$，计算公式如下：</p>\n<p>$$<br>\nq_{i}=\\frac{\\exp \\left(z_{i} / T\\right)}{\\sum_{j} \\exp \\left(z_{j} / T\\right)} \\tag{1}<br>\n$$</p>\n<p>其中T是温度参数，默认为1。使用较高的温度参数会在类别概率上形成较为平滑的分布。</p>\n<p>在最简单的蒸馏形式中，通过在转移集上训练模型并且使用繁琐模型在高温度下产生的softmax作为软目标来转移知识。在训练小模型的时候，温度参数不便。但是训练过后在使用模型的时候要将温度设回默认值。</p>\n<p>当转移集中所有或者部分样本的标签是已知的情况下，这种方法可以通过同时训练小模型来产生正确标签来获得巨大提升。一个方法是使用真实标签来调整软目标，但是Hinton发现了一个更好的方法，只需要给不同的目标函数加上一个权重。第一个目标函数是软目标的交叉熵并且这个交叉熵的计算是用相同温度的小模型的softmax和繁琐模型生成的软目标计算得来的。第二个目标函数是和真实标签的交叉熵损失函数。Hinton发现将第二个函数的权重设的比较低能够获得较好的结果。由于软目标产生梯度幅度为 $1/T^2$ ，在使用硬、软目标的时候都需要乘以 $T^2$ 。这能够保证在用元参数进行实验时候的温度变化不会影响软、硬目标的影响。</p>\n<h3 id=\"比较logits是蒸馏的一个特例\">比较logits是蒸馏的一个特例</h3>\n<p>转移集中的每一个样本在小模型中的logit $z_i$ 都会贡献一个交叉熵梯度，$dC/dz_i$ 。如果繁琐模型的logits是 $v_i$ ，会产生概率 $p_i$ ，并且转移训练的过程是在温度T下进行的话，梯度如下：</p>\n<p>$$<br>\n\\frac{\\partial C}{\\partial z_{i}}=\\frac{1}{T}\\left(q_{i}-p_{i}\\right)=\\frac{1}{T}\\left(\\frac{e^{z_{i} / T}}{\\sum_{j} e^{z_{j} / T}}-\\frac{e^{v_{i} / T}}{\\sum_{j} e^{v_{j} / T}}\\right) \\tag{2}<br>\n$$</p>\n<p>如果温度足够高的话可以近似如下：</p>\n<p>$$<br>\n\\frac{\\partial C}{\\partial z_{i}} \\approx \\frac{1}{T}\\left(\\frac{1+z_{i} / T}{N+\\sum_{j} z_{j} / T}-\\frac{1+v_{i} / T}{N+\\sum_{j} v_{j} / T}\\right) \\tag{3}<br>\n$$</p>\n<p>此时如果我们假设logits对于每个样本都是零均值分布的，则上式可以简化为：</p>\n<p>$$<br>\n\\frac{\\partial C}{\\partial z_{i}} \\approx \\frac{1}{N T^{2}}\\left(z_{i}-v_{i}\\right) \\tag{4}<br>\n$$</p>\n<p><strong>因此在高温度的情况下，蒸馏就等价于最小化 $1/2(z_i-v_i)^2$（logits是零均值分布的情况下）。在低温情况下，蒸馏不会过于注重比平均负标签负得多得多的logits的匹配。这是有潜在优势的，因为这些logits几乎完全不受繁琐模型使用的损失函数的限制，因此他们非常嘈杂。另一方面，这些有很多负数的logits可能会传递繁琐模型获取到的知识的有用信息。对于这些不同影响的掌握是一个经验问题。Hinton表明当小模型太小而不能够获取繁琐模型的全部知识的情况下，中等的温度作用最好，因为它会忽略过大的负数logits。</strong> （这段我也不是很理解）</p>\n<h2 id=\"在非常大的数据集上训练专家模型集合\">在非常大的数据集上训练专家模型集合</h2>\n<p>训练模型的集合是一个很简单的利用并行计算的方法，并且集合在测试阶段需要太多计算的问题可以通过蒸馏来解决。但是模型集合另一个重要的问题是：如果单独的一个模型是超大的神经网络并且数据集也非常大的情况下，即便是用并行计算，其计算消耗也是非常大的。</p>\n<p>在这一节中，Hinton给出了这样的一个数据集的例子，并且展示学习集中于类的不同可混淆子集专家模型是如何减少计算总量的。集中于做细粒度分类的专家模型的主要问题就是他们非常容易过拟合而Hinton展示这种问题是如何通过使用软目标避免的。</p>\n<h3 id=\"JFT数据集\">JFT数据集</h3>\n<p>JFT是一个google内部数据集有1亿张图像，15000个类。</p>\n<h3 id=\"专家模型\">专家模型</h3>\n<p>当类别数量非常多的情况下，繁琐模型做成一个集合是非常有意义的，这个集合中以当包含一个在所有数据上训练的通才模型和在一些高度相似易混淆的子类上训练的专家模型（比如蘑菇的不同种类）。这种专家模型的softmax输出可以更小，通过将其他类统一视作一个单独的垃圾类。</p>\n<p>为了减少过拟合和分担学习低级特征检测器的任务，每一个专家模型都用通才模型的权重初始化。这些权重在之后训练专家模型的时候进行调整，训练集一半是该专家模型的特定子集一半是从完整训练集中随机取样。在训练过后，我们能够通过以专家模型过采样的比例的log来增加垃圾类的logit以修正偏差训练集。</p>\n","categories":["Incremental Learning"],"tags":["Hinton"]},{"title":"Learning with drift detection","url":"/2022/03/28/Learning-with-drift-detection/","content":"<h2 id=\"摘要-6\">摘要</h2>\n<p>机器学习中的大部分工作都是假设样本是根据静态概率分布随机生成的。本文作者主要研究了学习生成样本的类别概率分布从何时开始随着时间变化，提出了一个检测样本概率分布变化的方法。文章的一个中心点就是上下文的概念：一组静态分布的连续样本。本文主要通过控制在线错误率来进行漂移检测。统计学的理论保证了分布是静态是，错误率会下降，分布是动态时，错误率会上涨。对于现实环境，作者还定义了一个警告等级和漂移等级。如果在一系列样本中错误率升高达到了这两个等级，那么就会定义一个新的环境。算法会仅用达到警告等级的那个样本之前的样本作为数据集新训练一个模型。</p>\n<span id=\"more\"></span>\n<h2 id=\"追踪概念漂移\">追踪概念漂移</h2>\n<p>解决概念漂移的方法大致可以分成两类：</p>\n<ol>\n<li>每隔一段时间训练一个新的模型，不需要考虑概念漂移到底有没有发生。</li>\n<li>首先检测概念漂移，然后让模型去学习漂移后的变化。</li>\n</ol>\n<p>对于第一种方法可以设置一个时间窗，但是难点在于时间窗的大小，时间窗如果比较小，虽然能很快对概念漂移做出反应，但是在比较稳定的时期会影响模型的表现；如果时间窗比较大，虽然能提供比较好的表现和稳定的结果但是对概念漂移的发生不敏感。</p>\n<p>第二种方法需要检测概念漂移的发生，因此会监控一些指标（比如表现性能，数据属性等）。如果检测到了概念漂移，就会对模型进行调整。如果使用自适应的时间窗的话就会根据概念飘逸的程度进行自动调节。总体规则是，如果概念漂移发生则时间窗要减小，否则时间窗会增大。</p>\n<h2 id=\"漂移检测方法\">漂移检测方法</h2>\n<p>在本文中作者是假设数据一个一个来，当然，要是扩展为一批一批来也很简单。当样本到来时，模型需要做出预测。只有在预测完成之后环境才会给模型一个反馈（这个样本的label）。</p>\n<p>假设存在一组样本$(x_i,y_i)$，对于一个样本集，错误是一个随机变量。n个样本中的一个发生错误的概率服从二项分布。对于序列样本中的每一个时间点i，错误率是观察到错误的概率，$p_i$，标准差为$s_i=\\sqrt{\\frac{p_i\\times (1-p_i)}{i}}$。</p>\n<p>统计学理论保证了即使样本类分布是静态的，错误率会随着样本数量增加而减少。所以如果错误率出现明显上升的时候就表明类分布发生了变化，现在的模型可能已经不适用了。</p>\n<p>考虑到前后环境是静态时概率分布不会发生改变，n&gt;30时的样本错误率的$1-\\frac{\\alpha}{2}$置信区间大约为$p_i \\pm \\alpha \\times s_i$。参数$\\alpha$取决于置信度。漂移检测方法在训练期间会管理两个值$p_{min}$,$s_{min}$。每当新的样本的$p_i+s_i$小于$p_{min}$,$s_{min}$时，都会进行更新。</p>\n<p>作者使用一个警告等级来定义前后环境的合适窗口大小。环境窗口应当包含新环境中的旧样本和旧环境中最少的样本。假设在样本序列中存在一个样本i和其对应的 $p_i$ 。实验中低于置信度95%的时候就会触发警告，即 $p_i+s_i \\geq p_{min}+2<em>s_{min}$ 。漂移的置信度设为 $99%$ ，即 $p_i+s_i \\geq p_{min}+3</em>s_{min}$ 就认定为发生漂移。如果一组样本中错误率在样本 $k_w$ 的时候达到警告等级，在样本 $k_d$ 的时候达到漂移等级，这时候就会定义一个新的前后环境，该环境从 $k_w$ 开始，并且会用 $k_w$, $k_d$ 之间的数据新训练一个模型。当然也会存在错误率达到警告等级之后又降下去的现象，我们认为这种现象是错误警告，不需要改变前后环境。下图展示了动态窗口的结构。</p>\n<p><img src=\"https://i.imgur.com/Se2GUNb.png\" alt=\"picture 14\"></p>\n<p>该方法能够被用到任何模型中。能够直接在线上和增量算法中使用。从一个实用观点来看的话，该方法做的就是选择更加符合实际情况的训练集。</p>\n","categories":["概念漂移"]},{"title":"LightGBM的时间序列预测","url":"/2022/01/20/LightGBM%E7%9A%84%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B/","content":"<h2 id=\"决策树和梯度提升树简介\">决策树和梯度提升树简介</h2>\n<p>以下是表格数据的一个样例。其中列出了5个人物的信息，包括年龄、性别、职业、是否每天使用电脑这4个维度，我们希望利用这些信息构建机器学习模型，来预测一个人是否喜欢电脑游戏。因此，这4个维度的信息即是数据的特征，而是否喜欢电脑游戏则是数据的标签。每一行的数据是一个样本。</p>\n<p>表1</p>\n<table>\n<thead>\n<tr>\n<th>年龄</th>\n<th>性别</th>\n<th>职业</th>\n<th>是否每天使用电脑</th>\n<th>是否喜欢电脑游戏</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>12</td>\n<td>男</td>\n<td>学生</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>13</td>\n<td>女</td>\n<td>学生</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>36</td>\n<td>女</td>\n<td>护士</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>60</td>\n<td>男</td>\n<td>退休</td>\n<td>否</td>\n<td>否</td>\n</tr>\n<tr>\n<td>57</td>\n<td>女</td>\n<td>退休</td>\n<td>否</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<p>表格数据的特征类型可大致归为数值特征与类别特征这两大类。其中，数值特征的数值大小具有意义，不同特征值之间可以进行大小的比较，表1中的年龄就属于数值特征。而类别特征的不能比较大小，而是表示样本的一种属性，例如表1中的职业、性别等等。</p>\n<span id=\"more\"></span>\n<h3 id=\"决策树的基本结构\">决策树的基本结构</h3>\n<p>决策树是一种基于决策规则的树结构模型。下图是基于表1中数据的决策树的一个例子。该决策树使用表1中的特征预测了每个人是否喜爱电脑游戏。</p>\n<p><img src=\"https://i.imgur.com/3cFe97Y.png\" alt=\"picture 1\"></p>\n<p>样本从决策树的根节点出发，经过一系列的决策条件之后到达叶子节点。例如，对于表1中的第一个样本，由于其年龄不超过15岁，并且性别为男性，故会到达决策树最左边的叶子节点。决策树的每个叶子节点都包含一个常数预测值，作为所有落在该叶子上的样本的预测结果。</p>\n<h3 id=\"决策树的分类\">决策树的分类</h3>\n<p>决策树的分类方法有许多。最常见的是根据其叶子上输出的类型进行分类。叶子上预测值为类别的，称为分类树，用于分类任务。叶子上预测值为实数值的，称为回归树，用于回归任务。上图中的决策树就是一个分类树。</p>\n<h3 id=\"决策树的训练\">决策树的训练</h3>\n<p>同其他有监督学习方法一样，决策树的训练本身也是以优化某个目标函数为目的的。例如，对于回归问题，目标函数可以是最小化均方误差；对于分类问题，目标函数可以是最小化分类错误率。 但是，要找到一个最优的决策树结构非常困难，故决策树的训练通常使用自顶向下的贪心方法。流程如下：</p>\n<ol>\n<li>在训练的开始，决策树仅有一个根节点，所有的训练数据都被分配在根节点上（这时候的根节点也是叶子节点）。</li>\n<li>在当前每片叶子上，遍历所有可能的决策条件，并记录下对优化目标函数贡献（我们称这一贡献为分割增益，即split gain）最大的决策条件，作为该叶子的最优决策条件。</li>\n<li>选取一些叶子，将选中的每片叶子分割为两片新的叶子，同时将这些叶子上的训练数据按照最优决策条件划分到两片新的叶子上。</li>\n<li>对新的叶子赋予预测值，使落在该叶子上的这部分训练数据的目标函数值最优。</li>\n</ol>\n<p>循环以上过程，直到决策树达到预定的规模，或者没有合适的决策条件（例如，所有叶子上的决策条件都有损于目标函数的优化）为止。 需要特别说明的是，在步骤3中选取哪些叶子进行分割有两种常见的方式。第一种是按层分割，即每次分割现存的所有叶子节点。按层分割训练出来的决策树是一个完全二叉树。第二种是按叶子分割，每次只选取当前对优化目标函数最有效的那片叶子。按叶子分割产生的决策树不一定是完全二叉树，因此结构更加灵活。下图展示了两种分割的区别。</p>\n<p><img src=\"https://i.imgur.com/ofGBFqu.png\" alt=\"picture 2\"></p>\n<p>下图展示了以表1为训练数据，以最小化分类错误率为目标、按叶子分割的分类树训练过程。首先让我们关注一下每片叶子上的预测值。正如上面步骤4中所提到的，每片叶子上的预测值，是以最小化该片叶子上数据的分类错误率为目的的。例如，一开始所有数据点都在根节点上，这5条数据中，只有1条的标签为“是”，其余的标签均为“否”，因此一开始根节点上的预测值为否。分割了根节点之后，得到的紫色叶子上有一条数据标签为“是”，其他为“否”，对该叶子赋予“是”或“否”都没有区别，我们随机赋予它“是”作为预测值。 总结而言，对于最小化分类错误率的分类任务，一片叶子上的最优预测值是该片叶子上所有训练数据标签最多归属的类别。 对于最小化均方误差的回归任务，容易得到一片叶子上的最优预测值，就是该片叶子上所有训练数据的标签均值。</p>\n<p>接着我们来完整地查看这个决策树的训练过程。 在训练的一开始，分类错误率为⅕，且容易发现，不管在根节点上选择哪个决策条件，都不能降低分类错误率。因此，我们随机选取年龄是否超过15岁作为根节点的最优分割条件。分割好根节点之后，我们发现右边的子节点上的数据标签已经属于同一类别（都是“否”），它所对应的那部分训练数据的分类错误率已经是0，因此不需要对右边的子节点继续进行分割。考虑左边的子节点，显然，只有用性别作为决策条件才能够分开左边子节点上的两条数据，让训练误差达到0。</p>\n<p><img src=\"https://i.imgur.com/4juLbOA.png\" alt=\"picture 3\"></p>\n<h3 id=\"决策树的正则\">决策树的正则</h3>\n<p>可以想象，只要我们不停地分割叶子节点，且训练集中不存在两条完全相同但标签不同的数据，最后一定可以让决策树完全拟合训练数据的标签，只是这样训练出来的决策树的通常只是在过拟合训练数据，泛化能力较差。因此，除了直接限制决策树的规模之外，在决策树的训练过程中通常会引入一些正则化的限制。常见的有： 1. 叶子上的训练数据不能少于一个阈值。 2. 分割叶子带来的目标函数的改进量不能低于某个阈值。</p>\n<h3 id=\"梯度提升树\">梯度提升树</h3>\n<p>由于单个决策树的拟合能力有限，常通过集成学习的方式将许多决策树综合起来。其中梯度提升树（Gradient Boosted Decision Trees，GBDT）就是一种强有力的决策树集成学习算法，它通过训练一系列的回归树，使得预测值不断逼近目标。GBDT是一个迭代算法，每个迭代都会训练一棵新的回归树，这棵回归树的训练算法与普通的回归树并没有区别。不同的是它所使用的标签，具体如下。</p>\n<p>用 $t_i$ 表示第i轮迭代得到的回归树。那么，在进行完前k轮迭代之后，GBDT对训练数据点(x,y)（其中x为特征，y为标签）的预测值为 $f_k(x)=\\sum_{i=1}^k t_i(x)$ 。则第k+1轮迭代训练使用的数据标签为 $-\\frac{\\partial l(y, \\hat{y})}{\\partial \\hat{y}}|_{\\hat{y} = t_k(x_i)}$ 。 其中 $l(y,\\hat{y})$ 表示单个样本点对损失函数的贡献。例如，当损失函数为均方误差时， $l(y, \\hat{y}) = \\frac{1}{2}(y - \\hat{y}) ^ 2$ 。因此，在第k+1轮迭代训练的决策树，实际上是拟合当前GBDT预测值对损失函数的负梯度。如果损失函数为均方误差，则负梯度为 $f_k(x)-y$ ，这实际上就是当前预测值与标签y的残差。</p>\n<p>前面提到决策树有分类树和回归树。而GBDT只使用回归树，那么GBDT如何处理分类任务呢？虽然，GBDT直接的预测输出是实数值，而不是类别，但是与逻辑回归类似，可以通过sigmoid函数或者softmax转化成分类概率。并以最小化cross-entropy作为训练目标。</p>\n<p>除了决策树本身的正则化手段之外，梯度提升树也有一些正则化方式，主要包括： 1. 在训练好一棵决策树之后，将它的输出乘上一个小的系数（通常小于1）。这一过程称为shrinkage，这个系数可以看作是GBDT的学习率。注意到沿着一个点的负梯度方向，通常只有在该点的领域附近才能带来损失函数的下降，如果走得太远，损失函数可能不降反升。shrinkage在这一点上，与神经网络梯度优化方法的训练中的学习率的作用是一致的。此外，大量的实验表明GBDT使用适当的学习率有助于提高泛化性能。 2. 每个决策树只采样一部分训练数据和特征进行训练。这样做一方面可以提高每个决策树的训练速度；另一方面，使用样本采样时，每个子模型看到了不同的数据集。虽然这些数据集都是整个训练集的子集，但是一定程度上避免了所有子模型过分集中精力去优化整个训练集上的表现，从而缓解了过拟合，也使得在不同测试集上的表现更加稳定。 3. 对回归树叶子的预测值进行L2正则。具体来说，在训练第k+1棵决策树时，在损失函数当中加入一项 $\\beta \\sum_{l \\in t_{k+1}} w_l^2$ ，其中 $l\\in t_{k+1}$ 表示决策树 $t_{k+1}$ 中的所有叶子，w_l表示叶子l上的预测值。</p>\n<h2 id=\"LightGBM\">LightGBM</h2>\n<p>在性能方面，LightGBM的特点主要包括：</p>\n<ol>\n<li>率先支持了按叶子分割的决策树训练方式。在更早的GBDT开源实现中，均采用按层分割的决策树训练。正如上文介绍决策树训练的部分提到的，按叶子分割的方式更加灵活。使用相同叶子数量的情况下，按叶子分割可以更加充分地拟合训练数据。</li>\n<li>对类别特征的直接支持。在决策树的基本结构中，提到了决策树基于类别特征进行的分割，是选出类别特征所有取值中的一个子集 $\\mathcal{C}$ 作为判断条件。若一个样本的该类别特征值在 $\\mathcal{C}$ 中，则将被划分到左边的子节点，否则划分到右边的子节点。然而，要遍历所有这样的 $\\mathcal{C}$ 并选出最优的一个，代价十分巨大。假设一个类别特征共有K种不同的取值，则需要考虑的子集 $\\mathcal{C}$ 的数量为 $2^{K-1}-1$ 。在实际的数据中，很容易出现K达到上万甚至几十万的情况。因此，穷举所有的子集 $\\mathcal{C}$ 的代价是不可接受的。因此，在GBDT中对类别特征常见的处理方式，是将它们通过编码转换成数值特征。LightGBM提供了一种高效地寻找最优子集 $\\mathcal{C}$ 的方法，因此用户无需对类别特征进行额外的预处理。具体来说，在查找类别特征在某片叶子上的最优分割条件时，LightGBM首先将类别特征值按照某个统计量进行排序，然后按照这个顺序从左往右遍历不同的取值，并依次考虑将左边的全部取值作为子集 $\\mathcal{C}$ 。关于排序使用的统计量这里不展开介绍，但是使用这个统计量，就可以保证选取出来的 $\\mathcal{C}$ 一定是最优的。不过，由于选取的子集是 $2^{K-1}-1$ 个中最优的，因此这个方法很容易过拟合数据，尤其是在拥有每种类别特征值的训练样本数量较少的情况下。故LightGBM引入了三个对类别特征分割进行正则化的超参数，分别是: - max_cat_threshold，该参数限制子集 $\\mathcal{C}$ 的最大允许规模。 - cat_smooth，该参数用于对排序使用的统计量进行平滑操作。 - cat_l2，该参数用于增加使用类别特征时的L2正则权重。 要让LightGBM对类别特征的直接支持达到比较好的效果，必须很仔细地调整好这三个参数，缓解过拟合。</li>\n</ol>\n<p>在效率方面，LightGBM的特性主要包括:</p>\n<ol>\n<li>率先使用特征直方图来加速最优分割条件的查找。所谓的直方图优化，就是对每个特征构建一个直方图，在直方图中的每个区间中，累积了计算分割增益所需要的统计量。在查找一个特征的最优分割点，只考虑从直方图的区间边界中进行选取。通常直方图的区间数量不需要太多，几十个到两百多个就可以取得很好的结果。减少候选分割点的数量还可以起到一定的正则化作用。此外，LightGBM还采用了直方图做差的技巧。具体来说，由于直方图每个区间中累积的统计量是按数据进行累加得到的，因此一个特征在父节点中的直方图就等于在两个子节点中的直方图之和。故对属于同一个父节点的两个子节点，我们只需要对其中一个数据量较少的节点构建直方图，而另一个节点的直方图可以从父节点的直方图中减去其兄弟节点的直方图来得到。使用直方图做差可以让直方图的构建加速至少两倍。</li>\n<li>基于梯度的单边样本采样(Gradient-based One-side Sampling，简称GOSS)。与随机森林类似，GBDT每一轮迭代可以只选取一部分数据进行训练。这样做一方面可以降低每轮迭代的训练开销，另一方面也可以提高模型的泛化性能。一般的样本采样方法是随机采样。但是在GBDT的训练中，样本的重要性是有区别的。由于每轮的决策树拟合的标签是当前每个样本的负梯度，故需要根据当前轮次的梯度进行分割增益的计算，因此梯度绝对值的大小很大程度上决定了样本对计算分割增益的贡献。因此，LightGBM提出了一种基于梯度的采样方法GOSS。假设训练数据总量为N，在训练每个决策树之前，GOSS首先选出梯度绝对值最大的a\\times N样本，然后从剩下的样本中，再随机选取 $b\\times N$ 个样本，并将随机选取的这b\\times N个样本的梯度值乘上 $\\frac{1-a}{b}$ ，从而保证采样后的样本梯度和是采样前的一个无偏估计（这样做是因为叶子上的分割增益的计算与梯度之和有关）。使用GOSS，可以在相同的采样率下，取得比随机采样更好的训练结果。</li>\n<li>互斥特征捆绑(Exclusive Feature Bundling，简称EFB)。在表格数据中，常常会遇到一些特征，它们只在很少的一部分训练数据上有取值，而在大部分训练数据上都是缺失的。这样的特征称为稀疏特征。EFB将稀疏特征分组，并将每个分组合并为一个稠密特征，从而减少了训练中的实际特征数量，优化了存储空间并提高最有分割条件的查找速度。合并的原则，是尽可能地减少同组内不同稀疏特征之间的冲突（当两个稀疏特征在同一个数据点都有取值时，我们称之为一个冲突）。</li>\n<li>LightGBM设计了一种改进的数据分布式方案，称为投票分布式(parallel voting trees)。与数据分布式一样，投票分布式将数据按行分配到不同的机器上，并使用本地数据构造不完整的直方图。但是构造完直方图之后，投票分布式只会选取一小部分特征，通过与其他机器的通信得到这些特征的全局直方图，这样就。这些特征的选取方式如下：首先每台机器使用本地不完整的直方图，计算出每个特征的最优分割增益，并选出增益最大的K个特征。记这台机器给这K个特征各投了一票。最后统计每个特征在所有机器中所得的票数，选出的票最高的2K个特征，只通信获得这2K个特征的全局直方图。实验表明投票分布式可以在不降低准确率的前提下减少通信时间，从而提高分布式训练的效率。</li>\n</ol>\n<p><a href=\"https://microsoft.github.io/ai-edu/%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B/B16-%E5%9F%BA%E4%BA%8ELightGBM%E7%9A%84%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B/index.html#%E5%9F%BA%E4%BA%8Elightgbm%E7%9A%84%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B\">具体案例</a></p>\n","categories":["MachineLearning"],"tags":["LightGBM，GBDT"]},{"title":"Unsupervised Concept Drift Detection with a Discriminative Classifier","url":"/2022/04/08/Unsupervised-Concept-Drift-Detection-with-a-Discriminative-Classifier/","content":"<h2 id=\"摘要-7\">摘要</h2>\n<p>作者提出了一个无监督的方法D3，它使用一个带有滑动窗口的分类器通过监视特征空间的变化来检测概念漂移。这个方法可以和已有的分类器一起使用，即便该分类器本身并没有漂移适应机制。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-6\">引言</h2>\n<p>漂移检测主要有两种类型：有监督和无监督。无监督要求数据到了之后标签就要到，有监督则不需要。大多数情况下，有监督方法是检测分类器的表现，当表现下降的时候就说明要发生概念漂移了。而无监督方法主要研究特征的属性。</p>\n<p>本文提出的方法中，通过周期性地训练测试一个分类器来使它能够分别新样本的分布是否和就样本差不多。在批处理设置中与之相类似的问题是训练和测试分布不同的协变量移位适应，用的和本文相近的方法来检测和更正协变量移位。在流处理设置中，本文是第一个提出使用分类器来做漂移检测任务的。</p>\n<h2 id=\"问题定义\">问题定义</h2>\n<p>流分类是发生在数据流中，在时间和内存限制下的监督学习问题。数据流由按序到来的数据$D=\\left{(X_0,y_0),(X_1,y_1),\\dots,(X_t,y_t),\\dots \\right}$组成。其中数据的类别$y_t$只有在测试之后才能获取。</p>\n<p>t时刻的概念表示为$p_t(X,y)$，这样漂移检测就变成了一个判断输入X和标签y的联合分布是否和上一个时间步不一样。</p>\n<p><img src=\"https://i.imgur.com/OiEohiL.png\" alt=\"picture 1\"></p>\n<p>漂移检测的初始目标是设计一个能够和分类模型合作的方法，根据检测到的漂移改进模型，从而提供对于数据分布变化的适应性，最终提升模型的分类表现。</p>\n<h2 id=\"D3（Discriminative-Drift-Detector）方法\">D3（Discriminative Drift Detector）方法</h2>\n<p><img src=\"https://i.imgur.com/dK9AnlV.png\" alt=\"picture 2\"></p>\n<p>使用一个固定尺寸的滑动窗口，包含俩个集合，一个为旧数据，一个为新数据。训练一个简单分类器来区分这些集合，然后根据分类表现来判断是否发生漂移。</p>\n<p>理想状态下，可以通过估计他们的分布和计算他们之间的变化（如kl散度）来观察是否发生漂移。但是这在流数据模式下代价很大，因为需要不断重复估计且我们想要即时的结果。我们想要的仅仅是观察新旧集合是否连续不同，而不是估计他们的分布。学习分布之间的差异其实就足够检测概念漂移了。</p>\n<p>作者使用滑动窗口W，旧数据数量为w，新数据数量为wp，其中p是旧数据占新数据的比例。在初始化阶段，整个窗口为空，我们等待它装满。然后开始第一次检查，引入一个自由变量s，旧样本标记为old并且赋值为0，剩下的样本标记为new并且赋值为1。然后用s作为标签训练一个逻辑回归模型作为分类器来分辨old和new。</p>\n<p>使用AUC作为散度的度量，表示模型能分别两个类的能力。如果能很好分辨两个类的话说明发生了漂移，否则说明没有发生。为此，对AUC设置一个阈值$\\tau$作为发生漂移的分界。</p>\n<p><img src=\"https://i.imgur.com/6TMAow7.png\" alt=\"picture 3\"></p>\n<p>如前面的过程图所示，分类器分类之后会有两个结果：</p>\n<ol>\n<li>AUC大于等于阈值，这时说明发生漂移，然后就需要丢弃所有旧样本，放入新的样本。</li>\n<li>AUC小于等于阈值，这时说明没漂移，丢弃wp(也就是新样本数量)个旧样本，然后放入新样本。</li>\n</ol>\n<p>虽然新旧样本的数量是超参数，我们总会把旧样本数量设的更大。因为需要这一部分数据足够描述当前的分布并且尽量能够覆盖多的特征空间。但是也不能太大，否则可能包含多个不同的概念。由于新数据相对来说很少，因此选择一个在类不均衡场景下能够有效工作的度量是非常有必要的，为此作者选择了AUC，因为它适用于这种场景。</p>\n<h2 id=\"个人感觉这个方法的缺点\">个人感觉这个方法的缺点</h2>\n<p>使用滑动窗口的方法存在一个共同缺点就是窗口的选择，窗口过大可能永远不会检测到漂移，过小可能一直检测到漂移。</p>\n","categories":["概念漂移"]},{"title":"Dynamic Adapting Window Independence Drift Detection(DAWIDD)","url":"/2022/04/11/Dynamic-Adapting-Window-Independence-Drift-Detection-DAWIDD/","content":"<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>许多线上学习方法都包含漂移检测模块来对数据的变化做出检测和反应。但是，可靠的漂移检测算法存在一个具有挑战性的问题，不断变化的漂移特征和缺少反应漂移的参数化模型，这一问题在数据维度较高时更加明显。本文作者提出了DAWIDD的漂移检测方法，旨在对各种漂移特征进行非参的漂移检测。为此，作者在相应的漂移过程中建立了漂移发生与特定随机变量的依赖性的数学等价。这使得漂移检测无需依赖参数化模型，可以进行独立测试，这样的方案对于检测不同类型的漂移足够鲁棒。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>作者的贡献点在于：</p>\n<ol>\n<li>对用于文献中的两种不同的漂移的概念进行了形式化，即作为概率变化的漂移和作为损失函数变化的漂移，并且对他们的等价性做了证明。</li>\n<li>根据漂移过程中随机变量的独立性提供了一个新的漂移的数学表征，并且证明了这种形式化与文献中使用的漂移概念的等价。</li>\n</ol>\n<h2 id=\"概念漂移的定义\"><a href=\"#概念漂移的定义\" class=\"headerlink\" title=\"概念漂移的定义\"></a>概念漂移的定义</h2><h3 id=\"定义1\"><a href=\"#定义1\" class=\"headerlink\" title=\"定义1\"></a>定义1</h3><p>漂移过程 $(p_t,P_T)$ 是由一个[0,1]上的概率测度和 $R^d$ 上的测度集合 $p_t,t\\in [0,1]$构成，这样从t到 $p_t(A)$ 的映射对于每一个 $A \\subset R^d$，都是可测量的。</p>\n<p>对于每一个漂移过程(p_t,P_T)，存在一个在 $R^d\\times [0,1]$ 上的概率测度P，定义为：</p>\n<p><img src=\"https://i.imgur.com/Jwr26yo.png\" alt=\"picture 1\">  </p>\n<p>其中 $B \\subset [0,1],A \\subset R^d$ 。在后面我们将这个定义表示为 $p_t \\otimes P_T$ 。</p>\n<h3 id=\"定义2\"><a href=\"#定义2\" class=\"headerlink\" title=\"定义2\"></a>定义2</h3><p>如果 $p_t \\neq p_s$ 仅在 $P_T$ 为空集情况下成立，则称 $p_t$ 没有发生漂移。</p>\n<p><strong>引理1.</strong> (p_t,P_T)是漂移过程，则以下三点等价：</p>\n<ul>\n<li>$p_t$ 没有漂移</li>\n<li>在 $P_T$ 中存在 $P_X&#x3D;P_t$</li>\n<li>存在 $P_X$ 使得 $p_t \\otimes P_T &#x3D; P_X \\times P_T$</li>\n</ul>\n<h3 id=\"将损失的改变作为漂移的预测\"><a href=\"#将损失的改变作为漂移的预测\" class=\"headerlink\" title=\"将损失的改变作为漂移的预测\"></a>将损失的改变作为漂移的预测</h3><p>作者想要通过说明在哪些场景下损失变化作为预测和上述定义的漂移是等价的来证实基于损失的预测方法。</p>\n<h3 id=\"定义3\"><a href=\"#定义3\" class=\"headerlink\" title=\"定义3\"></a>定义3</h3><p>H作为假设类， $R^d$ 作为测度空间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">证明看不懂，直接跳过，总而言之作者就是证明了其提出的概念漂移的定义和传统的概念漂移检测方法检测到漂移时的情况是一样的。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DAWIDD\"><a href=\"#DAWIDD\" class=\"headerlink\" title=\"DAWIDD\"></a>DAWIDD</h3><p>将漂移检测设计为一个依赖测试：给定 $X_1,\\dots ,X_n$ 作为样本，增加一个时间的随机变量 $T_i$ ，就变成了 $(X_1,T_1),\\dots,(X_n,T_n)$ 。通过对于 $X_i$ 和 $T_i$ 之间的独立性测试我们能够获得一个漂移检测器。</p>\n<p>执行独立性测试我们需要一个固定数量的样本，可以通过一个滑窗来实现。如果检测到漂移，将样本从窗口中移除达到最小值；如果没有，当窗口超微指定大小时，随机移除样本。这样做比数据流上的滑窗在数据上更稳定。比如说移除掉的旧样本恰好能够很好地表示一个渐进漂移。随机移除样本的合理性由下面的引理给出：</p>\n<p><strong>引理2.</strong> $(p_t,P_T)$ 和 $q_t,Q_T$ 是漂移过程。假设 $P_T(A)&#x3D;0 &#x3D;&gt; Q_T(A)&#x3D;0$ 对于任意 $A\\subset[0,1]$ 成立且 $p_t&#x3D;q_t$ 对于所有 $t\\in [0,1]$ 成立，则若 $p_t$ 没有漂移那么 $q_t$ 也没有漂移。</p>\n<p><img src=\"https://i.imgur.com/i4eyB9C.png\" alt=\"picture 1\">  </p>\n","categories":["概念漂移"]},{"title":"go web 编程","url":"/2022/03/09/go-web-%E7%BC%96%E7%A8%8B/","content":"<h2 id=\"web基础\">web基础</h2>\n<h3 id=\"web工作方式\">web工作方式</h3>\n<h4 id=\"http请求包\">http请求包</h4>\n<p>Request 包分为 3 部分，第一部分叫 Request line（请求行）, 第二部分叫 Request header（请求头）, 第三部分是 body（主体）。header 和 body 之间有个空行，请求包的例子所示:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">GET /domains/example/ HTTP/1.1      // 请求行: 请求方法 请求 URI HTTP 协议/协议版本</span><br><span class=\"line\">Host：www.iana.org               // 服务端的主机名</span><br><span class=\"line\">User-Agent：Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4          // 浏览器信息</span><br><span class=\"line\">Accept：text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8  // 客户端能接收的 mine</span><br><span class=\"line\">Accept-Encoding：gzip,deflate,sdch       // 是否支持流压缩</span><br><span class=\"line\">Accept-Charset：UTF-8,*;q=0.5        // 客户端字符编码集</span><br><span class=\"line\">// 空行,用于分割请求头和消息体</span><br><span class=\"line\">// 消息体,请求资源参数,例如 POST 传递的参数</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://i.imgur.com/uTPJIPq.png\" alt=\"picture 1\"></p>\n<p>fiddler抓取的GET信息</p>\n<p><img src=\"https://i.imgur.com/1ZOWDms.png\" alt=\"picture 3\"></p>\n<p>fiddler抓取的POST信息</p>\n<p>可以看出GET请求体为空，POST请求体存在内容。</p>\n<ul>\n<li>GET提交的数据放在URL后用<code>?</code>分割URL和传输数据，不同参数间用<code>&amp;</code>相连。POST方法是将提交的数据放在HTTP包的body中</li>\n<li>GET提交的数据有限（因为URL的长度有限），POST方法无限</li>\n<li>GET提交方法存在安全问题，比如账户密码用GET提交的话会显式地展示在URL上</li>\n</ul>\n<span id=\"more\"></span>\n<h4 id=\"http响应包\">http响应包</h4>\n<p>http的response包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK                     // 状态行</span><br><span class=\"line\">Server: nginx/1.0.8                 // 服务器使用的 WEB 软件名及版本</span><br><span class=\"line\">Date: Tue, 30 Oct 2012 04:14:25 GMT     // 发送时间</span><br><span class=\"line\">Content-Type: text/html             // 服务器发送信息的类型</span><br><span class=\"line\">Transfer-Encoding: chunked          // 表示发送 HTTP 包是分段发的</span><br><span class=\"line\">Connection: keep-alive              // 保持连接状态</span><br><span class=\"line\">Content-Length: 90                  // 主体内容长度</span><br><span class=\"line\">// 空行 用来分割消息头和主体</span><br><span class=\"line\">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;... // 消息体</span><br></pre></td></tr></table></figure>\n<h3 id=\"搭建一个web服务器\">搭建一个web服务器</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayhelloName</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    r.ParseForm()  <span class=\"comment\">// 解析参数，默认是不会解析的</span></span><br><span class=\"line\">    fmt.Println(r.Form)  <span class=\"comment\">// 这些信息是输出到服务器端的打印信息</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;path&quot;</span>, r.URL.Path)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;scheme&quot;</span>, r.URL.Scheme)</span><br><span class=\"line\">    fmt.Println(r.Form[<span class=\"string\">&quot;url_long&quot;</span>])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> r.Form &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;key:&quot;</span>, k)</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;val:&quot;</span>, strings.Join(v, <span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Hello astaxie!&quot;</span>) <span class=\"comment\">// 这个写入到 w 的是输出到客户端的</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, sayhelloName) <span class=\"comment\">// 设置访问的路由</span></span><br><span class=\"line\">    err := http.ListenAndServe(<span class=\"string\">&quot;:9090&quot;</span>, <span class=\"literal\">nil</span>) <span class=\"comment\">// 设置监听的端口</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"go如何使得web工作\">go如何使得web工作</h3>\n<h4 id=\"http包运行机制\">http包运行机制</h4>\n<p><img src=\"https://i.imgur.com/AD1s9gm.png\" alt=\"picture 4\"></p>\n<ul>\n<li>创建 Listen Socket, 监听指定的端口，等待客户端请求到来。</li>\n<li>Listen Socket 接受客户端的请求，得到 Client Socket, 接下来通过 Client Socket 与客户端通信。</li>\n<li>处理客户端的请求，首先从 Client Socket 读取 HTTP 请求的协议头，如果是 POST 方法，还可能要读取客户端提交的数据，然后交给相应的 handler 处理请求，handler 处理完毕准备好客户端需要的数据，通过 Client Socket 写给客户端。</li>\n</ul>\n<p>下面的代码来自go的http包的源码，通过下面代码可以看到整个http处理过程</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">Serve</span><span class=\"params\">(l net.Listener)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> l.Close()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tempDelay time.Duration <span class=\"comment\">// how long to sleep on accept failure</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        rw, e := l.Accept()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> e != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果发生了网络错误的话，可以等待一会后再重试</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> tempDelay == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    tempDelay = <span class=\"number\">5</span> * time.Millisecond</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    tempDelay *= <span class=\"number\">2</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> max := <span class=\"number\">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class=\"line\">                    tempDelay = max</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                log.Printf(<span class=\"string\">&quot;http: Accept error: %v; retrying in %v&quot;</span>, e, tempDelay)</span><br><span class=\"line\">                time.Sleep(tempDelay)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tempDelay = <span class=\"number\">0</span></span><br><span class=\"line\">        c, err := srv.newConn(rw)<span class=\"comment\">//创建一个connection</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">go</span> c.serve()<span class=\"comment\">//创建一个新的goroutine，将参数扔给conn去服务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后怎么具体分配到相应的函数来处理请求呢？conn先解析request:<code>c.readRequest()</code>，然后获取相应的handler：<code>handler:=c.server.Handler</code>，即我们刚才在调用的<code>ListenAndServe</code>时的第二个参数，我们传入的是nil因此会取默认值<code>handler=DefaultServeMux</code>，这个变量就是一个路由器，用来匹配url跳转到相应的handle函数。我们也设置了handle函数<code>http.HandleFunc(&quot;/&quot;,sayHello)</code>，这就是注册了<code>/</code>的路由规则。</p>\n<p>当请求为<code>/</code>的时候，DefaultServeMux会调用ServeHTTP方法，其内部就是调用sayHello，最后通过写入response的信息反馈到客户端</p>\n<p>以下是详细的工作过程</p>\n<p><img src=\"https://i.imgur.com/VDo4ZQr.png\" alt=\"picture 5\"></p>\n<h3 id=\"http包详解\">http包详解</h3>\n<h4 id=\"ServeMux的自定义\">ServeMux的自定义</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ServeMux <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    mu sync.RWMutex   <span class=\"comment\">// 锁，由于请求涉及到并发处理，因此这里需要一个锁机制</span></span><br><span class=\"line\">    m  <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]muxEntry  <span class=\"comment\">// 路由规则，一个 string 对应一个 mux 实体，这里的 string 就是注册的路由表达式</span></span><br><span class=\"line\">    hosts <span class=\"keyword\">bool</span> <span class=\"comment\">// 是否在任意的规则中带有 host 信息</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> muxEntry <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    explicit <span class=\"keyword\">bool</span>   <span class=\"comment\">// 是否精确匹配</span></span><br><span class=\"line\">    h        Handler <span class=\"comment\">// 这个路由表达式对应哪个 handler</span></span><br><span class=\"line\">    pattern  <span class=\"keyword\">string</span>  <span class=\"comment\">// 匹配字符串</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    ServeHTTP(ResponseWriter, *Request)  <span class=\"comment\">// 路由实现器</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们可以看到Handler接口需要实现ServeHTTP方法，但是我们自己的sayHello并没有实现这个方法，为什么能作为handler func被添加呢？</p>\n<p>因为http包中还有一个类型<code>HandlerFunc</code>，它默认实现了ServeHTTP这个接口我们定义的函数<code>sayHello</code>就是它调用之后的结果。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> HandlerFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ResponseWriter, *Request)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ServeHTTP calls f(w, r).</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f HandlerFunc)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class=\"line\">    f(w, r)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样路由器里面存储了相应的路由规则之后，具体的请求是怎么发放的呢？默认的路由器实现了ServeHTTP：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.RequestURI == <span class=\"string\">&quot;*&quot;</span> &#123;</span><br><span class=\"line\">        w.Header().Set(<span class=\"string\">&quot;Connection&quot;</span>, <span class=\"string\">&quot;close&quot;</span>)</span><br><span class=\"line\">        w.WriteHeader(StatusBadRequest)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    h, _ := mux.Handler(r)</span><br><span class=\"line\">    h.ServeHTTP(w, r)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>路由器接收到请求了之后，如果是<code>*</code>就关闭链接，否则的话调用<code>mux.Handler</code>返回对应设置路由的处理handler，然后执行<code>h.SerceHTTP(w,r)</code></p>\n<p>那么<code>mux.Handler(r)</code>是怎么处理的呢？</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handler</span><span class=\"params\">(r *Request)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.Method != <span class=\"string\">&quot;CONNECT&quot;</span> &#123;<span class=\"comment\">//如果r是非连接请求的话</span></span><br><span class=\"line\">        <span class=\"comment\">//p初始化为URL路径</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> p := cleanPath(r.URL.Path); p != r.URL.Path &#123;</span><br><span class=\"line\">            _, pattern = mux.handler(r.Host, p)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> RedirectHandler(p, StatusMovedPermanently), pattern</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mux.handler(r.Host, r.URL.Path)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">handler</span><span class=\"params\">(host, path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    mux.mu.RLock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> mux.mu.RUnlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Host-specific pattern takes precedence over generic ones</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> mux.hosts &#123;</span><br><span class=\"line\">        <span class=\"comment\">//将host和path组合</span></span><br><span class=\"line\">        h, pattern = mux.match(host + path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> h == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        h, pattern = mux.match(path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> h == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        h, pattern = NotFoundHandler(), <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原来他是根据用户请求的 URL 和路由器里面存储的 map 去匹配的，当匹配到之后返回存储的 handler，调用这个 handler 的 ServeHTTP 接口就可以执行到相应的函数了。</p>\n<p>通过上面这个介绍，我们了解了整个路由过程，Go 其实支持外部实现的路由器 ListenAndServe 的第二个参数就是用以配置外部路由器的，它是一个 Handler 接口，即外部路由器只要实现了 Handler 接口就可以，我们可以在自己实现的路由器的 ServeHTTP 里面实现自定义路由功能。</p>\n<p>如下代码所示，我们自己实现了一个简易的路由器</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyMux <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *MyMux)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.URL.Path == <span class=\"string\">&quot;/&quot;</span> &#123;</span><br><span class=\"line\">        sayhelloName(w, r)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    http.NotFound(w, r)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayhelloName</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Hello myroute!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    mux := &amp;MyMux&#123;&#125;</span><br><span class=\"line\">    http.ListenAndServe(<span class=\"string\">&quot;:9090&quot;</span>, mux)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>梳理一下整个代码的执行过程</p>\n<ul>\n<li>首先调用<code>Http.HandleFunc</code>\n<ol>\n<li>调用了<code>DefaultServeMux</code>的<code>HandleFunc</code></li>\n<li>调用了<code>DefaultServeMux</code>的<code>Handle</code></li>\n<li>往<code>DefaultServeMux</code>的<code>map[string]muxEntry</code>中增加对应的handler和路由规则</li>\n</ol>\n</li>\n<li>其次调用http.ListenAndServe(“:9090”,nil)\n<ol>\n<li>实例化Server</li>\n<li>调用Server的ListenAndServe()</li>\n<li>调用<code>net.Listen(&quot;tcp&quot;,addr)</code></li>\n<li>启动一个for循环，在循环体中Accept请求</li>\n<li>对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务<code>go c.serve()</code></li>\n<li>读取每个请求的内容<code>w,err:=c.readRequest()</code></li>\n<li>判断handler是否为空，如果没有设置handler，则默认设置为<code>DefaultServeMux</code></li>\n<li>调用handler的ServeHttp</li>\n<li>根据request选择handler，并且进入其ServeHTTP函数中</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"表单\">表单</h2>\n<h3 id=\"处理表单的输入\">处理表单的输入</h3>\n<p>下面是一个表单递交的例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;/login&quot;</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;post&quot;</span>&gt;</span></span><br><span class=\"line\">    用户名:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span>&gt;</span></span><br><span class=\"line\">    密码:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;登录&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>将以上表单递交到<code>/login</code>，当用户点击login之后，会跳转到这个路由，我们就首先要判断这是通过什么方式传递过来的。</p>\n<p>这在http包中可以用一个很简单的方式获取</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;html/template&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayhelloName</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    r.ParseForm()       <span class=\"comment\">// 解析 url 传递的参数，对于 POST 则解析响应包的主体（request body）</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意:如果没有调用 ParseForm 方法，下面无法获取表单的数据</span></span><br><span class=\"line\">    fmt.Println(r.Form) <span class=\"comment\">// 这些信息是输出到服务器端的打印信息</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;path&quot;</span>, r.URL.Path)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;scheme&quot;</span>, r.URL.Scheme)</span><br><span class=\"line\">    fmt.Println(r.Form[<span class=\"string\">&quot;url_long&quot;</span>])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> r.Form &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;key:&quot;</span>, k)</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;val:&quot;</span>, strings.Join(v, <span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Hello astaxie!&quot;</span>) <span class=\"comment\">// 这个写入到 w 的是输出到客户端的</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">login</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;method:&quot;</span>, r.Method) <span class=\"comment\">// 获取请求的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.Method == <span class=\"string\">&quot;GET&quot;</span> &#123;</span><br><span class=\"line\">        t, _ := template.ParseFiles(<span class=\"string\">&quot;login.gtpl&quot;</span>)</span><br><span class=\"line\">        log.Println(t.Execute(w, <span class=\"literal\">nil</span>))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        err := r.ParseForm()   <span class=\"comment\">// 解析 url 传递的参数，对于 POST 则解析响应包的主体（request body）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// handle error http.Error() for example</span></span><br><span class=\"line\">          log.Fatal(<span class=\"string\">&quot;ParseForm: &quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 请求的是登录数据，那么执行登录的逻辑判断</span></span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;username:&quot;</span>, r.Form[<span class=\"string\">&quot;username&quot;</span>])</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;password:&quot;</span>, r.Form[<span class=\"string\">&quot;password&quot;</span>])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, sayhelloName)       <span class=\"comment\">// 设置访问的路由</span></span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/login&quot;</span>, login)         <span class=\"comment\">// 设置访问的路由</span></span><br><span class=\"line\">    err := http.ListenAndServe(<span class=\"string\">&quot;:9090&quot;</span>, <span class=\"literal\">nil</span>) <span class=\"comment\">// 设置监听的端口</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>request.Form</code>是一个url.Values类型，里面存储的是对应的类似键值对的信息</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">v := url.Values&#123;&#125;</span><br><span class=\"line\">v.Set(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Ava&quot;</span>)</span><br><span class=\"line\">v.Add(<span class=\"string\">&quot;friend&quot;</span>, <span class=\"string\">&quot;Jess&quot;</span>)</span><br><span class=\"line\">v.Add(<span class=\"string\">&quot;friend&quot;</span>, <span class=\"string\">&quot;Sarah&quot;</span>)</span><br><span class=\"line\">v.Add(<span class=\"string\">&quot;friend&quot;</span>, <span class=\"string\">&quot;Zoe&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// v.Encode() == &quot;name=Ava&amp;friend=Jess&amp;friend=Sarah&amp;friend=Zoe&quot;</span></span><br><span class=\"line\">fmt.Println(v.Get(<span class=\"string\">&quot;name&quot;</span>))</span><br><span class=\"line\">fmt.Println(v.Get(<span class=\"string\">&quot;friend&quot;</span>))</span><br><span class=\"line\">fmt.Println(v[<span class=\"string\">&quot;friend&quot;</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"预防跨站脚本\">预防跨站脚本</h3>\n<p>现在的网页大部分内容是动态加载的，这会导致容易受到“跨站脚本攻击”（XSS）的威胁。</p>\n<p>对XSS的防护应该结合以下两种方法：</p>\n<ul>\n<li>验证所有输入数据，有效检测攻击</li>\n<li>对所有输出数据进行适当处理，防止已经成功注入的脚本在浏览器运行</li>\n</ul>\n<p>go里面自带的几个函数可以帮我们进行转义</p>\n<ul>\n<li>func HTMLEscape (w io.Writer, b [] byte) // 把 b 进行转义之后写到 w</li>\n<li>func HTMLEscapeString (s string) string // 转义 s 之后返回结果字符串</li>\n<li>func HTMLEscaper (args …interface {}) string // 支持多个参数一起转义，返回结果字符串</li>\n</ul>\n<p>我们可以看4.1小节的例子</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">fmt.Println(<span class=\"string\">&quot;username:&quot;</span>, template.HTMLEscapeString(r.Form.Get(<span class=\"string\">&quot;username&quot;</span>))) <span class=\"comment\">// 输出到服务器端</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">&quot;password:&quot;</span>, template.HTMLEscapeString(r.Form.Get(<span class=\"string\">&quot;password&quot;</span>)))</span><br><span class=\"line\">template.HTMLEscape(w, []<span class=\"keyword\">byte</span>(r.Form.Get(<span class=\"string\">&quot;username&quot;</span>))) <span class=\"comment\">// 输出到客户端</span></span><br></pre></td></tr></table></figure>\n<p>如果我们输入的username是<code>&lt;script&gt;alert()&lt;/script&gt;</code>,浏览器上就会出现alert提示。</p>\n<p>这个包可以帮助我们过滤html标签，但是我们只想要输出这个看起来正常的信息应该怎么做呢？</p>\n<p>比如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;text/template&quot;</span></span><br><span class=\"line\">...</span><br><span class=\"line\">t, err := template.New(<span class=\"string\">&quot;foo&quot;</span>).Parse(<span class=\"string\">`&#123;&#123;define &quot;T&quot;&#125;&#125;Hello, &#123;&#123;.&#125;&#125;!&#123;&#123;end&#125;&#125;`</span>)</span><br><span class=\"line\">err = t.ExecuteTemplate(out, <span class=\"string\">&quot;T&quot;</span>, <span class=\"string\">&quot;&lt;script&gt;alert(&#x27;you have been pwned&#x27;)&lt;/script&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello, &lt;script&gt;alert(&#x27;you have been pwned&#x27;)&lt;/script&gt;!</span><br></pre></td></tr></table></figure>\n<p>或者将其中的<code>&quot;&lt;script&gt;alert('you have been pwned')&lt;/script&gt;&quot;</code>改成<code>template.HTML(&quot;&lt;script&gt;alert('you have been pwned')&lt;/script&gt;&quot;)</code></p>\n<h3 id=\"验证表单的输入\">验证表单的输入</h3>\n<p>开发web的一个重要原则，不要相信用户输入的任何信息。所以我们需要对用户输入进行验证。通常有两种验证方式，一种是在页面端的js验证，一种是在服务器端的验证，我们主要关注如何在服务器端验证。</p>\n<h4 id=\"必填字段\">必填字段</h4>\n<p>如果我们想确保从表单中获取一个值，比如前面提到的用户名，可以用len函数获取字符串长度，比如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(r.Form[<span class=\"string\">&quot;username&quot;</span>][<span class=\"number\">0</span>])==<span class=\"number\">0</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 为空的处理</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>r.Form</code>对不同表单元素有不同处理，对于空文本框、空文本区域以及文件上传，元素的值为空值，而如果是未选中的复选框和单选按钮，根本不会被<code>r.Form</code>获取到，应用上面的程序就会出错。因此我们需要用<code>r.Form.Get()</code>来获取值，如果字段不存在会返回空，但是这个方法只能取一个值，如果要取map的值，就必须要用上面的方法</p>\n<h4 id=\"数字\">数字</h4>\n<p>如果想要确保一个表单的输入框必须是数字，我们想要判断是正整数的话，先转成int，然后处理</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">getint,err:=strconv.Atoi(r.Form.Get(<span class=\"string\">&quot;age&quot;</span>))</span><br><span class=\"line\"><span class=\"keyword\">if</span> err!=<span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 数字转化出错了，那么可能就不是数字</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接下来就可以判断这个数字的大小范围了</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> getint &gt;<span class=\"number\">100</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 太大了</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以使用正则匹配</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> m, _ := regexp.MatchString(<span class=\"string\">&quot;^[0-9]+$&quot;</span>, r.Form.Get(<span class=\"string\">&quot;age&quot;</span>)); !m &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般来说，尽量避免使用复杂的正则表达式，因为效率会比较低。</p>\n<h4 id=\"中文\">中文</h4>\n<p>有时我们需要对中文进行验证，目前我们有两种验证中文的方式，可以使用<code>unicode</code>包提供的<code>func Is(rangeTab *RangeTable, r rune) bool</code>来验证，也可以使用正则表达式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> m, _ := regexp.MatchString(<span class=\"string\">&quot;^\\\\p&#123;Han&#125;+$&quot;</span>, r.Form.Get(<span class=\"string\">&quot;realname&quot;</span>)); !m &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外包括邮箱、手机号码等都可以使用正则表达式来进行验证，这里就不一一赘述。</p>\n<h4 id=\"下拉菜单\">下拉菜单</h4>\n<p>如果我们需要判断表单里面的<code>&lt;select&gt;</code>的下拉菜单中是否有元素被选中，有时候攻击者会伪造一个菜单中不存在的值发送给服务器，我们如何判断呢？</p>\n<p>比如，我们的select是这样的一些元素</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;fruit&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;apple&quot;</span>&gt;</span>apple<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;pear&quot;</span>&gt;</span>pear<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;banana&quot;</span>&gt;</span>banana<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们可以这样来验证</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">slice:=[]<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;apple&quot;</span>,<span class=\"string\">&quot;pear&quot;</span>,<span class=\"string\">&quot;banana&quot;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">v := r.Form.Get(<span class=\"string\">&quot;fruit&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> _, item := <span class=\"keyword\">range</span> slice &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> item == v &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>对于单选按钮也可以采用相同的验证方法。</p>\n<h4 id=\"日期和时间\">日期和时间</h4>\n<p>想要确定用户填写的日期是否有效的话，可以利用time包</p>\n<h3 id=\"防止多次递交表单\">防止多次递交表单</h3>\n<p>有些时候一些帖子后面会有多条重复的记录，这通常是误操作。但是如果是某项投票中，有人估计多次重复提交的话我们该怎么防止呢？</p>\n<p>解决方案是在表单中添加一个带有唯一值的隐藏字段，验证表单时先验证这个表单是否已经验证过了，如果是的话就拒绝再次提交。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;interest&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;football&quot;</span>&gt;</span>足球</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;interest&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;basketball&quot;</span>&gt;</span>篮球</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;interest&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;tennis&quot;</span>&gt;</span>网球    </span><br><span class=\"line\">用户名:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span>&gt;</span></span><br><span class=\"line\">密码:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;hidden&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;token&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;&#123;&#123;.&#125;&#125;&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;登录&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们在模板中增加了一个隐藏字段<code>token</code>，它的值我们通过时间戳（MD5）来获取唯一值，然后存储到服务器。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">login</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;method:&quot;</span>, r.Method) <span class=\"comment\">// 获取请求的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.Method == <span class=\"string\">&quot;GET&quot;</span> &#123;</span><br><span class=\"line\">        crutime := time.Now().Unix()</span><br><span class=\"line\">        h := md5.New()</span><br><span class=\"line\">        io.WriteString(h, strconv.FormatInt(crutime, <span class=\"number\">10</span>))</span><br><span class=\"line\">        token := fmt.Sprintf(<span class=\"string\">&quot;%x&quot;</span>, h.Sum(<span class=\"literal\">nil</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">        t, _ := template.ParseFiles(<span class=\"string\">&quot;login.gtpl&quot;</span>)</span><br><span class=\"line\">        t.Execute(w, token)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求的是登录数据，那么执行登录的逻辑判断</span></span><br><span class=\"line\">        r.ParseForm()</span><br><span class=\"line\">        token := r.Form.Get(<span class=\"string\">&quot;token&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> token != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 验证 token 的合法性</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不存在 token 报错</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;username length:&quot;</span>, <span class=\"built_in\">len</span>(r.Form[<span class=\"string\">&quot;username&quot;</span>][<span class=\"number\">0</span>]))</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;username:&quot;</span>, template.HTMLEscapeString(r.Form.Get(<span class=\"string\">&quot;username&quot;</span>))) <span class=\"comment\">// 输出到服务器端</span></span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;password:&quot;</span>, template.HTMLEscapeString(r.Form.Get(<span class=\"string\">&quot;password&quot;</span>)))</span><br><span class=\"line\">        template.HTMLEscape(w, []<span class=\"keyword\">byte</span>(r.Form.Get(<span class=\"string\">&quot;username&quot;</span>))) <span class=\"comment\">// 输出到客户端</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"处理文件上传\">处理文件上传</h3>\n<p>要使表单能够上传文件，首先要添加form的<code>enctype</code>属性，<code>enctype</code>属性有如下三种情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">application/x-www-form-urlencoded   表示在发送前编码所有字符（默认）</span><br><span class=\"line\">multipart/form-data   不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。</span><br><span class=\"line\">text/plain    空格转换为 &quot;+&quot; 加号，但不对特殊字符编码。</span><br></pre></td></tr></table></figure>\n<p>在服务器端，我们增加一个handlerFunc</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">http.HandleFunc(<span class=\"string\">&quot;/upload&quot;</span>, upload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理 /upload  逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">upload</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;method:&quot;</span>, r.Method) <span class=\"comment\">// 获取请求的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.Method == <span class=\"string\">&quot;GET&quot;</span> &#123;</span><br><span class=\"line\">        crutime := time.Now().Unix()</span><br><span class=\"line\">        h := md5.New()</span><br><span class=\"line\">        io.WriteString(h, strconv.FormatInt(crutime, <span class=\"number\">10</span>))</span><br><span class=\"line\">        token := fmt.Sprintf(<span class=\"string\">&quot;%x&quot;</span>, h.Sum(<span class=\"literal\">nil</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">        t, _ := template.ParseFiles(<span class=\"string\">&quot;upload.gtpl&quot;</span>)</span><br><span class=\"line\">        t.Execute(w, token)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        r.ParseMultipartForm(<span class=\"number\">32</span> &lt;&lt; <span class=\"number\">20</span>)</span><br><span class=\"line\">        file, handler, err := r.FormFile(<span class=\"string\">&quot;uploadfile&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            fmt.Println(err)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\">        fmt.Fprintf(w, <span class=\"string\">&quot;%v&quot;</span>, handler.Header)</span><br><span class=\"line\">        f, err := os.OpenFile(<span class=\"string\">&quot;./test/&quot;</span>+handler.Filename, os.O_WRONLY|os.O_CREATE, <span class=\"number\">0666</span>)  <span class=\"comment\">// 此处假设当前目录下已存在test目录</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            fmt.Println(err)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> f.Close()</span><br><span class=\"line\">        io.Copy(f, file)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面的代码可以看到，处理文件上传我们需要调用 r.ParseMultipartForm，里面的参数表示 maxMemory，调用 ParseMultipartForm 之后，上传的文件存储在 maxMemory 大小的内存里面，如果文件大小超过了 maxMemory，那么剩下的部分将存储在系统的临时文件中。我们可以通过 r.FormFile 获取上面的文件句柄，然后实例中使用了 io.Copy 来存储文件。</p>\n<p>通过上面的实例我们可以发现文件处理的主要三步：</p>\n<ul>\n<li>表单中增加 enctype=“multipart/form-data”</li>\n<li>服务端调用 r.ParseMultipartForm, 把上传的文件存储在内存和临时文件中</li>\n<li>使用 r.FormFile 获取文件句柄，然后对文件进行存储等处理。</li>\n</ul>\n<p>文件 handler 是 multipart.FileHeader, 里面存储了如下结构信息</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> FileHeader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Filename <span class=\"keyword\">string</span></span><br><span class=\"line\">    Header   textproto.MIMEHeader</span><br><span class=\"line\">    <span class=\"comment\">// contains filtered or unexported fields</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"客户端上传文件\">客户端上传文件</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;bytes&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;io/ioutil&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;mime/multipart&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">postFile</span><span class=\"params\">(filename <span class=\"keyword\">string</span>, targetUrl <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    bodyBuf := &amp;bytes.Buffer&#123;&#125;</span><br><span class=\"line\">    bodyWriter := multipart.NewWriter(bodyBuf)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关键的一步操作</span></span><br><span class=\"line\">    fileWriter, err := bodyWriter.CreateFormFile(<span class=\"string\">&quot;uploadfile&quot;</span>, filename)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;error writing to buffer&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 打开文件句柄操作</span></span><br><span class=\"line\">    fh, err := os.Open(filename)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;error opening file&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> fh.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// iocopy</span></span><br><span class=\"line\">    _, err = io.Copy(fileWriter, fh)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    contentType := bodyWriter.FormDataContentType()</span><br><span class=\"line\">    bodyWriter.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    resp, err := http.Post(targetUrl, contentType, bodyBuf)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> resp.Body.Close()</span><br><span class=\"line\">    resp_body, err := ioutil.ReadAll(resp.Body)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(resp.Status)</span><br><span class=\"line\">    fmt.Println(<span class=\"keyword\">string</span>(resp_body))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sample usage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    target_url := <span class=\"string\">&quot;http://localhost:9090/upload&quot;</span></span><br><span class=\"line\">    filename := <span class=\"string\">&quot;./astaxie.pdf&quot;</span></span><br><span class=\"line\">    postFile(filename, target_url)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"session和数据存储\">session和数据存储</h2>\n<p>cookie是客户端机制，将用户数据保存在客户端；session是服务器端的机制，用类似散列表的结构来保存信息，每个网站访客都会分配一个唯一标识符，sessionID。他的存放形式有两种：经过url传递或者保存在客户端的cookie中，当然也可以保存到数据库中，但是这样效率低。</p>\n<h3 id=\"session和cookie\">session和cookie</h3>\n<p>cookie简而言之就是在本地保存用户操作的历史信息（包括登录信息），并在用户再次访问该站点的时候将本地cookie发送给服务器完成验证</p>\n<p><img src=\"https://i.imgur.com/H39aGop.png\" alt=\"picture 1\"></p>\n<p>session简而言之就是在服务器上保留用户操作的历史信息。使用session id来标识session，由服务器产生，保证随机性和唯一性。但是在这种情况下，仍然需要将发送请求的客户端与session进行对应，所以可以借助cookie机制来获取session id也可以通过get方式将id提交给服务器。</p>\n<p><img src=\"https://i.imgur.com/96ZoX9F.png\" alt=\"picture 2\"></p>\n<h3 id=\"go设置cookie\">go设置cookie</h3>\n<p>go中通过net/http包中的SetCookie来设置</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">http.SetCookie(w ResponseWriter, cookie *Cookie)</span><br></pre></td></tr></table></figure>\n<p>cookie是一个结构体，我们看一下其中的内容</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Cookie <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name       <span class=\"keyword\">string</span></span><br><span class=\"line\">    Value      <span class=\"keyword\">string</span></span><br><span class=\"line\">    Path       <span class=\"keyword\">string</span></span><br><span class=\"line\">    Domain     <span class=\"keyword\">string</span></span><br><span class=\"line\">    Expires    time.Time</span><br><span class=\"line\">    RawExpires <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MaxAge=0 means no &#x27;Max-Age&#x27; attribute specified.</span></span><br><span class=\"line\"><span class=\"comment\">// MaxAge&lt;0 means delete cookie now, equivalently &#x27;Max-Age: 0&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// MaxAge&gt;0 means Max-Age attribute present and given in seconds</span></span><br><span class=\"line\">    MaxAge   <span class=\"keyword\">int</span></span><br><span class=\"line\">    Secure   <span class=\"keyword\">bool</span></span><br><span class=\"line\">    HttpOnly <span class=\"keyword\">bool</span></span><br><span class=\"line\">    Raw      <span class=\"keyword\">string</span></span><br><span class=\"line\">    Unparsed []<span class=\"keyword\">string</span> <span class=\"comment\">// Raw text of unparsed attribute-value pairs</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个简单的设置cookie的例子</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">expiration := time.Now()</span><br><span class=\"line\">expiration = expiration.AddDate(<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">cookie := http.Cookie&#123;Name: <span class=\"string\">&quot;username&quot;</span>, Value: <span class=\"string\">&quot;astaxie&quot;</span>, Expires: expiration&#125;</span><br><span class=\"line\">http.SetCookie(w, &amp;cookie)</span><br></pre></td></tr></table></figure>\n<h3 id=\"go读取cookie\">go读取cookie</h3>\n<p>有两种方式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单独读一个指定的cookie</span></span><br><span class=\"line\">cookie, _ := r.Cookie(<span class=\"string\">&quot;username&quot;</span>)</span><br><span class=\"line\">fmt.Fprint(w, cookie)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将cookie中的记录全部读出</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _, cookie := <span class=\"keyword\">range</span> r.Cookies() &#123;</span><br><span class=\"line\">    fmt.Fprint(w, cookie.Name)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"session\">session</h3>\n<p>session 机制是一种服务器端的机制，服务器使用一种类似于散列表的结构 (也可能就是使用散列表) 来保存信息。</p>\n<p>但程序需要为某个客户端的请求创建一个 session 的时候，服务器首先检查这个客户端的请求里是否包含了一个 session 标识－称为 session id，如果已经包含一个 session id 则说明以前已经为此客户创建过 session，服务器就按照 session id 把这个 session 检索出来使用 (如果检索不到，可能会新建一个，这种情况可能出现在服务端已经删除了该用户对应的 session 对象，但用户人为地在请求的 URL 后面附加上一个 JSESSION 的参数)。如果客户请求不包含 session id，则为此客户创建一个 session 并且同时生成一个与此 session 相关联的 session id，这个 session id 将在本次响应中返回给客户端保存。</p>\n<h2 id=\"go如何使用session\">go如何使用session</h2>\n<p>生成session的三个步骤：</p>\n<ul>\n<li>生成sessionID</li>\n<li>开辟数据存储空间，一般是在内存中创建相应数据结构，但是这样断电的话所有数据会丢失。为此，可以将会话数据写到文件中或者存储到数据库中，虽然会增加IO开销，但是可以实现session的持久化</li>\n<li>将sessionID发送给客户端</li>\n</ul>\n<p>上面步骤中，最重要的是如何发送sessionID。根据HTTP协议，数据可以放到请求行、头域或者body中，因此一般用两种方式：</p>\n<ul>\n<li>cookie：服务端通过设置cookie头就可以将session标识符传送到客户端，客户端之后每次请求都会带上这个标识符。一般包含session信息的cookie会将失效时间设置为0，即浏览器进程关闭时。</li>\n<li>URL重写：在返回给用户的页面里所有的URL后面追加session标识符，这样用户无论点击相应页面的哪个链接或者表单都会带上sessionID。虽然比较麻烦，但是在用户禁用cookie的情况下是首选方案</li>\n</ul>\n<h3 id=\"go实现session管理\">go实现session管理</h3>\n<h4 id=\"session管理设计\">session管理设计</h4>\n<p>session管理涉及以下几个因素：</p>\n<ul>\n<li>全局session管理器</li>\n<li>保证sessionid的全局唯一性</li>\n<li>为每个客户关联一个session</li>\n<li>session的存储（内存、文件、数据库）</li>\n<li>session过期处理</li>\n</ul>\n<h4 id=\"session管理器\">session管理器</h4>\n<p>定义一个全局的session管理器</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Manager <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    cookieName  <span class=\"keyword\">string</span>     <span class=\"comment\">// private cookiename</span></span><br><span class=\"line\">    lock        sync.Mutex <span class=\"comment\">// protects session</span></span><br><span class=\"line\">    provider    Provider</span><br><span class=\"line\">    maxLifeTime <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewManager</span><span class=\"params\">(provideName, cookieName <span class=\"keyword\">string</span>, maxLifeTime <span class=\"keyword\">int64</span>)</span> <span class=\"params\">(*Manager, error)</span></span> &#123;</span><br><span class=\"line\">    provider, ok := provides[provideName]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;session: unknown provide %q (forgotten import?)&quot;</span>, provideName)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Manager&#123;provider: provider, cookieName: cookieName, maxLifeTime: maxLifeTime&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>go实现整个流程应该也是这样的，在main包中创建一个全局的session管理器</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> globalSessions *session.Manager</span><br><span class=\"line\"><span class=\"comment\">// 然后在 init 函数中初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    globalSessions, _ = NewManager(<span class=\"string\">&quot;memory&quot;</span>, <span class=\"string\">&quot;gosessionid&quot;</span>, <span class=\"number\">3600</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>session保存在服务器端，它可以以任何方式存储，因此我们抽象出一个Provider接口，用以表征session管理器底层的存储结构</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Provider <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//新建一个session并且返回</span></span><br><span class=\"line\">    SessionInit(sid <span class=\"keyword\">string</span>) (Session, error)</span><br><span class=\"line\">    <span class=\"comment\">//返回sid代表的session变量，不存在就新建并且返回</span></span><br><span class=\"line\">    SessionRead(sid <span class=\"keyword\">string</span>) (Session, error)</span><br><span class=\"line\">    <span class=\"comment\">//销毁sid表示的session变量</span></span><br><span class=\"line\">    SessionDestroy(sid <span class=\"keyword\">string</span>) error</span><br><span class=\"line\">    <span class=\"comment\">//根据生命周期来删除过期数据</span></span><br><span class=\"line\">    SessionGC(maxLifeTime <span class=\"keyword\">int64</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>session接口需要实现的功能就是增删改查</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Session <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Set(key, value <span class=\"keyword\">interface</span>&#123;&#125;) error <span class=\"comment\">// set session value</span></span><br><span class=\"line\">    Get(key <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"keyword\">interface</span>&#123;&#125;  <span class=\"comment\">// get session value</span></span><br><span class=\"line\">    Delete(key <span class=\"keyword\">interface</span>&#123;&#125;) error     <span class=\"comment\">// delete session value</span></span><br><span class=\"line\">    SessionID() <span class=\"keyword\">string</span>                <span class=\"comment\">// back current sessionID</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面根据需要注册存储session的结构的register函数的实现</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> provides = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Provider)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过名称激活一个provider，如果已经调用过一次的话就panic</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Register</span><span class=\"params\">(name <span class=\"keyword\">string</span>, provider Provider)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> provider == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;session: Register provider is nil&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> _, dup := provides[name]; dup &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;session: Register called twice for provider &quot;</span> + name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    provides[name] = provider</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"全局唯一的sessionID\">全局唯一的sessionID</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(manager *Manager)</span> <span class=\"title\">sessionId</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    b := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> _, err := rand.Read(b); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> base64.URLEncoding.EncodeToString(b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"session创建\">session创建</h3>\n<p>我们需要将用户和session相关联，下面这个函数就是检测是否已经由session与当前用户关联，如果没有就创建</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(manager *Manager)</span> <span class=\"title\">SessionStart</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span> <span class=\"params\">(session Session)</span></span> &#123;</span><br><span class=\"line\">    manager.lock.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> manager.lock.Unlock()</span><br><span class=\"line\">    cookie, err := r.Cookie(manager.cookieName)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> || cookie.Value == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">        sid := manager.sessionId()</span><br><span class=\"line\">        session, _ = manager.provider.SessionInit(sid)</span><br><span class=\"line\">        cookie := http.Cookie&#123;Name: manager.cookieName, Value: url.QueryEscape(sid), Path: <span class=\"string\">&quot;/&quot;</span>, HttpOnly: <span class=\"literal\">true</span>, MaxAge: <span class=\"keyword\">int</span>(manager.maxLifeTime)&#125;</span><br><span class=\"line\">        http.SetCookie(w, &amp;cookie)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        sid, _ := url.QueryUnescape(cookie.Value)</span><br><span class=\"line\">        session, _ = manager.provider.SessionRead(sid)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用前面的login操作来演示session的作用</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">login</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    sess := globalSessions.SessionStart(w, r)</span><br><span class=\"line\">    r.ParseForm()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.Method == <span class=\"string\">&quot;GET&quot;</span> &#123;</span><br><span class=\"line\">        t, _ := template.ParseFiles(<span class=\"string\">&quot;login.gtpl&quot;</span>)</span><br><span class=\"line\">        w.Header().Set(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;text/html&quot;</span>)</span><br><span class=\"line\">        t.Execute(w, sess.Get(<span class=\"string\">&quot;username&quot;</span>))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        sess.Set(<span class=\"string\">&quot;username&quot;</span>, r.Form[<span class=\"string\">&quot;username&quot;</span>])</span><br><span class=\"line\">        http.Redirect(w, r, <span class=\"string\">&quot;/&quot;</span>, <span class=\"number\">302</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"session存储\">session存储</h3>\n<p>基于内存的session存储接口的实现</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> memory</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;container/list&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/astaxie/session&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> pder = &amp;Provider&#123;list: list.New()&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> SessionStore <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    sid          <span class=\"keyword\">string</span>                      <span class=\"comment\">// session id唯一标示</span></span><br><span class=\"line\">    timeAccessed time.Time                   <span class=\"comment\">// 最后访问时间</span></span><br><span class=\"line\">    value        <span class=\"keyword\">map</span>[<span class=\"keyword\">interface</span>&#123;&#125;]<span class=\"keyword\">interface</span>&#123;&#125; <span class=\"comment\">// session里面存储的值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置session中的key value并且更新最后访问时间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(st *SessionStore)</span> <span class=\"title\">Set</span><span class=\"params\">(key, value <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    st.value[key] = value</span><br><span class=\"line\">    pder.SessionUpdate(st.sid)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//根据给定键获取session中的值，并且更新最终访问时间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(st *SessionStore)</span> <span class=\"title\">Get</span><span class=\"params\">(key <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">interface</span></span>&#123;&#125; &#123;</span><br><span class=\"line\">    pder.SessionUpdate(st.sid)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> v, ok := st.value[key]; ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//删除给定键的键值对，更新最终访问时间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(st *SessionStore)</span> <span class=\"title\">Delete</span><span class=\"params\">(key <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">delete</span>(st.value, key)</span><br><span class=\"line\">    pder.SessionUpdate(st.sid)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取sessionID</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(st *SessionStore)</span> <span class=\"title\">SessionID</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st.sid</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Provider <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    lock     sync.Mutex               <span class=\"comment\">// 用来锁</span></span><br><span class=\"line\">    sessions <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*list.Element <span class=\"comment\">// 用来存储在内存</span></span><br><span class=\"line\">    list     *list.List               <span class=\"comment\">// 用来做 gc</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pder *Provider)</span> <span class=\"title\">SessionInit</span><span class=\"params\">(sid <span class=\"keyword\">string</span>)</span> <span class=\"params\">(session.Session, error)</span></span> &#123;</span><br><span class=\"line\">    pder.lock.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> pder.lock.Unlock()</span><br><span class=\"line\">    v := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">interface</span>&#123;&#125;]<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">    newsess := &amp;SessionStore&#123;sid: sid, timeAccessed: time.Now(), value: v&#125;</span><br><span class=\"line\">    element := pder.list.PushFront(newsess)</span><br><span class=\"line\">    pder.sessions[sid] = element</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newsess, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pder *Provider)</span> <span class=\"title\">SessionRead</span><span class=\"params\">(sid <span class=\"keyword\">string</span>)</span> <span class=\"params\">(session.Session, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> element, ok := pder.sessions[sid]; ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> element.Value.(*SessionStore), <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        sess, err := pder.SessionInit(sid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sess, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pder *Provider)</span> <span class=\"title\">SessionDestroy</span><span class=\"params\">(sid <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> element, ok := pder.sessions[sid]; ok &#123;</span><br><span class=\"line\">        <span class=\"built_in\">delete</span>(pder.sessions, sid)</span><br><span class=\"line\">        pder.list.Remove(element)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pder *Provider)</span> <span class=\"title\">SessionGC</span><span class=\"params\">(maxlifetime <span class=\"keyword\">int64</span>)</span></span> &#123;</span><br><span class=\"line\">    pder.lock.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> pder.lock.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        element := pder.list.Back()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> element == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (element.Value.(*SessionStore).timeAccessed.Unix() + maxlifetime) &lt; time.Now().Unix() &#123;</span><br><span class=\"line\">            pder.list.Remove(element)</span><br><span class=\"line\">            <span class=\"built_in\">delete</span>(pder.sessions, element.Value.(*SessionStore).sid)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pder *Provider)</span> <span class=\"title\">SessionUpdate</span><span class=\"params\">(sid <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    pder.lock.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> pder.lock.Unlock()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> element, ok := pder.sessions[sid]; ok &#123;</span><br><span class=\"line\">        element.Value.(*SessionStore).timeAccessed = time.Now()</span><br><span class=\"line\">        pder.list.MoveToFront(element)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    pder.sessions = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*list.Element, <span class=\"number\">0</span>)</span><br><span class=\"line\">    session.Register(<span class=\"string\">&quot;memory&quot;</span>, pder)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"文本处理\">文本处理</h2>\n<h3 id=\"XML处理\">XML处理</h3>\n<p>假设服务器上生成了如下的xml的配置文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servers</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">serverName</span>&gt;</span>Shanghai_VPN<span class=\"tag\">&lt;/<span class=\"name\">serverName</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">serverIP</span>&gt;</span>127.0.0.1<span class=\"tag\">&lt;/<span class=\"name\">serverIP</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">serverName</span>&gt;</span>Beijing_VPN<span class=\"tag\">&lt;/<span class=\"name\">serverName</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">serverIP</span>&gt;</span>127.0.0.2<span class=\"tag\">&lt;/<span class=\"name\">serverIP</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servers</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"解析XML\">解析XML</h4>\n<p>我们可以通过xml包的<code>Unmarshal</code>来达到我们的目的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Unmarshal</span><span class=\"params\">(data []<span class=\"keyword\">byte</span>, v <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<p>data接收的是XML数据流，v是需要输出的结构，可以把XML转换为任意格式。这里我们主要看转换成struct，因为他们都有类似树结构的特征。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/xml&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;io/ioutil&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Recurlyservers <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    XMLName     xml.Name <span class=\"string\">`xml:&quot;servers&quot;`</span></span><br><span class=\"line\">    Version     <span class=\"keyword\">string</span>   <span class=\"string\">`xml:&quot;version,attr&quot;`</span></span><br><span class=\"line\">    Svs         []server <span class=\"string\">`xml:&quot;server&quot;`</span></span><br><span class=\"line\">    Description <span class=\"keyword\">string</span>   <span class=\"string\">`xml:&quot;,innerxml&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    XMLName    xml.Name <span class=\"string\">`xml:&quot;server&quot;`</span></span><br><span class=\"line\">    ServerName <span class=\"keyword\">string</span>   <span class=\"string\">`xml:&quot;serverName&quot;`</span></span><br><span class=\"line\">    ServerIP   <span class=\"keyword\">string</span>   <span class=\"string\">`xml:&quot;serverIP&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    file, err := os.Open(<span class=\"string\">&quot;servers.xml&quot;</span>) <span class=\"comment\">// For read access.     </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;error: %v&quot;</span>, err)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\">    data, err := ioutil.ReadAll(file)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;error: %v&quot;</span>, err)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    v := Recurlyservers&#123;&#125;</span><br><span class=\"line\">    err = xml.Unmarshal(data, &amp;v)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;error: %v&quot;</span>, err)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Println(v)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子会输出如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&#123; servers&#125; 1 [&#123;&#123; server&#125; Shanghai_VPN 127.0.0.1&#125; &#123;&#123; server&#125; Beijing_VPN 127.0.0.2&#125;]</span><br><span class=\"line\">&lt;server&gt;</span><br><span class=\"line\">    &lt;serverName&gt;Shanghai_VPN&lt;/serverName&gt;</span><br><span class=\"line\">    &lt;serverIP&gt;127.0.0.1&lt;/serverIP&gt;</span><br><span class=\"line\">&lt;/server&gt;</span><br><span class=\"line\">&lt;server&gt;</span><br><span class=\"line\">    &lt;serverName&gt;Beijing_VPN&lt;/serverName&gt;</span><br><span class=\"line\">    &lt;serverIP&gt;127.0.0.2&lt;/serverIP&gt;</span><br><span class=\"line\">&lt;/server&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到struct的字段后面多了一些<code>xml:&quot;serverName&quot;</code>的内容，这是struct的特性，在后面加上tag用来辅助反射，我们看一下Unmarshal的定义</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Unmarshal</span><span class=\"params\">(data []<span class=\"keyword\">byte</span>, v <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<p>两个参数，一个是XML数据流，另一个是存储的对应类型，目前来说支持struct、slice和string，XML包内部通过反射进行数据映射，因此v里面的字段必须导出。</p>\n<p>那XML元素和字段怎么对应呢？这是有优先级顺序的，首先读取struct tag，如果没有就读取字段名。<strong>需要注意的是，解析时tag、字段名和XML元素都是对大小写敏感的</strong>。</p>\n<ul>\n<li>如果struct的一个字段是string或者[]byte类型且它的tag含有<code>&quot;,innerxml&quot;</code>，Unmarshal会将此字段所对应的元素内的所有内嵌的原始XML累加到此字段上，如上面例子中的Description。</li>\n<li>如果 struct 中有一个叫做 XMLName，且类型为 <a href=\"http://xml.Name\">xml.Name</a> 字段，那么在解析的时候就会保存这个 element 的名字到该字段，如上面例子中的 servers。</li>\n<li>如果某个 struct 字段的 tag 定义中含有 XML 结构中 element 的名称，那么解析的时候就会把相应的 element 值赋值给该字段，如上 servername 和 serverip 定义。</li>\n<li>如果某个 struct 字段的 tag 定义了中含有 <code>&quot;,attr&quot;</code>，那么解析的时候就会将该结构所对应的 element 的与字段同名的属性的值赋值给该字段，如上 version 定义。</li>\n<li>如果某个 struct 字段的 tag 定义 型如 “a&gt;b&gt;c”, 则解析的时候，会将 xml 结构 a 下面的 b 下面的 c 元素的值赋值给该字段。</li>\n<li>如果某个 struct 字段的 tag 定义了 “-”, 那么不会为该字段解析匹配任何 xml 数据。</li>\n<li>如果 struct 字段后面的 tag 定义了 “,any”，如果他的子元素在不满足其他的规则的时候就会匹配到这个字段。</li>\n<li>如果某个 XML 元素包含一条或者多条注释，那么这些注释将被累加到第一个 tag 含有 “,comments” 的字段上，这个字段的类型可能是 [] byte 或 string, 如果没有这样的字段存在，那么注释将会被抛弃。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">注意： 为了正确解析，go 语言的 xml 包要求 struct 定义中的所有字段必须是可导出的（即首字母大写）</span><br></pre></td></tr></table></figure>\n<h4 id=\"输出XML\">输出XML</h4>\n<p>如果我们不是要解析而是要生成，该如何实现呢？</p>\n<p>xml包中提供了<code>Marshal</code>和<code>MarshalIndent</code>，他们的区别是后者会增加前缀和缩进</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Marshal</span><span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MarshalIndent</span><span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;, prefix, indent <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>\n<p>两个函数都是用来生成xml的结构定义类型数据，返回XML的数据流。我们来看一下如何输出如上的XML</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/xml&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Servers <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    XMLName xml.Name <span class=\"string\">`xml:&quot;servers&quot;`</span></span><br><span class=\"line\">    Version <span class=\"keyword\">string</span>   <span class=\"string\">`xml:&quot;version,attr&quot;`</span></span><br><span class=\"line\">    Svs     []server <span class=\"string\">`xml:&quot;server&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ServerName <span class=\"keyword\">string</span> <span class=\"string\">`xml:&quot;serverName&quot;`</span></span><br><span class=\"line\">    ServerIP   <span class=\"keyword\">string</span> <span class=\"string\">`xml:&quot;serverIP&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    v := &amp;Servers&#123;Version: <span class=\"string\">&quot;1&quot;</span>&#125;</span><br><span class=\"line\">    v.Svs = <span class=\"built_in\">append</span>(v.Svs, server&#123;<span class=\"string\">&quot;Shanghai_VPN&quot;</span>, <span class=\"string\">&quot;127.0.0.1&quot;</span>&#125;)</span><br><span class=\"line\">    v.Svs = <span class=\"built_in\">append</span>(v.Svs, server&#123;<span class=\"string\">&quot;Beijing_VPN&quot;</span>, <span class=\"string\">&quot;127.0.0.2&quot;</span>&#125;)</span><br><span class=\"line\">    output, err := xml.MarshalIndent(v, <span class=\"string\">&quot;  &quot;</span>, <span class=\"string\">&quot;    &quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;error: %v\\n&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    os.Stdout.Write([]<span class=\"keyword\">byte</span>(xml.Header))</span><br><span class=\"line\"></span><br><span class=\"line\">    os.Stdout.Write(output)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出信息如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span><br><span class=\"line\">&lt;servers version=<span class=\"string\">&quot;1&quot;</span>&gt;</span><br><span class=\"line\">&lt;server&gt;</span><br><span class=\"line\">    &lt;serverName&gt;Shanghai_VPN&lt;/serverName&gt;</span><br><span class=\"line\">    &lt;serverIP&gt;<span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>&lt;/serverIP&gt;</span><br><span class=\"line\">&lt;/server&gt;</span><br><span class=\"line\">&lt;server&gt;</span><br><span class=\"line\">    &lt;serverName&gt;Beijing_VPN&lt;/serverName&gt;</span><br><span class=\"line\">    &lt;serverIP&gt;<span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.2</span>&lt;/serverIP&gt;</span><br><span class=\"line\">&lt;/server&gt;</span><br><span class=\"line\">&lt;/servers&gt;</span><br></pre></td></tr></table></figure>\n<p>之所以其中会有<code>os.Stdout.Write([]byte(xml.Header))</code>,是因为这两个函数都是不带xml信息头的，为了生成正确的xml文件，我们需要使用xml包预定义的header。</p>\n<p>可以看到<code>Marshal</code>函数接收的参数v是interface{}，那么它根据什么规则来生成相应的文件呢？</p>\n<ul>\n<li>v是array或者slice，则输出每一个元素，类似于value</li>\n<li>v是指针，会Marshal指针指向的内容，如果为空什么都不输出</li>\n<li>v是interface，处理interface包含的数据</li>\n<li>v是其他，输出这个数据类型所拥有的字段信息</li>\n</ul>\n<p>那生成的XML文件中的element的名字由什么决定呢？按照以下优先级</p>\n<ul>\n<li>v是struct，XMLName的tag中定义的名称</li>\n<li>类型为xml.Name的名叫XMLName的字段的值</li>\n<li>通过struct中字段的tag获取</li>\n<li>通过struct的字段名用来获取</li>\n<li>marshal的类型名称</li>\n</ul>\n<p>那么应该如何设置struct中字段的tag信息来控制最终生成的xml文件呢？</p>\n<ul>\n<li>XMLName 不会被输出</li>\n<li>tag 中含有 “-” 的字段不会输出</li>\n<li>tag 中含有 “name,attr”，会以 name 作为属性名，字段值作为值输出为这个  XML 元素的属性，如上 version 字段所描述</li>\n<li>tag 中含有 “,attr”，会以这个 struct 的字段名作为属性名输出为 XML 元 素的属性，类似上一条，只是这个 name 默认是字段名了。</li>\n<li>tag 中含有 “,chardata”，输出为 xml 的 character data 而非 element。</li>\n<li>tag 中含有 “,innerxml”，将会被原样输出，而不会进行常规的编码过程<br>\ntag 中含有 “,comment”，将被当作 xml 注释来输出，而不会进行常规的编码过程，字段值中不能含有 “–” 字符串</li>\n<li>tag 中含有 “omitempty”, 如果该字段的值为空值那么该字段就不会被输出到 XML，空值包括：false、0、nil 指针或 nil 接口，任何长度为 0 的 array, slice, map 或者 string</li>\n<li>tag 中含有 “a&gt;b&gt;c”，那么就会循环输出三个元素 a 包含 b，b 包含 c，例如如下代码就会输出</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">FirstName string   `xml:&quot;name&gt;first&quot;`</span><br><span class=\"line\">LastName  string   `xml:&quot;name&gt;last&quot;`</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;name&gt;</span><br><span class=\"line\">&lt;first&gt;Asta&lt;/first&gt;</span><br><span class=\"line\">&lt;last&gt;Xie&lt;/last&gt;</span><br><span class=\"line\">&lt;/name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JSON处理\">JSON处理</h3>\n<p>上一小节的例子的JSON表示如下</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;servers&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;serverName&quot;</span>: <span class=\"string\">&quot;Shanghai_VPN&quot;</span>, </span><br><span class=\"line\">            <span class=\"attr\">&quot;serverIP&quot;</span>: <span class=\"string\">&quot;127.0.0.1&quot;</span></span><br><span class=\"line\">        &#125;, </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;serverName&quot;</span>: <span class=\"string\">&quot;Beijing_VPN&quot;</span>, </span><br><span class=\"line\">            <span class=\"attr\">&quot;serverIP&quot;</span>: <span class=\"string\">&quot;127.0.0.2&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"解析JSON到结构体\">解析JSON到结构体</h4>\n<p>假如有了上述JSON串，如何对他进行解析呢？</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Unmarshal</span><span class=\"params\">(data []<span class=\"keyword\">byte</span>, v <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<p>通过这个函数我们可以解析JSON，代码如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ServerName <span class=\"keyword\">string</span></span><br><span class=\"line\">    ServerIP   <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Serverslice <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Servers []Server</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s Serverslice</span><br><span class=\"line\">    str := <span class=\"string\">`&#123;&quot;servers&quot;:[&#123;&quot;serverName&quot;:&quot;Shanghai_VPN&quot;,&quot;serverIP&quot;:&quot;127.0.0.1&quot;&#125;,&#123;&quot;serverName&quot;:&quot;Beijing_VPN&quot;,&quot;serverIP&quot;:&quot;127.0.0.2&quot;&#125;]&#125;`</span></span><br><span class=\"line\">    json.Unmarshal([]<span class=\"keyword\">byte</span>(str), &amp;s)</span><br><span class=\"line\">    fmt.Println(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中我们首先定义了json数据对应的结构体，数组对应slice，字段名对应json里面的key，那么解析的时候怎么将json数据和struct字段相匹配呢？比如json中的key是<code>Foo</code>，怎么找对应的字段呢？</p>\n<ul>\n<li>首先查找tag中含有<code>Foo</code>的可以导出的struct字段（首字母大写）</li>\n<li>其次查找字段名是<code>Foo</code>的导出字段</li>\n<li>最后查找类似<code>FOO</code>或者<code>FoO</code>这样的除了首字母之外其他大小写不敏感的导出字段</li>\n</ul>\n<h4 id=\"解析到interface\">解析到interface</h4>\n<p>上面的解析建立在我们知道被解析的json数据的结构下采取的方案，如果我们不知道被解析的数据的格式呢？</p>\n<p>interface{}可以处理任意数据类型，其正好可以用于存储解析的未知结构的json数据的结果。json包中采取<code>map[string]interface&#123;&#125;</code>和<code>[]interface&#123;&#125;</code>结构来存储任意JSON对象和数组。</p>\n<p>go类型和json类型对应关系如下</p>\n<ul>\n<li>bool :JSON booleans</li>\n<li>float64 :JSON numbers</li>\n<li>string :JSON strings</li>\n<li>nil :JSON null</li>\n</ul>\n<p>现在假设有以下JSON数据</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">b := []<span class=\"keyword\">byte</span>(<span class=\"string\">`&#123;&quot;Name&quot;:&quot;Wednesday&quot;,&quot;Age&quot;:6,&quot;Parents&quot;:[&quot;Gomez&quot;,&quot;Morticia&quot;]&#125;`</span>)</span><br></pre></td></tr></table></figure>\n<p>如果我们在不知道内部结构的情况下将他解析到interface{}中</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">err := json.Unmarshal(b, &amp;f)</span><br></pre></td></tr></table></figure>\n<p>这个时候f里面存储了一个map类型，他们的key是string，值存储在空的interface{}里面</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">f = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;Wednesday&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Age&quot;</span>:  <span class=\"number\">6</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Parents&quot;</span>: []<span class=\"keyword\">interface</span>&#123;&#125;&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;Gomez&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Morticia&quot;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要通过断言的方式来访问这些数据</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">m := f.(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> m &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> vv := v.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">string</span>:</span><br><span class=\"line\">        fmt.Println(k, <span class=\"string\">&quot;is string&quot;</span>, vv)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">int</span>:</span><br><span class=\"line\">        fmt.Println(k, <span class=\"string\">&quot;is int&quot;</span>, vv)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">float64</span>:</span><br><span class=\"line\">        fmt.Println(k,<span class=\"string\">&quot;is float64&quot;</span>,vv)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> []<span class=\"keyword\">interface</span>&#123;&#125;:</span><br><span class=\"line\">        fmt.Println(k, <span class=\"string\">&quot;is an array:&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, u := <span class=\"keyword\">range</span> vv &#123;</span><br><span class=\"line\">            fmt.Println(i, u)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        fmt.Println(k, <span class=\"string\">&quot;is of a type I don&#x27;t know how to handle&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以发现，通过interface{}和类型断言的结合，就可以解析未知结构的json数据了</p>\n<p>上述是官方提供的解决方案，但用起来不是很方便，<code>simplejson</code>包在处理未知结构的json时相当方便，例子如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">js, err := simplejson.NewJson([]<span class=\"keyword\">byte</span>(<span class=\"string\">`&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;test&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;array&quot;: [1, &quot;2&quot;, 3],</span></span><br><span class=\"line\"><span class=\"string\">        &quot;int&quot;: 10,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;float&quot;: 5.150,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;bignum&quot;: 9223372036854775807,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;string&quot;: &quot;simplejson&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;bool&quot;: true</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;`</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">arr, _ := js.Get(<span class=\"string\">&quot;test&quot;</span>).Get(<span class=\"string\">&quot;array&quot;</span>).Array()</span><br><span class=\"line\">i, _ := js.Get(<span class=\"string\">&quot;test&quot;</span>).Get(<span class=\"string\">&quot;int&quot;</span>).Int()</span><br><span class=\"line\">ms := js.Get(<span class=\"string\">&quot;test&quot;</span>).Get(<span class=\"string\">&quot;string&quot;</span>).MustString()</span><br></pre></td></tr></table></figure>\n<h4 id=\"生成json\">生成json</h4>\n<p>通过JSON包里的<code>Marshal</code>来处理</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Marshal</span><span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;)</span><span class=\"params\">([]<span class=\"keyword\">byte</span>,error)</span></span></span><br></pre></td></tr></table></figure>\n<p>假设我们还是需要生成上面的服务器列表信息，看下面的例子</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ServerName <span class=\"keyword\">string</span></span><br><span class=\"line\">    ServerIP   <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Serverslice <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Servers []Server</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s Serverslice</span><br><span class=\"line\">    s.Servers = <span class=\"built_in\">append</span>(s.Servers, Server&#123;ServerName: <span class=\"string\">&quot;Shanghai_VPN&quot;</span>, ServerIP: <span class=\"string\">&quot;127.0.0.1&quot;</span>&#125;)</span><br><span class=\"line\">    s.Servers = <span class=\"built_in\">append</span>(s.Servers, Server&#123;ServerName: <span class=\"string\">&quot;Beijing_VPN&quot;</span>, ServerIP: <span class=\"string\">&quot;127.0.0.2&quot;</span>&#125;)</span><br><span class=\"line\">    b, err := json.Marshal(s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;json err:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(<span class=\"keyword\">string</span>(b))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&quot;Servers&quot;:[&#123;&quot;ServerName&quot;:&quot;Shanghai_VPN&quot;,&quot;ServerIP&quot;:&quot;127.0.0.1&quot;&#125;,&#123;&quot;ServerName&quot;:&quot;Beijing_VPN&quot;,&quot;ServerIP&quot;:&quot;127.0.0.2&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到上面的都是首字母大写，如果想用小写首字母怎么办呢，用结构体的tag来实现</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ServerName <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;serverName&quot;`</span></span><br><span class=\"line\">    ServerIP   <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;serverIP&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Serverslice <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Servers []Server <span class=\"string\">`json:&quot;servers&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>针对json的输出，定义tag的时候需要注意：</p>\n<ul>\n<li>字段的 tag 是 “-”，那么这个字段不会输出到 JSON</li>\n<li>tag 中带有自定义名称，那么这个自定义名称会出现在 JSON 的字段名中，例如上面例子中 serverName</li>\n<li>tag 中如果带有 “omitempty” 选项，那么如果该字段值为空，就不会输出到 JSON 串中</li>\n<li>如果字段类型是 bool, string, int, int64 等，而 tag 中带有 “,string” 选项，那么这个字段在输出到 JSON 的时候会把该字段对应的值转换成 JSON 字符串</li>\n</ul>\n","categories":["go"],"tags":["web"]},{"title":"Semi-Supervised Classification With Graph Convolutional Networks","url":"/2022/03/20/Semi-Supervised-Classification-With-Graph-Convolutional-Networks/","content":"<h2 id=\"引言-8\">引言</h2>\n<p>文章主要围绕对仅有少部分节点存在标签的图节点进行分类任务。这个问题可以被认为是基于图的半监督学习，通过某种基于图的正则化来平滑图上的标签信息，比如在损失函数中增加一个图拉普拉斯正则化。</p>\n<p><img src=\"https://i.imgur.com/q31vbLg.png\" alt=\"picture 44\"></p>\n<p>其中$L_0$是有标签部分的损失项，函数f是一个可微函数，$\\lambda$是一个权重参数，X是节点的特征向量矩阵，$\\delta =D-A$是一个未归一化的图拉普拉斯矩阵，A是邻接矩阵，D是度矩阵。**公式一是居于相邻节点可能会共享相同标签的假设下的。**然而这种假设会限制模型的能力，因为图的边不一定是表示节点相似性的，可能是不相似性！</p>\n<p>文中作者直接使用神经网络模型$f(X,A)$来编码整个图结构并且在所有有监督的节点上获取loss进行训练，因此就避免了损失函数中基于图的显示正则化。在图的邻接矩阵上调节函数f会使得模型能够从监督损失中分配梯度信息并且使它既能学习有标签也能学习无标签节点的表示。</p>\n<p>主要贡献有两点：</p>\n<ol>\n<li>提出了一个简单有效的神经网络模型的传播规则，能够直接用于图并且展示了它是如何从一阶近似的谱图卷积得来的。</li>\n<li>解释了这种模型是如何应用于快速且可扩展的节点半监督分类任务中的。</li>\n</ol>\n<span id=\"more\"></span>\n<h2 id=\"图的快速近似卷积\">图的快速近似卷积</h2>\n<p>下面是本文中GCN的逐层传播规则：</p>\n<p><img src=\"https://i.imgur.com/dEpVbPD.png\" alt=\"picture 51\"></p>\n<p>其中$\\widetilde{A}=A+I_N$是带有自连接的邻接矩阵，$\\tilde{D}$就是根据$\\tilde{A}$的来的度矩阵，$W^{(l)}$是各层独立的可训练的权重参数，$\\sigma$是激活函数，$H^{(l)} \\in R^{N \\times D}$是第l层的隐藏状态矩阵,$H^{(0)}=X$。</p>\n<h3 id=\"谱图卷积\">谱图卷积</h3>\n<p>谱卷积定义为信号x和过滤器$g_\\theta \\times =Ug_\\theta U^Tx $在傅里叶域上的乘法</p>\n<p><img src=\"https://i.imgur.com/c7vuiU7.png\" alt=\"picture 52\"></p>\n<p>其中U是归一化拉普拉斯的特征向量组成的矩阵，$L=L_N-D^{- \\frac{1}{2}}AD^{- \\frac{1}{2}}=U\\Lambda U^T$，$U^Tx$是对x的图傅里叶转换。我们可以将$g_\\theta$理解成对L的特征值的函数，比如$g_\\theta(\\Lambda)$。但是计算公式3的计算成本太高，并且对于大的图更是如此。为此，有人提出$g_\\theta (\\Lambda)$可以由车比雪夫多项式的前k部分估计出来</p>\n<p><img src=\"https://i.imgur.com/L1Monm9.png\" alt=\"picture 53\"></p>\n<p>其中$\\tilde{\\Lambda}=\\frac{2}{\\lambda_{max}} \\Lambda - I_N$，$\\lambda_{max}$是L的最大特征值。车比雪夫多项式可以递归地定义为$T_k(x)=2xT_{k-1}(x)-T_{k-2}(x)$,其中$T_0(x)=1$,$T_1(x)=x$。</p>\n<p>回到我们的定义上，现在我们有</p>\n<p><img src=\"https://i.imgur.com/sWHyYb3.png\" alt=\"picture 54\"></p>\n<p>可以看出这个表达式只关心节点的k阶邻居，这使得它的计算复杂度直线下降。</p>\n<h3 id=\"逐层的线性模型\">逐层的线性模型</h3>\n<p>因此根据公式5可以堆叠多个基于图卷积的神经网络层，每一层之后更一个逐点的非线性层。现在我们对逐层的卷积操作进行限制，使它只关注一阶邻居，即K=1，这样的话就是在拉普拉斯图谱上进行一个线性操作。</p>\n<p>用这种方式仍然可以通过叠加这样的层来恢复丰富的卷积滤波器函数。我们期望这种模型能够减轻在图的局部邻接关系上的过拟合问题。此外，这样的逐层线性转化使我们能够构建更深的模型。</p>\n<p>我们近似将$\\lambda =2$，这样公式5就可以简化为：</p>\n<p><img src=\"https://i.imgur.com/LXQcZ2B.png\" alt=\"picture 55\"></p>\n<p>实际应用中我们可以限制参数的数量来解决过拟合问题，并且最小化每一层的计算量。这样我们可以得到以下公式</p>\n<p><img src=\"https://i.imgur.com/BNLrisG.png\" alt=\"picture 56\"></p>\n<p>其中$\\theta =\\theta_{1}^{‘} =-\\theta_{1}^{’}$。但是重复这一操作会导致数值不稳定出现梯度消失/爆炸。为了解决这一问题，这里做了个小trick，邻接矩阵使用包含自邻接关系，度矩阵也包含自邻接关系。</p>\n<p>这样我们就可以将具有C个输入通道的信号矩阵$X\\in R^{N\\times C}$和过滤器或者特征图定义为下式</p>\n<p><img src=\"https://i.imgur.com/jJj90Ec.png\" alt=\"picture 57\"></p>\n<h2 id=\"自监督节点分类\">自监督节点分类</h2>\n<h3 id=\"举例\">举例</h3>\n<p>我们假设一个两层的GCN用于半监督节点分类。我们先在一个预处理步骤中计算出$\\tilde{A}=\\tilde{D}^{-\\frac{1}{2}}\\tilde{A}\\tilde{D}^{-\\frac{1}{2}}$。前向传播公式如下</p>\n<p><img src=\"https://i.imgur.com/h5iMkZD.png\" alt=\"picture 58\"></p>\n<p>其中，$W^{(0)}\\in R^{C\\times H}$是第一个隐藏层的参数，$W^{(1)}\\in R^{H\\times F}$是输出层的参数。然后我们在所有的有标签样本上计算交叉熵损失</p>\n<p><img src=\"https://i.imgur.com/Jtsg0ac.png\" alt=\"picture 59\"></p>\n<p>下图是图卷积层的示意图</p>\n<p><img src=\"https://i.imgur.com/JGUN9Vu.png\" alt=\"picture 60\"></p>\n<h2 id=\"文章中公式的详细理解\">文章中公式的详细理解</h2>\n<p>首先我们有了一张图和他的基本信息，注意这里每个节点的向量可以是通过一些embeding方式得到的，不是重点。</p>\n<p><img src=\"https://i.imgur.com/ldUPSX0.png\" alt=\"picture 61\"></p>\n<p>那我们怎么获取到周遭节点的信息来辅助更新本节点的信息呢？可以用邻接矩阵和全部节点的特征组成的矩阵进行乘法，下图可以直观地展示出为什么能够获得邻居节点的信息</p>\n<p><img src=\"https://i.imgur.com/LPPsfou.png\" alt=\"picture 13\"></p>\n<p>当然，这样做还是有缺点的：</p>\n<ol>\n<li>缺少该节点本身的特征信息</li>\n<li>如果一个节点连接的邻居特别多或者特别少，用这种sum方法就会出现梯度爆炸或者梯度消失的问题。此外神经网络对输入信息的值比较敏感，因此需要归一化</li>\n</ol>\n<p>对于问题一解决办法很简单，邻接矩阵包含自邻接信息就可以了。</p>\n<p>对于问题二，一般做矩阵的缩放是乘以一个对角阵实现的。自然而然我们会想到使用度矩阵来实现。这里的度矩阵同样应该是包含自邻接关系的。使用度矩阵的逆，就可以实现邻接节点特征求和之后的取平均了。如下图所示</p>\n<p><img src=\"https://i.imgur.com/ZqluyWD.png\" alt=\"picture 63\"></p>\n<p>但是我们会发现，因为对角阵是在邻接矩阵左边乘的，所以实际上，只是用了$D_{ii}$对邻接矩阵的行进行了缩放，而没有对列进行。如下图所示</p>\n<p><img src=\"https://i.imgur.com/rDiJJK0.png\" alt=\"picture 64\"></p>\n<p>既然如此，我们可以尝试在右边再乘一个度矩阵的逆，这样不就行列都能得到缩放了吗？但是需要注意这里的原理是邻接矩阵是一个对称阵，所以其第i行和第i列是一样的，因此才可以这么做。</p>\n<p><img src=\"https://i.imgur.com/qYMvgrE.png\" alt=\"picture 65\"></p>\n<p>新的缩放方法给出了一个平均的权重，我们做的改进就是让他对邻接关系少的节点赋予更高的权重，这样能够减少邻接关系多的节点的影响。</p>\n<p>需要注意，我们对缩放矩阵进行归一化的时候一般做两次，一次对行一次对列，这是最常用的方式。也是文中作者使用的方式。</p>\n<p><img src=\"https://i.imgur.com/kphpELZ.png\" alt=\"picture 66\"></p>\n<p>卷积层的数量意味着一个节点的特征能够传播的距离。假如我们只有一层的话，那只能获取到邻居的信息，所有节点同时聚合自己邻居的信息。但如果我们堆叠多层，一个节点的邻居就能够包含其自身邻居的信息，经过聚合后当前节点就能够获得更远的节点的信息。</p>\n<p>但是一般我们不希望有太多层，经过6-7次跳跃，我们几乎已经可以聚合整张图的信息了。</p>\n","categories":["图神经网络"],"tags":["GCN"]},{"title":"go语言圣经学习","url":"/2022/01/15/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F%E5%AD%A6%E4%B9%A0/","content":"<h2 id=\"入门\">入门</h2>\n<h3 id=\"命令行参数\">命令行参数</h3>\n<p><code>os</code>包提供了一些与餐佐系统交互的函数和变量。命令行参数可以从os包的Args变量中获取；os包外部使用os.Args访问该变量。</p>\n<p>os.Args变量是一个字符串(string)的切片(slice)。os.Args[0]是命令本身的名字，其他元素是程序启动时传给他的参数。</p>\n<p>下面是echo命令的一个实现，其作用是将命令行参数打印成一行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s, sep <span class=\"keyword\">string</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">len</span>(os.Args); i++ &#123;</span><br><span class=\"line\">        <span class=\"comment\">//连接sep（为空或者为空格）和命令行参数</span></span><br><span class=\"line\">        s += sep + os.Args[i]</span><br><span class=\"line\">        sep = <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p>另外一种版本</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    s, sep := <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, arg := <span class=\"keyword\">range</span> os.Args[<span class=\"number\">1</span>:] &#123;</span><br><span class=\"line\">        s += sep + arg</span><br><span class=\"line\">        sep = <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第三种</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(strings.Join(os.Args[<span class=\"number\">1</span>:], <span class=\"string\">&quot; &quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查找重复行\">查找重复行</h3>\n<p>Unix中的uniq命令，作用是寻找相邻的重复行。</p>\n<p>第一个版本答应标准输入中重复出现的行，以重复次数开头</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;bufio&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    counts := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    input := bufio.NewScanner(os.Stdin)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> input.Scan() &#123;</span><br><span class=\"line\">        counts[input.Text()]++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> ignoring potential errors from input.Err()</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> line, n := <span class=\"keyword\">range</span> counts &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%d\\t%s\\n&quot;</span>, n, line)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很多程序要么从标准输入中读取数据，如上面的例子所示，要么从一系列具名文件中读取数据。dup程序的下个版本读取标准输入或是使用os.Open打开各个具名文件，并操作它们。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;bufio&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    counts := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    files := os.Args[<span class=\"number\">1</span>:]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(files) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        countLines(os.Stdin, counts)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, arg := <span class=\"keyword\">range</span> files &#123;</span><br><span class=\"line\">            f, err := os.Open(arg)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                fmt.Fprintf(os.Stderr, <span class=\"string\">&quot;dup2: %v\\n&quot;</span>, err)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            countLines(f, counts)</span><br><span class=\"line\">            f.Close()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line, n := <span class=\"keyword\">range</span> counts &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%d\\t%s\\n&quot;</span>, n, line)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">countLines</span><span class=\"params\">(f *os.File, counts <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    input := bufio.NewScanner(f)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> input.Scan() &#123;</span><br><span class=\"line\">        counts[input.Text()]++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> ignoring potential errors from input.Err()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前两个版本都是以“流”模式读取输入，并且根据需要拆分成多行。下面的方法是一口气把数据全部放到内存中，一次分割为多行，然后处理他们。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;io/ioutil&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    counts := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, filename := <span class=\"keyword\">range</span> os.Args[<span class=\"number\">1</span>:] &#123;</span><br><span class=\"line\">        data, err := ioutil.ReadFile(filename)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            fmt.Fprintf(os.Stderr, <span class=\"string\">&quot;dup3: %v\\n&quot;</span>, err)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, line := <span class=\"keyword\">range</span> strings.Split(<span class=\"keyword\">string</span>(data), <span class=\"string\">&quot;\\n&quot;</span>) &#123;</span><br><span class=\"line\">            counts[line]++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line, n := <span class=\"keyword\">range</span> counts &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%d\\t%s\\n&quot;</span>, n, line)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"GIF动画\">GIF动画</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;image&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;image/color&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;image/gif&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;math/rand&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> palette = []color.Color&#123;color.White, color.Black&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    whiteIndex = <span class=\"number\">0</span> <span class=\"comment\">// first color in palette</span></span><br><span class=\"line\">    blackIndex = <span class=\"number\">1</span> <span class=\"comment\">// next color in palette</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// The sequence of images is deterministic unless we seed</span></span><br><span class=\"line\">    <span class=\"comment\">// the pseudo-random number generator using the current time.</span></span><br><span class=\"line\">    <span class=\"comment\">// Thanks to Randall McPherson for pointing out the omission.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用当前时间作为随机种子</span></span><br><span class=\"line\">    rand.Seed(time.Now().UTC().UnixNano())</span><br><span class=\"line\">    lissajous(os.Stdout)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lissajous</span><span class=\"params\">(out io.Writer)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> (</span><br><span class=\"line\">        cycles  = <span class=\"number\">5</span>     <span class=\"comment\">// 完整的x震荡器转数</span></span><br><span class=\"line\">        res     = <span class=\"number\">0.001</span> <span class=\"comment\">// 角转</span></span><br><span class=\"line\">        size    = <span class=\"number\">100</span>   <span class=\"comment\">// 画布覆盖范围</span></span><br><span class=\"line\">        nframes = <span class=\"number\">64</span>    <span class=\"comment\">// 动画帧数</span></span><br><span class=\"line\">        delay   = <span class=\"number\">8</span>     <span class=\"comment\">// 10ms为单位的帧之间的延迟</span></span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    freq := rand.Float64() * <span class=\"number\">3.0</span> <span class=\"comment\">// y震荡器的相关频率</span></span><br><span class=\"line\">    anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br><span class=\"line\">    phase := <span class=\"number\">0.0</span> <span class=\"comment\">// 相位差</span></span><br><span class=\"line\">    <span class=\"comment\">//刻画每一帧的图像</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; nframes; i++ &#123;</span><br><span class=\"line\">        rect := image.Rect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>*size+<span class=\"number\">1</span>, <span class=\"number\">2</span>*size+<span class=\"number\">1</span>)</span><br><span class=\"line\">        img := image.NewPaletted(rect, palette)</span><br><span class=\"line\">        <span class=\"comment\">//刻画当前帧的完整图像</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> t := <span class=\"number\">0.0</span>; t &lt; cycles*<span class=\"number\">2</span>*math.Pi; t += res &#123;</span><br><span class=\"line\">            x := math.Sin(t)</span><br><span class=\"line\">            y := math.Sin(t*freq + phase)</span><br><span class=\"line\">            img.SetColorIndex(size+<span class=\"keyword\">int</span>(x*size+<span class=\"number\">0.5</span>), size+<span class=\"keyword\">int</span>(y*size+<span class=\"number\">0.5</span>),</span><br><span class=\"line\">                blackIndex)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        phase += <span class=\"number\">0.1</span></span><br><span class=\"line\">        anim.Delay = <span class=\"built_in\">append</span>(anim.Delay, delay)</span><br><span class=\"line\">        anim.Image = <span class=\"built_in\">append</span>(anim.Image, img)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    gif.EncodeAll(out, &amp;anim) <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> ignoring encoding errors</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>lissajous函数内部有两层嵌套的for循环。外层循环会循环64次，每一次都会生成一个单独的动画帧。它生成了一个包含两种颜色的201*201大小的图片，白色和黑色。所有像素点都会被默认设置为其零值（也就是调色板palette里的第0个值），这里我们设置的是白色。每次外层循环都会生成一张新图片，并将一些像素设置为黑色。其结果会append到之前结果之后。这里我们用到了append内置函数，将结果append到anim中的帧列表末尾，并设置一个默认的80ms的延迟值。循环结束后所有的延迟值被编码进了GIF图片中，并将结果写入到输出流。out这个变量是io.Writer类型，这个类型支持把输出结果写到很多目标，很快我们就可以看到例子。</p>\n<p>我们可以用color.RGBA{0xRR, 0xGG, 0xBB, 0xff}来得到#RRGGBB这个色值，三个十六进制的字符串分别代表红、绿、蓝像素。</p>\n<p>下面这个命令会在当前目录下产生一个GIF动画。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ go build gopl.io/ch1/lissajous</span><br><span class=\"line\">$ ./lissajous &gt;out.gif</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取URL\">获取URL</h3>\n<p>对于很多现代应用来说，访问互联网上的信息和访问本地文件系统一样重要。Go语言在net这个强大package的帮助下提供了一系列的package来做这件事情，使用这些包可以更简单地用网络收发信息，还可以建立更底层的网络连接，编写服务器程序。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;io/ioutil&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, url := <span class=\"keyword\">range</span> os.Args[<span class=\"number\">1</span>:] &#123;</span><br><span class=\"line\">        resp, err := http.Get(url)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            fmt.Fprintf(os.Stderr, <span class=\"string\">&quot;fetch: %v\\n&quot;</span>, err)</span><br><span class=\"line\">            os.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        b, err := ioutil.ReadAll(resp.Body)</span><br><span class=\"line\">        resp.Body.Close()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            fmt.Fprintf(os.Stderr, <span class=\"string\">&quot;fetch: reading %s: %v\\n&quot;</span>, url, err)</span><br><span class=\"line\">            os.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s&quot;</span>, b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Web服务\">Web服务</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, handler) <span class=\"comment\">// each request calls handler</span></span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(<span class=\"string\">&quot;localhost:8000&quot;</span>, <span class=\"literal\">nil</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// handler echoes the Path component of the request URL r.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;URL.Path = %q\\n&quot;</span>, r.URL.Path)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>main函数将所有发送到/路径下的请求和handler函数关联起来，/开头的请求其实就是所有发送到当前站点上的请求，服务监听8000端口。发送到这个服务的“请求”是一个http.Request类型的对象，这个对象中包含了请求中的一系列相关字段，其中就包括我们需要的URL。当请求到达服务器时，这个请求会被传给handler函数来处理，这个函数会将/hello这个路径从请求的URL中解析出来，然后把其发送到响应中，这里我们用的是标准输出流的fmt.Fprintf。</p>\n<p>让我们在后台运行这个服务程序。如果你的操作系统是Mac OS X或者Linux，那么在运行命令的末尾加上一个&amp;符号，即可让程序简单地跑在后台，windows下可以在另外一个命令行窗口去运行这个程序。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ go run src/gopl.io/ch1/server1/main.go &amp;</span><br></pre></td></tr></table></figure>\n<p>现在可以通过命令行来发送客户端请求了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ go build gopl.io/ch1/fetch</span><br><span class=\"line\">$ ./fetch http://localhost:8000</span><br><span class=\"line\">URL.Path = &quot;/&quot;</span><br><span class=\"line\">$ ./fetch http://localhost:8000/help</span><br><span class=\"line\">URL.Path = &quot;/help&quot;</span><br></pre></td></tr></table></figure>\n<p>在这个服务的基础上叠加特性是很容易的。一种比较实用的修改是为访问的url添加某种状态。比如，下面这个版本输出了同样的内容，但是会对请求的次数进行计算；对URL的请求结果会包含各种URL被访问的总次数，直接对/count这个URL的访问要除外。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mu sync.Mutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> count <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, handler)</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/count&quot;</span>, counter)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(<span class=\"string\">&quot;localhost:8000&quot;</span>, <span class=\"literal\">nil</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// handler echoes the Path component of the requested URL.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    mu.Lock()</span><br><span class=\"line\">    count++</span><br><span class=\"line\">    mu.Unlock()</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;URL.Path = %q\\n&quot;</span>, r.URL.Path)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// counter echoes the number of calls so far.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">counter</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    mu.Lock()</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Count %d\\n&quot;</span>, count)</span><br><span class=\"line\">    mu.Unlock()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个服务器有两个请求处理函数，根据请求的url不同会调用不同的函数：对/count这个url的请求会调用到counter这个函数，其它的url都会调用默认的处理函数。如果你的请求pattern是以/结尾，那么所有以该url为前缀的url都会被这条规则匹配。在这些代码的背后，服务器每一次接收请求处理时都会另起一个goroutine，这样服务器就可以同一时间处理多个请求。然而在并发情况下，假如真的有两个请求同一时刻去更新count，那么这个值可能并不会被正确地增加；这个程序可能会引发一个严重的bug：竞态条件。为了避免这个问题，我们必须保证每次修改变量的最多只能有一个goroutine，这也就是代码里的mu.Lock()和mu.Unlock()调用将修改count的所有行为包在中间的目的。</p>\n<h2 id=\"程序结构\">程序结构</h2>\n<h3 id=\"命名\">命名</h3>\n<p>Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。<strong>大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。</strong></p>\n<p>如果一个名字是在函数内部定义，那么它就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可以在fmt包外部访问。包本身的名字一般总是用小写字母。</p>\n<h3 id=\"声明\">声明</h3>\n<p>声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。</p>\n<p>一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。每个源文件中以包的声明语句开始，说明该源文件是属于哪个包。包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要（译注：函数内部的名字则必须先声明之后才能使用）。</p>\n<h3 id=\"变量\">变量</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var 变量名字 类型 = 表达式</span><br></pre></td></tr></table></figure>\n<p>其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。</p>\n<h4 id=\"指针\">指针</h4>\n<p>一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字。</p>\n<p>如果用“var x int”声明语句声明一个x变量，那么&amp;x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是<code>*int</code>，指针被称之为“指向int类型的指针”。如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时<code>*p</code>表达式对应p指针指向的变量的值。一般<code>*p</code>表达式读取指针指向的变量的值，这里为int类型的值，同时因为<code>*p</code>对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。</p>\n<p>变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受&amp;取地址操作。</p>\n<p>在Go语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = f()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span> *<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    v := <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;v</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每次调用f函数都将返回不同的结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fmt.Println(f() == f()) // &quot;false&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"new函数\">new函数</h4>\n<p>另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code>。</p>\n<p>用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)。换言之，new函数类似是一种语法糖，而不是一个新的基础概念。</p>\n<p>new函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活。</p>\n<h4 id=\"变量的生命周期\">变量的生命周期</h4>\n<p>Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。</p>\n<p>因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。</p>\n<p>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> global *<span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x <span class=\"keyword\">int</span></span><br><span class=\"line\">    x = <span class=\"number\">1</span></span><br><span class=\"line\">    global = &amp;x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">g</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    y := <span class=\"built_in\">new</span>(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    *y = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量<code>*y</code>将是不可达的，也就是说可以马上被回收的。因此，<code>*y</code>并没有从函数g中逃逸，编译器可以选择在栈上分配<code>*y</code>的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。</p>\n<h3 id=\"类型\">类型</h3>\n<p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type 类型名字 底层类型</span><br></pre></td></tr></table></figure>\n<p>类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。</p>\n<p>为了说明类型声明，我们将不同温度单位分别定义为不同的类型：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> tempconv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Celsius <span class=\"keyword\">float64</span>    <span class=\"comment\">// 摄氏温度</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Fahrenheit <span class=\"keyword\">float64</span> <span class=\"comment\">// 华氏温度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    AbsoluteZeroC Celsius = <span class=\"number\">-273.15</span> <span class=\"comment\">// 绝对零度</span></span><br><span class=\"line\">    FreezingC     Celsius = <span class=\"number\">0</span>       <span class=\"comment\">// 结冰点温度</span></span><br><span class=\"line\">    BoilingC      Celsius = <span class=\"number\">100</span>     <span class=\"comment\">// 沸水温度</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CToF</span><span class=\"params\">(c Celsius)</span> <span class=\"title\">Fahrenheit</span></span> &#123; <span class=\"keyword\">return</span> Fahrenheit(c*<span class=\"number\">9</span>/<span class=\"number\">5</span> + <span class=\"number\">32</span>) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FToC</span><span class=\"params\">(f Fahrenheit)</span> <span class=\"title\">Celsius</span></span> &#123; <span class=\"keyword\">return</span> Celsius((f - <span class=\"number\">32</span>) * <span class=\"number\">5</span> / <span class=\"number\">9</span>) &#125;</span><br></pre></td></tr></table></figure>\n<p>我们在这个包声明了两种类型：Celsius和Fahrenheit分别对应不同的温度单位。它们虽然有着相同的底层类型float64，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误；因此需要一个类似Celsius(t)或Fahrenheit(t)形式的显式转型操作才能将float64转为对应的类型。Celsius(t)和Fahrenheit(t)是类型转换操作，它们并不是函数调用。类型转换不会改变值本身，但是会使它们的语义发生变化。另一方面，CToF和FToC两个函数则是对不同温度单位下的温度进行换算，它们会返回不同的值。</p>\n<h3 id=\"包和文件\">包和文件</h3>\n<p>Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径；<a href=\"http://xn--gopl-zu6f77pg6m.io/ch1/helloworld%E5%AF%B9%E5%BA%94%E7%9A%84%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%E6%98%AF$GOPATH/src/gopl.io/ch1/helloworld%E3%80%82\">例如包gopl.io/ch1/helloworld对应的目录路径是$GOPATH/src/gopl.io/ch1/helloworld。</a></p>\n<p>每个包都对应一个独立的名字空间。例如，在image包中的Decode函数和在unicode/utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问。</p>\n<p>包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。</p>\n<p>为了演示包基本的用法，先假设我们的温度转换软件已经很流行，我们希望到Go语言社区也能使用这个包。我们该如何做呢？</p>\n<p><a href=\"http://xn--gopl-k84fui2d97du1om8e8o0be0h784l.io/ch2/tempconv%E7%9A%84%E5%8C%85%EF%BC%8C%E8%BF%99%E6%98%AF%E5%89%8D%E9%9D%A2%E4%BE%8B%E5%AD%90%E7%9A%84%E4%B8%80%E4%B8%AA%E6%94%B9%E8%BF%9B%E7%89%88%E6%9C%AC%E3%80%82%EF%BC%88%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E6%B2%A1%E6%9C%89%E6%8C%89%E7%85%A7%E6%83%AF%E4%BE%8B%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%AF%B9%E4%BE%8B%E5%AD%90%E8%BF%9B%E8%A1%8C%E7%BC%96%E5%8F%B7%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%8C%85%E8%B7%AF%E5%BE%84%E7%9C%8B%E8%B5%B7%E6%9D%A5%E6%9B%B4%E5%83%8F%E4%B8%80%E4%B8%AA%E7%9C%9F%E5%AE%9E%E7%9A%84%E5%8C%85%EF%BC%89%E5%8C%85%E4%BB%A3%E7%A0%81%E5%AD%98%E5%82%A8%E5%9C%A8%E4%B8%A4%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E7%94%A8%E6%9D%A5%E6%BC%94%E7%A4%BA%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6%E5%A3%B0%E6%98%8E%E7%84%B6%E5%90%8E%E5%9C%A8%E5%85%B6%E4%BB%96%E7%9A%84%E6%BA%90%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%EF%BC%9B%E8%99%BD%E7%84%B6%E5%9C%A8%E7%8E%B0%E5%AE%9E%E4%B8%AD%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%8F%E7%9A%84%E5%8C%85%E4%B8%80%E8%88%AC%E5%8F%AA%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E3%80%82\">让我们创建一个名为gopl.io/ch2/tempconv的包，这是前面例子的一个改进版本。（这里我们没有按照惯例按顺序对例子进行编号，因此包路径看起来更像一个真实的包）包代码存储在两个源文件中，用来演示如何在一个源文件声明然后在其他的源文件访问；虽然在现实中，这样小的包一般只需要一个文件。</a></p>\n<p>我们把变量的声明、对应的常量，还有方法都放到tempconv.go源文件中：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> tempconv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Celsius <span class=\"keyword\">float64</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Fahrenheit <span class=\"keyword\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    AbsoluteZeroC Celsius = <span class=\"number\">-273.15</span></span><br><span class=\"line\">    FreezingC     Celsius = <span class=\"number\">0</span></span><br><span class=\"line\">    BoilingC      Celsius = <span class=\"number\">100</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c Celsius)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span>    &#123; <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;%g°C&quot;</span>, c) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f Fahrenheit)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123; <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;%g°F&quot;</span>, f) &#125;</span><br></pre></td></tr></table></figure>\n<p>转换函数则放在另一个conv.go源文件中：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> tempconv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// CToF converts a Celsius temperature to Fahrenheit.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CToF</span><span class=\"params\">(c Celsius)</span> <span class=\"title\">Fahrenheit</span></span> &#123; <span class=\"keyword\">return</span> Fahrenheit(c*<span class=\"number\">9</span>/<span class=\"number\">5</span> + <span class=\"number\">32</span>) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// FToC converts a Fahrenheit temperature to Celsius.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FToC</span><span class=\"params\">(f Fahrenheit)</span> <span class=\"title\">Celsius</span></span> &#123; <span class=\"keyword\">return</span> Celsius((f - <span class=\"number\">32</span>) * <span class=\"number\">5</span> / <span class=\"number\">9</span>) &#125;</span><br></pre></td></tr></table></figure>\n<p>每个源文件都是以包的声明语句开始，用来指明包的名字。当包被导入的时候，包内的成员将通过类似tempconv.CToF的形式访问。而包级别的名字，例如在一个文件声明的类型和常量，在同一个包的其他源文件也是可以直接访问的，就好像所有代码都在一个文件一样。要注意的是tempconv.go源文件导入了fmt包，但是conv.go源文件并没有，因为这个源文件中的代码并没有用到fmt包。</p>\n<h4 id=\"导入包\">导入包</h4>\n<p>在Go语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似&quot;<a href=\"http://gopl.io/ch2/tempconv\">gopl.io/ch2/tempconv</a>&quot;的字符串对应包的导入路径。Go语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件。</p>\n<p>除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。按照惯例，一个包的名字和包的导入路径的最后一个字段相同，<a href=\"http://xn--gopl-zu6fx14c.io/ch2/tempconv%E5%8C%85%E7%9A%84%E5%90%8D%E5%AD%97%E4%B8%80%E8%88%AC%E6%98%AFtempconv%E3%80%82\">例如gopl.io/ch2/tempconv包的名字一般是tempconv。</a></p>\n<h2 id=\"基础数据类型\">基础数据类型</h2>\n<h3 id=\"整型\">整型</h3>\n<p>Go语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。</p>\n<p>Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。</p>\n<p>不管它们的具体大小，int、uint和uintptr是不同类型的兄弟类型。其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然。</p>\n<p>Go语言还提供了以下的bit位操作运算符，前面4个操作运算符并不区分是有符号还是无符号数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;      位运算 AND</span><br><span class=\"line\">|      位运算 OR</span><br><span class=\"line\">^      位运算 XOR</span><br><span class=\"line\">&amp;^     位清空（AND NOT）</span><br><span class=\"line\">&lt;&lt;     左移</span><br><span class=\"line\">&gt;&gt;     右移</span><br></pre></td></tr></table></figure>\n<p>位操作运算符^作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反；也就是说，它返回一个每个bit位都取反的数。位操作运算符&amp;^用于按位置零（AND NOT）：如果对应y中bit位为1的话，表达式z = x &amp;^ y结果z的对应的bit位为0，否则z对应的bit位等于x相应的bit位的值。</p>\n<h3 id=\"浮点型\">浮点型</h3>\n<p>Go语言提供了两种精度的浮点数，float32和float64。它们的算术规范由IEEE754浮点数国际标准定义，该浮点数规范被所有现代的CPU支持。</p>\n<p>用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。所有的这三个打印形式都可以指定打印的宽度和控制打印精度。</p>\n<p>math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1)。</p>\n<p>接下来的程序演示了通过浮点计算生成的图形。它是带有两个参数的z = f(x, y)函数的三维形式，使用了可缩放矢量图形（SVG）格式输出，SVG是一个用于矢量线绘制的XML标准。图3.1显示了sin®/r函数的输出图形，其中r是<code>sqrt(x*x+y*y)</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    width, height = <span class=\"number\">600</span>, <span class=\"number\">320</span>            <span class=\"comment\">// canvas size in pixels</span></span><br><span class=\"line\">    cells         = <span class=\"number\">100</span>                 <span class=\"comment\">// number of grid cells</span></span><br><span class=\"line\">    xyrange       = <span class=\"number\">30.0</span>                <span class=\"comment\">// axis ranges (-xyrange..+xyrange)</span></span><br><span class=\"line\">    xyscale       = width / <span class=\"number\">2</span> / xyrange <span class=\"comment\">// pixels per x or y unit</span></span><br><span class=\"line\">    zscale        = height * <span class=\"number\">0.4</span>        <span class=\"comment\">// pixels per z unit</span></span><br><span class=\"line\">    angle         = math.Pi / <span class=\"number\">6</span>         <span class=\"comment\">// angle of x, y axes (=30°)</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sin30, cos30 = math.Sin(angle), math.Cos(angle) <span class=\"comment\">// sin(30°), cos(30°)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; &quot;</span>+</span><br><span class=\"line\">        <span class=\"string\">&quot;style=&#x27;stroke: grey; fill: white; stroke-width: 0.7&#x27; &quot;</span>+</span><br><span class=\"line\">        <span class=\"string\">&quot;width=&#x27;%d&#x27; height=&#x27;%d&#x27;&gt;&quot;</span>, width, height)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; cells; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; cells; j++ &#123;</span><br><span class=\"line\">            ax, ay := corner(i+<span class=\"number\">1</span>, j)</span><br><span class=\"line\">            bx, by := corner(i, j)</span><br><span class=\"line\">            cx, cy := corner(i, j+<span class=\"number\">1</span>)</span><br><span class=\"line\">            dx, dy := corner(i+<span class=\"number\">1</span>, j+<span class=\"number\">1</span>)</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;&lt;polygon points=&#x27;%g,%g %g,%g %g,%g %g,%g&#x27;/&gt;\\n&quot;</span>,</span><br><span class=\"line\">                ax, ay, bx, by, cx, cy, dx, dy)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;&lt;/svg&gt;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">corner</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"params\">(<span class=\"keyword\">float64</span>, <span class=\"keyword\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Find point (x,y) at corner of cell (i,j).</span></span><br><span class=\"line\">    x := xyrange * (<span class=\"keyword\">float64</span>(i)/cells - <span class=\"number\">0.5</span>)</span><br><span class=\"line\">    y := xyrange * (<span class=\"keyword\">float64</span>(j)/cells - <span class=\"number\">0.5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Compute surface height z.</span></span><br><span class=\"line\">    z := f(x, y)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Project (x,y,z) isometrically onto 2-D SVG canvas (sx,sy).</span></span><br><span class=\"line\">    sx := width/<span class=\"number\">2</span> + (x-y)*cos30*xyscale</span><br><span class=\"line\">    sy := height/<span class=\"number\">2</span> + (x+y)*sin30*xyscale - z*zscale</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sx, sy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">(x, y <span class=\"keyword\">float64</span>)</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">    r := math.Hypot(x, y) <span class=\"comment\">// distance from (0,0)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> math.Sin(r) / r</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"复数\">复数</h3>\n<p>Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">complex128</span> = <span class=\"built_in\">complex</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 1+2i</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> y <span class=\"keyword\">complex128</span> = <span class=\"built_in\">complex</span>(<span class=\"number\">3</span>, <span class=\"number\">4</span>) <span class=\"comment\">// 3+4i</span></span><br><span class=\"line\">fmt.Println(x*y)                 <span class=\"comment\">// &quot;(-5+10i)&quot;</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">real</span>(x*y))           <span class=\"comment\">// &quot;-5&quot;</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">imag</span>(x*y))           <span class=\"comment\">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure>\n<p>如果一个浮点数面值或一个十进制整数面值后面跟着一个i，例如3.141592i或2i，它将构成一个复数的虚部，复数的实部是0：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">fmt.Println(<span class=\"number\">1i</span> * <span class=\"number\">1i</span>) <span class=\"comment\">// &quot;(-1+0i)&quot;, i^2 = -1</span></span><br></pre></td></tr></table></figure>\n<p>在常量算术规则下，一个复数常量可以加到另一个普通数值常量（整数或浮点数、实部或虚部），我们可以用自然的方式书写复数，就像1+2i或与之等价的写法2i+1。上面x和y的声明语句还可以简化：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">1</span> + <span class=\"number\">2i</span></span><br><span class=\"line\">y := <span class=\"number\">3</span> + <span class=\"number\">4i</span></span><br></pre></td></tr></table></figure>\n<p>复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的（译注：浮点数的相等比较是危险的，需要特别小心处理精度问题）。</p>\n<p>math/cmplx包提供了复数处理的许多函数，例如求复数的平方根函数和求幂函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">fmt.Println(cmplx.Sqrt(<span class=\"number\">-1</span>)) <span class=\"comment\">// &quot;(0+1i)&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串\">字符串</h3>\n<p>一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。</p>\n<p>第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字节。我们先简单说下字符的工作方式。</p>\n<p>子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串。生成的新字符串将包含j-i个字节。</p>\n<p>因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">s[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;L&#x27;</span> <span class=\"comment\">// compile error: cannot assign to s[0]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串字面值\">字符串字面值</h4>\n<p>在一个双引号包含的字符串面值中，可以用以反斜杠\\开头的转义序列插入任意的数据。下面的换行、回车和制表符等是常见的ASCII控制代码的转义方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\a      响铃</span><br><span class=\"line\">\\b      退格</span><br><span class=\"line\">\\f      换页</span><br><span class=\"line\">\\n      换行</span><br><span class=\"line\">\\r      回车</span><br><span class=\"line\">\\t      制表符</span><br><span class=\"line\">\\v      垂直制表符</span><br><span class=\"line\">\\&#x27;      单引号（只用在 &#x27;\\&#x27;&#x27; 形式的rune符号面值中）</span><br><span class=\"line\">\\&quot;      双引号（只用在 &quot;...&quot; 形式的字符串面值中）</span><br><span class=\"line\">\\\\      反斜杠</span><br></pre></td></tr></table></figure>\n<p>一个原生的字符串面值形式是<code>...</code>，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行（译注：在原生字符串面值内部是无法直接写`字符的，可以用八进制或十六进制转义或+&quot;`&quot;连接字符串常量完成）。唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些把回车也放入文本文件的系统（译注：Windows系统会把回车和换行一起放入文本文件中）。</p>\n<p>原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> GoUsage = <span class=\"string\">`Go is a tool for managing Go source code.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">Usage:</span></span><br><span class=\"line\"><span class=\"string\">    go command [arguments]</span></span><br><span class=\"line\"><span class=\"string\">...`</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Unicode\">Unicode</h4>\n<p>下面例子中，字符串总共包含13个字节，但是只对应9个unicode字符</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;unicode/utf8&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">s := <span class=\"string\">&quot;Hello, 世界&quot;</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">len</span>(s))                    <span class=\"comment\">// &quot;13&quot;</span></span><br><span class=\"line\">fmt.Println(utf8.RuneCountInString(s)) <span class=\"comment\">// &quot;9&quot;</span></span><br></pre></td></tr></table></figure>\n<p>为了处理这些真实的字符，我们需要一个UTF8解码器。unicode/utf8包提供了该功能，我们可以这样使用：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(s); &#123;</span><br><span class=\"line\">    r, size := utf8.DecodeRuneInString(s[i:])</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%d\\t%c\\n&quot;</span>, i, r)</span><br><span class=\"line\">    i += size</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每一次调用DecodeRuneInString函数都返回一个r和长度，r对应字符本身，长度对应r采用UTF8编码后的编码字节数目。长度可以用于更新第i个字符在字符串中的字节索引位置。但是这种编码方式是笨拙的，我们需要更简洁的语法。幸运的是，Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串。下面的循环运行如图所示；需要注意的是对于非ASCII，索引更新的步长将超过1个字节。</p>\n<p><img src=\"https://i.imgur.com/hN2UTLB.png\" alt=\"picture 1\"></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i, r := <span class=\"keyword\">range</span> <span class=\"string\">&quot;Hello, 世界&quot;</span> &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%d\\t%q\\t%d\\n&quot;</span>, i, r, r)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串和byte切片\">字符串和byte切片</h4>\n<p>标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。</p>\n<p>bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效。</p>\n<p>strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</p>\n<p>unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。</p>\n<p>bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">intsToString</span><span class=\"params\">(values []<span class=\"keyword\">int</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf bytes.Buffer</span><br><span class=\"line\">    buf.WriteByte(<span class=\"string\">&#x27;[&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> values &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            buf.WriteString(<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Fprintf(&amp;buf, <span class=\"string\">&quot;%d&quot;</span>, v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buf.WriteByte(<span class=\"string\">&#x27;]&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buf.String()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(intsToString([]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;)) <span class=\"comment\">// &quot;[1, 2, 3]&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"常量\">常量</h3>\n<p>常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。</p>\n<p>下面是来自time包的例子，它首先定义了一个Weekday命名类型，然后为一周的每天定义了一个常量，从周日0开始。在其它编程语言中，这种类型一般被称为枚举类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Weekday <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    Sunday Weekday = <span class=\"literal\">iota</span></span><br><span class=\"line\">    Monday</span><br><span class=\"line\">    Tuesday</span><br><span class=\"line\">    Wednesday</span><br><span class=\"line\">    Thursday</span><br><span class=\"line\">    Friday</span><br><span class=\"line\">    Saturday</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>周日将对应0，周一为1，如此等等。</p>\n<p>我们也可以在复杂的常量表达式中使用iota，下面是来自net包的例子，用于给一个无符号整数的最低5bit的每个bit指定一个名字：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Flags <span class=\"keyword\">uint</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    FlagUp Flags = <span class=\"number\">1</span> &lt;&lt; <span class=\"literal\">iota</span> <span class=\"comment\">// is up</span></span><br><span class=\"line\">    FlagBroadcast            <span class=\"comment\">// supports broadcast access capability</span></span><br><span class=\"line\">    FlagLoopback             <span class=\"comment\">// is a loopback interface</span></span><br><span class=\"line\">    FlagPointToPoint         <span class=\"comment\">// belongs to a point-to-point link</span></span><br><span class=\"line\">    FlagMulticast            <span class=\"comment\">// supports multicast access capability</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h4 id=\"无类型常量\">无类型常量</h4>\n<p>Go语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如int或float64，或者是类似time.Duration这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</p>\n<p>通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。例如，例子中的ZiB和YiB的值已经超出任何Go语言中整数类型能表达的范围，但是它们依然是合法的常量，而且像下面的常量表达式依然有效（译注：YiB/ZiB是在编译期计算出来的，并且结果常量是1024，是Go语言int变量能有效表示的）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    _ = <span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">10</span> * <span class=\"literal\">iota</span>)</span><br><span class=\"line\">    KiB <span class=\"comment\">// 1024</span></span><br><span class=\"line\">    MiB <span class=\"comment\">// 1048576</span></span><br><span class=\"line\">    GiB <span class=\"comment\">// 1073741824</span></span><br><span class=\"line\">    TiB <span class=\"comment\">// 1099511627776             (exceeds 1 &lt;&lt; 32)</span></span><br><span class=\"line\">    PiB <span class=\"comment\">// 1125899906842624</span></span><br><span class=\"line\">    EiB <span class=\"comment\">// 1152921504606846976</span></span><br><span class=\"line\">    ZiB <span class=\"comment\">// 1180591620717411303424    (exceeds 1 &lt;&lt; 64)</span></span><br><span class=\"line\">    YiB <span class=\"comment\">// 1208925819614629174706176</span></span><br><span class=\"line\">)</span><br><span class=\"line\">fmt.Println(YiB/ZiB) <span class=\"comment\">// &quot;1024&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"复合数据类型\">复合数据类型</h2>\n<h3 id=\"数组\">数组</h3>\n<p>数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">r := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">99</span>: <span class=\"number\">-1</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。</p>\n<p>如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候我们可以直接通过==比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。不相等比较运算符!=遵循同样的规则。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">a := [<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">b := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">c := [<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">fmt.Println(a == b, a == c, b == c) <span class=\"comment\">// &quot;true false false&quot;</span></span><br><span class=\"line\">d := [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">fmt.Println(a == d) <span class=\"comment\">// compile error: cannot compare [2]int == [3]int</span></span><br></pre></td></tr></table></figure>\n<p>作为一个真实的例子，crypto/sha256包的Sum256函数对一个任意的字节slice类型的数据生成一个对应的消息摘要。消息摘要有256bit大小，因此对应[32]byte数组类型。如果两个消息摘要是相同的，那么可以认为两个消息本身也是相同（译注：理论上有HASH码碰撞的情况，但是实际应用可以基本忽略）；如果消息摘要不同，那么消息本身必然也是不同的。下面的例子用SHA256算法分别生成“x”和“X”两个信息的摘要：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;crypto/sha256&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    c1 := sha256.Sum256([]<span class=\"keyword\">byte</span>(<span class=\"string\">&quot;x&quot;</span>))</span><br><span class=\"line\">    c2 := sha256.Sum256([]<span class=\"keyword\">byte</span>(<span class=\"string\">&quot;X&quot;</span>))</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%x\\n%x\\n%t\\n%T\\n&quot;</span>, c1, c2, c1 == c2, c1)</span><br><span class=\"line\">    <span class=\"comment\">// Output:</span></span><br><span class=\"line\">    <span class=\"comment\">// 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881</span></span><br><span class=\"line\">    <span class=\"comment\">// 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015</span></span><br><span class=\"line\">    <span class=\"comment\">// false</span></span><br><span class=\"line\">    <span class=\"comment\">// [32]uint8</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Slice\">Slice</h3>\n<p>数组和slice之间有着紧密的联系。一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。</p>\n<p>多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。图4.1显示了表示一年中每个月份名字的字符串数组，还有重叠引用了该数组的两个slice。数组这样定义</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">months := [...]<span class=\"keyword\">string</span>&#123;<span class=\"number\">1</span>: <span class=\"string\">&quot;January&quot;</span>, <span class=\"comment\">/* ... */</span>, <span class=\"number\">12</span>: <span class=\"string\">&quot;December&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大。</p>\n<p>因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名。</p>\n<p>要注意的是slice类型的变量s和数组类型的变量a的初始化语法的差异。slice和数组的字面值语法很类似，它们都是用花括弧包含一系列的初始化元素，但是对于slice并没有指明序列的长度。<strong>这会隐式地创建一个合适大小的数</strong>组，然后slice的指针指向底层的数组。就像数组字面值一样，slice的字面值也可以按顺序指定初始化值序列，或者是通过索引和元素值指定，或者用两种风格的混合语法初始化。</p>\n<p>和数组不同的是，slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">equal</span><span class=\"params\">(x, y []<span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(x) != <span class=\"built_in\">len</span>(y) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> x &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x[i] != y[i] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>slice唯一合法的比较操作是和nil比较，例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> summer == <span class=\"literal\">nil</span> &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>一个零值的slice等于nil。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的，例如<code>[]int&#123;&#125;</code>或<code>make([]int, 3)[3:]</code>。与任意类型的nil值一样，我们可以用[]int(nil)类型转换表达式来生成一个对应类型slice的nil值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s []<span class=\"keyword\">int</span>    <span class=\"comment\">// len(s) == 0, s == nil</span></span><br><span class=\"line\">s = <span class=\"literal\">nil</span>        <span class=\"comment\">// len(s) == 0, s == nil</span></span><br><span class=\"line\">s = []<span class=\"keyword\">int</span>(<span class=\"literal\">nil</span>) <span class=\"comment\">// len(s) == 0, s == nil</span></span><br><span class=\"line\">s = []<span class=\"keyword\">int</span>&#123;&#125;    <span class=\"comment\">// len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Map\">Map</h3>\n<p>在Go语言中，一个map就是一个哈希表的引用，map类型可以写为<code>map[K]V</code>，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做key类型则是一个坏的想法，正如第三章提到的，最坏的情况是可能出现的NaN和任何浮点数都不相等。对于V对应的value数据类型则没有任何的限制。</p>\n<p>内置的make函数可以创建一个map：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ages := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>) <span class=\"comment\">// mapping from strings to ints</span></span><br></pre></td></tr></table></figure>\n<p>使用内置的delete函数可以删除元素：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">delete</span>(ages, <span class=\"string\">&quot;alice&quot;</span>) <span class=\"comment\">// remove element ages[&quot;alice&quot;]</span></span><br></pre></td></tr></table></figure>\n<p>所有这些操作是安全的，即使这些元素不在map中也没有关系；如果一个查找失败将返回value类型对应的零值，例如，即使map中不存在“bob”下面的代码也可以正常工作，因为ages[“bob”]失败时将返回0。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ages[<span class=\"string\">&quot;bob&quot;</span>] = ages[<span class=\"string\">&quot;bob&quot;</span>] + <span class=\"number\">1</span> <span class=\"comment\">// happy birthday!</span></span><br></pre></td></tr></table></figure>\n<p>而且<code>x += y</code>和<code>x++</code>等简短赋值语法也可以用在map上，所以上面的代码可以改写成</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ages[<span class=\"string\">&quot;bob&quot;</span>] += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>但是map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">_ = &amp;ages[<span class=\"string\">&quot;bob&quot;</span>] <span class=\"comment\">// compile error: cannot take address of map element</span></span><br></pre></td></tr></table></figure>\n<p>禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</p>\n<p>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key/value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序。下面是常见的处理方式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;sort&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> names []<span class=\"keyword\">string</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> name := <span class=\"keyword\">range</span> ages &#123;</span><br><span class=\"line\">    names = <span class=\"built_in\">append</span>(names, name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sort.Strings(names)</span><br><span class=\"line\"><span class=\"keyword\">for</span> _, name := <span class=\"keyword\">range</span> names &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%s\\t%d\\n&quot;</span>, name, ages[name])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>map上的大部分操作，包括查找、删除、len和range循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似。但是向一个nil值的map存入元素将导致一个panic异常。</p>\n<p>通过key作为索引下标来访问map将产生一个value。如果key在map中是存在的，那么将得到与key对应的value；如果key不存在，那么将得到value对应类型的零值，正如我们前面看到的ages[“bob”]那样。这个规则很实用，但是有时候可能需要知道对应的元素是否真的是在map之中。例如，如果元素类型是一个数字，你可能需要区分一个已经存在的0，和不存在而返回零值的0，可以像下面这样测试：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">age, ok := ages[<span class=\"string\">&quot;bob&quot;</span>]</span><br><span class=\"line\"><span class=\"keyword\">if</span> !ok &#123; <span class=\"comment\">/* &quot;bob&quot; is not a key in this map; age == 0. */</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>你会经常看到将这两个结合起来使用，像这样：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> age, ok := ages[<span class=\"string\">&quot;bob&quot;</span>]; !ok &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>在这种场景下，map的下标语法将产生两个值；第二个是一个布尔值，用于报告元素是否真的存在。布尔变量一般命名为ok，特别适合马上用于if条件判断部分。</p>\n<p>有时候我们需要一个map或set的key是slice类型，但是map的key必须是可比较的类型，但是slice并不满足这个条件。不过，我们可以通过两个步骤绕过这个限制。第一步，定义一个辅助函数k，将slice转为map对应的string类型的key，确保只有x和y相等时k(x) == k(y)才成立。然后创建一个key为string类型的map，在每次对map操作时先用k辅助函数将slice转化为string类型。</p>\n<p>下面的例子演示了如何使用map来记录提交相同的字符串列表的次数。它使用了fmt.Sprintf函数将字符串列表转换为一个字符串以用于map的key，通过%q参数忠实地记录每个字符串元素的信息：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">k</span><span class=\"params\">(list []<span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123; <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;%q&quot;</span>, list) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Add</span><span class=\"params\">(list []<span class=\"keyword\">string</span>)</span></span>       &#123; m[k(list)]++ &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Count</span><span class=\"params\">(list []<span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> m[k(list)] &#125;</span><br></pre></td></tr></table></figure>\n<p>使用同样的技术可以处理任何不可比较的key类型，而不仅仅是slice类型。这种技术对于想使用自定义key比较函数的时候也很有用，例如在比较字符串的时候忽略大小写。同时，辅助函数k(x)也不一定是字符串类型，它可以返回任何可比较的类型，例如整数、数组或结构体等。</p>\n<h3 id=\"结构体\">结构体</h3>\n<p>下面两个语句声明了一个叫Employee的命名的结构体类型，并且声明了一个Employee类型的变量dilbert：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Employee <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ID        <span class=\"keyword\">int</span></span><br><span class=\"line\">    Name      <span class=\"keyword\">string</span></span><br><span class=\"line\">    Address   <span class=\"keyword\">string</span></span><br><span class=\"line\">    DoB       time.Time</span><br><span class=\"line\">    Position  <span class=\"keyword\">string</span></span><br><span class=\"line\">    Salary    <span class=\"keyword\">int</span></span><br><span class=\"line\">    ManagerID <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dilbert Employee</span><br></pre></td></tr></table></figure>\n<p>下面的EmployeeByID函数将根据给定的员工ID返回对应的员工信息结构体的指针。我们可以使用点操作符来访问它里面的成员：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">EmployeeByID</span><span class=\"params\">(id <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Employee</span></span> &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(EmployeeByID(dilbert.ManagerID).Position) <span class=\"comment\">// &quot;Pointy-haired boss&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">id := dilbert.ID</span><br><span class=\"line\">EmployeeByID(id).Salary = <span class=\"number\">0</span> <span class=\"comment\">// fired for... no real reason</span></span><br></pre></td></tr></table></figure>\n<p>后面的语句通过EmployeeByID返回的结构体指针更新了Employee结构体的成员。如果将EmployeeByID函数的返回值从*Employee指针类型改为Employee值类型，那么更新语句将不能编译通过，因为在赋值语句的左边并不确定是一个变量（译注：调用函数返回的是值，并不是一个可取地址的变量）。</p>\n<p>通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话可以被合并到一行，就像下面的Name和Address成员那样：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Employee <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ID            <span class=\"keyword\">int</span></span><br><span class=\"line\">    Name, Address <span class=\"keyword\">string</span></span><br><span class=\"line\">    DoB           time.Time</span><br><span class=\"line\">    Position      <span class=\"keyword\">string</span></span><br><span class=\"line\">    Salary        <span class=\"keyword\">int</span></span><br><span class=\"line\">    ManagerID     <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结构体成员的输入顺序也有重要的意义。我们也可以将Position成员合并（因为也是字符串类型），或者是交换Name和Address出现的先后顺序，那样的话就是定义了不同的结构体类型。通常，我们只是将相关的成员写到一起。</p>\n<p>如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。</p>\n<p>一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适用于数组。）但是S类型的结构体可以包含*S指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。在下面的代码中，我们使用一个二叉树来实现一个插入排序：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> tree <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    value       <span class=\"keyword\">int</span></span><br><span class=\"line\">    left, right *tree</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Sort sorts values in place.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Sort</span><span class=\"params\">(values []<span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> root *tree</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> values &#123;</span><br><span class=\"line\">        root = add(root, v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    appendValues(values[:<span class=\"number\">0</span>], root)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// appendValues appends the elements of t to values in order</span></span><br><span class=\"line\"><span class=\"comment\">// and returns the resulting slice.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">appendValues</span><span class=\"params\">(values []<span class=\"keyword\">int</span>, t *tree)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        values = appendValues(values, t.left)</span><br><span class=\"line\">        values = <span class=\"built_in\">append</span>(values, t.value)</span><br><span class=\"line\">        values = appendValues(values, t.right)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> values</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">(t *tree, value <span class=\"keyword\">int</span>)</span> *<span class=\"title\">tree</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Equivalent to return &amp;tree&#123;value: value&#125;.</span></span><br><span class=\"line\">        t = <span class=\"built_in\">new</span>(tree)</span><br><span class=\"line\">        t.value = value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> value &lt; t.value &#123;</span><br><span class=\"line\">        t.left = add(t.left, value)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        t.right = add(t.right, value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"结构体字面值\">结构体字面值</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span>&#123; X, Y <span class=\"keyword\">int</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有两种形式的结构体字面值语法，上面的是第一种写法，要求以结构体成员定义的顺序为每个结构体成员指定一个字面值。它要求写代码和读代码的人要记住结构体的每个成员的类型和顺序，不过结构体成员有细微的调整就可能导致上述代码不能编译。因此，上述的语法一般只在定义结构体的包内部使用，或者是在较小的结构体中使用，这些结构体的成员排列比较规则，比如image.Point{x, y}或color.RGBA{red, green, blue, alpha}。</p>\n<p>其实更常用的是第二种写法，以成员名字和相应的值来初始化，可以包含部分或全部的成员，如1.4节的Lissajous程序的写法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br></pre></td></tr></table></figure>\n<p>两种不同形式的写法不能混合使用。而且，你不能企图在外部包中用第一种顺序赋值的技巧来偷偷地初始化结构体中未导出的成员。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> p</span><br><span class=\"line\"><span class=\"keyword\">type</span> T <span class=\"keyword\">struct</span>&#123; a, b <span class=\"keyword\">int</span> &#125; <span class=\"comment\">// a and b are not exported</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> q</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;p&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> _ = p.T&#123;a: <span class=\"number\">1</span>, b: <span class=\"number\">2</span>&#125; <span class=\"comment\">// compile error: can&#x27;t reference a, b</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> _ = p.T&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;       <span class=\"comment\">// compile error: can&#x27;t reference a, b</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"结构体比较\">结构体比较</h4>\n<p>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用==或!=运算符进行比较。相等比较运算符==将比较两个结构体的每个成员，因此下面两个比较的表达式是等价的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span>&#123; X, Y <span class=\"keyword\">int</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">q := Point&#123;<span class=\"number\">2</span>, <span class=\"number\">1</span>&#125;</span><br><span class=\"line\">fmt.Println(p.X == q.X &amp;&amp; p.Y == q.Y) <span class=\"comment\">// &quot;false&quot;</span></span><br><span class=\"line\">fmt.Println(p == q)                   <span class=\"comment\">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>\n<p>可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> address <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    hostname <span class=\"keyword\">string</span></span><br><span class=\"line\">    port     <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hits := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[address]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">hits[address&#123;<span class=\"string\">&quot;golang.org&quot;</span>, <span class=\"number\">443</span>&#125;]++</span><br></pre></td></tr></table></figure>\n<h4 id=\"结构体嵌入和匿名成员\">结构体嵌入和匿名成员</h4>\n<p>在本节中，我们将看到如何使用Go语言提供的不同寻常的结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，这样就可以通过简单的点运算符x.f来访问匿名成员链中嵌套的x.d.e.f成员。</p>\n<p>考虑一个二维的绘图程序，提供了一个各种图形的库，例如矩形、椭圆形、星形和轮形等几何形状。这里是其中两个的定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    X, Y, Radius <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Wheel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    X, Y, Radius, Spokes <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个Circle代表的圆形类型包含了标准圆心的X和Y坐标信息，和一个Radius表示的半径信息。一个Wheel轮形除了包含Circle类型所有的全部成员外，还增加了Spokes表示径向辐条的数量。我们可以这样创建一个wheel变量：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> w Wheel</span><br><span class=\"line\">w.X = <span class=\"number\">8</span></span><br><span class=\"line\">w.Y = <span class=\"number\">8</span></span><br><span class=\"line\">w.Radius = <span class=\"number\">5</span></span><br><span class=\"line\">w.Spokes = <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<p>随着库中几何形状数量的增多，我们一定会注意到它们之间的相似和重复之处，所以我们可能为了便于维护而将相同的属性独立出来：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    X, Y <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Center Point</span><br><span class=\"line\">    Radius <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Wheel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Circle Circle</span><br><span class=\"line\">    Spokes <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样改动之后结构体类型变的清晰了，但是这种修改同时也导致了访问每个成员变得繁琐：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> w Wheel</span><br><span class=\"line\">w.Circle.Center.X = <span class=\"number\">8</span></span><br><span class=\"line\">w.Circle.Center.Y = <span class=\"number\">8</span></span><br><span class=\"line\">w.Circle.Radius = <span class=\"number\">5</span></span><br><span class=\"line\">w.Spokes = <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<p>Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。下面的代码中，Circle和Wheel各自都有一个匿名成员。我们可以说Point类型被嵌入到了Circle结构体，同时Circle类型被嵌入到了Wheel结构体。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Point</span><br><span class=\"line\">    Radius <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Wheel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Circle</span><br><span class=\"line\">    Spokes <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>得益于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> w Wheel</span><br><span class=\"line\">w.X = <span class=\"number\">8</span>            <span class=\"comment\">// equivalent to w.Circle.Point.X = 8</span></span><br><span class=\"line\">w.Y = <span class=\"number\">8</span>            <span class=\"comment\">// equivalent to w.Circle.Point.Y = 8</span></span><br><span class=\"line\">w.Radius = <span class=\"number\">5</span>       <span class=\"comment\">// equivalent to w.Circle.Radius = 5</span></span><br><span class=\"line\">w.Spokes = <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<p>在右边的注释中给出的显式形式访问这些叶子成员的语法依然有效，因此匿名成员并不是真的无法访问了。其中匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。我们在访问子成员的时候可以忽略任何匿名成员部分。</p>\n<p>不幸的是，结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">w = Wheel&#123;<span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">20</span>&#125;                       <span class=\"comment\">// compile error: unknown fields</span></span><br><span class=\"line\">w = Wheel&#123;X: <span class=\"number\">8</span>, Y: <span class=\"number\">8</span>, Radius: <span class=\"number\">5</span>, Spokes: <span class=\"number\">20</span>&#125; <span class=\"comment\">// compile error: unknown fields</span></span><br></pre></td></tr></table></figure>\n<p>结构体字面值必须遵循形状类型声明时的结构，所以我们只能用下面的两种语法，它们彼此是等价的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">w = Wheel&#123;Circle&#123;Point&#123;<span class=\"number\">8</span>, <span class=\"number\">8</span>&#125;, <span class=\"number\">5</span>&#125;, <span class=\"number\">20</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">w = Wheel&#123;</span><br><span class=\"line\">    Circle: Circle&#123;</span><br><span class=\"line\">        Point:  Point&#123;X: <span class=\"number\">8</span>, Y: <span class=\"number\">8</span>&#125;,</span><br><span class=\"line\">        Radius: <span class=\"number\">5</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Spokes: <span class=\"number\">20</span>, <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> trailing comma necessary here (and at Radius)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%#v\\n&quot;</span>, w)</span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">w.X = <span class=\"number\">42</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%#v\\n&quot;</span>, w)</span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:42, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span></span><br></pre></td></tr></table></figure>\n<p>需要注意的是Printf函数中%v参数包含的#副词，它表示用和Go语言类似的语法打印值。对于结构体类型来说，将包含每个成员的名字。</p>\n<p>因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。同时，因为成员的名字是由其类型隐式地决定的，所以匿名成员也有可见性的规则约束。在上面的例子中，Point和Circle匿名成员都是导出的。即使它们不导出（比如改成小写字母开头的point和circle），我们依然可以用简短形式访问匿名成员嵌套的成员</p>\n<p>到目前为止，我们看到匿名成员特性只是对访问嵌套成员的点运算符提供了简短的语法糖。稍后，我们将会看到匿名成员并不要求是结构体类型；其实任何命名的类型都可以作为结构体的匿名成员。但是为什么要嵌入一个没有任何子成员类型的匿名成员类型呢？</p>\n<p>答案是匿名类型的方法集。简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访问它们的方法。实际上，外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。这个机制可以用于将一些有简单行为的对象组合成有复杂行为的对象。组合是Go语言中面向对象编程的核心，我们将在6.3节中专门讨论。</p>\n<h3 id=\"JSON\">JSON</h3>\n<p>JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。在类似的协议中，JSON并不是唯一的一个标准协议。 XML（§7.14）、ASN.1和Google的Protocol Buffers都是类似的协议，并且有各自的特色，但是由于简洁性、可读性和流行程度等原因，JSON是应用最广泛的一个。</p>\n<p>基本的JSON类型有数字（十进制或科学记数法）、布尔值（true或false）、字符串，其中字符串是以双引号包含的Unicode字符序列，支持和Go语言类似的反斜杠转义特性，不过JSON使用的是<code>\\Uhhhh</code>转义数字来表示一个UTF-16编码（译注：UTF-16和UTF-8一样是一种变长的编码，有些Unicode码点较大的字符需要用4个字节表示；而且UTF-16还有大端和小端的问题），而不是Go语言的rune类型。</p>\n<p>这些基础类型可以通过JSON的数组和对象类型进行递归组合。一个JSON数组是一个有序的值序列，写在一个方括号中并以逗号分隔；一个JSON数组可以用于编码Go语言的数组和slice。一个JSON对象是一个字符串到值的映射，写成一系列的name:value对形式，用花括号包含并以逗号分隔；JSON的对象类型可以用于编码Go语言的map类型（key类型是字符串）和结构体。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">boolean         <span class=\"literal\">true</span></span><br><span class=\"line\">number          <span class=\"number\">-273.15</span></span><br><span class=\"line\"><span class=\"keyword\">string</span>          <span class=\"string\">&quot;She said \\&quot;Hello, BF\\&quot;&quot;</span></span><br><span class=\"line\">array           [<span class=\"string\">&quot;gold&quot;</span>, <span class=\"string\">&quot;silver&quot;</span>, <span class=\"string\">&quot;bronze&quot;</span>]</span><br><span class=\"line\">object          &#123;<span class=\"string\">&quot;year&quot;</span>: <span class=\"number\">1980</span>,</span><br><span class=\"line\">                 <span class=\"string\">&quot;event&quot;</span>: <span class=\"string\">&quot;archery&quot;</span>,</span><br><span class=\"line\">                 <span class=\"string\">&quot;medals&quot;</span>: [<span class=\"string\">&quot;gold&quot;</span>, <span class=\"string\">&quot;silver&quot;</span>, <span class=\"string\">&quot;bronze&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>\n<p>考虑一个应用程序，该程序负责收集各种电影评论并提供反馈功能。它的Movie数据类型和一个典型的表示电影的值列表如下所示。（在结构体声明中，Year和Color成员后面的字符串面值是结构体成员Tag；我们稍后会解释它的作用。）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Movie <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Title  <span class=\"keyword\">string</span></span><br><span class=\"line\">    Year   <span class=\"keyword\">int</span>  <span class=\"string\">`json:&quot;released&quot;`</span></span><br><span class=\"line\">    Color  <span class=\"keyword\">bool</span> <span class=\"string\">`json:&quot;color,omitempty&quot;`</span></span><br><span class=\"line\">    Actors []<span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> movies = []Movie&#123;</span><br><span class=\"line\">    &#123;Title: <span class=\"string\">&quot;Casablanca&quot;</span>, Year: <span class=\"number\">1942</span>, Color: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        Actors: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;Humphrey Bogart&quot;</span>, <span class=\"string\">&quot;Ingrid Bergman&quot;</span>&#125;&#125;,</span><br><span class=\"line\">    &#123;Title: <span class=\"string\">&quot;Cool Hand Luke&quot;</span>, Year: <span class=\"number\">1967</span>, Color: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        Actors: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;Paul Newman&quot;</span>&#125;&#125;,</span><br><span class=\"line\">    &#123;Title: <span class=\"string\">&quot;Bullitt&quot;</span>, Year: <span class=\"number\">1968</span>, Color: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        Actors: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;Steve McQueen&quot;</span>, <span class=\"string\">&quot;Jacqueline Bisset&quot;</span>&#125;&#125;,</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的数据结构特别适合JSON格式，并且在两者之间相互转换也很容易。将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）。编组通过调用json.Marshal函数完成：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">data, err := json.Marshal(movies)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">&quot;JSON marshaling failed: %s&quot;</span>, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%s\\n&quot;</span>, data)</span><br></pre></td></tr></table></figure>\n<p>Marshal函数返回一个编码后的字节slice，包含很长的字符串，并且没有空白缩进；我们将它折行以便于显示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">[&#123;<span class=\"string\">&quot;Title&quot;</span>:<span class=\"string\">&quot;Casablanca&quot;</span>,<span class=\"string\">&quot;released&quot;</span>:<span class=\"number\">1942</span>,<span class=\"string\">&quot;Actors&quot;</span>:[<span class=\"string\">&quot;Humphrey Bogart&quot;</span>,<span class=\"string\">&quot;Ingr</span></span><br><span class=\"line\"><span class=\"string\">id Bergman&quot;</span>]&#125;,&#123;<span class=\"string\">&quot;Title&quot;</span>:<span class=\"string\">&quot;Cool Hand Luke&quot;</span>,<span class=\"string\">&quot;released&quot;</span>:<span class=\"number\">1967</span>,<span class=\"string\">&quot;color&quot;</span>:<span class=\"literal\">true</span>,<span class=\"string\">&quot;Ac</span></span><br><span class=\"line\"><span class=\"string\">tors&quot;</span>:[<span class=\"string\">&quot;Paul Newman&quot;</span>]&#125;,&#123;<span class=\"string\">&quot;Title&quot;</span>:<span class=\"string\">&quot;Bullitt&quot;</span>,<span class=\"string\">&quot;released&quot;</span>:<span class=\"number\">1968</span>,<span class=\"string\">&quot;color&quot;</span>:<span class=\"literal\">true</span>,<span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">Actors&quot;</span>:[<span class=\"string\">&quot;Steve McQueen&quot;</span>,<span class=\"string\">&quot;Jacqueline Bisset&quot;</span>]&#125;]</span><br></pre></td></tr></table></figure>\n<p>这种紧凑的表示形式虽然包含了全部的信息，但是很难阅读。为了生成便于阅读的格式，另一个json.MarshalIndent函数将产生整齐缩进的输出。该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">data, err := json.MarshalIndent(movies, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;    &quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">&quot;JSON marshaling failed: %s&quot;</span>, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%s\\n&quot;</span>, data)</span><br></pre></td></tr></table></figure>\n<p>上面的代码将产生这样的输出（译注：在最后一个成员或元素后面并没有逗号分隔符）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;Title&quot;</span>: <span class=\"string\">&quot;Casablanca&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;released&quot;</span>: <span class=\"number\">1942</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Actors&quot;</span>: [</span><br><span class=\"line\">            <span class=\"string\">&quot;Humphrey Bogart&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;Ingrid Bergman&quot;</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;Title&quot;</span>: <span class=\"string\">&quot;Cool Hand Luke&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;released&quot;</span>: <span class=\"number\">1967</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;color&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Actors&quot;</span>: [</span><br><span class=\"line\">            <span class=\"string\">&quot;Paul Newman&quot;</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;Title&quot;</span>: <span class=\"string\">&quot;Bullitt&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;released&quot;</span>: <span class=\"number\">1968</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;color&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Actors&quot;</span>: [</span><br><span class=\"line\">            <span class=\"string\">&quot;Steve McQueen&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;Jacqueline Bisset&quot;</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术，我们将在12.6节讨论）。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。</p>\n<p>细心的读者可能已经注意到，其中Year名字的成员在编码后变成了released，还有Color成员编码后变成了小写字母开头的color。这是因为结构体成员Tag所导致的。一个结构体成员Tag是和在编译阶段关联到该成员的元信息字符串：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">Year  <span class=\"keyword\">int</span>  <span class=\"string\">`json:&quot;released&quot;`</span></span><br><span class=\"line\">Color <span class=\"keyword\">bool</span> <span class=\"string\">`json:&quot;color,omitempty&quot;`</span></span><br></pre></td></tr></table></figure>\n<p>结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:&quot;value&quot;键值对序列；因为值中含有双引号字符，因此成员Tag一般用原生字符串面值的形式书写。json开头键名对应的值用于控制encoding/json包的编码和解码的行为，并且encoding/…下面其它的包也遵循这个约定。成员Tag中json对应值的第一部分用于指定JSON对象的名字，比如将Go语言中的TotalCount成员对应到JSON中的total_count对象。Color成员的Tag还带了一个额外的omitempty选项，表示当Go语言结构体成员为空或零值时不生成该JSON对象（这里false为零值）。果然，Casablanca是一个黑白电影，并没有输出Color成员。</p>\n<p>编码的逆操作是解码，对应将JSON数据解码为Go语言的数据结构，Go语言中一般叫unmarshaling，通过json.Unmarshal函数完成。下面的代码将JSON格式的电影数据解码为一个结构体slice，结构体中只有Title成员。通过定义合适的Go语言数据结构，我们可以选择性地解码JSON中感兴趣的成员。当Unmarshal函数调用返回，slice将被只含有Title信息的值填充，其它JSON成员将被忽略。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> titles []<span class=\"keyword\">struct</span>&#123; Title <span class=\"keyword\">string</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> err := json.Unmarshal(data, &amp;titles); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">&quot;JSON unmarshaling failed: %s&quot;</span>, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(titles) <span class=\"comment\">// &quot;[&#123;Casablanca&#125; &#123;Cool Hand Luke&#125; &#123;Bullitt&#125;]&quot;</span></span><br></pre></td></tr></table></figure>\n<p>许多web服务都提供JSON接口，通过HTTP接口发送JSON格式请求并返回JSON格式的信息。为了说明这一点，我们通过Github的issue查询服务来演示类似的用法。首先，我们要定义合适的类型和常量：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Package github provides a Go API for the GitHub issue tracker.</span></span><br><span class=\"line\"><span class=\"comment\">// See https://developer.github.com/v3/search/#search-issues.</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> github</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> IssuesURL = <span class=\"string\">&quot;https://api.github.com/search/issues&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> IssuesSearchResult <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    TotalCount <span class=\"keyword\">int</span> <span class=\"string\">`json:&quot;total_count&quot;`</span></span><br><span class=\"line\">    Items          []*Issue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Issue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Number    <span class=\"keyword\">int</span></span><br><span class=\"line\">    HTMLURL   <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;html_url&quot;`</span></span><br><span class=\"line\">    Title     <span class=\"keyword\">string</span></span><br><span class=\"line\">    State     <span class=\"keyword\">string</span></span><br><span class=\"line\">    User      *User</span><br><span class=\"line\">    CreatedAt time.Time <span class=\"string\">`json:&quot;created_at&quot;`</span></span><br><span class=\"line\">    Body      <span class=\"keyword\">string</span>    <span class=\"comment\">// in Markdown format</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Login   <span class=\"keyword\">string</span></span><br><span class=\"line\">    HTMLURL <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;html_url&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和前面一样，即使对应的JSON对象名是小写字母，每个结构体的成员名也是声明为大写字母开头的。因为有些JSON成员名字和Go结构体成员名字并不相同，因此需要Go语言结构体成员Tag来指定对应的JSON名字。同样，在解码的时候也需要做同样的处理，GitHub服务返回的信息比我们定义的要多很多。</p>\n<p>SearchIssues函数发出一个HTTP请求，然后解码返回的JSON格式的结果。因为用户提供的查询条件可能包含类似?和&amp;之类的特殊字符，为了避免对URL造成冲突，我们用url.QueryEscape来对查询中的特殊字符进行转义操作。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> github</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/url&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// SearchIssues queries the GitHub issue tracker.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SearchIssues</span><span class=\"params\">(terms []<span class=\"keyword\">string</span>)</span> <span class=\"params\">(*IssuesSearchResult, error)</span></span> &#123;</span><br><span class=\"line\">    q := url.QueryEscape(strings.Join(terms, <span class=\"string\">&quot; &quot;</span>))</span><br><span class=\"line\">    resp, err := http.Get(IssuesURL + <span class=\"string\">&quot;?q=&quot;</span> + q)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// We must close resp.Body on all execution paths.</span></span><br><span class=\"line\">    <span class=\"comment\">// (Chapter 5 presents &#x27;defer&#x27;, which makes this simpler.)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> resp.StatusCode != http.StatusOK &#123;</span><br><span class=\"line\">        resp.Body.Close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;search query failed: %s&quot;</span>, resp.Status)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> result IssuesSearchResult</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;result); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        resp.Body.Close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    resp.Body.Close()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;result, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在早些的例子中，我们使用了json.Unmarshal函数来将JSON格式的字符串解码为字节slice。但是这个例子中，我们使用了基于流式的解码器json.Decoder，它可以从一个输入流解码JSON数据，尽管这不是必须的。如您所料，还有一个针对输出流的json.Encoder编码对象。</p>\n<p>我们调用Decode方法来填充变量。这里有多种方法可以格式化结构。下面是最简单的一种，以一个固定宽度打印每个issue，但是在下一节我们将看到如何利用模板来输出复杂的格式。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Issues prints a table of GitHub issues matching the search terms.</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;gopl.io/ch4/github&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    result, err := github.SearchIssues(os.Args[<span class=\"number\">1</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%d issues:\\n&quot;</span>, result.TotalCount)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, item := <span class=\"keyword\">range</span> result.Items &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;#%-5d %9.9s %.55s\\n&quot;</span>,</span><br><span class=\"line\">            item.Number, item.User.Login, item.Title)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过命令行参数指定检索条件。下面的命令是查询Go语言项目中和JSON解码相关的问题，还有查询返回的结果：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">go</span> build gopl.io/ch4/issues</span><br><span class=\"line\">$ ./issues repo:golang/<span class=\"keyword\">go</span> is:open json decoder</span><br><span class=\"line\"><span class=\"number\">13</span> issues:</span><br><span class=\"line\">#<span class=\"number\">5680</span>    eaigner encoding/json: set key converter on en/decoder</span><br><span class=\"line\">#<span class=\"number\">6050</span>  gopherbot encoding/json: provide tokenizer</span><br><span class=\"line\">#<span class=\"number\">8658</span>  gopherbot encoding/json: use bufio</span><br><span class=\"line\">#<span class=\"number\">8462</span>  kortschak encoding/json: UnmarshalText confuses json.Unmarshal</span><br><span class=\"line\">#<span class=\"number\">5901</span>        rsc encoding/json: allow override <span class=\"keyword\">type</span> marshaling</span><br><span class=\"line\">#<span class=\"number\">9812</span>  klauspost encoding/json: <span class=\"keyword\">string</span> tag not symmetric</span><br><span class=\"line\">#<span class=\"number\">7872</span>  extempora encoding/json: Encoder internally buffers full output</span><br><span class=\"line\">#<span class=\"number\">9650</span>    cespare encoding/json: Decoding gives errPhase when unmarshalin</span><br><span class=\"line\">#<span class=\"number\">6716</span>  gopherbot encoding/json: include field name in unmarshal error me</span><br><span class=\"line\">#<span class=\"number\">6901</span>  lukescott encoding/json, encoding/xml: option to treat unknown fi</span><br><span class=\"line\">#<span class=\"number\">6384</span>    joeshaw encoding/json: encode precise floating point integers u</span><br><span class=\"line\">#<span class=\"number\">6647</span>    btracey x/tools/cmd/godoc: display <span class=\"keyword\">type</span> kind of each named <span class=\"keyword\">type</span></span><br><span class=\"line\">#<span class=\"number\">4237</span>  gjemiller encoding/base64: URLEncoding padding is optional</span><br></pre></td></tr></table></figure>","categories":["go"]},{"title":"kaggle数据集上传到colab","url":"/2022/01/20/kaggle%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8A%E4%BC%A0%E5%88%B0colab/","content":"<p>在colab上依次运行下面的命令</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">!pip install kaggle</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\">token=&#123;<span class=\"string\">&quot;username&quot;</span>:<span class=\"string\">&quot;xxxxx&quot;</span>,<span class=\"string\">&quot;key&quot;</span>:<span class=\"string\">&quot;xxxxx&quot;</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./content/kaggle.json&#x27;</span>,<span class=\"string\">&#x27;w&#x27;</span>) <span class=\"keyword\">as</span> file:</span><br><span class=\"line\">    json.dump(token,file)</span><br></pre></td></tr></table></figure>\n<p>token中的键值对对应的是自己的账号内容，具体操作：</p>\n<ol>\n<li>进入kaggle，点击头像，点击myaccount</li>\n<li>往下拖，点击API栏中的Creat New API token，会自动生成一个json文件</li>\n<li>将json文件中的username和key对应填写到上面代码中</li>\n</ol>\n<p>接下来，依次运行下面的代码</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">-mkdir -p ~/.kaggle</span><br><span class=\"line\">!cp /content/kaggle.json ~/.kaggle</span><br><span class=\"line\">!chmod <span class=\"number\">600</span> ~/.kaggle/kaggle.json</span><br><span class=\"line\">!kaggle config <span class=\"built_in\">set</span> -n path -v /content</span><br></pre></td></tr></table></figure>\n<p>找到我们需要的kaggle数据集的API后，复制执行</p>\n","categories":["DeepLearning"],"tags":["colab,kaggle"]},{"title":"从零实现一个go web框架：Gee","url":"/2022/03/27/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAgo-web%E6%A1%86%E6%9E%B6%EF%BC%9AGee/","content":"<h2 id=\"http-Handler\">http.Handler</h2>\n<h3 id=\"实现http-Handler接口\">实现http.Handler接口</h3>\n<p>首先我们看<code>net/http</code>源码中对Handler的定义，发现只要实现了ServeHTTP方法就Handler</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> http</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    ServeHTTP(w ResponseWriter, r *Request)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">(address <span class=\"keyword\">string</span>, h Handler)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<p>那接下来我们用自己的方法实现</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Engine is the uni handler for all requests</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Engine <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> req.URL.Path &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">        fmt.Fprintf(w, <span class=\"string\">&quot;URL.Path = %q\\n&quot;</span>, req.URL.Path)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;/hello&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> req.Header &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, <span class=\"string\">&quot;Header[%q] = %q\\n&quot;</span>, k, v)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        fmt.Fprintf(w, <span class=\"string\">&quot;404 NOT FOUND: %s\\n&quot;</span>, req.URL)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    engine := <span class=\"built_in\">new</span>(Engine)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(<span class=\"string\">&quot;:9999&quot;</span>, engine))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>我们定义的一个空结构体<code>Engine</code>实现了<code>ServeHTTP</code>方法</li>\n<li>在main中，我们将自己创建的engine实例传入ListenAndServe函数中。这将所有的http请求都转接到了我们自己的处理逻辑上了。在之前，我们只能针对具体路由写处理逻辑。但是现在使用Engine，我们可以拦截所有http请求并且可以自由定义路由规则的映射</li>\n</ul>\n<h3 id=\"Gee框架的雏形\">Gee框架的雏形</h3>\n<p>接下来重新组织代码，搭建整个框架的雏形，最终代码目录结构如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">gee/</span><br><span class=\"line\">  |--gee.go</span><br><span class=\"line\">  |--go.mod</span><br><span class=\"line\">main.go</span><br><span class=\"line\">go.mod</span><br></pre></td></tr></table></figure>\n<p>然后需要修改go.mod文件，使用replace将gee指向<code>./gee</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">module example</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"number\">1.13</span></span><br><span class=\"line\"></span><br><span class=\"line\">require gee v0<span class=\"number\">.0</span><span class=\"number\">.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">replace gee =&gt; ./gee</span><br></pre></td></tr></table></figure>\n<h3 id=\"gee-go\">gee.go</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> gee</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义我们框架中需要使用的handler函数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> HandlerFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Engine 实现ServeHTTP接口</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Engine <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\trouter <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]HandlerFunc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// New 用于新建一个gee.Engine</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span> *<span class=\"title\">Engine</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Engine&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]HandlerFunc),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">\tkey := req.Method + <span class=\"string\">&quot;-&quot;</span> + req.URL.Path</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> handler, ok := engine.router[key]; ok &#123;</span><br><span class=\"line\">\t\thandler(w, req)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tfmt.Fprintf(w, <span class=\"string\">&quot;404 NOT FOUND:%s\\n&quot;</span>, req.URL)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// addRoute 将路径和handler添加到engine中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">addRoute</span><span class=\"params\">(method <span class=\"keyword\">string</span>, pattern <span class=\"keyword\">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tkey := method + <span class=\"string\">&quot;-&quot;</span> + pattern</span><br><span class=\"line\">\tengine.router[key] = handler</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">GET</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tengine.addRoute(<span class=\"string\">&quot;GET&quot;</span>, pattern, handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">POST</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tengine.addRoute(<span class=\"string\">&quot;POST&quot;</span>, pattern, handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">Run</span><span class=\"params\">(addr <span class=\"keyword\">string</span>)</span> <span class=\"params\">(err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> http.ListenAndServe(<span class=\"string\">&quot;addr&quot;</span>, engine)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码是整章的重点：</p>\n<ul>\n<li>首先定义了<code>HandlerFunc</code>类型，提供给框架用户，用来定义路由映射的处理方法。我们在<code>Engine</code>中定义了一张路由映射表<code>router</code>，key由请求方法和静态路由地址构成，这样如果请求方法不同那么能够映射到不同的处理方法上，value是用户映射的处理方法。</li>\n<li>当用户调用<code>(*Engine).GET()</code>方法的时候会将处理方法和路由映射到router中</li>\n<li>Engine实现的ServeHTTP方法的作用就是解析请求的路径，查找路由映射表，有就执行，没有报404</li>\n</ul>\n<h3 id=\"main-go\">main.go</h3>\n<p>然后是写main函数测试我们这个框架到目前为止是否是有用的，基本和Gin框架是一样的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;base3/gee&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tr := gee.New()</span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t\tfmt.Fprintf(w, <span class=\"string\">&quot;URL.Path = %q\\n&quot;</span>, req.URL.Path)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/hello&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> req.Header &#123;</span><br><span class=\"line\">\t\t\tfmt.Fprintf(w, <span class=\"string\">&quot;Header[%q] = %q\\n&quot;</span>, k, v)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tr.Run(<span class=\"string\">&quot;:9999&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"上下文context\">上下文context</h2>\n<h3 id=\"设计context\">设计context</h3>\n<p>对于web服务来说，无非是根据请求构造响应，但是这两个对象提供的接口粒度太过于细致，比如我们构造一个完整的响应，需要考虑消息头和消息体，而header中包含了状态码、消息类型等几乎每次请求都需要设置的信息，因此如果不封装，会导致每次都要重复写大量的代码。我们用json数据作比较，感受下封装前后差距</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//封装前</span></span><br><span class=\"line\">obj = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;geektutu&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;password&quot;</span>: <span class=\"string\">&quot;1234&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">w.Header().Set(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/json&quot;</span>)</span><br><span class=\"line\">w.WriteHeader(http.StatusOK)</span><br><span class=\"line\">encoder := json.NewEncoder(w)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err := encoder.Encode(obj); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    http.Error(w, err.Error(), <span class=\"number\">500</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//封装后</span></span><br><span class=\"line\">c.JSON(http.StatusOK, gee.H&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;username&quot;</span>: c.PostForm(<span class=\"string\">&quot;username&quot;</span>),</span><br><span class=\"line\">    <span class=\"string\">&quot;password&quot;</span>: c.PostForm(<span class=\"string\">&quot;password&quot;</span>),</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>针对使用场景，封装*http.Request和http.ResponseWriter的方法，简化相关接口的调用，只是设计 Context 的原因之一。对于框架来说，还需要支撑额外的功能。例如，将来解析动态路由/hello/:name，参数:name的值放在哪呢？再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？Context 随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由 Context 承载。因此，设计 Context 结构，扩展性和复杂性留在了内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件，参数都统一使用 Context 实例， Context 就像一次会话的百宝箱，可以找到任何东西。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> gee</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// H 是字符串-空接口映射的别名</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> H <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Context <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 基本部件</span></span><br><span class=\"line\">\tWriter http.ResponseWriter</span><br><span class=\"line\">\tReq    *http.Request</span><br><span class=\"line\">\t<span class=\"comment\">// 请求信息</span></span><br><span class=\"line\">\tPath   <span class=\"keyword\">string</span></span><br><span class=\"line\">\tMethod <span class=\"keyword\">string</span></span><br><span class=\"line\">\t<span class=\"comment\">// 返回信息</span></span><br><span class=\"line\">\tStatusCode <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// newContext 根绝输入的w和req返回一个Context的指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newContext</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span> *<span class=\"title\">Context</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Context&#123;</span><br><span class=\"line\">\t\tWriter: w,</span><br><span class=\"line\">\t\tReq:    req,</span><br><span class=\"line\">\t\tPath:   req.URL.Path,</span><br><span class=\"line\">\t\tMethod: req.Method,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PostForm 解析表单中的数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">PostForm</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.Req.FormValue(key)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Query 解析URL中指定的参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">Query</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.Req.URL.Query().Get(key)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Status 将状态码添加到context中，并且写入到返回头</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">Status</span><span class=\"params\">(code <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tc.StatusCode = code</span><br><span class=\"line\">\tc.Writer.WriteHeader(code)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// SetHeader 设置返回头中的键值对</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">SetHeader</span><span class=\"params\">(key <span class=\"keyword\">string</span>, value <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\tc.Writer.Header().Set(key, value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// String 返回是string类型的数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">String</span><span class=\"params\">(code <span class=\"keyword\">int</span>, format <span class=\"keyword\">string</span>, values ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tc.SetHeader(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;text/plain&quot;</span>)</span><br><span class=\"line\">\tc.Status(code)</span><br><span class=\"line\">\tc.Writer.Write([]<span class=\"keyword\">byte</span>(fmt.Sprintf(format, values...)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// JSON 返回编码好的json数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">JSON</span><span class=\"params\">(code <span class=\"keyword\">int</span>, obj <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tc.SetHeader(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/json&quot;</span>)</span><br><span class=\"line\">\tc.Status(code)</span><br><span class=\"line\">\tencoder := json.NewEncoder(c.Writer)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := encoder.Encode(obj); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\thttp.Error(c.Writer, err.Error(), <span class=\"number\">500</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Data 直接返回数据流</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">Data</span><span class=\"params\">(code <span class=\"keyword\">int</span>, data []<span class=\"keyword\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">\tc.Status(code)</span><br><span class=\"line\">\tc.Writer.Write(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HTML 返回html数据，本质上也是将html转成[]byte数据流再传回去</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">HTML</span><span class=\"params\">(code <span class=\"keyword\">int</span>, html <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\tc.Status(code)</span><br><span class=\"line\">\tc.SetHeader(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;text/html&quot;</span>)</span><br><span class=\"line\">\tc.Writer.Write([]<span class=\"keyword\">byte</span>(html))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"路由\">路由</h3>\n<p>我们将和路由相关的方法和结构提取了出来，放到了一个新的文件中router.go，方便我们下一次对 router 的功能进行增强，例如提供动态路由的支持。 router 的 handle 方法作了一个细微的调整，即 handler 的参数，变成了 Context。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> gee</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> router <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\thandlers <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]HandlerFunc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// newRouter 创建一个新的router管理器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newRouter</span><span class=\"params\">()</span> *<span class=\"title\">router</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;router&#123;</span><br><span class=\"line\">\t\thandlers: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]HandlerFunc),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// addRoute 为路径管理器中的路径映射表添加映射</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *router)</span> <span class=\"title\">addRoute</span><span class=\"params\">(method <span class=\"keyword\">string</span>, pattern <span class=\"keyword\">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">&quot;Route %4s - %s&quot;</span>, method, pattern)</span><br><span class=\"line\">\tkey := method + <span class=\"string\">&quot;-&quot;</span> + pattern</span><br><span class=\"line\">\tr.handlers[key] = handler</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// handle 调用handler函数，如果存在的话</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *router)</span> <span class=\"title\">handle</span><span class=\"params\">(c *Context)</span></span> &#123;</span><br><span class=\"line\">\tkey := c.Method + <span class=\"string\">&quot;-&quot;</span> + c.Path</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> handler, ok := r.handlers[key]; ok &#123;</span><br><span class=\"line\">\t\thandler(c)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tc.String(http.StatusNotFound, <span class=\"string\">&quot;404 NOT FOUND:%s\\n&quot;</span>, c.Path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"框架入口\">框架入口</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> HandlerFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx *Context)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Engine <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\trouter *router</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// New 初始化一个新的Engine</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span> *<span class=\"title\">Engine</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Engine&#123;</span><br><span class=\"line\">\t\trouter: newRouter(),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">addRoute</span><span class=\"params\">(method <span class=\"keyword\">string</span>,pattern <span class=\"keyword\">string</span>,handler HandlerFunc)</span></span>&#123;</span><br><span class=\"line\">\tengine.router.addRoute(method,pattern,handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">GET</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>,handler HandlerFunc)</span></span>&#123;</span><br><span class=\"line\">\tengine.addRoute(<span class=\"string\">&quot;GET&quot;</span>,pattern,handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">POST</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>,handler HandlerFunc)</span></span>&#123;</span><br><span class=\"line\">\tengine.addRoute(<span class=\"string\">&quot;POST&quot;</span>,pattern,handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">Run</span><span class=\"params\">(addr <span class=\"keyword\">string</span>)</span> <span class=\"params\">(err error)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> http.ListenAndServe(addr,engine)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter,req *http.Request)</span></span>&#123;</span><br><span class=\"line\">\tc:=newContext(w,req)</span><br><span class=\"line\">\tengine.router.handle(c)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将router相关的代码独立后，gee.go简单了不少。最重要的还是通过实现了 ServeHTTP 接口，接管了所有的 HTTP 请求。相比第一天的代码，这个方法也有细微的调整，在调用 router.handle 之前，构造了一个 Context 对象。这个对象目前还非常简单，仅仅是包装了原来的两个参数，之后我们会慢慢地给Context插上翅膀。</p>\n<p>接下来写个main来试试看这个框架目前有没有用</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;context/gee&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tr := gee.New()</span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tctx.HTML(http.StatusOK, <span class=\"string\">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/hello&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tctx.String(http.StatusOK, <span class=\"string\">&quot;hello %s,you are at %s\\n&quot;</span>, ctx.Query(<span class=\"string\">&quot;name&quot;</span>), ctx.Path)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tr.POST(<span class=\"string\">&quot;/login&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tctx.JSON(http.StatusOK, gee.H&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;username&quot;</span>: ctx.PostForm(<span class=\"string\">&quot;username&quot;</span>),</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;password&quot;</span>: ctx.PostForm(<span class=\"string\">&quot;password&quot;</span>),</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tr.Run(<span class=\"string\">&quot;:9999&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"前缀树路由router\">前缀树路由router</h2>\n<h3 id=\"Trie树简介\">Trie树简介</h3>\n<p>之前，我们用了一个非常简单的map结构存储了路由表，使用map存储键值对，索引非常高效，但是有一个弊端，键值对的存储的方式，只能用来索引静态路由。那如果我们想支持类似于/hello/:name这样的动态路由怎么办呢？所谓动态路由，即一条路由规则可以匹配某一类型而非某一条固定的路由。例如/hello/:name，可以匹配/hello/geektutu、hello/jack等。</p>\n<p><img src=\"https://i.imgur.com/8xaRXEv.png\" alt=\"picture 4\"></p>\n<p>实现动态路由最常用的数据结构，被称为前缀树(Trie树)。看到名字你大概也能知道前缀树长啥样了：每一个节点的所有的子节点都拥有相同的前缀。这种结构非常适用于路由匹配，比如我们定义了如下路由规则：</p>\n<ul>\n<li>/:lang/doc</li>\n<li>/:lang/tutorial</li>\n<li>/:lang/intro</li>\n<li>/about</li>\n<li>/p/blog</li>\n<li>/p/related</li>\n</ul>\n<p><img src=\"https://i.imgur.com/xeFRKUb.png\" alt=\"picture 5\"></p>\n<p>接下来我们实现的动态路由具备以下两个功能。</p>\n<ul>\n<li>参数匹配:。例如 /p/:lang/doc，可以匹配 /p/c/doc 和 /p/go/doc。</li>\n<li>通配*。例如 /static/*filepath，可以匹配/static/fav.ico，也可以匹配/static/js/jQuery.js，这种模式常用于静态服务器，能够递归地匹配子路径。</li>\n</ul>\n<h3 id=\"Trie树实现\">Trie树实现</h3>\n<p>首先我们需要设计树节点上应该存储那些信息。</p>\n<p>与普通的树不同，为了实现动态路由匹配，加上了isWild这个参数。即当我们匹配 /p/go/doc/这个路由时，第一层节点，p精准匹配到了p，第二层节点，go模糊匹配到:lang，那么将会把lang这个参数赋值为go，继续下一层匹配。我们将匹配的逻辑，包装为一个辅助函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> gee</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> node <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tpattern  <span class=\"keyword\">string</span>  <span class=\"comment\">//待匹配的路由 如 /p/:lang</span></span><br><span class=\"line\">\tpart     <span class=\"keyword\">string</span>  <span class=\"comment\">//路由中的一部分，例如 :lang</span></span><br><span class=\"line\">\tchildren []*node <span class=\"comment\">//子节点</span></span><br><span class=\"line\">\tisWild   <span class=\"keyword\">bool</span>    <span class=\"comment\">//是否精确匹配，part含有:或者*时为True</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// matchChild 第一个匹配成功的节点，用于插入</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n *node)</span> <span class=\"title\">matchChild</span><span class=\"params\">(part <span class=\"keyword\">string</span>)</span> *<span class=\"title\">node</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, child := <span class=\"keyword\">range</span> n.children &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> child.part == part || child.isWild &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> child</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// matchChildren 返回所有匹配成功的节点，用于查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n *node)</span> <span class=\"title\">matchChildren</span><span class=\"params\">(part <span class=\"keyword\">string</span>)</span> []*<span class=\"title\">node</span></span> &#123;</span><br><span class=\"line\">\tnodes := <span class=\"built_in\">make</span>([]*node, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, child := <span class=\"keyword\">range</span> n.children &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> child.part == part || child.isWild &#123;</span><br><span class=\"line\">\t\t\tnodes = <span class=\"built_in\">append</span>(nodes, child)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> nodes</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于路由来说，最重要的当然是注册与匹配了。开发服务时，注册路由规则，映射handler；访问时，匹配路由规则，查找到对应的handler。因此，Trie 树需要支持节点的插入与查询。插入功能很简单，递归查找每一层的节点，如果没有匹配到当前part的节点，则新建一个，有一点需要注意，/p/:lang/doc只有在第三层节点，即doc节点，pattern才会设置为/p/:lang/doc。p和:lang节点的pattern属性皆为空。因此，当匹配结束时，我们可以使用n.pattern == &quot;&quot;来判断路由规则是否匹配成功。例如，/p/python虽能成功匹配到:lang，但:lang的pattern值为空，因此匹配失败。查询功能，同样也是递归查询每一层的节点，退出规则是，匹配到了*，匹配失败，或者匹配到了第len(parts)层节点。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// insert 插入一个新的路径节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n *node)</span> <span class=\"title\">insert</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, parts []<span class=\"keyword\">string</span>, height <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(parts) == height &#123;</span><br><span class=\"line\">\t\tn.pattern = pattern</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpart := parts[height]</span><br><span class=\"line\">\tchild := n.matchChild(part)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> child == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tchild = &amp;node&#123;</span><br><span class=\"line\">\t\t\tpart:   part,</span><br><span class=\"line\">\t\t\tisWild: part[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;:&#x27;</span> || part[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;*&#x27;</span>,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn.children = <span class=\"built_in\">append</span>(n.children, child)</span><br><span class=\"line\"></span><br><span class=\"line\">\tchild.insert(pattern, parts, height+<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// search 搜索是否存在某个路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n *node)</span> <span class=\"title\">search</span><span class=\"params\">(parts []<span class=\"keyword\">string</span>, height <span class=\"keyword\">int</span>)</span> *<span class=\"title\">node</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(parts) == height || strings.HasPrefix(n.part, <span class=\"string\">&quot;*&quot;</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n.pattern == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpart := parts[height]</span><br><span class=\"line\">\tchildren := n.matchChildren(part)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, child := <span class=\"keyword\">range</span> children &#123;</span><br><span class=\"line\">\t\tresult := child.search(parts, height+<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> result != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> result</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Router\">Router</h3>\n<p>我们使用 roots 来存储每种请求方式的Trie 树根节点。使用 handlers 存储每种请求方式的 HandlerFunc 。getRoute 函数中，还解析了:和*两种匹配符的参数，返回一个 map 。例如/p/go/doc匹配到/p/:lang/doc，解析结果为：{lang: “go”}，/static/css/geektutu.css匹配到/static/*filepath，解析结果为{filepath: “css/geektutu.css”}。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> gee</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> router <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\troots    <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*node</span><br><span class=\"line\">\thandlers <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]HandlerFunc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// newRouter 创建一个新的router</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newRouter</span><span class=\"params\">()</span> *<span class=\"title\">router</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;router&#123;</span><br><span class=\"line\">\t\troots:    <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*node),</span><br><span class=\"line\">\t\thandlers: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]HandlerFunc),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// parsePattern 只允许出现一次*</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parsePattern</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tvs := strings.Split(pattern, <span class=\"string\">&quot;/&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tparts := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, item := <span class=\"keyword\">range</span> vs &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> item != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\tparts = <span class=\"built_in\">append</span>(parts, item)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> item[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;*&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> parts</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// addRoute 在router管理器中增加新的节点，并且增加新的路径-方法映射</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *router)</span> <span class=\"title\">addRoute</span><span class=\"params\">(method <span class=\"keyword\">string</span>, pattern <span class=\"keyword\">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tparts := parsePattern(pattern)</span><br><span class=\"line\"></span><br><span class=\"line\">\tkey := method + <span class=\"string\">&quot;-&quot;</span> + pattern</span><br><span class=\"line\">\t_, ok := r.roots[method]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\tr.roots[method] = &amp;node&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr.roots[method].insert(pattern, parts, <span class=\"number\">0</span>)</span><br><span class=\"line\">\tr.handlers[key] = handler</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// getRoute 获取某个路径的叶子节点和对应的参数映射表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *router)</span> <span class=\"title\">getRoute</span><span class=\"params\">(method <span class=\"keyword\">string</span>, path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*node, <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\tsearchParts := parsePattern(path)</span><br><span class=\"line\">\tparams := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>)</span><br><span class=\"line\">\troot, ok := r.roots[method]</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tn := root.search(searchParts, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tparts := parsePattern(n.pattern)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> index, part := <span class=\"keyword\">range</span> parts &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> part[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;:&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//将对应匹配到的参数记录下来（URL参数）</span></span><br><span class=\"line\">\t\t\t\tparams[part[<span class=\"number\">1</span>:]] = searchParts[index]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> part[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;*&#x27;</span> &amp;&amp; <span class=\"built_in\">len</span>(part) &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\tparams[part[<span class=\"number\">1</span>:]] = strings.Join(searchParts[index:], <span class=\"string\">&quot;/&quot;</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n,params</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>,<span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"context和handle的变化\">context和handle的变化</h3>\n<p>在 HandlerFunc 中，希望能够访问到解析的参数，因此，需要对 Context 对象增加一个属性和方法，来提供对路由参数的访问。我们将解析后的参数存储到Params中，通过c.Param(“lang”)的方式获取到对应的值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//context的改动</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Context <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// origin objects</span></span><br><span class=\"line\">\tWriter http.ResponseWriter</span><br><span class=\"line\">\tReq    *http.Request</span><br><span class=\"line\">\t<span class=\"comment\">// request info</span></span><br><span class=\"line\">\tPath   <span class=\"keyword\">string</span></span><br><span class=\"line\">\tMethod <span class=\"keyword\">string</span></span><br><span class=\"line\">\tParams <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span></span><br><span class=\"line\">\t<span class=\"comment\">// response info</span></span><br><span class=\"line\">\tStatusCode <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">Param</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tvalue, _ := c.Params[key]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//router的改动</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *router)</span> <span class=\"title\">handle</span><span class=\"params\">(c *Context)</span></span> &#123;</span><br><span class=\"line\">\tn, params := r.getRoute(c.Method, c.Path)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tc.Params = params</span><br><span class=\"line\">\t\tkey := c.Method + <span class=\"string\">&quot;-&quot;</span> + n.pattern</span><br><span class=\"line\">\t\tr.handlers[key](c)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tc.String(http.StatusNotFound, <span class=\"string\">&quot;404 NOT FOUND: %s\\n&quot;</span>, c.Path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"分组控制\">分组控制</h2>\n<p>分组控制(Group Control)是 Web 框架应提供的基础功能之一。所谓分组，是指路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。但是真实的业务场景中，往往某一组路由需要相似的处理。例如：</p>\n<ul>\n<li>以/post开头的路由匿名可访问。</li>\n<li>以/admin开头的路由需要鉴权。</li>\n<li>以/api开头的路由是 RESTful 接口，可以对接第三方平台，需要三方平台鉴权。</li>\n</ul>\n<p>大部分情况下的路由分组，是以相同的前缀来区分的。因此，我们今天实现的分组控制也是以前缀来区分，并且支持分组的嵌套。例如/post是一个分组，/post/a和/post/b可以是该分组下的子分组。作用在/post分组上的中间件(middleware)，也都会作用在子分组，子分组还可以应用自己特有的中间件。</p>\n<p>一个 Group 对象需要具备哪些属性呢？首先是前缀(prefix)，比如/，或者/api；要支持分组嵌套，那么需要知道当前分组的父亲(parent)是谁；当然了，按照我们一开始的分析，中间件是应用在分组上的，那还需要存储应用在该分组上的中间件(middlewares)。还记得，我们之前调用函数(*Engine).addRoute()来映射所有的路由规则和 Handler 。如果Group对象需要直接映射路由规则的话，比如我们想在使用框架时，这么调用：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">r := gee.New()</span><br><span class=\"line\">v1 := r.Group(<span class=\"string\">&quot;/v1&quot;</span>)</span><br><span class=\"line\">v1.GET(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\tc.HTML(http.StatusOK, <span class=\"string\">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>那么Group对象，还需要有访问Router的能力，为了方便，我们可以在Group中，保存一个指针，指向Engine，整个框架的所有资源都是由Engine统一协调的，那么就可以通过Engine间接地访问各种接口了。</p>\n<p>所以，最后的 Group 的定义是这样的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> (</span><br><span class=\"line\">\tRouterGroup <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t\tprefix      <span class=\"keyword\">string</span></span><br><span class=\"line\">\t\tmiddlewares []HandlerFunc <span class=\"comment\">// support middleware</span></span><br><span class=\"line\">\t\tparent      *RouterGroup  <span class=\"comment\">// support nesting</span></span><br><span class=\"line\">\t\tengine      *Engine       <span class=\"comment\">// all groups share a Engine instance</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tEngine <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t\t*RouterGroup</span><br><span class=\"line\">\t\trouter *router</span><br><span class=\"line\">\t\tgroups []*RouterGroup <span class=\"comment\">// store all groups</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>我们还可以进一步地抽象，将Engine作为最顶层的分组，也就是说Engine拥有RouterGroup所有的能力。</p>\n<p>那我们就可以将和路由有关的函数，都交给RouterGroup实现了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// New is the constructor of gee.Engine</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span> *<span class=\"title\">Engine</span></span> &#123;</span><br><span class=\"line\">\tengine := &amp;Engine&#123;router: newRouter()&#125;</span><br><span class=\"line\">\tengine.RouterGroup = &amp;RouterGroup&#123;engine: engine&#125;</span><br><span class=\"line\">\tengine.groups = []*RouterGroup&#123;engine.RouterGroup&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> engine</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Group is defined to create a new RouterGroup</span></span><br><span class=\"line\"><span class=\"comment\">// remember all groups share the same Engine instance</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(group *RouterGroup)</span> <span class=\"title\">Group</span><span class=\"params\">(prefix <span class=\"keyword\">string</span>)</span> *<span class=\"title\">RouterGroup</span></span> &#123;</span><br><span class=\"line\">\tengine := group.engine</span><br><span class=\"line\">\tnewGroup := &amp;RouterGroup&#123;</span><br><span class=\"line\">\t\tprefix: group.prefix + prefix,</span><br><span class=\"line\">\t\tparent: group,</span><br><span class=\"line\">\t\tengine: engine,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tengine.groups = <span class=\"built_in\">append</span>(engine.groups, newGroup)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newGroup</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(group *RouterGroup)</span> <span class=\"title\">addRoute</span><span class=\"params\">(method <span class=\"keyword\">string</span>, comp <span class=\"keyword\">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tpattern := group.prefix + comp</span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">&quot;Route %4s - %s&quot;</span>, method, pattern)</span><br><span class=\"line\">\tgroup.engine.router.addRoute(method, pattern, handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GET defines the method to add GET request</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(group *RouterGroup)</span> <span class=\"title\">GET</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tgroup.addRoute(<span class=\"string\">&quot;GET&quot;</span>, pattern, handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST defines the method to add POST request</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(group *RouterGroup)</span> <span class=\"title\">POST</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tgroup.addRoute(<span class=\"string\">&quot;POST&quot;</span>, pattern, handler)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tr := gee.New()</span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/index&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tc.HTML(http.StatusOK, <span class=\"string\">&quot;&lt;h1&gt;Index Page&lt;/h1&gt;&quot;</span>)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tv1 := r.Group(<span class=\"string\">&quot;/v1&quot;</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv1.GET(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\t\tc.HTML(http.StatusOK, <span class=\"string\">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tv1.GET(<span class=\"string\">&quot;/hello&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// expect /hello?name=geektutu</span></span><br><span class=\"line\">\t\t\tc.String(http.StatusOK, <span class=\"string\">&quot;hello %s, you&#x27;re at %s\\n&quot;</span>, c.Query(<span class=\"string\">&quot;name&quot;</span>), c.Path)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tv2 := r.Group(<span class=\"string\">&quot;/v2&quot;</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv2.GET(<span class=\"string\">&quot;/hello/:name&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// expect /hello/geektutu</span></span><br><span class=\"line\">\t\t\tc.String(http.StatusOK, <span class=\"string\">&quot;hello %s, you&#x27;re at %s\\n&quot;</span>, c.Param(<span class=\"string\">&quot;name&quot;</span>), c.Path)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t\tv2.POST(<span class=\"string\">&quot;/login&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\t\tc.JSON(http.StatusOK, gee.H&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;username&quot;</span>: c.PostForm(<span class=\"string\">&quot;username&quot;</span>),</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;password&quot;</span>: c.PostForm(<span class=\"string\">&quot;password&quot;</span>),</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tr.Run(<span class=\"string\">&quot;:9999&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"中间件\">中间件</h2>\n<h3 id=\"中间件是什么\">中间件是什么</h3>\n<p>简单来说中间件就是非业务的技术类组件。因为框架不可能去理解所有的任务，不会实现所有功能，所以需要有一个插口让用户自己定义功能。需要考虑两个关键点：</p>\n<ul>\n<li>插入点在哪？使用框架的人并不关心底层逻辑的具体实现，如果插入点太底层，中间件逻辑就会非常复杂。如果插入点离用户太近，那和用户直接定义一组函数，每次在 Handler 中手工调用没有多大的优势了。</li>\n<li>中间件的输入是什么？中间件的输入，决定了扩展能力。暴露的参数太少，用户发挥空间有限。</li>\n</ul>\n<h3 id=\"中间件的设计\">中间件的设计</h3>\n<p>Gee 的中间件的定义与路由映射的 Handler 一致，处理的输入是Context对象。插入点是框架接收到请求初始化Context对象后，允许用户使用自己定义的中间件做一些额外的处理，例如记录日志等，以及对Context进行二次加工。另外通过调用(*Context).Next()函数，中间件可等待用户自己定义的 Handler处理结束后，再做一些额外的操作，例如计算本次处理所用时间等。即 Gee 的中间件支持用户在请求被处理的前后，做一些额外的操作。举个例子，我们希望最终能够支持如下定义的中间件，c.Next()表示等待执行其他的中间件或用户的Handler：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Logger</span><span class=\"params\">()</span> <span class=\"title\">HandlerFunc</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *Context)</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Start timer</span></span><br><span class=\"line\">\t\tt := time.Now()</span><br><span class=\"line\">\t\t<span class=\"comment\">// Process request</span></span><br><span class=\"line\">\t\tc.Next()</span><br><span class=\"line\">\t\t<span class=\"comment\">// Calculate resolution time</span></span><br><span class=\"line\">\t\tlog.Printf(<span class=\"string\">&quot;[%d] %s in %v&quot;</span>, c.StatusCode, c.Req.RequestURI, time.Since(t))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外要支持设置多个中间件，依次进行调用。</p>\n<p>我们之前的框架设计是这样的，当接收到请求后，匹配路由，该请求的所有信息都保存在Context中。中间件也不例外，接收到请求后，应查找所有应作用于该路由的中间件，保存在Context中，依次进行调用。为什么依次调用后，还需要在Context中保存呢？因为在设计中，中间件不仅作用在处理流程前，也可以作用在处理流程后，即在用户定义的 Handler 处理完毕后，还可以执行剩下的操作。</p>\n<p>为此，我们给Context添加了2个参数，定义了Next方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Context <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// origin objects</span></span><br><span class=\"line\">\tWriter http.ResponseWriter</span><br><span class=\"line\">\tReq    *http.Request</span><br><span class=\"line\">\t<span class=\"comment\">// request info</span></span><br><span class=\"line\">\tPath   <span class=\"keyword\">string</span></span><br><span class=\"line\">\tMethod <span class=\"keyword\">string</span></span><br><span class=\"line\">\tParams <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span></span><br><span class=\"line\">\t<span class=\"comment\">// response info</span></span><br><span class=\"line\">\tStatusCode <span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"comment\">// middleware</span></span><br><span class=\"line\">\thandlers []HandlerFunc</span><br><span class=\"line\">\tindex    <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newContext</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span> *<span class=\"title\">Context</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Context&#123;</span><br><span class=\"line\">\t\tPath:   req.URL.Path,</span><br><span class=\"line\">\t\tMethod: req.Method,</span><br><span class=\"line\">\t\tReq:    req,</span><br><span class=\"line\">\t\tWriter: w,</span><br><span class=\"line\">\t\tindex:  <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">Next</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tc.index++</span><br><span class=\"line\">\ts := <span class=\"built_in\">len</span>(c.handlers)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ; c.index &lt; s; c.index++ &#123;</span><br><span class=\"line\">\t\tc.handlers[c.index](c)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>index是记录当前执行到第几个中间件，当在中间件中调用Next方法时，控制权交给了下一个中间件，直到调用到最后一个中间件，然后再从后往前，调用每个中间件在Next方法之后定义的部分。</p>\n<h3 id=\"代码实现\">代码实现</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Use is defined to add middleware to the group</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(group *RouterGroup)</span> <span class=\"title\">Use</span><span class=\"params\">(middlewares ...HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tgroup.middlewares = <span class=\"built_in\">append</span>(group.middlewares, middlewares...)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> middlewares []HandlerFunc</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, group := <span class=\"keyword\">range</span> engine.groups &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> strings.HasPrefix(req.URL.Path, group.prefix) &#123;</span><br><span class=\"line\">\t\t\tmiddlewares = <span class=\"built_in\">append</span>(middlewares, group.middlewares...)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc := newContext(w, req)</span><br><span class=\"line\">\tc.handlers = middlewares</span><br><span class=\"line\">\tengine.router.handle(c)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ServeHTTP 函数也有变化，当我们接收到一个具体请求时，要判断该请求适用于哪些中间件，在这里我们简单通过 URL 的前缀来判断。得到中间件列表后，赋值给 c.handlers。</p>\n<p>handle 函数中，将从路由匹配得到的 Handler 添加到 c.handlers列表中，执行c.Next()。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *router)</span> <span class=\"title\">handle</span><span class=\"params\">(c *Context)</span></span> &#123;</span><br><span class=\"line\">\tn, params := r.getRoute(c.Method, c.Path)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tkey := c.Method + <span class=\"string\">&quot;-&quot;</span> + n.pattern</span><br><span class=\"line\">\t\tc.Params = params</span><br><span class=\"line\">\t\tc.handlers = <span class=\"built_in\">append</span>(c.handlers, r.handlers[key])</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tc.handlers = <span class=\"built_in\">append</span>(c.handlers, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *Context)</span></span> &#123;</span><br><span class=\"line\">\t\t\tc.String(http.StatusNotFound, <span class=\"string\">&quot;404 NOT FOUND: %s\\n&quot;</span>, c.Path)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc.Next()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"模板\">模板</h2>\n<h3 id=\"服务端渲染\">服务端渲染</h3>\n<p>现在越来越流行前后端分离的开发模式，即 Web 后端提供 RESTful 接口，返回结构化的数据(通常为 JSON 或者 XML)。前端使用 AJAX 技术请求到所需的数据，利用 JavaScript 进行渲染。Vue/React 等前端框架持续火热，这种开发模式前后端解耦，优势非常突出。后端童鞋专心解决资源利用，并发，数据库等问题，只需要考虑数据如何生成；前端童鞋专注于界面设计实现，只需要考虑拿到数据后如何渲染即可。使用 JSP 写过网站的童鞋，应该能感受到前后端耦合的痛苦。JSP 的表现力肯定是远不如 Vue/React 等专业做前端渲染的框架的。而且前后端分离在当前还有另外一个不可忽视的优势。因为后端只关注于数据，接口返回值是结构化的，与前端解耦。同一套后端服务能够同时支撑小程序、移动APP、PC端 Web 页面，以及对外提供的接口。随着前端工程化的不断地发展，Webpack，gulp 等工具层出不穷，前端技术越来越自成体系了。</p>\n<p>但前后分离的一大问题在于，页面是在客户端渲染的，比如浏览器，这对于爬虫并不友好。Google 爬虫已经能够爬取渲染后的网页，但是短期内爬取服务端直接渲染的 HTML 页面仍是主流。</p>\n<p>今天的内容便是介绍 Web 框架如何支持服务端渲染的场景。</p>\n<h3 id=\"静态文件\">静态文件</h3>\n<p>要做到服务端渲染，第一步便是要支持 JS、CSS 等静态文件。还记得我们之前设计动态路由的时候，支持通配符* 匹配多级子路径。比如路由规则/assets/*filepath，可以匹配/assets/开头的所有的地址。例如/assets/js/geektutu.js，匹配后，参数filepath就赋值为js/geektutu.js。</p>\n<p>那如果我么将所有的静态文件放在/usr/web目录下，那么filepath的值即是该目录下文件的相对地址。映射到真实的文件后，将文件返回，静态服务器就实现了。</p>\n<p>找到文件后，如何返回这一步，net/http库已经实现了。因此，gee 框架要做的，仅仅是解析请求的地址，映射到服务器上文件的真实地址，交给http.FileServer处理就好了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// createStaticHandler 创建静态的handler</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(group *RouterGroup)</span> <span class=\"title\">createStaticHandler</span><span class=\"params\">(relativePath <span class=\"keyword\">string</span>, fs http.FileSystem)</span> <span class=\"title\">HandlerFunc</span></span> &#123;</span><br><span class=\"line\">\tabsolutePath := path.Join(group.prefix, relativePath)</span><br><span class=\"line\">\tfileServer := http.StripPrefix(absolutePath, http.FileServer(fs))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx *Context)</span></span> &#123;</span><br><span class=\"line\">\t\tfile := ctx.Param(<span class=\"string\">&quot;filepath&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _, err := fs.Open(file); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tctx.Status(http.StatusNotFound)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfileServer.ServeHTTP(ctx.Writer, ctx.Req)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Static 提供静态文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(group *RouterGroup)</span> <span class=\"title\">Static</span><span class=\"params\">(relativePath <span class=\"keyword\">string</span>, root <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\thandler := group.createStaticHandler(relativePath, http.Dir(root))</span><br><span class=\"line\">\turlPattern := path.Join(relativePath, <span class=\"string\">&quot;/*filepath&quot;</span>)</span><br><span class=\"line\">\tgroup.GET(urlPattern, handler)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们给RouterGroup添加了2个方法，Static这个方法是暴露给用户的。用户可以将磁盘上的某个文件夹root映射到路由relativePath。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">r := gee.New()</span><br><span class=\"line\">r.Static(<span class=\"string\">&quot;/assets&quot;</span>, <span class=\"string\">&quot;/usr/geektutu/blog/static&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 或相对路径 r.Static(&quot;/assets&quot;, &quot;./static&quot;)</span></span><br><span class=\"line\">r.Run(<span class=\"string\">&quot;:9999&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>用户访问localhost:9999/assets/js/geektutu.js，最终返回/usr/geektutu/blog/static/js/geektutu.js。</p>\n<h3 id=\"HTML模板渲染\">HTML模板渲染</h3>\n<p>Go语言内置了text/template和html/template2个模板标准库，其中html/template为 HTML 提供了较为完整的支持。包括普通变量渲染、列表渲染、对象渲染等。gee 框架的模板渲染直接使用了html/template提供的能力。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">Engine <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*RouterGroup</span><br><span class=\"line\">\trouter        *router</span><br><span class=\"line\">\tgroups        []*RouterGroup     <span class=\"comment\">// store all groups</span></span><br><span class=\"line\">\thtmlTemplates *template.Template <span class=\"comment\">// for html render</span></span><br><span class=\"line\">\tfuncMap       template.FuncMap   <span class=\"comment\">// for html render</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">SetFuncMap</span><span class=\"params\">(funcMap template.FuncMap)</span></span> &#123;</span><br><span class=\"line\">\tengine.funcMap = funcMap</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">LoadHTMLGlob</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\tengine.htmlTemplates = template.Must(template.New(<span class=\"string\">&quot;&quot;</span>).Funcs(engine.funcMap).ParseGlob(pattern))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先为 Engine 示例添加了 *template.Template 和 template.FuncMap对象，前者将所有的模板加载进内存，后者是所有的自定义模板渲染函数。</p>\n<p>另外，给用户分别提供了设置自定义渲染函数funcMap和加载模板的方法。</p>\n<p>接下来，对原来的 (*Context).HTML()方法做了些小修改，使之支持根据模板文件名选择模板进行渲染。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Context <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">\t<span class=\"comment\">// engine pointer</span></span><br><span class=\"line\">\tengine *Engine</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">HTML</span><span class=\"params\">(code <span class=\"keyword\">int</span>, name <span class=\"keyword\">string</span>, data <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tc.SetHeader(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;text/html&quot;</span>)</span><br><span class=\"line\">\tc.Status(code)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := c.engine.htmlTemplates.ExecuteTemplate(c.Writer, name, data); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tc.Fail(<span class=\"number\">500</span>, err.Error())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在 Context 中添加了成员变量 engine *Engine，这样就能够通过 Context 访问 Engine 中的 HTML 模板。实例化 Context 时，还需要给 c.engine 赋值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\tc := newContext(w, req)</span><br><span class=\"line\">\tc.handlers = middlewares</span><br><span class=\"line\">\tc.engine = engine</span><br><span class=\"line\">\tengine.router.handle(c)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"错误恢复\">错误恢复</h2>\n<h3 id=\"panic\">panic</h3>\n<p>Go 语言中，比较常见的错误处理方法是返回 error，由调用者决定后续如何处理。但是如果是无法恢复的错误，可以手动触发 panic，当然如果在程序运行过程中出现了类似于数组越界的错误，panic 也会被触发。panic 会中止当前执行的程序，退出。</p>\n<p>下面是主动触发的例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;before panic&quot;</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;crash&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;after panic&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是数组越界触发的 panic</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tarr := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">\tfmt.Println(arr[<span class=\"number\">4</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"defer\">defer</h3>\n<p>panic 会导致程序被中止，但是在退出前，会先处理完当前协程上已经defer 的任务，执行完成后再退出。效果类似于 java 语言的 try…catch。</p>\n<p>可以 defer 多个任务，在同一个函数中 defer 多个任务，会逆序执行。即先执行最后 defer 的任务。</p>\n<p>在这里，defer 的任务执行完成之后，panic 还会继续被抛出，导致程序非正常结束。</p>\n<h3 id=\"recover\">recover</h3>\n<p>Go 语言还提供了 recover 函数，可以避免因为 panic 发生而导致整个程序终止，<strong>recover 函数只在 defer 中生效</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test_recover</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;defer func&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;recover success&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tarr := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">\tfmt.Println(arr[<span class=\"number\">4</span>])</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;after panic&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ttest_recover()</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;after recover&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ go run hello.go </span><br><span class=\"line\">defer func</span><br><span class=\"line\">recover success</span><br><span class=\"line\">after recover</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，recover 捕获了 panic，程序正常结束。test_recover() 中的 after panic 没有打印，这是正确的，当 panic 被触发时，控制权就被交给了 defer 。就像在 java 中，try代码块中发生了异常，控制权交给了 catch，接下来执行 catch 代码块中的代码。而在 main() 中打印了 after recover，说明程序已经恢复正常，继续往下执行直到结束。</p>\n<h3 id=\"Gee的错误处理机制\">Gee的错误处理机制</h3>\n<p>对一个 Web 框架而言，错误处理机制是非常必要的。可能是框架本身没有完备的测试，导致在某些情况下出现空指针异常等情况。也有可能用户不正确的参数，触发了某些异常，例如数组越界，空指针等。如果因为这些原因导致系统宕机，必然是不可接受的。</p>\n<p>我们在第六天实现的框架并没有加入异常处理机制，如果代码中存在会触发 panic 的 BUG，很容易宕掉。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tr := gee.New()</span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/panic&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tnames := []<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;geektutu&quot;</span>&#125;</span><br><span class=\"line\">\t\tc.String(http.StatusOK, names[<span class=\"number\">100</span>])</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tr.Run(<span class=\"string\">&quot;:9999&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，我们为 gee 注册了路由 /panic，而这个路由的处理函数内部存在数组越界 names[100]，如果访问 localhost:9999/panic，Web 服务就会宕掉。</p>\n<p>今天，我们将在 gee 中添加一个非常简单的错误处理机制，即在此类错误发生时，向用户返回 Internal Server Error，并且在日志中打印必要的错误信息，方便进行错误定位。</p>\n<p>我们之前实现了中间件机制，错误处理也可以作为一个中间件，增强 gee 框架的能力。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Recovery</span><span class=\"params\">()</span> <span class=\"title\">HandlerFunc</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *Context)</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tmessage := fmt.Sprintf(<span class=\"string\">&quot;%s&quot;</span>, err)</span><br><span class=\"line\">\t\t\t\tlog.Printf(<span class=\"string\">&quot;%s\\n\\n&quot;</span>, trace(message))</span><br><span class=\"line\">\t\t\t\tc.Fail(http.StatusInternalServerError, <span class=\"string\">&quot;Internal Server Error&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tc.Next()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Recovery 的实现非常简单，使用 defer 挂载上错误恢复的函数，在这个函数中调用 <em>recover()</em>，捕获 panic，并且将堆栈信息打印在日志中，向用户返回 Internal Server Error。</p>\n<p>你可能注意到，这里有一个 trace() 函数，这个函数是用来获取触发 panic 的堆栈信息，完整代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">trace</span><span class=\"params\">(message <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> pcs [<span class=\"number\">32</span>]<span class=\"keyword\">uintptr</span></span><br><span class=\"line\">\tn := runtime.Callers(<span class=\"number\">3</span>, pcs[:]) <span class=\"comment\">// skip first 3 caller</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> str strings.Builder</span><br><span class=\"line\">\tstr.WriteString(message + <span class=\"string\">&quot;\\nTraceback:&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, pc := <span class=\"keyword\">range</span> pcs[:n] &#123;</span><br><span class=\"line\">\t\tfn := runtime.FuncForPC(pc)</span><br><span class=\"line\">\t\tfile, line := fn.FileLine(pc)</span><br><span class=\"line\">\t\tstr.WriteString(fmt.Sprintf(<span class=\"string\">&quot;\\n\\t%s:%d&quot;</span>, file, line))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> str.String()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 trace() 中，调用了 runtime.Callers(3, pcs[:])，Callers 用来返回调用栈的程序计数器, 第 0 个 Caller 是 Callers 本身，第 1 个是上一层 trace，第 2 个是再上一层的 defer func。因此，为了日志简洁一点，我们跳过了前 3 个 Caller。</p>\n<p>接下来，通过 runtime.FuncForPC(pc) 获取对应的函数，在通过 fn.FileLine(pc) 获取到调用该函数的文件名和行号，打印在日志中。</p>\n<p>至此，gee 框架的错误处理机制就完成了。</p>\n","categories":["go"],"tags":["web框架"]},{"title":"github无法用命令行连接","url":"/2022/03/17/github%E6%97%A0%E6%B3%95%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9E%E6%8E%A5/","content":"<p>如果在使用git命令的时候出现<code>ssh: connect to host github.com port 22: Connection timed out</code>,可能是host文件配置错误，我们打开host文件（win10一般在C:\\Windows\\System32\\drivers\\etc）。在最下方添加github ip。</p>\n<ul>\n<li>查看github的ip地址，进入网址：<a href=\"https://github.com.ipaddress.com\">https://github.com.ipaddress.com</a></li>\n<li>确定域名ip，进入网址：<a href=\"https://fastly.net.ipaddress.com/github.global.ssl.fastly.net\">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net</a></li>\n<li>确定静态资源ip（应该是有4个），进入网址：<a href=\"https://github.com.ipaddress.com/assets-cdn.github.com\">https://github.com.ipaddress.com/assets-cdn.github.com</a></li>\n</ul>\n<p>得到上述ip后添加到记事本最后，格式如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">140.82.113.4 github.com</span><br><span class=\"line\">199.232.69.194 github.global.ssl.fastly.net</span><br><span class=\"line\">185.199.108.153 assets-cdn.github.com</span><br><span class=\"line\">185.199.109.153 assets-cdn.github.com</span><br><span class=\"line\">185.199.110.153 assets-cdn.github.com</span><br><span class=\"line\">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure>","categories":["github"],"tags":["error"]},{"title":"使用ssh传输文件/文件夹","url":"/2022/02/16/%E4%BD%BF%E7%94%A8ssh%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9/","content":"<h2 id=\"从服务器上下载文件\">从服务器上下载文件</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">scp &lt;用户名&gt;@&lt;ssh服务器地址&gt;:&lt;文件路径&gt; &lt;本地文件名&gt;</span><br></pre></td></tr></table></figure>\n<p>比如下载文件到桌面</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">scp root@127.0.0.1:~/test.txt ~/Desktop/test.txt</span><br></pre></td></tr></table></figure>\n<h2 id=\"上传文件到服务器\">上传文件到服务器</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">scp &lt;本地文件名&gt; &lt;用户名&gt;@&lt;ssh服务器地址&gt;:&lt;上传保存路径即文件名&gt;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意：只能将文件上传到用户目录下，如果需要上传到其他地方需要之后再自行移动文件</p>\n<h2 id=\"对于文件夹的操作\">对于文件夹的操作</h2>\n<p>只需要加个-r操作就可以了</p>\n","categories":["服务器"],"tags":["ssh"]},{"title":"http.Client连接行为控制","url":"/2022/02/21/http-Client%E8%BF%9E%E6%8E%A5%E8%A1%8C%E4%B8%BA%E6%8E%A7%E5%88%B6/","content":"<h2 id=\"1-http包默认客户端\">1.http包默认客户端</h2>\n<p>使用http包实现http客户端最简单的方法如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">esp, err := http.Get(<span class=\"string\">&quot;http://example.com/&quot;</span>)</span><br><span class=\"line\">...</span><br><span class=\"line\">resp, err := http.Post(<span class=\"string\">&quot;http://example.com/upload&quot;</span>, <span class=\"string\">&quot;image/jpeg&quot;</span>, &amp;buf)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p><strong>不要忘记在后面调用 <code>defer resp.Nody.Close()</code></strong></p>\n<p>但是在底层，完成http客户端操作的是http包内置的DefaultClient。客户端在默认情况下是不会等待应答回来的，所以如果服务器暂时没有给出回答的话，客户端就会尝试建立新的连接发送新的http请求，但是环境最大允许建立的连接数是有限的，所以当发送连接次数过多的时候会发生报错<code>socket: too many open files</code>。</p>\n<span id=\"more\"></span>\n<h2 id=\"2-定义一个只在小范围内生效的client实例\">2.定义一个只在小范围内生效的client实例</h2>\n<p>遇到上述情况我们就需要控制客户端避免在资源受到限制的时候仍然继续发送请求，这可以通过设置<code>http.DefaultClient</code>的属性来实现，但是这是一个包级变量，其作用域是整个程序，其他使用默认client的包也会受到影响，所以我们可以定义一个在小范围中应用的http客户端实例。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">client := &amp;http.Client&#123;&#125; <span class=\"comment\">// 自定义一个http客户端实例</span></span><br><span class=\"line\">resp, err := client.Get(<span class=\"string\">&quot;http://example.com/&quot;</span>)</span><br><span class=\"line\">...</span><br><span class=\"line\">resp, err := client.Post(<span class=\"string\">&quot;http://example.com/upload&quot;</span>, <span class=\"string\">&quot;image/jpeg&quot;</span>, &amp;buf)</span><br><span class=\"line\">..</span><br></pre></td></tr></table></figure>\n<p>上面这段代码和1中的代码时相同的。唯一不同的地方在于这段代码的应用范围仅限于上述的范围，不会对其他调用默认http包的程序产生任何影响。</p>\n<h2 id=\"3-自定义连接某host的最大限制\">3.自定义连接某host的最大限制</h2>\n<p>http包的client结构如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//$GOROOT/src/net/http/client.go</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Client <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Transport specifies the mechanism by which individual</span></span><br><span class=\"line\">        <span class=\"comment\">// HTTP requests are made.</span></span><br><span class=\"line\">        <span class=\"comment\">// If nil, DefaultTransport is used.</span></span><br><span class=\"line\">        Transport RoundTripper</span><br><span class=\"line\"></span><br><span class=\"line\">    CheckRedirect <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(req *Request, via []*Request)</span> <span class=\"title\">error</span></span></span><br><span class=\"line\">    Jar CookieJar</span><br><span class=\"line\">    Timeout time.Duration</span><br></pre></td></tr></table></figure>\n<p>其中一共4个字段，控制Client连接行为的Transport字段，如果为nil的话就是默认设置</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $GOROOT/src/net/http/transport.go</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class=\"line\">        Proxy: ProxyFromEnvironment,</span><br><span class=\"line\">        DialContext: (&amp;net.Dialer&#123;</span><br><span class=\"line\">                Timeout:   <span class=\"number\">30</span> * time.Second,</span><br><span class=\"line\">                KeepAlive: <span class=\"number\">30</span> * time.Second,</span><br><span class=\"line\">        &#125;).DialContext,</span><br><span class=\"line\">        ForceAttemptHTTP2:     <span class=\"literal\">true</span>,</span><br><span class=\"line\">        MaxIdleConns:          <span class=\"number\">100</span>,</span><br><span class=\"line\">        IdleConnTimeout:       <span class=\"number\">90</span> * time.Second,</span><br><span class=\"line\">        TLSHandshakeTimeout:   <span class=\"number\">10</span> * time.Second,</span><br><span class=\"line\">        ExpectContinueTimeout: <span class=\"number\">1</span> * time.Second,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是上述的配置中并没有控制连接某个host的最大数的设置，因为在Transport结构体中起这个作用的字段是<code>MaxConnsPerHost</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $GOROOT/src/net/http/transport.go</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Transport <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// MaxConnsPerHost optionally limits the total number of</span></span><br><span class=\"line\">        <span class=\"comment\">// connections per host, including connections in the dialing,</span></span><br><span class=\"line\">        <span class=\"comment\">// active, and idle states. On limit violation, dials will block.</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"comment\">// Zero means no limit.</span></span><br><span class=\"line\">        MaxConnsPerHost <span class=\"keyword\">int</span></span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>http.Transport维护了到每个server host的计数器connsPerHost的请求等待队列</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $GOROOT/src/net/http/transport.go</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Transport <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">        connsPerHostMu   sync.Mutex</span><br><span class=\"line\">        connsPerHost     <span class=\"keyword\">map</span>[connectMethodKey]<span class=\"keyword\">int</span></span><br><span class=\"line\">        connsPerHostWait <span class=\"keyword\">map</span>[connectMethodKey]wantConnQueue <span class=\"comment\">// waiting getConns</span></span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> connectMethodKey <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        proxy, scheme, addr <span class=\"keyword\">string</span></span><br><span class=\"line\">        onlyH1              <span class=\"keyword\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个结构体中的<code>connectMethodKey</code>使用一个四元组(proxy,scheme,addr,onlyH1)来唯一地标识一个host。</p>\n<p>但是对于一个Client来说，通常只有addr(ip+port)是不同的，也就是说实际上是按照addr区分host的。</p>\n<p><img src=\"https://i.imgur.com/Ts3HKpV.png\" alt=\"picture 1\"></p>\n<h2 id=\"4-设定idle池的大小\">4.设定idle池的大小</h2>\n<p>但是如果一直维持这些连接的话，会有点资源浪费。比如某些Client空闲的时候其实可以适当减少连接。这可以通过Transport中的MaxIdleConnsPerHost字段实现。</p>\n<p>具体就是忙时建立的多条连接在闲时会被kill到这个设定的个数。之后再与服务器交流的话，就只会用这些没有kill掉的连接。</p>\n<p><img src=\"https://i.imgur.com/wSLiAHr.png\" alt=\"picture 2\"></p>\n<p>此外，结构体中还有一个字段MaxIdleConns，它针对的是整个Client中的所有的idle池中的连接数总和。</p>\n<h2 id=\"5-清理idle池中的连接\">5.清理idle池中的连接</h2>\n<p>如果没有其他设定的话，上面保留下来的连接会一直存在，即便没有使用。这也是一种资源浪费。对于这个问题，Transport提供了IdleConnTimeout清理超时的连接。可以通过它设置超时清理的时间。</p>\n<h2 id=\"6-其他控制项\">6.其他控制项</h2>\n<p>如果觉得超时清理也会占用资源的话，可以利用Transport的DisableKeepAlive使得每个请求都要建立一个新的连接。但是这样的方法在忙的时候效果不如前者。</p>\n<p>另外，有些服务器可能暂时没法回应，这种时候要限制client等待应答的时间，超时的话要自动返回失败。</p>\n","categories":["go"],"tags":["net/http"]},{"title":"利用GPU进行训练的方法","url":"/2022/01/26/%E5%88%A9%E7%94%A8GPU%E8%BF%9B%E8%A1%8C%E8%AE%AD%E7%BB%83%E7%9A%84%E6%96%B9%E6%B3%95/","content":"<h2 id=\"方法一\">方法一</h2>\n<p>在模型、损失函数和数据后面添加<code>.cuda()</code></p>\n<h2 id=\"方法二\">方法二</h2>\n<p>对上述数据使用<code>.to(device)</code>，device需要提前设置好，利用<code>torch.device(&quot;cuda:i&quot;)</code>其中i是你想用那一块显卡</p>\n<p><code>device=torch.device('cuda' if torch.cuda.is_available() else 'cpu')</code></p>\n","categories":["DeepLearning"],"tags":["GPU"]},{"title":"使用golang+postgres+docker进行开发","url":"/2022/01/28/%E4%BD%BF%E7%94%A8golang+postgres+docker%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/","content":"<p><a href=\"https://dev.to/techschoolguru/design-db-schema-and-generate-sql-code-with-dbdiagram-io-4ko5\">课程官方文档地址</a></p>\n<h2 id=\"docker的下载\">docker的下载</h2>\n<p><a href=\"https://docs.docker.com/engine/install/ubuntu/\">ubuntu的docker下载地址</a></p>\n<p>照着上述地址的步骤进行下载安装docker</p>\n<p>为了不用每次都要sudo权限运行docker，进行以下步骤使我们当前用户具有启用docker权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo groupadd docker //创建docker组 通常来说安装万docker就已经自动创建好了</span><br><span class=\"line\">sudo usermod -aG docker $USER //将当前用户添加到组中</span><br><span class=\"line\">newgrp docker  //刷新一下对group的更改</span><br><span class=\"line\">docker run hello-world //测试不用sudo是否可以进行使用docker</span><br></pre></td></tr></table></figure>\n<p><code>image</code>和<code>container</code>的区别在于，container是image的一个实例，通过<code>docker run</code>来启动，我们可以根据一个镜像启动多个container。</p>\n<span id=\"more\"></span>\n<h3 id=\"docker端口的映射\">docker端口的映射</h3>\n<p>docker容器是在一个虚拟网络上运行的，因此我们不能简单地连接5432端口上的postgres服务器，我们需要让docker创建一个本地和容器网路的映射。</p>\n<p>可以在容器启动的时候指定<code>-p 主机端口：容器端口</code></p>\n<h3 id=\"postgres的下载安装\">postgres的下载安装</h3>\n<p>接着去下面的地址找到postgres的镜像文件进行下载安装，推荐使用官方镜像。或者直接使用<code>docker pull postgres</code>也是可以的。</p>\n<p><a href=\"https://hub.docker.com/_/postgres\">postgres镜像地址</a></p>\n<p>通过下列命令可以创建一个postgres镜像的实例，也就是数据库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run --name 实例名称 -p 5432:5432 -e POSTGRES_PASSWORD=密码 -d postgres:version //-p后面的是docker的端口与主机端口的映射</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入容器的命令行\">进入容器的命令行</h3>\n<p>使用<code>docker exec</code>命令可以让我们在容器中执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it 容器名 psql -U 用户名</span><br></pre></td></tr></table></figure>\n<p><code>it</code>是高速docker以交互式模式启动命令行，然后指定容器名。由于我们想要运行的是postgresql的命令，所以我们使用<code>psql</code>,最后指定用户名。</p>\n<h3 id=\"查看容器的日志\">查看容器的日志</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker logs 容器名（或者id）</span><br></pre></td></tr></table></figure>\n<h2 id=\"dbdiagram的使用\">dbdiagram的使用</h2>\n<p><a href=\"https://dbdiagram.io/\">dbdiagram网址</a></p>\n<p>进去后按照自己的需要设计数据库，并且可以导出为sql文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Table accounts as A &#123;</span><br><span class=\"line\">  id bigserial [pk]</span><br><span class=\"line\">  owner varchar</span><br><span class=\"line\">  balance bigint</span><br><span class=\"line\">  currency varchar</span><br><span class=\"line\">  created_at timestamptz [default: `now()`]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中<code>bigserial</code>类型可以自增，是八个字节的，余额使用的是<code>bigint</code>这历史为了方便，实际上应该是<code>decimal</code>类型的。时间戳的格式我们不用<code>timestamp</code>而是<code>timestamptz</code>是因为后者包含了时区信息，并且我们需要给他设置默认值为当时的时间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Table entries &#123;</span><br><span class=\"line\">  id bigserial [pk]</span><br><span class=\"line\">  account_id bigint [ref: &gt; A.id]</span><br><span class=\"line\">  amount bigint</span><br><span class=\"line\">  created_at timestamptz [default: `now()`]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>entry表记录了某个账户所有的出入帐，其中账户id必须是accounts表中有的，所以需要设置一个<code>ref</code>关系来与accounts表建立联系，属于外键。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Table transfers &#123;</span><br><span class=\"line\">  id bigserial [pk]</span><br><span class=\"line\">  from_account_id bigint [ref: &gt; A.id]</span><br><span class=\"line\">  to_account_id bigint [ref: &gt; A.id]</span><br><span class=\"line\">  amount bigint</span><br><span class=\"line\">  created_at timestamptz [default: `now()`]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外我们还可以对每个字段增加一些限制，由于其他的字段并没什么好限制的，所以都只需要加上<code>not null</code>限制，此外，对于entries表，出入账可以为正负，正表示入，负表示出，但是对于transfers表，出入关系在其他字段给出了，所以数额字段只能是正。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Table accounts as A &#123;</span><br><span class=\"line\">  id bigserial [pk]</span><br><span class=\"line\">  owner varchar [not null]</span><br><span class=\"line\">  balance bigint [not null]</span><br><span class=\"line\">  currency varchar [not null]</span><br><span class=\"line\">  created_at timestamptz [not null, default: `now()`]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Table entries &#123;</span><br><span class=\"line\">  id bigserial [pk]</span><br><span class=\"line\">  account_id bigint [ref: &gt; A.id, not null]</span><br><span class=\"line\">  amount bigint [not null, note: &#x27;can be negative or positive&#x27;]</span><br><span class=\"line\">  created_at timestamptz [not null, default: `now()`]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Table transfers &#123;</span><br><span class=\"line\">  id bigserial [pk]</span><br><span class=\"line\">  from_account_id bigint [ref: &gt; A.id, not null]</span><br><span class=\"line\">  to_account_id bigint [ref: &gt; A.id, not null]</span><br><span class=\"line\">  amount bigint [not null, note: &#x27;must be positive&#x27;]</span><br><span class=\"line\">  created_at timestamptz [not null, default: `now()`]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外我们还可以定义自己的枚举类型，比如说对于货币的种类我们只设置两种<code>USD</code>和<code>EUR</code>,那我们就可以设置字段的类型为自己的自定义类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">enum Currency &#123;</span><br><span class=\"line\">    USD</span><br><span class=\"line\">    EUR</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Table accounts as A &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  currency Currency [not null]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>transfers表记录了每一笔账户之间的转账，我们在这里只考虑本simple bank中的账户之间的转账行为。</p>\n<p>接下来我们可以给表添加索引，在accounts表中我们想要能够通过onwer的名字来查询账户，所以我们将owner增加到indexes列表中。</p>\n<p>在entries表中，我们可能会需要列出一个账户的所有出入账，所以我们需要将<code>account_id</code>添加到索引中</p>\n<p>在transfers表中我们可能需要搜索一个账户全部的出账，或者一个账户全部的入账，甚至两个账户之间的所有交易记录，所以我们要将这两个字段和<strong>两个字段的组合</strong>添加到索引中</p>\n<p>接下来我们就可以生成sql代码了，当然也可以生成其他各种形式的如pdf、图片或者是mysql的代码。</p>\n<h2 id=\"tableplus的使用（GUI）\">tableplus的使用（GUI）</h2>\n<p><a href=\"https://tableplus.com/\">tableplus官网</a></p>\n<p>去到tableplus官网按照官网教程下载安装，之后就可以用这个的可视化界面管理数据库</p>\n<h2 id=\"数据库的迁移\">数据库的迁移</h2>\n<p>首先需要下载安装migrate库<a href=\"https://github.com/golang-migrate/migrate\">migrate的github地址</a>。进入cmd/migrate目录下按照提示操作安装migrate</p>\n<p>在需要迁移的项目下创建db目录，进入目录后输入<code>migrate create -ext sql -dir db/migration -seq init_schema</code>，然后将初始化db的query语句复制粘贴到其中的up文件中，删除操作放入到down文件中。<strong>写删除操作的时候需要注意，要先删除依赖别的表的表，否则无法删除</strong></p>\n<p>接着创建一个Makefile脚本，其基本格式可以如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">postgres:</span></span><br><span class=\"line\">  docker run --name postgres14 -p 5432:5432 -e POSTGRES_USER=root -e POSTGRES_PASSWORD=123 -d postgres</span><br><span class=\"line\"><span class=\"section\">createdb:</span></span><br><span class=\"line\">  docker exec -it postgres14 createdb --username=root --owner=root simplebank</span><br><span class=\"line\"><span class=\"section\">dropdb:</span></span><br><span class=\"line\">  docker exec -it postgres14 dropdb simplebank</span><br><span class=\"line\"><span class=\"section\">migrateup:</span></span><br><span class=\"line\">  migrate -path db -database <span class=\"string\">&quot;postgresql://root:123@localhost:5432/simplebank?sslmode=disable&quot;</span> -verbose up</span><br><span class=\"line\"><span class=\"section\">migratedown:</span></span><br><span class=\"line\">  migrate -path db -database <span class=\"string\">&quot;postgresql://root:123@localhost:5432/simplebank?sslmode=disable&quot;</span> -verbose down</span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>:postgres createdb dropdb migrateup migratedown</span></span><br></pre></td></tr></table></figure>\n<p>是为了方便整个项目在别的地方使用。</p>\n<h2 id=\"使用golang对数据库进行增删改查\">使用golang对数据库进行增删改查</h2>\n<h3 id=\"方法-2\">方法</h3>\n<ul>\n<li>使用DATABASE/SQL库\n<ul>\n<li>优点：快且直接</li>\n<li>缺点：需要手动将sql字段映射到变量，容易出错</li>\n</ul>\n</li>\n<li>GORM库\n<ul>\n<li>优点：生产代码短</li>\n<li>缺点：流量很高时运行速度较慢</li>\n</ul>\n</li>\n<li>SQLX库\n<ul>\n<li>优点：相当快并且易于使用</li>\n<li>缺点：执行时才会出现错误</li>\n</ul>\n</li>\n<li>SQLC库：\n<ul>\n<li>优点：运行快，只需要编写query就可以让golang自动生成代码，错误可以被立即发现</li>\n<li>缺点：只支持postgres</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"sqlc\">sqlc</h3>\n<p>首先去sqlc的官方文档，并且根据自己的系统安装sqlc</p>\n<p>然后进入项目目录下运行<code>sqlc init</code>,会自动生成一个yaml文件，我们将这个文件进行填充修改如下，其中参数可以自己设定</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\"><span class=\"attr\">packages:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;db&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">&quot;./db/sqlc&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">queries:</span> <span class=\"string\">&quot;./db/query/&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">schema:</span> <span class=\"string\">&quot;./db/migration/&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">engine:</span> <span class=\"string\">&quot;postgresql&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">emit_json_tags:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">emit_prepared_queries:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">emit_interface:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">emit_exact_table_names:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">emit_empty_slices:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>然后在db目录下创建一个query目录，其中存放我们对于数据库中表的CRUD操作的语句，语句开头用<code>--name:函数名:返回条目数量</code>来控制我们稍后自动生成的golang代码的函数。其形式大概是这样的</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- name: CreateAccount :one</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> accounts (</span><br><span class=\"line\">    owner,</span><br><span class=\"line\">    balance,</span><br><span class=\"line\">    currency</span><br><span class=\"line\">) <span class=\"keyword\">VALUES</span> (</span><br><span class=\"line\">$<span class=\"number\">1</span>, $<span class=\"number\">2</span>,$<span class=\"number\">3</span></span><br><span class=\"line\">)</span><br><span class=\"line\">RETURNING <span class=\"operator\">*</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- name: GetAccount :one</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> accounts</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> $<span class=\"number\">1</span> LIMIT <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- name: ListAccount :many</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> accounts</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> id</span><br><span class=\"line\">LIMIT $<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">OFFSET</span> $<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- name: UpdateAccount :one</span></span><br><span class=\"line\">UPDATE accounts</span><br><span class=\"line\"><span class=\"keyword\">SET</span> balance <span class=\"operator\">=</span> $<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> $<span class=\"number\">1</span></span><br><span class=\"line\">RETURNING <span class=\"operator\">*</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- name: DeleteAuthor :exec</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> accounts <span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> $<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>同样在db目录下创建一个sqlc目录，存放由sqlc生成的.go文件，命令行使用<code>sql generate</code>语句就可以自动生成对应的go文件。</p>\n<p>对于这些生成的文件我们不要去对它作修改改动，因为下次生成时会覆盖掉，如果我们需要自定义功能，就自己写一个文件。</p>\n<h2 id=\"测试单元\">测试单元</h2>\n<p>对于生成的文件，我们需要测试其提供给我们的函数是否是正确有用的，首先需要在sqlc目录下创建一个main_test.go文件，其测试是否能连接到创建的数据库.其中的TestMain函数是所有测试单元的主入口。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> db</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\"><span class=\"string\">&quot;database/sql&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">_ <span class=\"string\">&quot;github.com/lib/pq&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">dbDriver = <span class=\"string\">&quot;postgres&quot;</span></span><br><span class=\"line\">dbSource = <span class=\"string\">&quot;postgresql://root:123@localhost:5432/simplebank?sslmode=disable&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> testQueries *Queries</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestMain</span><span class=\"params\">(m *testing.M)</span></span> &#123;</span><br><span class=\"line\">conn, err := sql.Open(dbDriver, dbSource)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">  log.Fatal(<span class=\"string\">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">testQueries = New(conn)</span><br><span class=\"line\">os.Exit(m.Run())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后可以在其他的各种不同的单元测试中进行各种不同函数的测试，需要检查测试结果的话，推荐使用github上的<code>testify</code>包中require子包，具体用法如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">require.NoError(t, err)<span class=\"comment\">//判断没有产生err</span></span><br><span class=\"line\">require.NotEmpty(t, account)</span><br><span class=\"line\"></span><br><span class=\"line\">require.Equal(t, arg.Owner, account.Owner)<span class=\"comment\">//判断写入数据库的和返回的是同一份数据</span></span><br><span class=\"line\">require.Equal(t, arg.Balance, account.Balance)</span><br><span class=\"line\">require.Equal(t, arg.Currency, account.Currency)</span><br><span class=\"line\"></span><br><span class=\"line\">require.NotZero(t, account.ID)<span class=\"comment\">//判断返回的不是零值</span></span><br><span class=\"line\">require.NotZero(t, account.CreatedAt)</span><br></pre></td></tr></table></figure>\n<p>为了更好地测试db，我们可以在工程目录下创建util目录，其中存放我们需要的一些工具函数。比如数据库表中的每个条目我们可以通过随机生成并放入，这时就需要随机生成数据的函数，可以放在这个目录下面。</p>\n<h2 id=\"数据库事务\">数据库事务</h2>\n<p>之前写到的都是对数据库的增删改查操作，但是在实际操作中，一个事务往往需要结合多个数据库的CRUD操作</p>\n<p>假设我们要开始一个从account1转10元到account2上，那么这个事务包含5个CRUD操作：</p>\n<ol>\n<li>创建一个transfer=10的记录</li>\n<li>创建一个金额等于-10的记录，account1-10</li>\n<li>创建另一条entry记录account2，金额为10</li>\n<li>通过减去它来更新account1的banlance</li>\n<li>增加它来更新account2的balance</li>\n</ol>\n<h3 id=\"用go实现DB事务\">用go实现DB事务</h3>\n<h4 id=\"使用组合来扩展Queries的功能\">使用组合来扩展Queries的功能</h4>\n<p>首先在<code>db/sqlc</code>下创建一个<code>store.go</code>文件，我们在其中定义一个新的<code>Store</code>结构体，该结构体会绑定其需要的函数来独立运行数据库查询语句。</p>\n<p>之前已经由sqlc生成过对应的Quriers结构体了，但是一个query只能在一个表上执行一个特定的操作，所以Queries结构体并不支持事务。因此我们需要把它迁入到Store结构体中来扩展它的功能。将Queries迁入到Store后，Queries的函数将会对Store可用。</p>\n<p>此外，还需要在Store结构体中加入sql.DB对象，因为它需要创建一个数据库事务</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Store <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    *Queries</span><br><span class=\"line\">    db *sql.DB</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建一个新的Store对象\">创建一个新的Store对象</h4>\n<p>NewStore函数以一个<code>sql.DB</code>作为输入并且返回一个Store对象。Store.db就等于我们的输入，New()函数由sqlc生成，创建并返回一个Queries对象</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewStore</span><span class=\"params\">(db *sql.DB)</span> *<span class=\"title\">Store</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Store&#123;</span><br><span class=\"line\">        db:      db,</span><br><span class=\"line\">        Queries: New(db),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"执行一个通用数据库事务\">执行一个通用数据库事务</h4>\n<p>思路很简单：该函数以上下文环境和回调函数作为输入，之后以一个新的数据库事务作为开始，通过该事务创建一个新的Queries对象，通过这个新的Queries调用回调函数，最终根据函数返回的error来确定提交还是回滚事务。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">execTx</span><span class=\"params\">(ctx context.Context, fn <span class=\"keyword\">func</span>(*Queries)</span> <span class=\"title\">error</span>) <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，调用<code>store.db.BeginTx()</code>来开启一个新的事务，将环境和一个可选的参数<code>sql.TxOptions</code>传入,该参数允许我们对该事务设置一个通用的隔离等级。如果我们设为nil则会用数据库默认的隔离等级，在postgres中就是读提交。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">tx, err := store.db.BeginTx(ctx, &amp;sql.TxOptions&#123;&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>BeginTx</code>函数会返回一个事务对象或一个错误，如果存在错误则直接返回，否则的话通过新构建的事务tx调用<code>New()</code>得到一个新的返回的Queries对象。这里的<code>New()</code>函数和上面的<code>NewStore()</code>中的是一样的。唯一的差别在于，我们传入一个<code>sql.Tx</code>而非<code>sql.DB</code>。因为<code>New()</code>函数接受的是一个DBTX接口。</p>\n<p>现在有了能够在事务内部运行的queries，我们可以调用传入的函数并且获取返回的错误。如果存在错误的话，就调用<code>tx.Rollback()</code>回滚。同时会返回一个rollback错误。如果存在rollback错误，我们就需要报告两个错误。因此我们应该把他们合二为一，在返回之前使用<code>fmt.Errorf()</code>即可。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">execTx</span><span class=\"params\">(ctx context.Context, fn <span class=\"keyword\">func</span>(*Queries)</span> <span class=\"title\">error</span>) <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    tx, err := store.db.BeginTx(ctx, &amp;sql.TxOptions)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    q := New(tx)</span><br><span class=\"line\">    err = fn(q)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> rbErr := tx.Rollback(); rbErr != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;tx err: %v, rb err: %v&quot;</span>, err, rbErr)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tx.Commit()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果回滚成功的话我们只需要返回最初的事务错误。如果所有的操作都是成功的，我们只需要提交事务<code>tx.Commit()</code>就可以了，并且返回它的错误。</p>\n<p>到此我们就已经完成<code>execTx()</code>函数了。需要注意的是这个函数是不导出的，我们不希望在包外部可以直接调用它，作为代替，我们对每个具体的事务提供一个导出的函数。</p>\n<h3 id=\"实现转账事务\">实现转账事务</h3>\n<p>先回忆一下，这个事务需要创造一个新的转账记录，两条新的entry信息并且更新两个账户的余额。函数的输入应当是一个上下文变量和一个对应的<code>TransferTxParam</code>类型的参数。该函数需要返回一个<code>TransferTxResult</code>对象或者一个错误。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">func (store *Store) TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>TransferTxParams</code>结构体包含所有必要的在账户间转账的参数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TransferTxParams <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    FromAccountID <span class=\"keyword\">int64</span> <span class=\"string\">`json:&quot;from_account_id&quot;`</span></span><br><span class=\"line\">    ToAccountID   <span class=\"keyword\">int64</span> <span class=\"string\">`json:&quot;to_account_id&quot;`</span></span><br><span class=\"line\">    Amount        <span class=\"keyword\">int64</span> <span class=\"string\">`json:&quot;amount&quot;`</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>TransferTxResult</code>包含转账事务的结果</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TransferTxResult <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Transfer    Transfer <span class=\"string\">`json:&quot;transfer&quot;`</span></span><br><span class=\"line\">    FromAccount Account  <span class=\"string\">`json:&quot;from_account&quot;`</span></span><br><span class=\"line\">    ToAccount   Account  <span class=\"string\">`json:&quot;to_account&quot;`</span></span><br><span class=\"line\">    FromEntry   Entry    <span class=\"string\">`json:&quot;from_entry&quot;`</span></span><br><span class=\"line\">    ToEntry     Entry    <span class=\"string\">`json:&quot;to_entry&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在开始实现转账事务。首先创建一个空的结果，然后调用<code>store.execTX()</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">TransferTx</span><span class=\"params\">(ctx context.Context, arg TransferTxParams)</span> <span class=\"params\">(TransferTxResult, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result TransferTxResult</span><br><span class=\"line\"></span><br><span class=\"line\">    err := store.execTx(ctx, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(q *Queries)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般来说，我们可以使用Queries对象q调用任何单独的CRUD操作。要记住这个q是在一个单独的数据库事务中创建的，所以它提供的所有方法都只在这个事务中运行。</p>\n<p>接下来通过调用<code>q.CreateTransfer()</code>来创造我们的result中需要的transfer记录，该函数需要传入上下文变量和对应的<code>CreateTransferParams</code>变量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">TransferTx</span><span class=\"params\">(ctx context.Context, arg TransferTxParams)</span> <span class=\"params\">(TransferTxResult, error)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    err := store.execTx(ctx, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(q *Queries)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> err error</span><br><span class=\"line\"></span><br><span class=\"line\">        result.Transfer, err = q.CreateTransfer(ctx, CreateTransferParams&#123;</span><br><span class=\"line\">            FromAccountID: arg.FromAccountID,</span><br><span class=\"line\">            ToAccountID:   arg.ToAccountID,</span><br><span class=\"line\">            Amount:        arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们在回调函数中就能够接触到result和前面传入的arg变量，这使得回调函数形成一个闭包。go语言中由于缺乏泛型的概念，所以通常是使用这个方法来从回调函数中获取返回。</p>\n<p>接着对result中剩下4个条目的方法的操作是一样的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">TransferTx</span><span class=\"params\">(ctx context.Context, arg TransferTxParams)</span> <span class=\"params\">(TransferTxResult, error)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    err := store.execTx(ctx, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(q *Queries)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> err error</span><br><span class=\"line\"></span><br><span class=\"line\">        result.Transfer, err = q.CreateTransfer(ctx, CreateTransferParams&#123;</span><br><span class=\"line\">            FromAccountID: arg.FromAccountID,</span><br><span class=\"line\">            ToAccountID:   arg.ToAccountID,</span><br><span class=\"line\">            Amount:        arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result.FromEntry, err = q.CreateEntry(ctx, CreateEntryParams&#123;</span><br><span class=\"line\">            AccountID: arg.FromAccountID,</span><br><span class=\"line\">            Amount:    -arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result.ToEntry, err = q.CreateEntry(ctx, CreateEntryParams&#123;</span><br><span class=\"line\">            AccountID: arg.ToAccountID,</span><br><span class=\"line\">            Amount:    arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们现在完成了3个条目，剩下来的两个修改两个账户余额的操作比较复杂，涉及到死锁的问题，这一问题会在后面进行补充。</p>\n<h3 id=\"测试转账事务\">测试转账事务</h3>\n<p>首先创建一个store_test.go文件和store.go处在同一个目录下，然后对<code>TransferTx()</code>定义一个单元测试。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是我们需要先有一个Store对象，而<code>NewStore()</code>又需要有一个<code>sql.DB</code>对象，之前其实已经在<code>main_test.go</code>中创建了一个<code>sql.DB</code>对象，所以为了能够复用我们声明两个全局变量<code>testDB</code>和<code>testQueries</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> testQueries *Queries</span><br><span class=\"line\"><span class=\"keyword\">var</span> testDB *sql.DB</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestMain</span><span class=\"params\">(m *testing.M)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> err error</span><br><span class=\"line\">    testDB, err = sql.Open(dbDriver, dbSource)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    testQueries = New(testDB)</span><br><span class=\"line\"></span><br><span class=\"line\">    os.Exit(m.Run())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们就可以回到我们的单元测试中，并且通过将这个全局变量传给<code>NewStore()</code>来创建一个新的store。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    store := NewStore(testDB)</span><br><span class=\"line\"></span><br><span class=\"line\">    account1 := createRandomAccount(t)</span><br><span class=\"line\">    account2 := createRandomAccount(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着创建两个随机账户，会在这两个账户之间进行转账。为了保证该事务能够很好的运行，我们测试时需要并行多个进程。我们可以并行5个进程来将账户1的钱转10元到账户2，可以用一个for循环来实现。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    store := NewStore(testDB)</span><br><span class=\"line\"></span><br><span class=\"line\">    account1 := createRandomAccount(t)</span><br><span class=\"line\">    account2 := createRandomAccount(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    n := <span class=\"number\">5</span></span><br><span class=\"line\">    amount := <span class=\"keyword\">int64</span>(<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// run n concurrent transfer transaction</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            result, err := store.TransferTx(context.Background(), TransferTxParams&#123;</span><br><span class=\"line\">                FromAccountID: account1.ID,</span><br><span class=\"line\">                ToAccountID:   account2.ID,</span><br><span class=\"line\">                Amount:        amount,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在循环中我们不能立即使用<code>require</code>包来检查，因为这个函数运行在一个和我们的测试函数正在运行的进程所不相同的进程上，因此不能保证在某个条件不满足的情况下它会停止整个测试。</p>\n<p>正确的做法是将result和err送到测试单元所在的主进程上。为了做到这一点，我们使用channel，在此处我们需要两个channel来分别传输result和err。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// run n concurrent transfer transaction</span></span><br><span class=\"line\">    errs := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> error)</span><br><span class=\"line\">    results := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> TransferTxResult)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            result, err := store.TransferTx(context.Background(), TransferTxParams&#123;</span><br><span class=\"line\">                FromAccountID: account1.ID,</span><br><span class=\"line\">                ToAccountID:   account2.ID,</span><br><span class=\"line\">                Amount:        amount,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">            errs &lt;- err</span><br><span class=\"line\">            results &lt;- result</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样用一个for循环来获取channel中的值，并且对他们做检测</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// run n concurrent transfer transaction</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check results</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        err := &lt;-errs</span><br><span class=\"line\">        require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">        result := &lt;-results</span><br><span class=\"line\">        require.NotEmpty(t, result)</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于result中包含了太多的参数，所以我们一个一个来验证他们</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check results</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        err := &lt;-errs</span><br><span class=\"line\">        require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">        result := &lt;-results</span><br><span class=\"line\">        require.NotEmpty(t, result)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// check transfer</span></span><br><span class=\"line\">        transfer := result.Transfer</span><br><span class=\"line\">        require.NotEmpty(t, transfer)</span><br><span class=\"line\">        require.Equal(t, account1.ID, transfer.FromAccountID)</span><br><span class=\"line\">        require.Equal(t, account2.ID, transfer.ToAccountID)</span><br><span class=\"line\">        require.Equal(t, amount, transfer.Amount)</span><br><span class=\"line\">        require.NotZero(t, transfer.ID)</span><br><span class=\"line\">        require.NotZero(t, transfer.CreatedAt)</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着为了确保transfer记录真的在数据库中创建了，我们应该调用<code>store.GetTransfer()</code>来找到一个相同ID的记录。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check results</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        <span class=\"comment\">// check transfer</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        _, err = store.GetTransfer(context.Background(), transfer.ID)</span><br><span class=\"line\">        require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>接着对于两个entry的检测也是同样的步骤，这里就不多赘述。</p>\n<h2 id=\"事务锁以及如何解决死锁\">事务锁以及如何解决死锁</h2>\n<h3 id=\"测试驱动的开发\">测试驱动的开发</h3>\n<p>前面已经测试了三个部分了，剩下的余额部分还没有进行测试和开发，我们先写好测试程序，通过测试报错，不断完善开发程序直到测试程序能够通过。</p>\n<p>首先判断两个账户不为空以及result中两个账户的ID和对应的账户ID是相同的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check results</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// check accounts</span></span><br><span class=\"line\">        fromAccount := result.FromAccount</span><br><span class=\"line\">        require.NotEmpty(t, fromAccount)</span><br><span class=\"line\">        require.Equal(t, account1.ID, fromAccount.ID)</span><br><span class=\"line\"></span><br><span class=\"line\">        toAccount := result.ToAccount</span><br><span class=\"line\">        require.NotEmpty(t, toAccount)</span><br><span class=\"line\">        require.Equal(t, account2.ID, toAccount.ID)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> check accounts&#x27; balance</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们需要检查账户余额，将账户进行转账事务前的余额和进行事务后的余额做差，两个账户得到的差值应该是相同的，并且差值应该能够整除每一次的转账金额，因为转账次数为5次。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check results</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// check accounts&#x27; balance</span></span><br><span class=\"line\">        diff1 := account1.Balance - fromAccount.Balance</span><br><span class=\"line\">        diff2 := toAccount.Balance - account2.Balance</span><br><span class=\"line\">        require.Equal(t, diff1, diff2)</span><br><span class=\"line\">        require.True(t, diff1 &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        require.True(t, diff1%amount == <span class=\"number\">0</span>) <span class=\"comment\">// 1 * amount, 2 * amount, 3 * amount, ..., n * amount</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此，若我们计算出差值除以转账金额，就能够得到转账次数k，而且这个次数对于每次交易是唯一的，第一次就是1，第二次就是2。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check results</span></span><br><span class=\"line\">    existed := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">bool</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// check accounts&#x27; balance</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        k := <span class=\"keyword\">int</span>(diff1 / amount)</span><br><span class=\"line\">        require.True(t, k &gt;= <span class=\"number\">1</span> &amp;&amp; k &lt;= n)</span><br><span class=\"line\"></span><br><span class=\"line\">        require.NotContains(t, existed, k)</span><br><span class=\"line\">        existed[k] = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后我们还需要确定所有转账完成后是否真的对数据库中的数据进行了改动，我们用<code>store.GetAccount()</code>从数据库中获取对应的账户，并且将它的余额与应当变成的余额做相等比较，此处应该是相等的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check results</span></span><br><span class=\"line\">    existed := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">bool</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check the final updated balance</span></span><br><span class=\"line\">    updatedAccount1, err := store.GetAccount(context.Background(), account1.ID)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    updatedAccount2, err := store.GetAccount(context.Background(), account2.ID)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    require.Equal(t, account1.Balance-<span class=\"keyword\">int64</span>(n)*amount, updatedAccount1.Balance)</span><br><span class=\"line\">    require.Equal(t, account2.Balance+<span class=\"keyword\">int64</span>(n)*amount, updatedAccount2.Balance)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着就可以运行这个测试，当然测试失败了，因为我们的转账事务中的修改两方余额的部分还没有写呢！</p>\n<h3 id=\"更新账户余额\">更新账户余额</h3>\n<p>通常我们一个直觉的想法就是通过<code>q.GetAccount()</code>获取账户然后通过<code>q.updateAccount()</code>来更新账户的余额，但是这样的做法是错误的，它没有考虑到锁的问题。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- name: GetAccount :one</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> accounts</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> $<span class=\"number\">1</span> LIMIT <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>从getAccount的数据库定义中我们可以发现它仅仅使用了一个SELECT语句，并没由阻止其他的事务来读取相同的账户记录，因此两个并行的记录可能会得到账户1的相同的值，并对这个值进行修改后提交。</p>\n<p>这种情况可以在语句后面加上<code>FOR UPDATE</code>来创造一个锁，这样只有在前一个占用该数据的事务commit之后，后一个事务才能获取该条数据并且进行修改。</p>\n<p>因此，我们可以在<code>account.sql</code>文件中增加一组操作：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- name: GetAccountForUpdate :one</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> accounts</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> $<span class=\"number\">1</span> LIMIT <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>\n<p>然后通过<code>make sqlc</code>来生成<code>account.sql.go</code>文件，这样我们需要的带锁的<code>GetAccountForUpdate()</code>函数就生成了。接着我们在事务中使用这个函数代替原本的<code>GetAccount()</code>函数，然而这一次又报错了，这次报的错是<strong>检查到死锁</strong>。</p>\n<p>为了能够debug出错误出在那里，我们为每个事务都加上一个名字，使用<code>fmt.Sprintf()</code>来创造不同的事务名称</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// run n concurrent transfer transaction</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        txName := fmt.Sprintf(<span class=\"string\">&quot;tx %d&quot;</span>, i+<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            ctx := context.WithValue(context.Background(), txKey, txName)</span><br><span class=\"line\"></span><br><span class=\"line\">            result, err := store.TransferTx(ctx, TransferTxParams&#123;</span><br><span class=\"line\">                FromAccountID: account1.ID,</span><br><span class=\"line\">                ToAccountID:   account2.ID,</span><br><span class=\"line\">                Amount:        amount,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">            errs &lt;- err</span><br><span class=\"line\">            results &lt;- result</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check results</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了能够将事务额的名称加到环境中，我们调用<code>context.WithValue()</code>传入一个background上下文和一对键值对，其中值就是对应的事务名称。文档中有说明上下文环境的key不应当是string类型或者任何其他内置的类型，这是为了避免键冲突。通常来说我们应当定义一个struct类型的变量来作为key。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> txKey = <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">TransferTx</span><span class=\"params\">(ctx context.Context, arg TransferTxParams)</span> <span class=\"params\">(TransferTxResult, error)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着在<code>TransferTx()</code>中,上下文环境会拥有事务名称，我们可以通过调用<code>ctx.Value()</code>来获取<code>txKey</code>的值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">TransferTx</span><span class=\"params\">(ctx context.Context, arg TransferTxParams)</span> <span class=\"params\">(TransferTxResult, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result TransferTxResult</span><br><span class=\"line\"></span><br><span class=\"line\">    err := store.execTx(ctx, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(q *Queries)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> err error</span><br><span class=\"line\"></span><br><span class=\"line\">        txName := ctx.Value(txKey)</span><br><span class=\"line\"></span><br><span class=\"line\">        fmt.Println(txName, <span class=\"string\">&quot;create transfer&quot;</span>)</span><br><span class=\"line\">        result.Transfer, err = q.CreateTransfer(ctx, CreateTransferParams&#123;</span><br><span class=\"line\">            FromAccountID: arg.FromAccountID,</span><br><span class=\"line\">            ToAccountID:   arg.ToAccountID,</span><br><span class=\"line\">            Amount:        arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        fmt.Println(txName, <span class=\"string\">&quot;create entry 1&quot;</span>)</span><br><span class=\"line\">        result.FromEntry, err = q.CreateEntry(ctx, CreateEntryParams&#123;</span><br><span class=\"line\">            AccountID: arg.FromAccountID,</span><br><span class=\"line\">            Amount:    -arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        fmt.Println(txName, <span class=\"string\">&quot;create entry 2&quot;</span>)</span><br><span class=\"line\">        result.ToEntry, err = q.CreateEntry(ctx, CreateEntryParams&#123;</span><br><span class=\"line\">            AccountID: arg.ToAccountID,</span><br><span class=\"line\">            Amount:    arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// move money out of account1</span></span><br><span class=\"line\">        fmt.Println(txName, <span class=\"string\">&quot;get account 1&quot;</span>)</span><br><span class=\"line\">        account1, err := q.GetAccountForUpdate(ctx, arg.FromAccountID)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        fmt.Println(txName, <span class=\"string\">&quot;update account 1&quot;</span>)</span><br><span class=\"line\">        result.FromAccount, err = q.UpdateAccount(ctx, UpdateAccountParams&#123;</span><br><span class=\"line\">            ID:      arg.FromAccountID,</span><br><span class=\"line\">            Balance: account1.Balance - arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// move money into account2</span></span><br><span class=\"line\">        fmt.Println(txName, <span class=\"string\">&quot;get account 2&quot;</span>)</span><br><span class=\"line\">        account2, err := q.GetAccountForUpdate(ctx, arg.ToAccountID)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        fmt.Println(txName, <span class=\"string\">&quot;update account 2&quot;</span>)</span><br><span class=\"line\">        result.ToAccount, err = q.UpdateAccount(ctx, UpdateAccountParams&#123;</span><br><span class=\"line\">            ID:      arg.ToAccountID,</span><br><span class=\"line\">            Balance: account2.Balance + arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们已经把输出log功能添加到程序中了，接下来我们只并行运行两个进程来进行debug。最终遭到出现死锁的原因是更新操作需要对账户进行上锁，而Select操作的表中有来自账户表中的外键，这时事务2等待事务1，事务1等待事务2，形成了死锁。</p>\n<p>此时我们已经知道，出现死锁的原因在于数据库担心事务1会对<code>accountID</code>进行更新从而影响到<code>transfer</code>表的外键约束，但是实际上我们并不会改动id，因此在数据库文件中我们要描述的更加具体:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- name: GetAccountForUpdate :one</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> accounts</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> $<span class=\"number\">1</span> LIMIT <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">FOR</span> <span class=\"keyword\">NO</span> KEY UPDATE;</span><br></pre></td></tr></table></figure>\n<p>接着<code>make sqlc</code>生成文件，并且运行测试发现能够通过了！</p>\n<p>但是我们还有更好的方法来完成转账事务，之前我们是使用两条qeuries语句来完成对账户的更新，而我们现在可以只用一条query语句来实现这个功能，我们直接在账户的余额上进行增加或者减少。因此我们需要添加一条新sql语句到<code>account.sql</code>中</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- name: AddAccountBalance :one</span></span><br><span class=\"line\">UPDATE accounts</span><br><span class=\"line\"><span class=\"keyword\">SET</span> balance <span class=\"operator\">=</span> balance <span class=\"operator\">+</span> $<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> $<span class=\"number\">2</span></span><br><span class=\"line\">RETURNING <span class=\"operator\">*</span>;</span><br></pre></td></tr></table></figure>\n<p>但是这样生成的参数中增加的金额的参数名为balance而按照我们的思维，应当是amount，所以我们对该sql语句进行修改</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- name: AddAccountBalance :one</span></span><br><span class=\"line\">UPDATE accounts</span><br><span class=\"line\"><span class=\"keyword\">SET</span> balance <span class=\"operator\">=</span> balance <span class=\"operator\">+</span> sqlc.arg(amount)</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> sqlc.arg(id)</span><br><span class=\"line\">RETURNING <span class=\"operator\">*</span>;</span><br></pre></td></tr></table></figure>\n<p>这样自动生成的语句中就能够自动将参数名改称amount了。然后回到<code>TransferTx()</code>中将<code>GetAccountForUpdate()</code>去掉，并且将<code>UpdateAccount()</code>替换为<code>AddAccountBalance()</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">TransferTx</span><span class=\"params\">(ctx context.Context, arg TransferTxParams)</span> <span class=\"params\">(TransferTxResult, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result TransferTxResult</span><br><span class=\"line\"></span><br><span class=\"line\">    err := store.execTx(ctx, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(q *Queries)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// move money out of account1</span></span><br><span class=\"line\">        result.FromAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class=\"line\">            ID:     arg.FromAccountID,</span><br><span class=\"line\">            Amount: -arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// move money into account2</span></span><br><span class=\"line\">        result.ToAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class=\"line\">            ID:     arg.ToAccountID,</span><br><span class=\"line\">            Amount: arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何避免死锁\">如何避免死锁</h2>\n<p>前面我们已经解决了死锁的问题，但是如果我们呢仔细看的话我们能发现它仍然存在潜在的死锁问题。在事务中我们更新两个账户的余额，这两个操作都需要排他锁，因此如果存在两个事务同时对这两个账户进行操作就会存在一个潜在的死锁可能性。</p>\n<p>虽然我们已经确定了并行5个从账户1向账户2转账的并行事务是不会再产生死锁了，但是如果再并行5个从账户2向账户1转账的事务呢。结果我们会发现仍然会发生死锁的现象。</p>\n<p>原因是事务1可能完成了对1账户的更改，在申请对账户2的更改，而事务2完成了对账户2的更改，在申请对账户1的更改，但是两个事务都没有完成没法commit，所以就死锁了。</p>\n<p>我们可以做一个测试程序专门测试死锁</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTxDeadlock</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    store := NewStore(testDB)</span><br><span class=\"line\"></span><br><span class=\"line\">    account1 := createRandomAccount(t)</span><br><span class=\"line\">    account2 := createRandomAccount(t)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;&gt;&gt; before:&quot;</span>, account1.Balance, account2.Balance)</span><br><span class=\"line\"></span><br><span class=\"line\">    n := <span class=\"number\">10</span></span><br><span class=\"line\">    amount := <span class=\"keyword\">int64</span>(<span class=\"number\">10</span>)</span><br><span class=\"line\">    errs := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> error)</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再根据当前的循环次数的不同对<code>fromAccount</code>和<code>toAccount</code>进行不同的赋值</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTxDeadlock</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        fromAccountID := account1.ID</span><br><span class=\"line\">        toAccountID := account2.ID</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i%<span class=\"number\">2</span> == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            fromAccountID = account2.ID</span><br><span class=\"line\">            toAccountID = account1.ID</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            _, err := store.TransferTx(context.Background(), TransferTxParams&#123;</span><br><span class=\"line\">                FromAccountID: fromAccountID,</span><br><span class=\"line\">                ToAccountID:   toAccountID,</span><br><span class=\"line\">                Amount:        amount,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">            errs &lt;- err</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后对错误和结果进行检查，这里因为我们只要检查结果，对于过程中的对错我们就不检查了，只要能有结果出来就说明不存在死锁了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTxDeadlock</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        err := &lt;-errs</span><br><span class=\"line\">        require.NoError(t, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">TransferTx</span><span class=\"params\">(ctx context.Context, arg TransferTxParams)</span> <span class=\"params\">(TransferTxResult, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result TransferTxResult</span><br><span class=\"line\"></span><br><span class=\"line\">    err := store.execTx(ctx, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(q *Queries)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> arg.FromAccountID &lt; arg.ToAccountID &#123;</span><br><span class=\"line\">            result.FromAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class=\"line\">                ID:     arg.FromAccountID,</span><br><span class=\"line\">                Amount: -arg.Amount,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> err</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            result.ToAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class=\"line\">                ID:     arg.ToAccountID,</span><br><span class=\"line\">                Amount: arg.Amount,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> err</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result.ToAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class=\"line\">                ID:     arg.ToAccountID,</span><br><span class=\"line\">                Amount: arg.Amount,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> err</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            result.FromAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class=\"line\">                ID:     arg.FromAccountID,</span><br><span class=\"line\">                Amount: -arg.Amount,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> err</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用Gin框架在go语言中实现HTTP-API\">使用Gin框架在go语言中实现HTTP API</h2>\n<p>首先我们安装gin框架</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>\n<h3 id=\"定义服务器结构体\">定义服务器结构体</h3>\n<p>创建一个新的目录<code>api</code>并且在其中创建一个新的文件<code>server.go</code>，这里是我们实现HTTP API服务器的地方。</p>\n<p>首先我们定义一个Server结构体，它会提供所有的HTTP请求，它有两个字段：</p>\n<ul>\n<li><code>db.Store</code>，它使得我们处理来自客户端的请求的时候能够和数据库互动</li>\n<li><code>gin.Engine</code>，它是一个router，帮我们将每一个API请求送到正确的handler上</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    store  *db.Store</span><br><span class=\"line\">    router *gin.Engine</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着增加一个函数<code>NewServer</code>，它以<code>db.Store</code>为输入，返回一个<code>Server</code>。这个函数创造一个Server实例，并且为我们的服务在服务器上创建所有的HTTP API route。</p>\n<p>首先创建一个Server对象，然后创建一个router，我们会将routes添加到这个router中，在这之后我们将这个router分配给server并且返回server。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store *db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    server := &amp;Server&#123;store: store&#125;</span><br><span class=\"line\">    router := gin.Default()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> add routes to router</span></span><br><span class=\"line\"></span><br><span class=\"line\">    server.router = router</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们可以将第一个用于创建新账户的API以POST方式挂到该router上了，需要传入router的路径以及一个handler函数，如果传入多个函数的话，最后一个函数是真正的handler，其他的函数都应当是中间件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store *db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    server := &amp;Server&#123;store: store&#125;</span><br><span class=\"line\">    router := gin.Default()</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class=\"line\"></span><br><span class=\"line\">    server.router = router</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现创建账户API\">实现创建账户API</h3>\n<p>在当前<code>api</code>目录下创建一个新的<code>account.go</code>文件来实现跟account相关的api。其中我们声明一个<code>creatAccount()</code>函数，<strong>它必须只以一个<code>gin.Context</code>对象为输入</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createAccount</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着需要定义一个结构体去存储创建账户请求，它的字段和<code>createAccountParams</code>相近，但是不需要设置balance，因为创建账户时余额应当为0不能让客户端自己指定。<br>\n由于我们需要从HTTP请求主体中获取参数，所以字段的json标签仍然是需要的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> createAccountRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Owner    <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;owner&quot;`</span></span><br><span class=\"line\">    Currency <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;currency&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createAccount</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，无论何时我们获取到客户端传过来的输入数据时都要进行验证，因为可能会有非法的数据传过来。Gin在内部使用了一个验证包来自动执行验证。我们对两个字段增加binding的<code>required</code>标签，同时我们的银行只支持两种货币<code>USD</code>和<code>EUR</code>则我们在binding标签中还需要增加一个oneof参数用于指定值一定是在哪个范围</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> createAccountRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Owner    <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;owner&quot; binding:&quot;required&quot;`</span></span><br><span class=\"line\">    Currency <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;currency&quot; binding:&quot;required,oneof=USD EUR&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在<code>createAccount()</code>函数主体中我们生命一个该类型的实例<code>req</code>并且通过<code>ctx.shouldBindJSON()</code>来解析传过来的请求并且赋值给该<code>req</code>。这个函数会返回一个错误，如果存在错误的话就说明传过来的数据有问题我们返回一个badRequest错误，用<code>ctx.JSON()</code>实现。其中的第一个参数是HTTP状态码<code>http.StatusBadRequest</code>，第二个参数是我们希望返回给客户端的JSON对象。由于我们想返回的是个错误，所以我们需要将错误转变为一个键值对，这样Gin框架能够将他转成JSON并且返回给客户端。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createAccount</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> req createAccountRequest</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := ctx.ShouldBindJSON(&amp;req); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的<code>errorResponse()</code>是我们自定义的函数，由于我们后面会经常用到它，所以我们将它在<code>server.go</code>里面实现，我们使用<code>gin.H()</code>将错误转换为一个键值对，该函数本质上就是一个<code>map[string]interface&#123;&#125;</code>的别称。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">errorResponse</span><span class=\"params\">(err error)</span> <span class=\"title\">gin</span>.<span class=\"title\">H</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gin.H&#123;<span class=\"string\">&quot;error&quot;</span>: err.Error()&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们准备好对数据库进行CreatAccount的参数，然后调用该操作就可以了</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createAccount</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> req createAccountRequest</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := ctx.ShouldBindJSON(&amp;req); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    arg := db.CreateAccountParams&#123;</span><br><span class=\"line\">        Owner:    req.Owner,</span><br><span class=\"line\">        Currency: req.Currency,</span><br><span class=\"line\">        Balance:  <span class=\"number\">0</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    account, err := server.store.CreateAccount(ctx, arg)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.JSON(http.StatusOK, account)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"开启HTTP服务\">开启HTTP服务</h3>\n<p>我们对Server创建一个<code>Start</code>函数，它以一个地址作为输入，作用是在这个地址上运行我们的HTTP服务以监听传过来的API请求。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">Start</span><span class=\"params\">(address <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server.router.Run(address)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们创建server的入口，<code>main.go</code>在项目根目录下面，其具体内容和<code>main_test.go</code>相近，我们通过调用<code>db.NewStore()</code>创建一个<code>store</code>，再调用<code>api.NewServer()</code>来创建一个新的server。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    dbDriver      = <span class=\"string\">&quot;postgres&quot;</span></span><br><span class=\"line\">    dbSource      = <span class=\"string\">&quot;postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    conn, err := sql.Open(dbDriver, dbSource)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    store := db.NewStore(conn)</span><br><span class=\"line\">    server := api.NewServer(store)</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外我们还需要设置服务器监听的地址以及导入一个间接引用的包否则我们无法和数据库进行对话</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;database/sql&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    _ <span class=\"string\">&quot;github.com/lib/pq&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/techschool/simplebank/api&quot;</span></span><br><span class=\"line\">    db <span class=\"string\">&quot;github.com/techschool/simplebank/db/sqlc&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    dbDriver      = <span class=\"string\">&quot;postgres&quot;</span></span><br><span class=\"line\">    dbSource      = <span class=\"string\">&quot;postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable&quot;</span></span><br><span class=\"line\">    serverAddress = <span class=\"string\">&quot;0.0.0.0:8080&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    conn, err := sql.Open(dbDriver, dbSource)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    store := db.NewStore(conn)</span><br><span class=\"line\">    server := api.NewServer(store)</span><br><span class=\"line\"></span><br><span class=\"line\">    err = server.Start(serverAddress)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot start server:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在主函数入口完成了，我们可以去<code>Makefile</code>中再加入一个server指令，内容为<code>go run main.go</code></p>\n<h3 id=\"测试API接口\">测试API接口</h3>\n<p>这里我们可以用postman来模拟对接口的访问，注意下载postman的时候不要科学上网，不然会很慢。</p>\n<h3 id=\"实现get-account-API接口\">实现get account API接口</h3>\n<p>与上面不同的是，这里用GET请求显示地给出要查询的account的id。我们在<code>NewServer()</code>函数中使用GET方法向路径中添加一个功能。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store *db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts/:id&quot;</span>, server.getAccount)</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们需要实现<code>getAccount</code>handler。我们去到<code>account.go</code>中进行实现，我们首先需要一个结构体来作为请求的参数，这里由于ID是通过URI参数的方式获取到的，我们就不能用json标签了而是应该使用uri标签。同样的，在实现的过程中还需要将<code>shouldBindJSON</code>改为<code>shouldBindUri</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">getAccount</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> req getAccountRequest</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := ctx.ShouldBindUri(&amp;req); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    account, err := server.store.GetAccount(ctx, req.ID)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err == sql.ErrNoRows &#123;</span><br><span class=\"line\">            ctx.JSON(http.StatusNotFound, errorResponse(err))</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.JSON(http.StatusOK, account)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于list account的方法也是大同小异，其主要在于它的两个参数应该用<code>shouldBindQuery</code>来获取，它是通过query string传递参数的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> listAccountRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    PageID   <span class=\"keyword\">int32</span> <span class=\"string\">`form:&quot;page_id&quot; binding:&quot;required,min=1&quot;`</span></span><br><span class=\"line\">    PageSize <span class=\"keyword\">int32</span> <span class=\"string\">`form:&quot;page_size&quot; binding:&quot;required,min=5,max=10&quot;`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">listAccount</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> req listAccountRequest</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := ctx.ShouldBindQuery(&amp;req); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    arg := db.ListAccountsParams&#123;</span><br><span class=\"line\">        Limit:  req.PageSize,</span><br><span class=\"line\">        Offset: (req.PageID - <span class=\"number\">1</span>) * req.PageSize,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    accounts, err := server.store.ListAccounts(ctx, arg)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.JSON(http.StatusOK, accounts)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用Viper从文件中加载配置和环境变量\">使用Viper从文件中加载配置和环境变量</h2>\n<p>开发和部署后端的时候我们需要对不同的环境使用不同的配置。</p>\n<p>在我们目前的代码中，我们有一些以constant形式的变量配置在<code>main_test.go</code>中，接下来我们就要用viper来从文件和环境变量中读取这些配置信息。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    dbDriver      = <span class=\"string\">&quot;postgres&quot;</span></span><br><span class=\"line\">    dbSource      = <span class=\"string\">&quot;postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable&quot;</span></span><br><span class=\"line\">    serverAddress = <span class=\"string\">&quot;0.0.0.0:8080&quot;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>首先是安装Viper，进入<a href=\"https://github.com/spf13/viper\">Viper的github主页</a>下载安装viper。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get github.com/spf13/viper</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建配置文件\">创建配置文件</h3>\n<p>我们需要创建一个新的文件<code>app.env</code>来保存我们的配置信息，接着我们将上面的变量复制到这里，但是由于我们使用的是.env格式的文件，所以我们需要更改一下格式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DB_DRIVER=postgres</span><br><span class=\"line\">DB_SOURCE=postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable</span><br><span class=\"line\">SERVER_ADDRESS=0.0.0.0:8080</span><br></pre></td></tr></table></figure>\n<h3 id=\"加载配置文件\">加载配置文件</h3>\n<p>我们在util目录下创建一个config包，然后我们声明一个新的<code>Config</code>结构体变量，这个结构体中将会包含所有的配置变量信息，目前，我们有3个变量</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Config <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    DBDriver      <span class=\"keyword\">string</span> <span class=\"string\">`mapstructure:&quot;DB_DRIVER&quot;`</span></span><br><span class=\"line\">    DBSource      <span class=\"keyword\">string</span> <span class=\"string\">`mapstructure:&quot;DB_SOURCE&quot;`</span></span><br><span class=\"line\">    ServerAddress <span class=\"keyword\">string</span> <span class=\"string\">`mapstructure:&quot;SERVER_ADDRESS&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了能够获取到变量的值并且将他们保存到结构体中，我们需要用到Vpier的unmarshaling特征，viper使用<a href=\"https://github.com/mitchellh/mapstructure\">mapstructure</a>包在底层解析数据，因此我们需要使用mapstructure标签来制定每一个配置字段的名称</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Config <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    DBDriver      <span class=\"keyword\">string</span> <span class=\"string\">`mapstructure:&quot;DB_DRIVER&quot;`</span></span><br><span class=\"line\">    DBSource      <span class=\"keyword\">string</span> <span class=\"string\">`mapstructure:&quot;DB_SOURCE&quot;`</span></span><br><span class=\"line\">    ServerAddress <span class=\"keyword\">string</span> <span class=\"string\">`mapstructure:&quot;SERVER_ADDRESS&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来我们需要定义一个新的函数<code>LoadConfig()</code>，它以一个路径为输入，并且返回一个Config对象或者一个错误。这个函数会从路径中存在的配置文件中读取配置信息，或者重写这些配置的值</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LoadConfig</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(config Config, err error)</span></span> &#123;</span><br><span class=\"line\">    viper.AddConfigPath(path)</span><br><span class=\"line\">    viper.SetConfigName(<span class=\"string\">&quot;app&quot;</span>)</span><br><span class=\"line\">    viper.SetConfigType(<span class=\"string\">&quot;env&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了从文件中读取配置，我们还希望viper能够从环境变量中读取值，所以我们调用<code>viper.AutomaticEnv()</code>来让viper自动覆盖它已经从配置文件中读取到的相关的环境变量的值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LoadConfig reads configuration from file or environment variables.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LoadConfig</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(config Config, err error)</span></span> &#123;</span><br><span class=\"line\">    viper.AddConfigPath(path)</span><br><span class=\"line\">    viper.SetConfigName(<span class=\"string\">&quot;app&quot;</span>)</span><br><span class=\"line\">    viper.SetConfigType(<span class=\"string\">&quot;env&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    viper.AutomaticEnv()</span><br><span class=\"line\"></span><br><span class=\"line\">    err = viper.ReadInConfig()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = viper.Unmarshal(&amp;config)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后我们调用<code>viper.ReadInConfig()</code>来开始读取配置值。</p>\n<p>最后我们调用<code>viper.Unmarshal()</code>来将值解析到<code>config</code>变量中，最后返回。</p>\n<h3 id=\"在主函数中使用LoadConfig\">在主函数中使用LoadConfig</h3>\n<p>我们将之前手动配置的值全部删除，然后在主函数中我们调用刚才写的<code>util.LoadConfig()</code>并且传入<code>.</code>，意思是用当前的目录作为路径，因为我们的配置文件<code>app.env</code>是在<code>main.go</code>的统一目录下的。</p>\n<p>如果存在错误的话我么写一个fatal log来记录无法加载配置文件。否则，就成功，我们的原先的配置值就成为了结构体中的字段值，调用就可以了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    config, err := util.LoadConfig(<span class=\"string\">&quot;.&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot load config:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    conn, err := sql.Open(config.DBDriver, config.DBSource)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    store := db.NewStore(conn)</span><br><span class=\"line\">    server := api.NewServer(store)</span><br><span class=\"line\"></span><br><span class=\"line\">    err = server.Start(config.ServerAddress)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot start server:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样，在测试函数的主函数中我们也可以使用同样的方法加载这些配置信息。</p>\n<h2 id=\"为测试HTTP-API模拟一个数据库\">为测试HTTP API模拟一个数据库</h2>\n<p>如果我们无法隔离单元测试的数据来避免冲突，可以尝试模拟数据库。我们使用<a href=\"https://github.com/golang/mock\">Gomock</a>来为数据库结构生成存根。</p>\n<h3 id=\"模拟数据库的两种方式\">模拟数据库的两种方式</h3>\n<p>第一种方式是生成一个虚拟数据库，它将信息保存在内存之中。比如我们有一个Store接口定义了一系列的对于真实数据库的操作，那么我们就可以定义一个虚拟数据库的<code>MemStore</code>结构体来实现<code>Store</code>接口的所有功能，但只用一个映射去读取和写入数据。这个方法简单且易于实现，但是它需要我们去写更多只能用于测试的代码，这非常耗时。</p>\n<p>所以接下来我们将会用一个更好的方法来模拟数据库，<strong>使用存根来替代虚假的数据库</strong>。基本思路是使用<code>gomock</code>包来生成和构建存根，它会返回我们想要测试的场景的硬编码。</p>\n<p>在我们这个例子中，gomock会生成一个<code>MockStore</code>，我们需要做的是调用它的<code>EXPECT()</code>函数来生成一个存根，它会告诉gomock：<code>GetAccount()</code>函数通过输入的<code>AccountID</code>只能被调用一次，并且返回账户对象作为输出。这之后，我们只需要使用这个虚拟的store就可以测试API了。</p>\n<h3 id=\"安装gomock\">安装gomock</h3>\n<p>首先我们去gomock的github主页按照其中的命令安装gomock</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get github.com/golang/mock/mockgen@v1.4.4</span><br></pre></td></tr></table></figure>\n<p>接着可以发现，一个<code>mockgen</code>的二进制文件出现在go/bin的文件夹下。</p>\n<p>我们会使用这个工具来生成模拟数据库，所以我们要确认该命令能够在任何地方执行。我们可以通过以下命令检查</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">❯ which mockgen</span><br><span class=\"line\">mockgen not found</span><br></pre></td></tr></table></figure>\n<p>如果出现如上的情况所名go/bin目录没有被添加到环境变量中，我们可以将它添加到环境变量中。</p>\n<h3 id=\"定义Store接口\">定义Store接口</h3>\n<p>为了能够使用mockgen来生成虚拟数据库，我们需要先稍微修改一下我们的代码。</p>\n<p>目前，在<code>api/server.go</code>文件中，<code>NewServer()</code>函数接收一个<code>db.Store</code>对象</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    store  *db.Store</span><br><span class=\"line\">    router *gin.Engine</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store *db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>db.Store</code>是在<code>db/sqlc/store.go</code>中定义的，这是我们连接真实数据库的结构体</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Store <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    db *sql.DB</span><br><span class=\"line\">    *Queries</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了能在API测试中使用虚拟数据库，我们需要用一个接口替代store对象。我们会赋值<code>Store</code>结构体的定义并且将它的类型改成接口。然后将原本的定义重命名为<code>SQLStore</code>，这是<code>Store</code>接口的真实实现，能够与SQL数据库交互。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Store <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> add functions to this interface</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> SQLStore <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    db *sql.DB</span><br><span class=\"line\">    *Queries</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>接着，<code>NewStore()</code>函数不应该再返回一个指针，而是直接返回一个接口，并且在内部它应当返回真实的数据库接口实现</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewStore</span><span class=\"params\">(db *sql.DB)</span> <span class=\"title\">Store</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;SQLStore&#123;</span><br><span class=\"line\">        db:      db,</span><br><span class=\"line\">        Queries: New(db),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们同样需要改变<code>execTx()</code>和<code>TransferTx()</code>函数的<code>store</code>接收器类型改为<code>*SQLStore</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *SQLStore)</span> <span class=\"title\">execTx</span><span class=\"params\">(ctx context.Context, fn <span class=\"keyword\">func</span>(*Queries)</span> <span class=\"title\">error</span>) <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *SQLStore)</span> <span class=\"title\">TransferTx</span><span class=\"params\">(ctx context.Context, arg TransferTxParams)</span> <span class=\"params\">(TransferTxResult, error)</span></span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们需要定义一系列<code>Store</code>接口能够执行的操作。首先，它应该拥有所有的<code>Queries</code>结构体的函数，并且还多处一个执行转账交易的函数。所以我们首先将<code>TransferTx()</code>的定义复制到<code>Store</code>接口中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Store <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于<code>Queries</code>结构体的函数，我们可以同样赋值粘贴，但是这样太耗时了。所幸，sqlc包中有一个选项是发散包含<code>Queries</code>结构体包含的所有函数的接口。我们所要做的就是将它的值这是为true</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\"><span class=\"attr\">packages:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;db&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">&quot;./db/sqlc&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">queries:</span> <span class=\"string\">&quot;./db/query/&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">schema:</span> <span class=\"string\">&quot;./db/migration/&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">engine:</span> <span class=\"string\">&quot;postgresql&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">emit_json_tags:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">emit_prepared_queries:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">emit_interface:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">emit_exact_table_names:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">emit_empty_slices:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>然后再执行一次make sqlc</p>\n<p>之后在<code>db/sqlc</code>中我们可以看到一个新的文件<code>querier.go</code>，它包含了生成的<code>Querier</code>接口其中包含所有的对数据库进行交互操作的函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Querier <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    AddAccountBalance(ctx context.Context, arg AddAccountBalanceParams) (Account, error)</span><br><span class=\"line\">    CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error)</span><br><span class=\"line\">    CreateEntry(ctx context.Context, arg CreateEntryParams) (Entry, error)</span><br><span class=\"line\">    CreateTransfer(ctx context.Context, arg CreateTransferParams) (Transfer, error)</span><br><span class=\"line\">    DeleteAccount(ctx context.Context, id <span class=\"keyword\">int64</span>) error</span><br><span class=\"line\">    GetAccount(ctx context.Context, id <span class=\"keyword\">int64</span>) (Account, error)</span><br><span class=\"line\">    GetAccountForUpdate(ctx context.Context, id <span class=\"keyword\">int64</span>) (Account, error)</span><br><span class=\"line\">    GetEntry(ctx context.Context, id <span class=\"keyword\">int64</span>) (Entry, error)</span><br><span class=\"line\">    GetTransfer(ctx context.Context, id <span class=\"keyword\">int64</span>) (Transfer, error)</span><br><span class=\"line\">    ListAccounts(ctx context.Context, arg ListAccountsParams) ([]Account, error)</span><br><span class=\"line\">    ListEntries(ctx context.Context, arg ListEntriesParams) ([]Entry, error)</span><br><span class=\"line\">    ListTransfers(ctx context.Context, arg ListTransfersParams) ([]Transfer, error)</span><br><span class=\"line\">    UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> _ Querier = (*Queries)(<span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<p>接着我们只需要将这个接口的定义迁入到<code>Store</code>接口中就可以了</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Store <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Querier</span><br><span class=\"line\">    TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们回到<code>api/server.go</code>文件中将<code>*db.Store</code>类型因为它不再是一个结构体指针了而是一个接口</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并且由于我们更改了<code>db.NewStore</code>的返回值所以我们在<code>main.go</code>中不需要对函数主体进行任何的修改</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    config, err := util.LoadConfig(<span class=\"string\">&quot;.&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot load config:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    conn, err := sql.Open(config.DBDriver, config.DBSource)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    store := db.NewStore(conn)</span><br><span class=\"line\">    server := api.NewServer(store)</span><br><span class=\"line\"></span><br><span class=\"line\">    err = server.Start(config.ServerAddress)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot start server:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成模拟数据库\">生成模拟数据库</h3>\n<p>目前我们已经有了<code>db.Store</code>接口，我们能够使用gomock去生成一个虚拟实现。</p>\n<p>首先我们创造一个新的<code>mock</code>目录在<code>db</code>目录下，然后我们打开终端运行<code>mockgen -help</code>。mockgen给我们两种方式去生成模拟，<code>source mode</code>会从单个源文件生成模拟接口，这在该文件导入了别的包的情况下会比较复杂。</p>\n<p>在本例子中，我们最好使用<code>reflect mode</code>，我们只需要提供包的名字和接口，mockgen就会利用反射去自动决定怎么做</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">mockgen github.com/techschool/simplebank/db/sqlc Store</span><br></pre></td></tr></table></figure>\n<p>第一个参数是导入的<code>Store</code>的路径即该接口定义的路径，第二个参数是接口的名称。我们还应该制定生成文件的路径。否则，mockgen会默认生成代码到标准输出上。所以我们用<code>-destination</code>来指定代码生成的位置。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">mockgen -destination db/mock/store.go github.com/techschool/simplebank/db/sqlc Store</span><br></pre></td></tr></table></figure>\n<p>在生成文件中有两个重要的结构体<code>MockStore</code>和<code>MockStoreRecorder</code></p>\n<p><code>MockStore</code>是执行所有<code>Store</code>接口的必要函数的结构体，<code>MockStoreRecorder</code>同样有这些相同名字的函数，只不过他们的参数是普通的接口类型。</p>\n<p>此外，由mockgen生成的代码的包的名字是<code>mock_sqlc</code>这不太好，我们可以在刚才的命令中加入一个参数来指定包名。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">mockgen -package mockdb -destination db/mock/store.go github.com/techschool/simplebank/db/sqlc Store</span><br></pre></td></tr></table></figure>\n<p>接下来我们先在MakeFile中将mock命令添加进区，之后就可以测试API了</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">mock:</span></span><br><span class=\"line\">    mockgen -package mockdb -destination db/mock/store.go github.com/techschool/simplebank/db/sqlc Store</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: postgres createdb dropdb migrateup migratedown sqlc test </span></span><br></pre></td></tr></table></figure>\n<h3 id=\"对API进行单元测试\">对API进行单元测试</h3>\n<p>在api目录下创建一个新的文件<code>account_test.go</code>。在其中我们定义一个新的函数<code>TestGetAccountAPI(t *testing.T)</code>。为了能够测试，我们需要账户，所以我们先写一个函数来生成随机的账户</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomAccount</span><span class=\"params\">()</span> <span class=\"title\">db</span>.<span class=\"title\">Account</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> db.Account&#123;</span><br><span class=\"line\">        ID:       util.RandomInt(<span class=\"number\">1</span>, <span class=\"number\">1000</span>),</span><br><span class=\"line\">        Owner:    util.RandomOwner(),</span><br><span class=\"line\">        Balance:  util.RandomMoney(),</span><br><span class=\"line\">        Currency: util.RandomCurrency(),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们返回测试，在函数中调用上面这个函数来创建一个新的用户</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    account := randomAccount()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们需要用<code>mockdb.NewMockStore()</code>创建一个新的mock store，它以一个gomock.Controller对象为输入，所以我们需要调用一个<code>gomock.NewController</code>来创建一个controller。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    account := randomAccount()</span><br><span class=\"line\"></span><br><span class=\"line\">    ctrl := gomock.NewController(t)</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> ctrl.Finish()</span><br><span class=\"line\"></span><br><span class=\"line\">    store := mockdb.NewMockStore(ctrl)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>defer调用finish非常重要，因为它会检查是否所有我们希望调用的函数都被调用到了。</p>\n<p>接下来是为虚拟store创建存根，在这个案例中我们值关心<code>GetAccount()</code>方法，因为它是唯一一个需要被GetAccount API调用的方法。所以接下来我们调用<code>store.EXPECT().GetAccount()</code>方法来创建存根。而<code>GetAccount()</code>方法需要两个参数作为输入，因此我们需要给出这两个参数。</p>\n<p>对于第一个参数，是上下文环境参数，它可以是任意值，所以我们使用<code>gomock.Any()</code>来匹配它，第二个参数应该等于我们创造的随机账户的ID，所以我们使用<code>gomock.Eq()</code>来匹配<code>account.ID</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    account := randomAccount()</span><br><span class=\"line\"></span><br><span class=\"line\">    ctrl := gomock.NewController(t)</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> ctrl.Finish()</span><br><span class=\"line\"></span><br><span class=\"line\">    store := mockdb.NewMockStore(ctrl)</span><br><span class=\"line\">    store.EXPECT().</span><br><span class=\"line\">        GetAccount(gomock.Any(), gomock.Eq(account.ID)).</span><br><span class=\"line\">        Times(<span class=\"number\">1</span>).</span><br><span class=\"line\">        Return(account, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样这个存根的意思就可以翻译为我希望GetAccount()函数被调用并且其参数是一个随意的上下文和指定的账户ID</p>\n<p>我们同样还可以指定函数应当被调用的次数，<code>Time(1)</code>表示我们希望这个函数被调用一次。此外我们还可以用<code>Return()</code>函数来告诉gomock返回指定的值。比如，在这个例子中，我们希望他能够返回账户对象和nil错误。需要注意的是，这里的Return函数的返回应当和GetAccount函数的返回值是相同的。</p>\n<p>现在存根已经设置完毕了，我们开始创建一个服务器</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    server := NewServer(store)</span><br><span class=\"line\">    recorder := httptest.NewRecorder()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了测试API我们不需要真的开启一个服务器，我们只需要使用httptest包的recording特征来记录API请求的返回值。所以我们调用<code>httptest.Recorder()</code>来创建一个新的<code>ResponseRecorder</code>。</p>\n<p>接着我们声明我们希望调用的API的url路径，在这里就是<code>/accounts/&#123;ID of the account we want to get&#125;</code>。然后我们用GET方法创建一个新的HTTP请求，因为用的是GET，我们可以对request body使用nil。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    server := NewServer(store)</span><br><span class=\"line\">    recorder := httptest.NewRecorder()</span><br><span class=\"line\"></span><br><span class=\"line\">    url := fmt.Sprintf(<span class=\"string\">&quot;/accounts/%d&quot;</span>, tc.accountID)</span><br><span class=\"line\">    request, err := http.NewRequest(http.MethodGet, url, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们用创建的recorder和request对象调用<code>server.router.ServeHTTP()</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    account := randomAccount()</span><br><span class=\"line\"></span><br><span class=\"line\">    ctrl := gomock.NewController(t)</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> ctrl.Finish()</span><br><span class=\"line\"></span><br><span class=\"line\">    store := mockdb.NewMockStore(ctrl)</span><br><span class=\"line\">    store.EXPECT().</span><br><span class=\"line\">        GetAccount(gomock.Any(), gomock.Eq(account.ID)).</span><br><span class=\"line\">        Times(<span class=\"number\">1</span>).</span><br><span class=\"line\">        Return(account, <span class=\"literal\">nil</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    server := NewServer(store)</span><br><span class=\"line\">    recorder := httptest.NewRecorder()</span><br><span class=\"line\"></span><br><span class=\"line\">    url := fmt.Sprintf(<span class=\"string\">&quot;/accounts/%d&quot;</span>, tc.accountID)</span><br><span class=\"line\">    request, err := http.NewRequest(http.MethodGet, url, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    server.router.ServeHTTP(recorder, request)</span><br><span class=\"line\">    require.Equal(t, http.StatusOK, recorder.Code)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面我们只是简单地检查了返回的http状态码是否正确，这是一种比较简陋的方法。</p>\n<p>那如果我们想要检查返回的主体呢，我们可以调用<code>requireBodyMatchAccount()</code>，它有三个参数：<code>testing.T</code>,<code>byte.Buffer</code>指针类型的返回主体和去比较的账户对象。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">requireBodyMatchAccount</span><span class=\"params\">(t *testing.T, body *bytes.Buffer, account db.Account)</span></span> &#123;</span><br><span class=\"line\">    data, err := ioutil.ReadAll(body)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> gotAccount db.Account</span><br><span class=\"line\">    err = json.Unmarshal(data, &amp;gotAccount)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.Equal(t, account, gotAccount)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取100-的覆盖率\">获取100%的覆盖率</h3>\n<p>首先我们需要定义一组测试用例，每一个测试用例会有一个独特的名字与其他用例区别开，并且会有一个accountID字段用来指定用于测试的id，此外由于每个测试所用到的存根时不一样的，所以要用一个对应的字段作为存根的设置，检查返回字段也是一样的道理。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    account := randomAccount()</span><br><span class=\"line\"></span><br><span class=\"line\">    testCases := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        name          <span class=\"keyword\">string</span></span><br><span class=\"line\">        accountID     <span class=\"keyword\">int64</span></span><br><span class=\"line\">        buildStubs    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span></span><br><span class=\"line\">        checkResponse <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T, recoder *httptest.ResponseRecorder)</span></span></span><br><span class=\"line\">    &#125;&#123;</span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> add test data</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们可以增加一些不同的场景到我们的测试用例里面了</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    account := randomAccount()</span><br><span class=\"line\"></span><br><span class=\"line\">    testCases := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        name          <span class=\"keyword\">string</span></span><br><span class=\"line\">        accountID     <span class=\"keyword\">int64</span></span><br><span class=\"line\">        buildStubs    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span></span><br><span class=\"line\">        checkResponse <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T, recoder *httptest.ResponseRecorder)</span></span></span><br><span class=\"line\">    &#125;&#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name:      <span class=\"string\">&quot;OK&quot;</span>,</span><br><span class=\"line\">            accountID: account.ID,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    GetAccount(gomock.Any(), gomock.Eq(account.ID)).</span><br><span class=\"line\">                    Times(<span class=\"number\">1</span>).</span><br><span class=\"line\">                    Return(account, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T, recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusOK, recorder.Code)</span><br><span class=\"line\">                requireBodyMatchAccount(t, recorder.Body, account)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后我们会在里面添加一些不同的案例场景，所以在测试函数中我们使用一个for loop来进行测试，我们将每个测试用例作为一个独立的测试，所以在for loop中我们呢使用<code>t.Run()</code>，传入用例名称和一个函数，然后将之前写的测试函数内部的操作都放到这个函数里面去。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> testCases &#123;</span><br><span class=\"line\">        tc := testCases[i]</span><br><span class=\"line\"></span><br><span class=\"line\">        t.Run(tc.name, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">            ctrl := gomock.NewController(t)</span><br><span class=\"line\">            <span class=\"keyword\">defer</span> ctrl.Finish()</span><br><span class=\"line\"></span><br><span class=\"line\">            store := mockdb.NewMockStore(ctrl)</span><br><span class=\"line\">            tc.buildStubs(store)</span><br><span class=\"line\"></span><br><span class=\"line\">            server := NewServer(store)</span><br><span class=\"line\">            recorder := httptest.NewRecorder()</span><br><span class=\"line\"></span><br><span class=\"line\">            url := fmt.Sprintf(<span class=\"string\">&quot;/accounts/%d&quot;</span>, tc.accountID)</span><br><span class=\"line\">            request, err := http.NewRequest(http.MethodGet, url, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">            server.router.ServeHTTP(recorder, request)</span><br><span class=\"line\">            tc.checkResponse(t, recorder)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后可以按照我们自己的想法向其中添加不同的测试用例，但是之后运行测试的时候会发现控制台中的输出太多了，干扰到我们观察我们需要观察的数据，这是因为Gin默认是在Debug模式下运行的。我们可以在api目录下创建一个<code>main_test.go</code>函数来将Gin的模式设置为Test模式。这个文件的内容和db包下的<code>main_test.go</code>文件是类似的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestMain</span><span class=\"params\">(m *testing.M)</span></span> &#123;</span><br><span class=\"line\">    gin.SetMode(gin.TestMode)</span><br><span class=\"line\">    os.Exit(m.Run())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用自定义参数验证器实现转账\">使用自定义参数验证器实现转账</h2>\n<p>这一节将会实现对于银行来说最重要的API：转账。并且还会实现一个自定义验证器来验证传给API的输入参数。</p>\n<h3 id=\"实现转账API的handler\">实现转账API的handler</h3>\n<p>我们首先在api包中创建一个transfer.go文件，转账api的实现和创建账户api的实现是相似的。</p>\n<p>我们用<code>transferRequest</code>结构体来保存api的输入参数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> transferRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    FromAccountID <span class=\"keyword\">int64</span>  <span class=\"string\">`json:&quot;from_account_id&quot; binding:&quot;required,min=1&quot;`</span></span><br><span class=\"line\">    ToAccountID   <span class=\"keyword\">int64</span>  <span class=\"string\">`json:&quot;to_account_id&quot; binding:&quot;required,min=1&quot;`</span></span><br><span class=\"line\">    Amount        <span class=\"keyword\">int64</span>  <span class=\"string\">`json:&quot;amount&quot; binding:&quot;required,gt=0&quot;`</span></span><br><span class=\"line\">    Currency      <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;currency&quot; binding:&quot;required,oneof=USD EUR CAD&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着在hadler函数<code>creatTransfer()</code>中将参数和请求进行绑定，并且如果出现错误的话就返回<code>http.StatusBadRequest</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createTransfer</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> req transferRequest</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := ctx.ShouldBindJSON(&amp;req); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    arg := db.TransferTxParams&#123;</span><br><span class=\"line\">        FromAccountID: req.FromAccountID,</span><br><span class=\"line\">        ToAccountID:   req.ToAccountID,</span><br><span class=\"line\">        Amount:        req.Amount,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    result, err := server.store.TransferTx(ctx, arg)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.JSON(http.StatusOK, result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的函数中我们已经创建好了一个handler函数了，但是我们req参数中的<code>request.Currency</code>其实是没有用到的，我们需要做的是比较转出账户和转入账户中这个参数是否是相同的。因此我们需要为<code>Server</code>结构体定义一个新的函数<code>validAccount()</code>。</p>\n<p>这个函数会检查带有指定ID的账户是否真实存在并且它的货币是否跟输入的货币相匹配。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">validAccount</span><span class=\"params\">(ctx *gin.Context, accountID <span class=\"keyword\">int64</span>, currency <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    account, err := server.store.GetAccount(ctx, accountID)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err == sql.ErrNoRows &#123;</span><br><span class=\"line\">            ctx.JSON(http.StatusNotFound, errorResponse(err))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> account.Currency != currency &#123;</span><br><span class=\"line\">        err := fmt.Errorf(<span class=\"string\">&quot;account [%d] currency mismatch: %s vs %s&quot;</span>, account.ID, account.Currency, currency)</span><br><span class=\"line\">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们要回到刚才的handler函数中，将这个valid模块插入进去。</p>\n<h3 id=\"登记转账API的路径\">登记转账API的路径</h3>\n<p>我们打开<code>api/server.go</code>文件，在其中添加一个路径，同样使用post方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    server := &amp;Server&#123;store: store&#125;</span><br><span class=\"line\">    router := gin.Default()</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts/:id&quot;</span>, server.getAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts&quot;</span>, server.listAccounts)</span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/transfers&quot;</span>, server.createTransfer)</span><br><span class=\"line\"></span><br><span class=\"line\">    server.router = router</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着在终端中输入并且执行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">make server</span><br></pre></td></tr></table></figure>\n<p>然后就可以验证我们的api了，同样使用postman进行测试验证，这里就不多做赘述了。需要注意的是，这里我们并没有使用虚拟数据库进行验证，而是使用了真实的数据库交互。</p>\n<h3 id=\"实现自定义货币验证模块\">实现自定义货币验证模块</h3>\n<p>在我们之前的定义中我们只硬编码了三种货币，加入之后我们需要增加货币种类，使它能够支持更多的货币类型呢？那我们如果仍然使用oneof的方式一个一个放入的话就很容易出错。而且对以货币的定义出现在很多的结构体中，一个一个修改他们并不现实。</p>\n<p>我们可以在api包下创建一个新的文件<code>validator.go</code>，然后声明一个新的<code>validator.Func</code>类型的变量<code>validCurrency</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> api</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/go-playground/validator/v10&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/techschool/simplebank/util&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> validCurrency validator.Func = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(fieldLevel validator.FieldLevel)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> currency, ok := fieldLevel.Field().Interface().(<span class=\"keyword\">string</span>); ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> util.IsSupportedCurrency(currency)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>总体上来说，<code>validator.Func</code>是一个函数，它以<code>validator.FieldLevel</code>接口作为输入并且返回true如果验证成功的话。这个接口包含了所有的信息来帮助函数进行字段的验证。</p>\n<p>我们需要做的就是通过<code>fieldLevel.Field()</code>获取到字段的值，需要注意的是这是一个反射值，所以我们需要调用<code>.interface()</code>来将值转为<code>interface&#123;&#125;</code>。然后我们将这个值转为string类型。该函数会返回一个货币字符串和一个bool类型的值，在我们这个案例中我们还需要对货币进行检查，看是否是我们支持的货币类型，因此我们需要在util中再创建一个工具函数来实现这个功能。</p>\n<p>我们首先用常量的形式将支持的货币写下，然后再用函数判断货币是否在这些常量中，如果在的话就能够支持，否则的话不能够支持。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> util</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Constants for all supported currencies</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    USD = <span class=\"string\">&quot;USD&quot;</span></span><br><span class=\"line\">    EUR = <span class=\"string\">&quot;EUR&quot;</span></span><br><span class=\"line\">CAD = <span class=\"string\">&quot;CAD&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IsSupportedCurrency returns true if the currency is supported</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsSupportedCurrency</span><span class=\"params\">(currency <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> currency &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> USD, EUR, CAD:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"登记自定义的货币验证器\">登记自定义的货币验证器</h3>\n<p>我们先打开<code>server.go</code>文件，在我们创建了Gin <code>router</code>之后我们需要调用<code>binding.Validator.Engine()</code>来得到目前Gin框架正在使用的验证器引擎。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> api</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/gin-gonic/gin/binding&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/go-playground/validator/v10&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    server := &amp;Server&#123;store: store&#125;</span><br><span class=\"line\">    router := gin.Default()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class=\"line\">        v.RegisterValidation(<span class=\"string\">&quot;currency&quot;</span>, validCurrency)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts/:id&quot;</span>, server.getAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts&quot;</span>, server.listAccounts)</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/transfers&quot;</span>, server.createTransfer)</span><br><span class=\"line\"></span><br><span class=\"line\">    server.router = router</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于这个函数返回的是一个<code>validator</code>对象，因此我们需要将他转换为<code>validator.Validate</code>对象指针，如果一切成功的话我们就可以调用<code>v.RegisterValidation()</code>来登记我们的自定义的验证函数。其中第一个参数是我们的验证标签，第二个参数是我们之前实现的<code>validCurrency()</code>函数。</p>\n<h3 id=\"使用自定义验证模块\">使用自定义验证模块</h3>\n<p>接下来在request参数结构体中有货币字段的，将货币字段的binding部分的oneof去掉改成currency</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> createAccountRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Owner    <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;owner&quot; binding:&quot;required&quot;`</span></span><br><span class=\"line\">    Currency <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;currency&quot; binding:&quot;required,currency&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> transferRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    FromAccountID <span class=\"keyword\">int64</span>  <span class=\"string\">`json:&quot;from_account_id&quot; binding:&quot;required,min=1&quot;`</span></span><br><span class=\"line\">    ToAccountID   <span class=\"keyword\">int64</span>  <span class=\"string\">`json:&quot;to_account_id&quot; binding:&quot;required,min=1&quot;`</span></span><br><span class=\"line\">    Amount        <span class=\"keyword\">int64</span>  <span class=\"string\">`json:&quot;amount&quot; binding:&quot;required,gt=0&quot;`</span></span><br><span class=\"line\">    Currency      <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;currency&quot; binding:&quot;required,currency&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着，我们运行<code>make server</code>并且进行测试。</p>\n<h2 id=\"通过特殊的外键限制在pgSQL中添加用户表\">通过特殊的外键限制在pgSQL中添加用户表</h2>\n<p>我们的银行系统到目前为止还缺少一个关键的表：用户认证和授权。接下来我们九江通过连接到已经存在的account表来创建一个user表。</p>\n<h3 id=\"增加user表\">增加user表</h3>\n<p>我们去到<code>diagram.io</code>添加我们的user表。</p>\n<p>表中第一个字段是用户名，它应当是一个varchar类型的变量，每一个用户名都应当是不同的，所以它应当是个主键[pk]</p>\n<p>第二个字段是<code>hashed_password</code>字段来存储用户的密码值，它的类型同样是<code>varchar</code>并且不应当为NULL。为什么是hashed呢？因为我们基本上不会在数据库存储一个未经任何修饰的密码，因为如果我们这样做了那么任何能够访问数据库的人都会看到所有人的密码，这是一个非常重要的安全问题。</p>\n<p>接下来的字段是用户的全名，它也是varchar，并且不能为null，然后是有向，每个用户的邮箱应该不同。</p>\n<p>然后我们有一个创建时间字段，记录创建该用户的时间并且默认值为当前时间。</p>\n<p>最后，为了安全考虑，通常会定期提醒用户去修改密码，所以我们设置一个<code>password_changed_at</code>来获取用户上一次修改密码是什么时候。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Table</span> users <span class=\"keyword\">as</span> U &#123;</span><br><span class=\"line\">  username <span class=\"type\">varchar</span> [pk]</span><br><span class=\"line\">  hashed_password <span class=\"type\">varchar</span> [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  full_name <span class=\"type\">varchar</span> [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  email <span class=\"type\">varchar</span> [<span class=\"keyword\">unique</span>, <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  password_changed_at timestamptz [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>, <span class=\"keyword\">default</span>: <span class=\"string\">&#x27;0001-01-01 00:00:00Z&#x27;</span>]</span><br><span class=\"line\">  created_at timestamptz [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>, <span class=\"keyword\">default</span>: `now()`]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们设置每个字段都不为null的目的非常简单，因为我们在程序中不希望单独处理为null的情况。如果密码一直没有改变过的话，我们会用默认的一个过去时间作为它的值。在go语言中，就是<code>0001-01-01 00:00:00Z</code>，Z的意思是0时区。</p>\n<h3 id=\"增加外键约束\">增加外键约束</h3>\n<p>现在，我们需要让一个用户能够有多个不同货币的账号，所以我们需要将<code>accounts</code>表的<code>owner</code>字段连接到<code>users</code>表的<code>username</code>字段，这会使得<code>owner</code>字段成为一个外键。</p>\n<p>我们会在定义<code>owner</code>的地方增加一个索引标签到username上。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Table</span> accounts <span class=\"keyword\">as</span> A &#123;</span><br><span class=\"line\">  id bigserial [pk]</span><br><span class=\"line\">  owner <span class=\"type\">varchar</span> [<span class=\"keyword\">ref</span>: <span class=\"operator\">&gt;</span> U.username, <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  balance <span class=\"type\">bigint</span> [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  currency <span class=\"type\">varchar</span> [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  created_at timestamptz [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>, <span class=\"keyword\">default</span>: `now()`]</span><br><span class=\"line\"></span><br><span class=\"line\">  Indexes &#123;</span><br><span class=\"line\">    owner</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"增加特殊约束\">增加特殊约束</h3>\n<p>还有一件事我们需要注意，一个用户可以有多个账户，但是那些账户应当有不同的货币类型。一个将这个限制在数据库级别实现的方法是增加一个<code>composite unique index</code>到account表中。这个索引由两个字段构成：owner和currency。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Table</span> accounts <span class=\"keyword\">as</span> A &#123;</span><br><span class=\"line\">  id bigserial [pk]</span><br><span class=\"line\">  owner <span class=\"type\">varchar</span> [<span class=\"keyword\">ref</span>: <span class=\"operator\">&gt;</span> U.username, <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  balance <span class=\"type\">bigint</span> [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  currency <span class=\"type\">varchar</span> [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  created_at timestamptz [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>, <span class=\"keyword\">default</span>: `now()`]</span><br><span class=\"line\"></span><br><span class=\"line\">  Indexes &#123;</span><br><span class=\"line\">    owner</span><br><span class=\"line\">    (owner, currency) [<span class=\"keyword\">unique</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后就可以将文件导出为SQL文件了。</p>\n<h3 id=\"将新的schema添加到项目中\">将新的schema添加到项目中</h3>\n<p>为了能够将变化更改到项目中去，一个方法是将<code>init_schema_migration</code>的全部内容都换成新的，然后重置数据库并且再次执行<code>migrate up</code>。但是，这么干在实际项目中显然是不可能的。因为需求一直在改，可能我们需要增加新表的时候，数据库已经投入到产品中了，不可能删库的。</p>\n<p>所以正确的合并变化的方式是创建一个新的migration版本</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">migrate create -ext sql -dir db/migration -seq add_users</span><br></pre></td></tr></table></figure>\n<p>我们用一些参数来告诉migrate输出的file要以sql作为文件扩展名，并且输出到<code>db/migration</code>，并且用一个序列数字作为文件的前缀，生成的文件名是<code>add_user</code></p>\n<h3 id=\"实现up-migration\">实现up migration</h3>\n<p>首先我们需要创建user表，所以我们将之前生成的SQL查询语句复制到新生成的up文件中，接着我们复制一个添加外键限制的查询语句到<code>account</code>表的<code>owner</code>字段中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE <span class=\"string\">&quot;users&quot;</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;username&quot;</span> varchar PRIMARY KEY,</span><br><span class=\"line\">  <span class=\"string\">&quot;hashed_password&quot;</span> varchar NOT NULL,</span><br><span class=\"line\">  <span class=\"string\">&quot;full_name&quot;</span> varchar NOT NULL,</span><br><span class=\"line\">  <span class=\"string\">&quot;email&quot;</span> varchar UNIQUE NOT NULL,</span><br><span class=\"line\">  <span class=\"string\">&quot;password_changed_at&quot;</span> timestamptz NOT NULL DEFAULT(<span class=\"string\">&#x27;0001-01-01 00:00:00Z&#x27;</span>),  </span><br><span class=\"line\">  <span class=\"string\">&quot;created_at&quot;</span> timestamptz NOT NULL DEFAULT (now())</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">ALTER TABLE <span class=\"string\">&quot;accounts&quot;</span> ADD FOREIGN KEY (<span class=\"string\">&quot;owner&quot;</span>) REFERENCES <span class=\"string\">&quot;users&quot;</span> (<span class=\"string\">&quot;username&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE UNIQUE INDEX ON <span class=\"string\">&quot;accounts&quot;</span> (<span class=\"string\">&quot;owner&quot;</span>, <span class=\"string\">&quot;currency&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>这样看起来已经很好了，但是我们还能有另一种方法，让每一个用户对每一种货币最多能有一个账户。我们不是使用一个unique索引，而是添加一个unique限制对每一个<code>owner</code>和<code>currency</code>对。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- CREATE UNIQUE INDEX ON &quot;accounts&quot; (&quot;owner&quot;, &quot;currency&quot;);</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> &quot;accounts&quot; <span class=\"keyword\">ADD</span> <span class=\"keyword\">CONSTRAINT</span> &quot;owner_currency_key&quot; <span class=\"keyword\">UNIQUE</span> (&quot;owner&quot;, &quot;currency&quot;);</span><br></pre></td></tr></table></figure>\n<p>这两种方法其实在底层是差不多的，都可以使用。</p>\n<h3 id=\"执行miagrate-up\">执行miagrate up</h3>\n<p>我们使用make migrateup命令来更新我们的改动，但是报错了。这是因为我们在account表中已经存在数据了但是在user表中没有，导致两表之间没有建立连接。所以在这个例子中，我们不得不清除掉所有的已经存在的数据，在执行刚才的命令之前。这是可行的，因为我们目前的系统还没有准备好部署呢。</p>\n<p>但是需要注意的是，由于刚才的操作失败了，它会将当前的schema改成版本2但是是以一个dirty状态。所以如果我们这时候运行down的话，我们会得到一个错误因为现在的版本是dirty的。我们可以手动去修改这个dirty标志为false，然后再运行<code>make migratedown</code>使它数据清空。然后我们再运行<code>make migrateup</code>来生成我们的数据库。</p>\n<h3 id=\"实现migration-down\">实现migration down</h3>\n<p>刚才我们为我们新创建的up文件进行了实现，接下来我们要实现我们刚刚创建的down文件。首先我们要丢弃<code>owner</code>和<code>currency</code>的特殊约束。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> &quot;accounts&quot; <span class=\"keyword\">DROP</span> <span class=\"keyword\">CONSTRAINT</span> IF <span class=\"keyword\">EXISTS</span> &quot;owner_currency_key&quot;;</span><br></pre></td></tr></table></figure>\n<p>接着我们用相同的方法丢弃掉owner的外键约束，但是我们这个时候怎么能知道这个外键约束的名称呢？我们可以点击tableplus窗口下方的info按钮获取到当前表的定义，其中会给出外键约束的名称。在这里我们的名称是<code>accounts_owner_fkey</code>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> &quot;accounts&quot; <span class=\"keyword\">DROP</span> <span class=\"keyword\">CONSTRAINT</span> IF <span class=\"keyword\">EXISTS</span> &quot;accounts_owner_fkey&quot;;</span><br></pre></td></tr></table></figure>\n<p>最后一步我们要把user表删掉就可以了。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> &quot;users&quot;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试up和down的migration\">测试up和down的migration</h3>\n<p>由于目前我们makefile中已经有一个make migratedown所以为了能够执行这个第二版本的down我们新增一个down1，其内容和之前是一样的，只是最后需要增加一个参数1，它的意思是只rollback到最后一个migration。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">migratedown1:</span></span><br><span class=\"line\">  migrate -path db/migration -database <span class=\"string\">&quot;postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable&quot;</span> -verbose down 1</span><br></pre></td></tr></table></figure>\n<p>对于up我们也是相同的做法，只向下up一层</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">migrateup1:</span></span><br><span class=\"line\">  migrate -path db/migration -database <span class=\"string\">&quot;postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable&quot;</span> -verbose up 1</span><br></pre></td></tr></table></figure>\n<p>然后把这两个添加到phony列表中。</p>\n<h2 id=\"如何正确处理DB错误\">如何正确处理DB错误</h2>\n<p>上一节中我们已经添加了一个新的user表到我们的数据库中，接下来我们就需要更改我们的代码来使它能够在这个表上工作，而且还要处理pg返回的一些特殊错误。</p>\n<h3 id=\"生成代码来创建和获取user\">生成代码来创建和获取user</h3>\n<p>首先我们需要创建一个新的<code>user.sql</code>文件，在这个文件中我们需要写两个SQL语句来创建和获取users。他们在结构上和我们之前对account的创建和获取应该是相似的。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- name: CreateUser :one</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> users (</span><br><span class=\"line\">  username,</span><br><span class=\"line\">  hashed_password,</span><br><span class=\"line\">  full_name,</span><br><span class=\"line\">  email</span><br><span class=\"line\">) <span class=\"keyword\">VALUES</span> (</span><br><span class=\"line\">  $<span class=\"number\">1</span>, $<span class=\"number\">2</span>, $<span class=\"number\">3</span>, $<span class=\"number\">4</span></span><br><span class=\"line\">) RETURNING <span class=\"operator\">*</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- name: GetUser :one</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> username <span class=\"operator\">=</span> $<span class=\"number\">1</span> LIMIT <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>然后用sqlc自动生成对应的代码。我们现在可以去<code>db/sqlc/models.go</code>中观察到一个新的结构体User已经出现了。</p>\n<h3 id=\"接下来需要给生成的代码编写测试\">接下来需要给生成的代码编写测试</h3>\n<p>我们可以使用之前对account做测试的文件中的一部分进行测试，其在本质上是差不多的。编写完成后发现对于单独的user的两个函数可以通过，但是要运行整个包通过就不可以了，因为我们的owner的外键约束还不存在呢！</p>\n<h3 id=\"修复失败了的测试\">修复失败了的测试</h3>\n<p>我们能够注意到，account_test中其创建的随机账户的owner并没有关联到我们的user表中，为了解决这个问题我们需要在数据库中创建一个用户。然后，我们不再是随机创建一个owner而是用已经创建好的account owner。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createRandomAccount</span><span class=\"params\">(t *testing.T)</span> <span class=\"title\">Account</span></span> &#123;</span><br><span class=\"line\">    user := createRandomUser(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    arg := CreateAccountParams&#123;</span><br><span class=\"line\">        Owner:    user.Username,</span><br><span class=\"line\">        Balance:  util.RandomMoney(),</span><br><span class=\"line\">        Currency: util.RandomCurrency(),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们再运行整个包，发现全部通过。但是需要注意，这只是运行了所有db包中的测试，我们还没有运行api包中的测试呢。再命令行输入 make test来运行所有的测试。</p>\n<p>我们会发现报错了，因为我们的mockstore没有实现db.Store接口。它缺失了一些函数的实现。这是因为我们运行sqlc生成代码的时候多出来两个函数<code>CreateUser</code>和<code>GetUser</code>被添加到了<code>Queries</code>接口中了，而<code>Queries</code>接口是<code>db.Store</code>接口的一部分。</p>\n<p>为了解决这个问题，我们需要将mock代码再次生成一次 <code>make mock</code>,之后再进行测试就会发现没问题了。</p>\n<h3 id=\"处理不同类型的DB错误\">处理不同类型的DB错误</h3>\n<p>接下来我们运行make server，然后打开postman来测试目前已经存在的api。</p>\n<p>首先我们尝试为一个不存在数据库中的user创建一个账户。显而易见它会报错，但是它报的是内部服务器错误，这个状态码明显不是我们要的，因为这是客户端的错误，它不应该给一个不存在的用户创建账户。这里返回的最好应该是<code>403 forbidden</code>。</p>\n<p>我们在<code>api/account.go</code>下面找到<code>creatAccount</code>函数，如果返回了一个错误的话，我们将会尝试将他转成<code>pg.Error</code>类型并且赋给一个<code>pgErr</code>变量</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createAccount</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    account, err := server.store.CreateAccount(ctx, arg)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pqErr, ok := err.(*pq.Error); ok &#123;</span><br><span class=\"line\">            log.Println(pqErr.Code.Name())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.JSON(http.StatusOK, account)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们重启服务器，发现这一次报的错误是我们想要的了。我们一会可以利用它对错误进行分类。</p>\n<p>现在我们想要对一个已经存在的用户创建一个账户，这一次能够成功，但是要是我们再进行一次重复操作呢？即对这个用户再创建一个相同的账户。就会报一个owner_currency的键的错误了。这一次我们同样希望它报的错误是403而不是500，然后我们看log中的错误，发现是<code>unique_violation</code>，这样我们就可以回到代码中进行更新</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createAccount</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    account, err := server.store.CreateAccount(ctx, arg)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pqErr, ok := err.(*pq.Error); ok &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> pqErr.Code.Name() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;foreign_key_violation&quot;</span>, <span class=\"string\">&quot;unique_violation&quot;</span>:</span><br><span class=\"line\">                ctx.JSON(http.StatusForbidden, errorResponse(err))</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.JSON(http.StatusOK, account)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何安全地存储密码\">如何安全地存储密码</h2>\n<p>之前已经提到我们不可以直接存储密码到数据库中，所以我们可以先对他做hash变换然后只存储hash值。基本上使用<code>bcrypt</code>hashing函数来实现的。除了原本的密码，这个函数还需要一个<code>cost</code>参数，它将会决定算法的密钥扩展轮次或者迭代次数。</p>\n<p><code>bcrypt</code>同样生成一个随机的<code>salt</code>用于这些迭代中，将会有助于抵抗<a href=\"https://en.wikipedia.org/wiki/Rainbow_table\">rainbow table attack</a>。因为存在随机的<code>salt</code>，所以算法每次都会给出一个完全不同的输出hash值，即便输入的密码是相同的。</p>\n<p><img src=\"https://i.imgur.com/Ai2hmEK.png\" alt=\"picture 1\"></p>\n<p><code>cost</code>和<code>salt</code>参数会被添加到hash中来生成最终的hash字符串。这个hash字符串包含4个部分：</p>\n<ul>\n<li>第一个部分是算法id，<code>2A</code>的意思是<code>bcrypt</code>算法</li>\n<li>第二个部分是cost，在本例子中cost是10，意思是<code>2^10</code>次密钥扩展</li>\n<li>第三个部分是长度为16byte的<code>salt</code>，它是使用<code>base64</code>格式化编码的，将会生成一个22个字符的字符串</li>\n<li>最后是24个字节的hash值，被编码为31个字符</li>\n</ul>\n<p>所有这些部分会连接到一个单独的hash字符串中，并且这个字符串就是我们需要存储到数据库中的字符串。</p>\n<p>那么当用户登陆的时候我们怎么验证这个密码呢？首先我们找到这个账户对应的密码，然后我们用密码中的<code>cost</code>和<code>salt</code>作为hash函数的参数，然后对用户输入的密码进行hash处理，如果结果和数据库中的密码结果是一样的，那么验证成功。</p>\n<h3 id=\"实现hash和比较密码\">实现hash和比较密码</h3>\n<p>对于实现hash密码函数，我们先在<code>util</code>包下面创建一个<code>password.go</code>文件，其中我们定义一个新的函数<code>HashPassword()</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HashPassword returns the bcrypt hash of the password</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HashPassword</span><span class=\"params\">(password <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">    hashedPassword, err := bcrypt.GenerateFromPassword([]<span class=\"keyword\">byte</span>(password), bcrypt.DefaultCost)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, fmt.Errorf(<span class=\"string\">&quot;failed to hash password: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">string</span>(hashedPassword), <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个函数中我们直接调用<code>bcrypt</code>包来生成我们的hash密码。</p>\n<p>接下来我们需要进行密码的比较，由于我们已经在上面定义了hash转换。所以我们可以对用户输入的密码做转换然后和数据库中的密码进行比较</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CheckPassword checks if the provided password is correct or not</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CheckPassword</span><span class=\"params\">(password <span class=\"keyword\">string</span>, hashedPassword <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bcrypt.CompareHashAndPassword([]<span class=\"keyword\">byte</span>(hashedPassword), []<span class=\"keyword\">byte</span>(password))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"为这两个函数写单元测试\">为这两个函数写单元测试</h3>\n<p>我们在<code>util</code>包下面创建一个新的文件<code>password_test.go</code>来对刚才的两个函数进行测试。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestPassword</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    password := RandomString(<span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    hashedPassword, err := HashPassword(password)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.NotEmpty(t, hashedPassword)</span><br><span class=\"line\"></span><br><span class=\"line\">    err = CheckPassword(password, hashedPassword1)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们就测试了密码正确时的情景，下面我们用一个错误密码进行测试</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestPassword</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    password := RandomString(<span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    hashedPassword, err := HashPassword(password)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.NotEmpty(t, hashedPassword)</span><br><span class=\"line\"></span><br><span class=\"line\">    wrongPassword := RandomString(<span class=\"number\">6</span>)</span><br><span class=\"line\">    err = CheckPassword(wrongPassword, hashedPassword)</span><br><span class=\"line\">    require.EqualError(t, err, bcrypt.ErrMismatchedHashAndPassword.Error())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"更新现有的代码\">更新现有的代码</h3>\n<p>目前我们已经能够对密码进行hash，因此我们需要返回<code>user_test.go</code>中的<code>creatRandomUser()</code>函数，使用<code>hashedPassword</code>来替换原本的随机密码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createRandomUser</span><span class=\"params\">(t *testing.T)</span> <span class=\"title\">User</span></span> &#123;</span><br><span class=\"line\">    hashedPassword, err := util.HashPassword(util.RandomString(<span class=\"number\">6</span>))</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    arg := CreateUserParams&#123;</span><br><span class=\"line\">        Username:       util.RandomOwner(),</span><br><span class=\"line\">        HashedPassword: hashedPassword,</span><br><span class=\"line\">        FullName:       util.RandomOwner(),</span><br><span class=\"line\">        Email:          util.RandomEmail(),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们就可以对整个包进行测试，发现全部测试成功！并且我们能够在数据库中发现密码已经变成我们生成的hash值了。</p>\n<h3 id=\"确保所有的hashedpassword都是不同的\">确保所有的hashedpassword都是不同的</h3>\n<p>我们需要保证即便输入两次相同的密码我们生成的hash密码应该是不一样的。所以我们回到<code>password_test.go</code>文件中，对其进行一定的修改然后进行测试。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestPassword</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    password := RandomString(<span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    hashedPassword1, err := HashPassword(password)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.NotEmpty(t, hashedPassword1)</span><br><span class=\"line\"></span><br><span class=\"line\">    err = CheckPassword(password, hashedPassword1)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    wrongPassword := RandomString(<span class=\"number\">6</span>)</span><br><span class=\"line\">    err = CheckPassword(wrongPassword, hashedPassword1)</span><br><span class=\"line\">    require.EqualError(t, err, bcrypt.ErrMismatchedHashAndPassword.Error())</span><br><span class=\"line\"></span><br><span class=\"line\">    hashedPassword2, err := HashPassword(password)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.NotEmpty(t, hashedPassword2)</span><br><span class=\"line\">    require.NotEqual(t, hashedPassword1, hashedPassword2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行测试之后发现能够成功！</p>\n<h3 id=\"实现创建user的API\">实现创建user的API</h3>\n<p>下一步我们需要使用<code>HashPassword()</code>函数来实现创建用户的API。我们先在api包下创建一个<code>user.go</code>的新文件。之前我们作为创建账户的api，创建用户的api和这个是非常相像的，所以我们可以直接赋值过来。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> createUserRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Username <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;username&quot; binding:&quot;required,alphanum&quot;`</span></span><br><span class=\"line\">    Password <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;password&quot; binding:&quot;required,min=6&quot;`</span></span><br><span class=\"line\">    FullName <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;full_name&quot; binding:&quot;required&quot;`</span></span><br><span class=\"line\">    Email    <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;email&quot; binding:&quot;required,email&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中比较重要的是最后一个email，因为我们需要确保email正确能够沟通，所以我们增加一个<code>email</code> tag来确保这个邮箱是正确的。其实在validator包中有很多好用的tag，我们可以在<a href=\"https://pkg.go.dev/github.com/go-playground/validator/v10\">官方文档</a>中查看他们。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createUser</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> req createUserRequest</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := ctx.ShouldBindJSON(&amp;req); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    hashedPassword, err := util.HashPassword(req.Password)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    arg := db.CreateUserParams&#123;</span><br><span class=\"line\">        Username:       req.Username,</span><br><span class=\"line\">        HashedPassword: hashedPassword,</span><br><span class=\"line\">        FullName:       req.FullName,</span><br><span class=\"line\">        Email:          req.Email,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    user, err := server.store.CreateUser(ctx, arg)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pqErr, ok := err.(*pq.Error); ok &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> pqErr.Code.Name() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;unique_violation&quot;</span>:</span><br><span class=\"line\">                ctx.JSON(http.StatusForbidden, errorResponse(err))</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.JSON(http.StatusOK, user)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意，对于传过来的密码我们要通过哈希加密之后才能传入数据库。</p>\n<p>正如在创建账户API中的一样，如果存在错误的话我们可能会有多个场景，需要记住，在用户表中我们有两个unique约束</p>\n<ul>\n<li>一个是用户名</li>\n<li>一个是邮箱</li>\n</ul>\n<p>在这个表中我们没有外键，所以我们只需要保留<code>unique_violation</code>来返回403错误就可以了</p>\n<p>接着我们需要在<code>NewServer()</code>函数中增加一个新的路径，我们使用POST方法，路径应当是<code>/users</code>，并且它的handler应当为<code>server.createUser</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NewServer creates a new HTTP server and set up routing.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    server := &amp;Server&#123;store: store&#125;</span><br><span class=\"line\">    router := gin.Default()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class=\"line\">        v.RegisterValidation(<span class=\"string\">&quot;currency&quot;</span>, validCurrency)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/users&quot;</span>, server.createUser)</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts/:id&quot;</span>, server.getAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts&quot;</span>, server.listAccounts)</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/transfers&quot;</span>, server.createTransfer)</span><br><span class=\"line\"></span><br><span class=\"line\">    server.router = router</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们就可以在postman中测试我们创建的这个api是否成功拉！</p>\n<h3 id=\"API不能暴露hash映射后的密码\">API不能暴露hash映射后的密码</h3>\n<p>在我们彻底完成之前，我们需要注意我们测试时服务器给我们返回的信息中包含了我们的密码哈希值，但是这显然是没必要的，因为客户端永远不会用到这个哈希值。并且这也会造成一些安全性的问题，我们最好从response中删除这一条信息。</p>\n<p>因此我们创建一个结构体作为返回对象，其中不需要password这一字段，另外在最后的return之前我们将user的内容转移到这个结构体的实例上面就可以了</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> createUserResponse <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Username          <span class=\"keyword\">string</span>    <span class=\"string\">`json:&quot;username&quot;`</span></span><br><span class=\"line\">    FullName          <span class=\"keyword\">string</span>    <span class=\"string\">`json:&quot;full_name&quot;`</span></span><br><span class=\"line\">    Email             <span class=\"keyword\">string</span>    <span class=\"string\">`json:&quot;email&quot;`</span></span><br><span class=\"line\">    PasswordChangedAt time.Time <span class=\"string\">`json:&quot;password_changed_at&quot;`</span></span><br><span class=\"line\">    CreatedAt         time.Time <span class=\"string\">`json:&quot;created_at&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createUser</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    user, err := server.store.CreateUser(ctx, arg)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pqErr, ok := err.(*pq.Error); ok &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> pqErr.Code.Name() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;unique_violation&quot;</span>:</span><br><span class=\"line\">                ctx.JSON(http.StatusForbidden, errorResponse(err))</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    rsp := createUserResponse&#123;</span><br><span class=\"line\">        Username:          user.Username,</span><br><span class=\"line\">        FullName:          user.FullName,</span><br><span class=\"line\">        Email:             user.Email,</span><br><span class=\"line\">        PasswordChangedAt: user.PasswordChangedAt,</span><br><span class=\"line\">        CreatedAt:         user.CreatedAt,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ctx.JSON(http.StatusOK, rsp)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"用自定义的go-mock匹配器写高效的单元测试\">用自定义的go-mock匹配器写高效的单元测试</h3>\n<p>通过go-mock我们可以很轻松的对我们刚才实现的API做单元测试，但是如果我们自己来写单元测试的话，我们会发现这会有点小插曲在里面。因为输入的密码参数在存入数据库之前经过了hash变换。</p>\n<p>为了更好地理解威慑呢蜜，我们先看下面这个版本的测试</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCreateUserAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    user, password := randomUser(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    testCases := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        name          <span class=\"keyword\">string</span></span><br><span class=\"line\">        body          gin.H</span><br><span class=\"line\">        buildStubs    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span></span><br><span class=\"line\">        checkResponse <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recoder *httptest.ResponseRecorder)</span></span></span><br><span class=\"line\">    &#125;&#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&quot;OK&quot;</span>,</span><br><span class=\"line\">            body: gin.H&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;username&quot;</span>:  user.Username,</span><br><span class=\"line\">                <span class=\"string\">&quot;password&quot;</span>:  password,</span><br><span class=\"line\">                <span class=\"string\">&quot;full_name&quot;</span>: user.FullName,</span><br><span class=\"line\">                <span class=\"string\">&quot;email&quot;</span>:     user.Email,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class=\"line\">                    Times(<span class=\"number\">1</span>).</span><br><span class=\"line\">                    Return(user, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusOK, recorder.Code)</span><br><span class=\"line\">                requireBodyMatchUser(t, recorder.Body, user)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&quot;InternalError&quot;</span>,</span><br><span class=\"line\">            body: gin.H&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;username&quot;</span>:  user.Username,</span><br><span class=\"line\">                <span class=\"string\">&quot;password&quot;</span>:  password,</span><br><span class=\"line\">                <span class=\"string\">&quot;full_name&quot;</span>: user.FullName,</span><br><span class=\"line\">                <span class=\"string\">&quot;email&quot;</span>:     user.Email,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class=\"line\">                    Times(<span class=\"number\">1</span>).</span><br><span class=\"line\">                    Return(db.User&#123;&#125;, sql.ErrConnDone)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusInternalServerError, recorder.Code)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&quot;DuplicateUsername&quot;</span>,</span><br><span class=\"line\">            body: gin.H&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;username&quot;</span>:  user.Username,</span><br><span class=\"line\">                <span class=\"string\">&quot;password&quot;</span>:  password,</span><br><span class=\"line\">                <span class=\"string\">&quot;full_name&quot;</span>: user.FullName,</span><br><span class=\"line\">                <span class=\"string\">&quot;email&quot;</span>:     user.Email,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class=\"line\">                    Times(<span class=\"number\">1</span>).</span><br><span class=\"line\">                    Return(db.User&#123;&#125;, &amp;pq.Error&#123;Code: <span class=\"string\">&quot;23505&quot;</span>&#125;)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusForbidden, recorder.Code)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&quot;InvalidUsername&quot;</span>,</span><br><span class=\"line\">            body: gin.H&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;username&quot;</span>:  <span class=\"string\">&quot;invalid-user#1&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;password&quot;</span>:  password,</span><br><span class=\"line\">                <span class=\"string\">&quot;full_name&quot;</span>: user.FullName,</span><br><span class=\"line\">                <span class=\"string\">&quot;email&quot;</span>:     user.Email,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class=\"line\">                    Times(<span class=\"number\">0</span>)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusBadRequest, recorder.Code)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&quot;InvalidEmail&quot;</span>,</span><br><span class=\"line\">            body: gin.H&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;username&quot;</span>:  user.Username,</span><br><span class=\"line\">                <span class=\"string\">&quot;password&quot;</span>:  password,</span><br><span class=\"line\">                <span class=\"string\">&quot;full_name&quot;</span>: user.FullName,</span><br><span class=\"line\">                <span class=\"string\">&quot;email&quot;</span>:     <span class=\"string\">&quot;invalid-email&quot;</span>,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class=\"line\">                    Times(<span class=\"number\">0</span>)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusBadRequest, recorder.Code)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&quot;TooShortPassword&quot;</span>,</span><br><span class=\"line\">            body: gin.H&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;username&quot;</span>:  user.Username,</span><br><span class=\"line\">                <span class=\"string\">&quot;password&quot;</span>:  <span class=\"string\">&quot;123&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;full_name&quot;</span>: user.FullName,</span><br><span class=\"line\">                <span class=\"string\">&quot;email&quot;</span>:     user.Email,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class=\"line\">                    Times(<span class=\"number\">0</span>)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusBadRequest, recorder.Code)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和之前一样，我们可以创建一个随机的用户，然后我们声明一组测试用例，其中我们能够定义输入的请求主体，以及两个函数分别用于创建store存根和检查API的返回值。</p>\n<p>我们可以测试一些不同的案例，比如：</p>\n<ul>\n<li>成功的案例</li>\n<li>内部服务器错误案例</li>\n<li>重复用户名</li>\n<li>非法用户名、邮箱或者密码</li>\n</ul>\n<p>我们迭代所有这些例子并且为他们运行独立的子测试。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCreateUserAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> testCases &#123;</span><br><span class=\"line\">        tc := testCases[i]</span><br><span class=\"line\"></span><br><span class=\"line\">        t.Run(tc.name, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">            ctrl := gomock.NewController(t)</span><br><span class=\"line\">            <span class=\"keyword\">defer</span> ctrl.Finish()</span><br><span class=\"line\"></span><br><span class=\"line\">            store := mockdb.NewMockStore(ctrl)</span><br><span class=\"line\">            tc.buildStubs(store)</span><br><span class=\"line\"></span><br><span class=\"line\">            server := NewServer(store)</span><br><span class=\"line\">            recorder := httptest.NewRecorder()</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Marshal body data to JSON</span></span><br><span class=\"line\">            data, err := json.Marshal(tc.body)</span><br><span class=\"line\">            require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">            url := <span class=\"string\">&quot;/users&quot;</span></span><br><span class=\"line\">            request, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(data))</span><br><span class=\"line\">            require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">            server.router.ServeHTTP(recorder, request)</span><br><span class=\"line\">            tc.checkResponse(recorder)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在每一个子测试中，我们创建一个新的gomock控制器，并且用它来创建一个新的DB store。然后我们调用<code>buildStubs()</code>来为store创建存根。之后，我们使用mock store创建一个新的服务器，并且创建一个新的HTTP返回<code>recorder</code>来记录API的返回值。接着我们解析输入的请求主体并且向API终端发送请求。我们调用<code>server.router.ServeHTTP()</code>，最后调用<code>tc.checkResponse()</code>来检查结果。</p>\n<p>这相当简单，就和我们之前做的一样。而现在，对于这一章节我们只需要注重于成功的例子</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCreateUserAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    user, password := randomUser(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    testCases := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        name          <span class=\"keyword\">string</span></span><br><span class=\"line\">        body          gin.H</span><br><span class=\"line\">        buildStubs    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span></span><br><span class=\"line\">        checkResponse <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recoder *httptest.ResponseRecorder)</span></span></span><br><span class=\"line\">    &#125;&#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&quot;OK&quot;</span>,</span><br><span class=\"line\">            body: gin.H&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;username&quot;</span>:  user.Username,</span><br><span class=\"line\">                <span class=\"string\">&quot;password&quot;</span>:  password,</span><br><span class=\"line\">                <span class=\"string\">&quot;full_name&quot;</span>: user.FullName,</span><br><span class=\"line\">                <span class=\"string\">&quot;email&quot;</span>:     user.Email,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class=\"line\">                    Times(<span class=\"number\">1</span>).</span><br><span class=\"line\">                    Return(user, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusOK, recorder.Code)</span><br><span class=\"line\">                requireBodyMatchUser(t, recorder.Body, user)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里的<code>buildstubs</code>函数中，我们用两个<code>gomock.Any()</code>函数来匹配<code>CreateUser()</code>函数的两个参数，这对于第一个参数上下文环境是合理的，但是对于第二个参数我们就无法判断是否输入的是合理的参数了。但是我们先这样用。</p>\n<p>我们输入一个成功案例并且进行测试，发现是可以的，但是如果我们将输入的参数设置为空，再运行测试发现还是可行的。这样的话就非常糟糕，因为我们的处理是错误的，但是测试竟然通过了！</p>\n<p>此外我们加入忽视用户生成的密码，而改用一个常量<code>weirdo</code>作为密码并且做hash转换，发现仍然不会报错。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createUser</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    hashedPassword, err := util.HashPassword(<span class=\"string\">&quot;xyz&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    arg := db.CreateUserParams&#123;</span><br><span class=\"line\">        Username:       req.Username,</span><br><span class=\"line\">        HashedPassword: hashedPassword,</span><br><span class=\"line\">        FullName:       req.FullName,</span><br><span class=\"line\">        Email:          req.Email,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    user, err := server.store.CreateUser(ctx, arg)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pqErr, ok := err.(*pq.Error); ok &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> pqErr.Code.Name() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;unique_violation&quot;</span>:</span><br><span class=\"line\">                ctx.JSON(http.StatusForbidden, errorResponse(err))</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"尝试使用gomock-Eq\">尝试使用<code>gomock.Eq</code></h3>\n<p>我们可以想到如果不使用<code>gomock.Any()</code>来作为替代呢，我们用别的，比如<code>gomock.Eq()</code>.</p>\n<p>首先我们声明一个新的arg变量是<code>db.CreateUserParams</code>，其中username是<code>user.Username</code>。对于<code>hashed_password</code>这一字段，我们需要映射输入的密码。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCreateUserAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    user, password := randomUser(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    hashedPassword, err := util.HashPassword(password)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    testCases := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        name          <span class=\"keyword\">string</span></span><br><span class=\"line\">        body          gin.H</span><br><span class=\"line\">        buildStubs    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span></span><br><span class=\"line\">        checkResponse <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recoder *httptest.ResponseRecorder)</span></span></span><br><span class=\"line\">    &#125;&#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&quot;OK&quot;</span>,</span><br><span class=\"line\">            body: gin.H&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;username&quot;</span>:  user.Username,</span><br><span class=\"line\">                <span class=\"string\">&quot;password&quot;</span>:  password,</span><br><span class=\"line\">                <span class=\"string\">&quot;full_name&quot;</span>: user.FullName,</span><br><span class=\"line\">                <span class=\"string\">&quot;email&quot;</span>:     user.Email,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                arg := db.CreateUserParams&#123;</span><br><span class=\"line\">                    Username: user.Username,</span><br><span class=\"line\">                    HashedPassword: hashedPassword,</span><br><span class=\"line\">                    FullName: user.FullName,</span><br><span class=\"line\">                    Email: user.Email,</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    CreateUser(gomock.Any(), gomock.Eq(arg)).</span><br><span class=\"line\">                    Times(<span class=\"number\">1</span>).</span><br><span class=\"line\">                    Return(user, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusOK, recorder.Code)</span><br><span class=\"line\">                requireBodyMatchUser(t, recorder.Body, user)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们用<code>gomock.Eq(arg)</code>来代替<code>gomock.Any()</code>。接下来我们测试如果传入的是空的值是否可以通过测试，发现确实不能通过了！这就对了，但是如果我们把这个传入的值设置为正确的值，结果发现不能通过。</p>\n<p>这是因为传入的值和gomock期待的值是不一样的，我们在log中可以看到，只有hashedpassword字段没有通过。我们还记得上一节说提到过，同样的密码经过hash得到的值也会是不一样的，因此我们的匹配不会成功。</p>\n<p>唯一能解决这个问题的办法似乎只能是我们自定义一个匹配器了。</p>\n<h3 id=\"实现自定义gomock匹配器\">实现自定义gomock匹配器</h3>\n<p>首先我们移除掉<code>hashedPassword</code>因为这部是我们在自定义匹配器中所需要的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Eq</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">Matcher</span></span> &#123; <span class=\"keyword\">return</span> eqMatcher&#123;x&#125; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Matcher <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Matches returns whether x is a match.</span></span><br><span class=\"line\">    Matches(x <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"keyword\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// String describes what the matcher matches.</span></span><br><span class=\"line\">    String() <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于我们自定义的匹配器而言，我们将写一个类似的实现，它只有两个方法：</p>\n<ul>\n<li><code>Matches()</code>，它应当返回输入<code>x</code>是否是一个匹配</li>\n<li><code>String()</code>，它描述匹配器匹配了哪些内容，用于日志的记录</li>\n</ul>\n<p>这是我们正在使用的相等匹配器的代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> eqMatcher <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    x <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e eqMatcher)</span> <span class=\"title\">Matches</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reflect.DeepEqual(e.x, x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e eqMatcher)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;is equal to %v&quot;</span>, e.x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们自定义的匹配器应该和它非常相像所以我把它复制到<code>user_test.go</code>文件的最上方，然后对他进行修改.</p>\n<p>首先我们把结构体的名字改成<code>eqCreateUserParamsMatcher</code>，并且为了正确比较输入的参数，我们需要两个字段</p>\n<ul>\n<li>首先是<code>arg</code>字段，它是<code>db.CreateUserParams</code>类型的</li>\n<li>第二个是password字段，存储最原始的密码值</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> eqCreateUserParamsMatcher <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    arg      db.CreateUserParams</span><br><span class=\"line\">    password <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在让我们实现<code>Matches()</code>函数，因为输入<code>x</code>是一个接口，我们应当把它转换为<code>db.CreateUserParams</code>对象。</p>\n<p>如果转换不成功我们返回错误，如果转换成功，我们检测输入的密码是否和hash转换后的密码相同</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e eqCreateUserParamsMatcher)</span> <span class=\"title\">Matches</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    arg, ok := x.(db.CreateUserParams)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err := util.CheckPassword(e.password, arg.HashedPassword)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    e.arg.HashedPassword = arg.HashedPassword</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reflect.DeepEqual(e.arg, arg)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们再修改其他的函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e eqCreateUserParamsMatcher)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;matches arg %v and password %v&quot;</span>, e.arg, e.password)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">EqCreateUserParams</span><span class=\"params\">(arg db.CreateUserParams, password <span class=\"keyword\">string</span>)</span> <span class=\"title\">gomock</span>.<span class=\"title\">Matcher</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> eqCreateUserParamsMatcher&#123;arg, password&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"在基于令牌的验证上为什么PASETO比JWT好\">在基于令牌的验证上为什么PASETO比JWT好</h2>\n<h3 id=\"基于令牌的验证\">基于令牌的验证</h3>\n<p>我们先了解一下基于令牌的验证。大体来说，在验证机制中，客户端会发起第一个请求来登陆账户，它会向客户端提供用户名和密码。然后服务器会检查用户名是否是正确的，如果是的话服务器会创建并且登记一个token，然后返回一个<code>200 ok</code>和产生的这个token一块到客户端。</p>\n<p>之所以这个token会被称为通行token是因为稍后客户端会通过它来获取服务器上面的资源。比如说客户端想要获取到当前user名下的所有银行账户，他需要发送一个<code>GET/accounts</code>请求到服务器，通行token会被嵌入在请求的头部。受到请求的时候，服务器会验证这个令牌是否是有效的，如果请求是被允许的话，就会返回<code>200 ok</code>和该user的银行账户列表。</p>\n<p>需要注意通行token通常是有生命周期的，在这个期间，客户端可以用相同的令牌向服务器发送多个请求。</p>\n<h3 id=\"JSON-Web-Tkoen-JWT\">JSON Web Tkoen(JWT)</h3>\n<p><img src=\"https://i.imgur.com/HNe1dBh.png\" alt=\"picture 1\"></p>\n<p>上图是一个JSON Web Token的例子，它基于64位字符串编码，由3个主要部分组成，中间由点分割开：</p>\n<ul>\n<li>第一部分是红色的部分，是令牌的头部，当我们解码这一部分的时候，我们将会获得一个JSON对象，其中包含令牌的类型<code>JWT</code>，和用于登记令牌的算法<code>HS256</code></li>\n<li>第二部分是紫色的部分，这一部分是我们保存当前登陆用户的信息的部分，比如用户名和该令牌的生命截止的时间戳。</li>\n</ul>\n<p>我们可以自定义这个JSON来存储一些别的信息，在这个例子中我们有一个ID字段来标识令牌。当令牌泄漏我们需要撤销令牌的权限的时候会派上用场。存储在JWT中的数据只是基于64位的编码，而不是加密，我们不需要用服务器的密钥来对它进行解密内容。这意味着我们可以很轻松地对头部和有效信息部分进行编码。那么服务器如何验证这个令牌的权限呢？</p>\n<p>这就是第三部分需要做的了</p>\n<ul>\n<li>数字签名，这个思路很简单，只有服务器拥有密钥来注册令牌，所以如果有黑客再没有正确密钥情况下尝试去创建一个虚假的令牌，服务器会很容易发现这一行为。</li>\n</ul>\n<p>JWT标准提供了许多不同种类的数字签名算法，但是总体上能够概括为两个主要类别</p>\n<h4 id=\"对称密钥算法\">对称密钥算法</h4>\n<p>在注册和验证密钥期间使用相同的密钥，因为只有一个密钥，它必须要保密。所以这个算法只适合本地用户，换句话说就是内部服务器。这个算法在大部分应用的情况下都是有效并且合适的。</p>\n<p>但是我们不能在存在第三方服务需要验证令牌的时候使用它，因为这意味着我们必须把密钥交给第三方。</p>\n<h4 id=\"非对称密钥算法\">非对称密钥算法</h4>\n<p>私有密钥用于注册令牌，公共密钥用于验证。</p>\n<h4 id=\"JWT存在的问题\">JWT存在的问题</h4>\n<ul>\n<li>算法太弱：JWT提供的算法中有很多已知比较脆弱的算法，对于开发新手来说，很难知道哪一个算法是最合适的。</li>\n<li>简单的令牌伪造：如果选了一个不恰当的库，我们的系统会成为极易攻破的目标。JWT将注册算法放在了令牌的头部，因此攻击者可以向令牌中这个位置设置none来绕过签名验证过程。虽然这个问题在大部分库中被解决了，但是我们在选择的时候仍然需要小心。</li>\n</ul>\n<h3 id=\"PASETO-Platform-Agnostic-Security-Token\">PASETO-Platform Agnostic Security Token</h3>\n<h4 id=\"强力算法\">强力算法</h4>\n<p>它解决了所有JSON Web Token中存在的问题，并且开发者不再需要选择算法，而是只需要选择PASETO的版本。同一时刻只有两个PASETO版本是可用的。</p>\n<p>版本1比较老旧并且只能用于不能使用现代密码学的遗留系统。</p>\n<p>和JWT类似，PASETO对于两种主要情况同样有两个算法总类，对于本地和内部服务器而言，可以使用对称密钥算法。但是和JWT不同的是，PASETO会在令牌中进行加密和验证所有的信息。对于公共服务器的情况，我们还是使用非对称密钥算法，可JWT一样不对令牌信息进行编码。</p>\n<p>PASETO版本2的令牌字段主要分为4个部分，用点分割开</p>\n<ul>\n<li>第一部分是PASETO的版本</li>\n<li>第二部分是令牌的目的，是用于本地还是公共场景</li>\n<li>第三个部分是令牌承载的有效信息的主要内容，注意这是加密的，我们需要用密钥对它进行解密，这之后我们得到三个小部分\n<ul>\n<li>有效信息主体</li>\n<li>用于加密和验证的随机数</li>\n<li>信息验证标签，用于验证加密信息和与之相关的未加密信息</li>\n</ul>\n</li>\n<li>最后一部分可以存储任何公共信息，因为它不会被加密，这一部分是可以选择的</li>\n</ul>\n<h2 id=\"如何用go创建和验证JWT和PASETO\">如何用go创建和验证JWT和PASETO</h2>\n<h3 id=\"声明制作令牌的接口\">声明制作令牌的接口</h3>\n<p>我们创建一个新的包<code>token</code>，然后在其中创建一个新的文件<code>make.go</code>。思路是声明一个总的<code>token.Maker</code>接口来管理令牌的创建和验证。然后我们会写一个<code>JWTMaker</code>和<code>PasetoMaker</code>结构体来实现这个接口。通过这样做，我们能够很轻松地在不同种类的令牌制造。</p>\n<p>这个接口应当有两个方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Maker <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    CreateToken(username <span class=\"keyword\">string</span>, duration time.Duration) (<span class=\"keyword\">string</span>, error)</span><br><span class=\"line\">    VerifyToken(token <span class=\"keyword\">string</span>) (*Payload, error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>CreateToken()</code>方法以<code>username</code>和<code>duration</code>作为输入，返回一个token和一个错误类型</p>\n<p><code>VerifyToken()</code>方法接收一个token然后返回<code>Payload</code>对象和一个错误类型，这个payload对象存储token的主体。</p>\n<h3 id=\"声明token的Payload结构体\">声明token的Payload结构体</h3>\n<p>我们需要创建一个<code>payload.go</code>文件，然后定义<code>Payload</code>结构体。其中最重要的是<code>Username</code>字段，用于识别token的拥有者。当使用基于验证的token的时候，一定要记住每一个token都有一个较短的验证时间，所以我们需要<code>ExpiredAt</code>字段来指明这个token什么时候会过期。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Payload <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ID        uuid.UUID <span class=\"string\">`json:&quot;id&quot;`</span></span><br><span class=\"line\">    Username  <span class=\"keyword\">string</span>    <span class=\"string\">`json:&quot;username&quot;`</span></span><br><span class=\"line\">    IssuedAt  time.Time <span class=\"string\">`json:&quot;issued_at&quot;`</span></span><br><span class=\"line\">    ExpiredAt time.Time <span class=\"string\">`json:&quot;expired_at&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通常来说我们只需要下面这三个字段就可以了，但是如果我们想要有一个机制来取消对某些泄漏的token的权限的话，我们需要增加一个<code>ID</code>字段来独立地标志每一个token。这里我们用到的是uuid，它在<a href=\"https://github.com/google/uuid\">uuid</a>包中定义，我们可以go get一下。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get github.com/google/uuid</span><br></pre></td></tr></table></figure>\n<p>接下来我们定义一个<code>NewPayload()</code>函数，以一个<code>username</code>和<code>duration</code>作为输入参数并且返回一个<code>Payload</code>对象和一个错误。这个函数会创建一个新的带有username和duration的token payload。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewPayload</span><span class=\"params\">(username <span class=\"keyword\">string</span>, duration time.Duration)</span> <span class=\"params\">(*Payload, error)</span></span> &#123;</span><br><span class=\"line\">    tokenID, err := uuid.NewRandom()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    payload := &amp;Payload&#123;</span><br><span class=\"line\">        ID:        tokenID,</span><br><span class=\"line\">        Username:  username,</span><br><span class=\"line\">        IssuedAt:  time.Now(),</span><br><span class=\"line\">        ExpiredAt: time.Now().Add(duration),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> payload, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们先调用<code>uuid.Random()</code>来进行随机生成tokenID，然后我们定义一个payload变量，对其中字段进行赋值。</p>\n<h3 id=\"实现JWT-Maker\">实现JWT Maker</h3>\n<p>我们需要JWT的包，包的种类很多但是我们选用最流行的<a href=\"https://github.com/dgrijalva/jwt-go\">https://github.com/dgrijalva/jwt-go</a>,我们go get一下这个包。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get github.com/dgrijalva/jwt-go</span><br></pre></td></tr></table></figure>\n<p>接着我们创建一个<code>jwt_maker.go</code>文件，然后声明一个<code>JWTMaker</code>结构体，它是一个JWT maker，用于实现token.Maker接。</p>\n<p>在我们的项目中，我们使用对称密钥算法来注册token，因此结构体中应当有一个字段来保存密钥。</p>\n<p>然后我们需要增加一个<code>NewJWTMaker()</code>函数，以<code>secretKey</code>作为输入，并且返回一个token.Maker接口和一个错误类型。通过返回这个接口，我们将会保证我们的<code>JWTMaker</code>实现了<code>token.Maker</code>接口。</p>\n<p>目前，景观我们将要使用的算法不需要获得密钥的长度，确保密钥不是太短仍然是一个不错的想法。因此我们声明一个常量<code>minSecrectKeySize</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> minSecretKeySize = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewJWTMaker</span><span class=\"params\">(secretKey <span class=\"keyword\">string</span>)</span> <span class=\"params\">(Maker, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(secretKey) &lt; minSecretKeySize &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;invalid key size: must be at least %d characters&quot;</span>, minSecretKeySize)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;JWTMaker&#123;secretKey&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在函数中我们检查密钥的长度，如果不够长的话我们回报错，如果够长我们就将他的值赋给JWTMaker对应的字段。</p>\n<p>到目前这一步我们发现我们的代码中还是有错误的，因为我们创建的<code>JWTMaker</code>对象没有实现<code>token.Maker</code>所要求的方法，因此我们需要解决这个问题就要实现这两个方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *JWTMaker)</span> <span class=\"title\">CreateToken</span><span class=\"params\">(username <span class=\"keyword\">string</span>, duration time.Duration)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *JWTMaker)</span> <span class=\"title\">VerifyToken</span><span class=\"params\">(token <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Payload, error)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现JWT-CreateToken方法\">实现JWT CreateToken方法</h3>\n<p>首先我们调用<code>NewPayload()</code>方法，并且传入<code>username</code>和<code>duration</code>,然后创建一个<code>jwtToken</code>通过调用jwt-go的包里面的<code>jwt.NewWithClaims()</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *JWTMaker)</span> <span class=\"title\">CreateToken</span><span class=\"params\">(username <span class=\"keyword\">string</span>, duration time.Duration)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">    payload, err := NewPayload(username, duration)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    jwtToken := jwt.NewWithClaims(jwt.SigningMethodHS256, payload)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jwtToken.SignedString([]<span class=\"keyword\">byte</span>(maker.secretKey))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是此时我们会遇到一个错误，我们的Payload结构体并没有实现jwt.Claims接口，它缺少一个<code>Valid()</code>方法。所以我们需要为它加上这个方法。它不需要仍和的输入参数，并且仅仅返回一个错误以防token是非法的。在jwt-go包中能够很轻易地找到这个方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ErrExpiredToken = errors.New(<span class=\"string\">&quot;token has expired&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(payload *Payload)</span> <span class=\"title\">Valid</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> time.Now().After(payload.ExpiredAt) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ErrExpiredToken</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它是用于判断当前token是否已经过期的函数，当现在时间迟于token的失效时间的时候，这个token就过期了，因此需要返回一个错误，我们应当把这个错误定义为一个公共的常量<code>ErrExpiredToken</code>，这样我们就可以从外部检查这个错误类型了。</p>\n<p>接着我们回到<code>jwtmaker.go</code>文件中，我们发现刚才的红线报的错误消失了。由于我们添加了<code>jwt-go</code>包，我们需要<code>go mod tidy</code>来将他添加到<code>go.mod</code>文件中。</p>\n<h3 id=\"实现JWT-VerifyToken方法\">实现JWT VerifyToken方法</h3>\n<p>首先我们需要解析token，调用<code>jwt.ParseWithClaims</code>并且传入token，一个空的payload和一个key函数。key函数接受一个解析后的但没验证的token，我们应该验证头部以确保注册算法和我们使用的是一致的。如果匹配的话，就返回key这样jwt-go能够用它来验证token。这一步对于预防攻击很重要。</p>\n<p>下面这个就是key函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *JWTMaker)</span> <span class=\"title\">VerifyToken</span><span class=\"params\">(token <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Payload, error)</span></span> &#123;</span><br><span class=\"line\">    keyFunc := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(token *jwt.Token)</span> <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class=\"line\">        _, ok := token.Method.(*jwt.SigningMethodHMAC)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrInvalidToken</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []<span class=\"keyword\">byte</span>(maker.secretKey), <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    jwtToken, err := jwt.ParseWithClaims(token, &amp;Payload&#123;&#125;, keyFunc)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在key函数中我们能够通过<code>token.Method</code>获得它的注册算法。注意到它的类型是一个<code>SigningMethod</code>，是一个接口，所以我们需要将他转换为一个具体的实现。在我们的代码中将他转换成了<code>SigningMethodHMAC</code>，因为我们使用的是<code>HS256</code>，是属于他的实例。如果转换不成功说明他们的类型是不一致的，我们需要返回一个空key和一个<code>ErrInvalidToken</code>错误，我们一会会在<code>payload.go</code>文件中定义这个错误。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">    ErrInvalidToken = errors.New(<span class=\"string\">&quot;token is invalid&quot;</span>)</span><br><span class=\"line\">    ErrExpiredToken = errors.New(<span class=\"string\">&quot;token has expired&quot;</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>如果转换成功的话，我们将密钥转成[]byte切片并且返回。</p>\n<p>现在key函数完成了，我们可以开始调用<code>ParseWithClaims</code>函数。如果它返回一个或者没有错误，可能存在2个不同的情况：要么token非法，要么token过期。但是我们需要区分这两种情况的时候问题变得复杂了，如果我们深入jwt-go包中的话我们发现它会自动调用<code>token.Claims.Valid()</code>函数，而在我们的函数实现中我们返回的是<code>ErrExpiredToken</code>，jwt-go中隐式地将最初的错误放在了<code>ValidationError</code>对象中了。</p>\n<p>因此为了弄清真实的错误，我们需要转换<code>ParseWithClaims()</code>函数返回的错误，使它成为<code>jwt.ValidationError</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *JWTMaker)</span> <span class=\"title\">VerifyToken</span><span class=\"params\">(token <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Payload, error)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    jwtToken, err := jwt.ParseWithClaims(token, &amp;Payload&#123;&#125;, keyFunc)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        verr, ok := err.(*jwt.ValidationError)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ok &amp;&amp; errors.Is(verr.Inner, ErrExpiredToken) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrExpiredToken</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrInvalidToken</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们这里将转换后的err赋值给<code>verr</code>变量，如果转换成功，<a href=\"http://xn--errors-hz8ig3bo82im51b.Is\">我们使用errors.Is</a>()函数来检查<code>verr.Inner</code>是否是<code>ErrExpiredToken</code>。如果是的话，我们返回一个空的payload和过期错误，否则我们返回token非法错误。</p>\n<p>如果一切都是正常，并且token也成功解析和验证，我们会尝试获取它的payload信息，通过将<code>jwtToken.Claims</code>转换为一个payload对象。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *JWTMaker)</span> <span class=\"title\">VerifyToken</span><span class=\"params\">(token <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Payload, error)</span></span> &#123;</span><br><span class=\"line\">    keyFunc := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(token *jwt.Token)</span> <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class=\"line\">        _, ok := token.Method.(*jwt.SigningMethodHMAC)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrInvalidToken</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []<span class=\"keyword\">byte</span>(maker.secretKey), <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    jwtToken, err := jwt.ParseWithClaims(token, &amp;Payload&#123;&#125;, keyFunc)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        verr, ok := err.(*jwt.ValidationError)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ok &amp;&amp; errors.Is(verr.Inner, ErrExpiredToken) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrExpiredToken</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrInvalidToken</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    payload, ok := jwtToken.Claims.(*Payload)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrInvalidToken</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> payload, <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试JWT-Maker\">测试JWT Maker</h3>\n<p>在token包下面创建一个新的文件<code>jwt_maker_test.go</code>我们对这个maker进行测试。</p>\n<p>首先我们调用<code>NewJWTMaker()</code>函数并且传入一个随机的密钥。我们require一个Noerror。接着我们用util.RandomOwner()生成一个username，并且将token的生命周期设置为1分钟。</p>\n<p>我们声明两个变量来比较最后的结果：</p>\n<ul>\n<li><code>issueAt</code>时间应当是`time.Now(0</li>\n<li>在这个基础上加上<code>duration</code>就可以得到我们的截止时间</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestJWTMaker</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    maker, err := NewJWTMaker(util.RandomString(<span class=\"number\">32</span>))</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    username := util.RandomOwner()</span><br><span class=\"line\">    duration := time.Minute</span><br><span class=\"line\"></span><br><span class=\"line\">    issuedAt := time.Now()</span><br><span class=\"line\">    expiredAt := issuedAt.Add(duration)</span><br><span class=\"line\"></span><br><span class=\"line\">    token, err := maker.CreateToken(username, duration)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.NotEmpty(t, token)</span><br><span class=\"line\"></span><br><span class=\"line\">    payload, err := maker.VerifyToken(token)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.NotEmpty(t, token)</span><br><span class=\"line\"></span><br><span class=\"line\">    require.NotZero(t, payload.ID)</span><br><span class=\"line\">    require.Equal(t, username, payload.Username)</span><br><span class=\"line\">    require.WithinDuration(t, issuedAt, payload.IssuedAt, time.Second)</span><br><span class=\"line\">    require.WithinDuration(t, expiredAt, payload.ExpiredAt, time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在测试中我们先生成token，然后调用token验证来确保token合法并且返回payload信息。最后我们再一一检查payload中的各个字段。然后我们就可以运行这个单元测试了。</p>\n<p>接下来我们需要增加一个测试用于过期token。和之前类似，我们首先创建一个新的JWTMaker，然后创建一个过期token，传入一个username和负的duration就可以了。</p>\n<p>我们最后还需要验证一下非法的token，其中算法头部是None。这在上一节中说过，是一个著名的攻击技术。首先我们创建一个新的payload，然后我们创建一个新的token。然后我们要使用<code>SignedString()</code>注册token。但是这里我们不能再使用随机密钥了，因为jwt-go包中已经完全禁止使用<code>None</code>算法去注册token。我们只能在传入指定常量的时候对他做测试：<code>jwt.UnsafeAllowNoneSignatureType</code>。</p>\n<p>如果你遵循这个值的实现，你可以看到通常不允许使用无符号方法，除非输入键是这个特殊的常量。这意味着你知道你在干什么。确保你只在测试的时候这样用！</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestInvalidJWTTokenAlgNone</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    payload, err := NewPayload(util.RandomOwner(), time.Minute)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    jwtToken := jwt.NewWithClaims(jwt.SigningMethodNone, payload)</span><br><span class=\"line\">    token, err := jwtToken.SignedString(jwt.UnsafeAllowNoneSignatureType)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    maker, err := NewJWTMaker(util.RandomString(<span class=\"number\">32</span>))</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    payload, err = maker.VerifyToken(token)</span><br><span class=\"line\">    require.Error(t, err)</span><br><span class=\"line\">    require.EqualError(t, err, ErrInvalidToken.Error())</span><br><span class=\"line\">    require.Nil(t, payload)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现PASETO-Maker\">实现PASETO Maker</h3>\n<p>接下来我们使用相同的token maker接口来实现PASETO。我们去到<a href=\"https://github.com/o1egl/paseto\">paseto golang github page</a>,使用go get获取这个包</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get github.com/o1egl/paseto</span><br></pre></td></tr></table></figure>\n<p>接着我回到项目中，创建一个<code>paseto_maker.go</code>文件在<code>token</code>包中，与我们刚才做的类似，我们声明一个<code>PasetoMaker</code>结构体，用于实现相同的<code>token.Maker</code>接口。我们在这里会使用paseto的版本2，所以该结构体中应当有一个指定版本的字段。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PasetoMaker <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    paseto       *paseto.V2</span><br><span class=\"line\">    symmetricKey []<span class=\"keyword\">byte</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为我们只是想在银行api内部使用token，我们将会使用对称加密方法对token payload进行加密，因此我们需要symmetricKey字段存储密钥。</p>\n<p>接下来我们增加一个函数，<code>NewPasetoMaker</code>创建一个新的PasetoMaker实例。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewPasetoMaker</span><span class=\"params\">(symmetricKey <span class=\"keyword\">string</span>)</span> <span class=\"params\">(Maker, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(symmetricKey) != chacha20poly1305.KeySize &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;invalid key size: must be exactly %d characters&quot;</span>, chacha20poly1305.KeySize)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    maker := &amp;PasetoMaker&#123;</span><br><span class=\"line\">        paseto:       paseto.NewV2(),</span><br><span class=\"line\">        symmetricKey: []<span class=\"keyword\">byte</span>(symmetricKey),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maker, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为version2使用的是<code>Chacha20 Poly1305</code>算法来加密，所以我们需要在函数中先检查对称密钥的长度。</p>\n<p>同样我们发现在返回的maker下面有红线提示错误，这是因为我们还没有实现<code>token.Maker</code>接口。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *PasetoMaker)</span> <span class=\"title\">CreateToken</span><span class=\"params\">(username <span class=\"keyword\">string</span>, duration time.Duration)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *PasetoMaker)</span> <span class=\"title\">VerifyToken</span><span class=\"params\">(token <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Payload, error)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现paseto-CreateToken方法\">实现paseto CreateToken方法</h3>\n<p>我们首先需要去创建一个新的<code>payload</code>用<code>username</code>和<code>duration</code>。然后我们返回<code>maker.paseto.Encrypt()</code>并且传入我们的密钥和payload对象。最后一个参数是可选的footer部分，我们不需要，所以设置为nil。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *PasetoMaker)</span> <span class=\"title\">CreateToken</span><span class=\"params\">(username <span class=\"keyword\">string</span>, duration time.Duration)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">    payload, err := NewPayload(username, duration)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maker.paseto.Encrypt(maker.symmetricKey, payload, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现paseto-VerifyToken-方法\">实现paseto VerifyToken 方法</h3>\n<p>我们只需要定义一个空的payload，然后调用decrypt来解密token就可以了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *PasetoMaker)</span> <span class=\"title\">VerifyToken</span><span class=\"params\">(token <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Payload, error)</span></span> &#123;</span><br><span class=\"line\">    payload := &amp;Payload&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err := maker.paseto.Decrypt(token, maker.symmetricKey, payload, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrInvalidToken</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = payload.Valid()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> payload, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个的测试和前面是相同的，因为他们是同样的接口。</p>\n<h2 id=\"实现用户登录API，返回PASETO或者JWT通行证\">实现用户登录API，返回PASETO或者JWT通行证</h2>\n<h3 id=\"将token-maker添加到服务器\">将token maker添加到服务器</h3>\n<p>我们打开<code>api.server.go</code>文件，在其中的Server结构体中增加一个<code>tokenMaker</code>字段。然后我们在<code>NewServer()</code>中对这个字段进行初始化。我们这里选用PASETO作为我们的token maker。这需要调用<code>token.NewPasetoMaker()</code>，他需要一个对称密钥字符串作为输入，所以我们需要加载环境变量。目前的话我们可以先放一个空字符串在这里占个位置。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store db.Store)</span> <span class=\"params\">(*Server, error)</span></span> &#123;</span><br><span class=\"line\">    tokenMaker, err := token.NewPasetoMaker(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;cannot create token maker: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server := &amp;Server&#123;</span><br><span class=\"line\">        store:      store,</span><br><span class=\"line\">        tokenMaker: tokenMaker,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> server, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来我们需要增加一个环境变量到<code>app.env</code>里面，我们把他命名为<code>TOKEN_SYMMETRIC_KEY</code>。由于我们用的paseto v2,这个密钥的长度应该为32。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">TOKEN_SYMMETRIC_KEY=12345678901234567890123456789012</span><br><span class=\"line\">ACCESS_TOKEN_DURATION=15m</span><br></pre></td></tr></table></figure>\n<p>此外我们还加入了一个控制token的生命周期的变量，我们设置它为15min。接下来我们需要更新我们的config结构体来包含我们刚刚增加的两个变量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Config <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    TokenSymmetricKey   <span class=\"keyword\">string</span>        <span class=\"string\">`mapstructure:&quot;TOKEN_SYMMETRIC_KEY&quot;`</span></span><br><span class=\"line\">    AccessTokenDuration time.Duration <span class=\"string\">`mapstructure:&quot;ACCESS_TOKEN_DURATION&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，我们定义time.Duration类型的环境变量的时候可以用我们人类方便理解的15m作为duration。</p>\n<p>然后我们需要在<code>NewServer()</code>中增加一个参数config，用它来加载我们的环境变量。我们同样需要将这个config字段增加到Server结构体中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    config     util.Config</span><br><span class=\"line\">    store      db.Store</span><br><span class=\"line\">    tokenMaker token.Maker</span><br><span class=\"line\">    router     *gin.Engine</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(config util.Config, store db.Store)</span> <span class=\"params\">(*Server, error)</span></span> &#123;</span><br><span class=\"line\">    tokenMaker, err := token.NewPasetoMaker(config.TokenSymmetricKey)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;cannot create token maker: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server := &amp;Server&#123;</span><br><span class=\"line\">        config:     config,</span><br><span class=\"line\">        store:      store,</span><br><span class=\"line\">        tokenMaker: tokenMaker,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class=\"line\">        v.RegisterValidation(<span class=\"string\">&quot;currency&quot;</span>, validCurrency)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server.setupRouter()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里由于我们改变了这个函数的输入输出，所以我们需要对之前的单元测试中用到这个函数的地方进行修改。</p>\n<h3 id=\"修复受影响的单元测试\">修复受影响的单元测试</h3>\n<p>在<code>api/main_test.go</code>文件中，我们要定义一个函数<code>newTestServer()</code>，它会创建一个新的server用于测试。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newTestServer</span><span class=\"params\">(t *testing.T, store db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    config := util.Config&#123;</span><br><span class=\"line\">        TokenSymmetricKey:   util.RandomString(<span class=\"number\">32</span>),</span><br><span class=\"line\">        AccessTokenDuration: time.Minute,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server, err := NewServer(config, store)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> server</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们去到<code>api/transfer_test.go</code>文件中，这里我们将<code>NewServer()</code>换成<code>newTestServer()</code>。其他测试文件中我们也做同样的修改。</p>\n<p>但是还有一个非常重要的地方我们要去更新，服务器的主入口<code>main.go</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    config, err := util.LoadConfig(<span class=\"string\">&quot;.&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot load config:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    conn, err := sql.Open(config.DBDriver, config.DBSource)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    store := db.NewStore(conn)</span><br><span class=\"line\">    server, err := api.NewServer(config, store)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot create server:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = server.Start(config.ServerAddress)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot start server:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现login-user的handler\">实现login user的handler</h3>\n<p>打开<code>api/user.go</code>文件，login api必须要包含用户名和密码，这和创建user的api相类似。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> loginUserRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Username <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;username&quot; binding:&quot;required,alphanum&quot;`</span></span><br><span class=\"line\">    Password <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;password&quot; binding:&quot;required,min=6&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们需要定义这个api的返回结构体，其中最重要的应该是<code>AccessToken</code>字符串</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> loginUserResponse <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    AccessToken <span class=\"keyword\">string</span>       <span class=\"string\">`json:&quot;access_token&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除此之外，我们还希望能够返回一部分登陆账户的相关信息，就像我们创建用户api中返回的那样。为了能将这个结构体进行重用，我们将它的名字改为<code>userResponse</code>，它会作为我们login api返回结构体中的一个字段。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> userResponse <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Username          <span class=\"keyword\">string</span>    <span class=\"string\">`json:&quot;username&quot;`</span></span><br><span class=\"line\">    FullName          <span class=\"keyword\">string</span>    <span class=\"string\">`json:&quot;full_name&quot;`</span></span><br><span class=\"line\">    Email             <span class=\"keyword\">string</span>    <span class=\"string\">`json:&quot;email&quot;`</span></span><br><span class=\"line\">    PasswordChangedAt time.Time <span class=\"string\">`json:&quot;password_changed_at&quot;`</span></span><br><span class=\"line\">    CreatedAt         time.Time <span class=\"string\">`json:&quot;created_at&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> loginUserResponse <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    AccessToken <span class=\"keyword\">string</span>       <span class=\"string\">`json:&quot;access_token&quot;`</span></span><br><span class=\"line\">    User        userResponse <span class=\"string\">`json:&quot;user&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们从<code>createUser()</code>的handler中复制出来，并且定义一个<code>newUserResponse()</code>函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newUserResponse</span><span class=\"params\">(user db.User)</span> <span class=\"title\">userResponse</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userResponse&#123;</span><br><span class=\"line\">        Username:          user.Username,</span><br><span class=\"line\">        FullName:          user.FullName,</span><br><span class=\"line\">        Email:             user.Email,</span><br><span class=\"line\">        PasswordChangedAt: user.PasswordChangedAt,</span><br><span class=\"line\">        CreatedAt:         user.CreatedAt,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数的作用是将输入的<code>db.User</code>转换为<code>userResponse</code>。这样做的原因是在<code>db.User</code>结构体中的部分信息比较敏感的数据<code>hashed_password</code>，这是我们不希望暴露给客户端的。</p>\n<p>所以在<code>createUser()</code>的handler中，我们能够只调用<code>newUserResponse()</code>函数来创建返回对象。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createUser</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    user, err := server.store.CreateUser(ctx, arg)</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    rsp := newUserResponse(user)</span><br><span class=\"line\">    ctx.JSON(http.StatusOK, rsp)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数同样对物品们的loginUser()的handler也有用。现在我们给服务器结构体:<code>loginUser()</code>,和其他的API handler相类似，这个函数以gin.Contest()作为输入。在里面，我们声明了一个<code>request</code>对象，并且我们调用<code>ctx.ShouldBindJSON</code>函数。这会绑定API的所有输入参数到<code>request</code>对象中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">loginUser</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> req loginUserRequest</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := ctx.ShouldBindJSON(&amp;req); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有错误的话，我们将要在数据库中查找这个用户。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">loginUser</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    user, err := server.store.GetUser(ctx, req.Username)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err == sql.ErrNoRows &#123;</span><br><span class=\"line\">            ctx.JSON(http.StatusNotFound, errorResponse(err))</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果一切正常的话，我们就需要检查客户端提供的密码是正确的还是错误的。因此我们调用函数来检查密码。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">loginUser</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    err = util.CheckPassword(req.Password, user.HashedPassword)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusUnauthorized, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只有当密码正确的时候我们彩绘创建一个通行令牌。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">loginUser</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    accessToken, err := server.tokenMaker.CreateToken(</span><br><span class=\"line\">        user.Username,</span><br><span class=\"line\">        server.config.AccessTokenDuration,</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    rsp := loginUserResponse&#123;</span><br><span class=\"line\">        AccessToken: accessToken,</span><br><span class=\"line\">        User:        newUserResponse(user),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ctx.JSON(http.StatusOK, rsp)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们处理login接口的handler就写好了。</p>\n<h3 id=\"将login-api的route添加到服务器上\">将login api的route添加到服务器上</h3>\n<p>我们接下来需要将一个新的终端添加到服务器上，并且以loginUser()作为handler。我将会把它放到创建用户的route旁边。所以<code>route.POST()</code>，路径应当为<code>/user/login</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(config util.Config, store db.Store)</span> <span class=\"params\">(*Server, error)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    router := gin.Default()</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/users&quot;</span>, server.createUser)</span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/users/login&quot;</span>, server.loginUser)</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以了。但是<code>NewServer()</code>函数太常了，这使得它很难阅读，所以我们要把它的功能部分分开。把路径设置部分单独拿出来做成<code>setupRouter()</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">setupRouter</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    router := gin.Default()</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/users&quot;</span>, server.createUser)</span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/users/login&quot;</span>, server.loginUser)</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts/:id&quot;</span>, server.getAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts&quot;</span>, server.listAccounts)</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/transfers&quot;</span>, server.createTransfer)</span><br><span class=\"line\"></span><br><span class=\"line\">    server.router = router</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现验证中间件和授权规则\">实现验证中间件和授权规则</h2>\n<p>目前为止我们的API都可以让任何人调用，不需要验证身份信息，这样做显然是不安全的。</p>\n","categories":["后端"],"tags":["sql,docker"]},{"title":"图卷积神经网络概述","url":"/2022/03/19/%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/","content":"<h2 id=\"图卷积缘起\">图卷积缘起</h2>\n<p>我们要思考：为什么研究者们要设计图卷积，直接在图上不能应用传统的卷积吗？要理解这个，我们首先要理解应用传统卷积的图像（欧氏空间）和图（非欧式空间的区别）。如下图，是在两种不同结构上应用卷积的场景</p>\n<p><img src=\"https://i.imgur.com/PrBt36X.png\" alt=\"picture 6\"></p>\n<p>图卷积真正的难点在于 <strong>邻居节点数量不固定</strong>。目前有两中主流的研究方向</p>\n<ul>\n<li>将非欧式空间转换为欧式空间</li>\n<li>找出一种可以处理变长邻居节点的卷积核在图上抽取特征</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"图卷积的框架\">图卷积的框架</h2>\n<p>如下图所示，输入的是整张图，在<code>Convolution Layer 1</code>里面，对每个节点的邻居都进行一次卷积操作，并且用卷积的结果更新这个节点；然后经过激活函数传给<code>Convolution Layer 2</code>与激活函数，重复这个过程。</p>\n<p>与GNN类似，GCN也有一个局部输出函数，用于将节点的状态（包括隐藏状态和节点特征）转换成任务相关的标签，称为<code>Node-Level</code>的任务；也有些任务是对整张图进行分类的，比如化合物分类，称为<code>Graph-Level</code>的任务。卷积操作只关心每个节点的隐藏状态如何更新，而对于<code>Graph-Level</code>的任务，会在卷积层之后增加更多的操作。</p>\n<h2 id=\"卷积\">卷积</h2>\n<p>图卷积神经网络主要两中：空域和频域的。通俗点，空域就是直接在图片的像素点上进行卷积，频域是对图片进行傅里叶变换后再卷积。</p>\n<h3 id=\"空域卷积\">空域卷积</h3>\n<p>其核心在于聚合邻居节点的信息。比如最简单的无参卷积方式是：将所有直连邻居节点的隐藏状态加和，来更新当前节点的隐藏状态。</p>\n<p><img src=\"https://i.imgur.com/3Jnfovx.png\" alt=\"picture 14\"></p>\n<h3 id=\"消息传递网络（Message-Passing-Neural-Network）\">消息传递网络（Message Passing Neural Network）</h3>\n<p>严格来说，MPNN并不是一种具体的模型，而是一种空域卷积的形式化框架。将空域卷积分解为两个过程：消息传递和状态更新，分别由$M_l(·)$和$U_l(·)$函数完成。将节点v的特征$X_v$作为隐藏状态的初始状态$H_v^0$之后，空域卷积对隐藏状态的更新如下：</p>\n<p><img src=\"https://i.imgur.com/dmxgXS1.png\" alt=\"picture 15\"></p>\n<p>其中l代表卷积层的第l层。式子的物理意义是：受到来自每个邻居的消息$M_{l+1}$之后，每个节点如何更新自己的状态。</p>\n<p>MPNN的示意图如下</p>\n<p><img src=\"https://i.imgur.com/aaerMwm.png\" alt=\"picture 16\"></p>\n<h3 id=\"图采样与聚合\">图采样与聚合</h3>\n<p>MPNN很好地概括了空域卷积的过程，但这个框架下的所有模型都有一个共同的缺陷：卷积操作针对的对象是整张图，即要将所有的节点放到内存中，才能卷积。但是实际应用中，整个图上的卷积操作并不现实。GraphSage利用采样部分节点的方式进行学习。当然，即使不需要整张图同时卷积，GraphSage仍然需要聚合邻居节点的信息。这种操作类似于MPNN中的消息传递过程</p>\n<p><img src=\"https://i.imgur.com/N3phwJo.png\" alt=\"picture 17\"></p>\n<p>具体采样过程分为三步：</p>\n<ol>\n<li>在图中随机采样若干个节点，节点数就是传统任务中的<code>batch_size</code>。对于每个节点，随机选择固定数目的邻居节点（未必是一阶邻居，也可以是二阶邻居）。</li>\n<li>将邻居节点的信息通过aggregate函数聚合起来更新刚才采样的节点</li>\n<li>计算采样节点处的损失。如果是无监督任务，我们希望图上邻居节点的编码相似；如果是监督任务，可以根据具体节点的任务标签计算损失。</li>\n</ol>\n<p>最终的GraphSage的状态更新公式如下：</p>\n<p><img src=\"https://i.imgur.com/e6fe9aR.png\" alt=\"picture 43\"></p>\n<p>GraphSage的设计重点是aggrega函数的设计上，它可以是max，mean也可以是带参数的如LSTM等神经网络。</p>\n<h2 id=\"图结构序列化\">图结构序列化</h2>\n<p>这个方法将图结构转换成序列结构，然后直接利用卷积神经网络在序列化之后的序列结构上进行卷积。</p>\n<p>这种序列转换需要保持图结构的两个特点：1.同构的性质。2.邻居节点的链接关系。对于前者，意思是我们把图上节点的标号随机打乱，得到的仍然应该是一样的序列；对于后者，意味着我们需要保持邻居节点和目标节点的距离关系。</p>\n<p>PATCH-SAN通过以下三个步骤来解决这两个问题：</p>\n<ol>\n<li><strong>节点选择</strong>：通过一些人为定义的规则（比如度大的节点分数高，邻居节点度大时分数较高等）为每个节点指定一个在图中的排序。完成排序后取出前$\\omega$个节点代表整个图。</li>\n<li><strong>邻居节点构造</strong>：以第一步选择的节点为中心，得到他们的邻居节点（可以是一阶邻居也可以是二阶邻居），这样就构成了$\\omega$个团，根据第一步得到的节点排序对每个团中的邻居节点进行排序，取前k个邻居节点按照顺序排序，就组成了$\\omega$个有序的团。</li>\n<li><strong>图规范化</strong>：按照每个团中的节点顺序可以将所有的团转换成固定长度的序列（k+1），再将他们按照中心节点的顺序从前到后依次拼接就能得到长度为$\\omega \\times (k+1)$的代表整张图的序列。需要注意的是，如果取不到$\\omega$或者k个节点，需要用空节点填充。</li>\n</ol>\n<p>流程图如下所示：</p>\n<p><img src=\"https://i.imgur.com/qEhL4bU.png\" alt=\"picture 24\"></p>\n<p>下图更清晰：</p>\n<p><img src=\"https://i.imgur.com/aRKWzoN.png\" alt=\"picture 25\"></p>\n<h2 id=\"频域卷积\">频域卷积</h2>\n<p>空域卷积直观地借鉴了图像中的卷积操作，但是缺乏理论基础。而频域卷积则不同，主要利用图傅里叶变换实现卷积。</p>\n<p>简单来说就是，利用图的拉普拉斯矩阵导出其频域上的拉普拉斯算子，再类比频域上的欧氏空间中的卷积，导出卷积公式。</p>\n<h3 id=\"傅里叶变换\">傅里叶变换</h3>\n<p>傅里叶变换会将一个在空域（或者时域）上定义的函数分解成频域上的若干频率成分。即傅里叶变换可以将一个函数从空域变换到频域。先抛开傅里叶变换的数学公式，用F来表示傅里叶变换的话，有一个重要的恒等式：</p>\n<p>$$<br>\n(f * g)(t)=F^{-1} [F [f(t)] \\odot F [g(t)] ]<br>\n$$</p>\n<p>这里的$F^{-1}$ 指的是傅里叶逆变换，$\\odot$ 指的是哈达玛积。上式的直观含义是：空（时）域卷积等于频域卷积。简单来说就是如果要求f和g的卷积，可以先将他们通过傅里叶变换变换到频域中，将两个函数在频域中相乘，然后再通过傅里叶逆变换转换出来。</p>\n<p>那么傅里叶变换能够做什么呢？一个简单的应用是给图像去除规律噪点。如下图，傅里叶变换前有一些规律的条纹，直接在原图去除有点困难，但我们可以将图片通过傅里叶变换变到频谱图中，频谱中的规律条纹就是原图中的背景条纹。</p>\n<p><img src=\"https://i.imgur.com/1RCTpbS.png\" alt=\"picture 26\"></p>\n<p>只要在频谱图中去除这些点，就可以将背景条纹去掉。</p>\n<p><img src=\"https://i.imgur.com/ocm1zaI.png\" alt=\"picture 27\"></p>\n<p>除了去除噪声点，其在加速卷积运算方面还有很大的潜力，快速傅里叶变换也是由此而生。事实上现在常用的卷积神经网络完全可以搭配傅里叶变换。但是由于目前的大部分卷积核都比较小，卷积操作本身就不是很大开销，搭配傅里叶变换不一定就会减小时间开销。</p>\n<p>那么傅里叶变换的公式是什么样的呢？</p>\n<p>$$<br>\n\\hat{f}(t)=\\int f(x) \\exp ^{-2 \\pi i x t} d x<br>\n$$</p>\n<p>其中$i=\\sqrt{-1}$，t是任意实数。</p>\n<p>我们这里实际上需要关注$\\exp ^{-2 \\pi i x t}$的物理意义，它实际上是拉普拉斯算子$\\delta$的广义特征函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">拉普拉斯算子(Laplacian operator) 的物理意义是空间二阶导，准确定义是：标量梯度场中的散度，一般可用于描述物理量的流入流出。比如说在二维空间中的温度传播规律，一般可以用拉普拉斯算子来描述。</span><br></pre></td></tr></table></figure>\n<p>为什么是特征向量呢？稍微推导以下就可以知道，拉普拉斯算子作用在$\\exp ^{-2 \\pi i x t}$确实满足以上特征向量的定义：</p>\n<p>$$<br>\n\\Delta \\exp ^{-2 \\pi i x t}=\\frac{\\partial^{2} } {\\partial t^{2} } \\exp ^{-2 \\pi i x t}=-4 \\pi^{2} x^{2} \\exp ^{-2 \\pi i x t}<br>\n$$</p>\n<p>这里$\\partial$是求导符号，$\\partial^2$是二阶导。</p>\n<p>实际上，仔细观察傅里叶变换的例子，本质上就是将函数f(t)映射到$\\exp ^{-2\\pi ixt}$的基向量空间中。</p>\n<h3 id=\"图上的傅里叶变换\">图上的傅里叶变换</h3>\n<p>前面讲的都是为了这一部分做铺垫。问题来了：在图上，我们怎么找拉普拉斯算子$\\delta$和$\\exp ^{-2\\pi ixt}$呢？</p>\n<p>研究者们找到了图的拉普拉斯矩阵和特征向量作为替代品。拉普拉斯矩阵本质上是度矩阵（D）减去邻接矩阵（A）L=D-A，如图所示</p>\n<p><img src=\"https://i.imgur.com/xkIhW3R.png\" alt=\"picture 28\"></p>\n<p>频域卷积的前提条件就是图必须是无向图，那么L就是对称矩阵。所以可以由以下公式分解：</p>\n<p><img src=\"https://i.imgur.com/zJw8FYb.png\" alt=\"picture 29\"></p>\n<p>那么根据上面卷积和傅里叶结合的变换公式，图上频域卷积的公式就可以写成$\\hat{f}(t)=\\sum_{n=1}^{N} f(n) u_{t}(n)$，如果整个图上的N个节点一起做卷积，就能够得到整张图上的卷积如下：</p>\n<p><img src=\"https://i.imgur.com/oZNB2qd.png\" alt=\"picture 30\"></p>\n<p>回顾传统卷积和图卷积，发现他们非常相似，这里f都是特征函数，g都是卷积核</p>\n<p><img src=\"https://i.imgur.com/hxBFtSB.png\" alt=\"picture 31\"></p>\n<p>如果把$U^Tg$整体看作可以学习的卷积核，我们写作$g_\\theta$。最终的卷积公式就是：</p>\n<p><img src=\"https://i.imgur.com/6ZqiOgV.png\" alt=\"picture 32\"></p>\n<h3 id=\"频域卷积网络\">频域卷积网络</h3>\n<p>上面推导出的$g_\\theta$就是首个提出的频域卷积神经网络的卷积核。设l层的隐藏状态为$h^l\\in R^{N\\times d_t}$，频域卷积层的状态更新计算公式如下：</p>\n<p><img src=\"https://i.imgur.com/K0CkMxN.png\" alt=\"picture 33\"></p>\n<p>物理上可以如下理解</p>\n<p><img src=\"https://i.imgur.com/lldUmjS.png\" alt=\"picture 34\"></p>\n<a href=\"/2022/03/19/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/\" title=\"图神经网络概述\">图神经网络概述</a>\n<a href=\"/2022/03/19/%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/\" title=\"图卷积神经网络概述\">图卷积神经网络概述</a>\n<a href=\"/2022/03/19/%E8%8A%82%E7%82%B9%E8%A1%A8%E7%A4%BA%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%9B%BE%E8%A1%A8%E7%A4%BA/\" title=\"节点表示如何生成图表示\">节点表示如何生成图表示</a>","categories":["图神经网络"],"tags":["GCN 综述"]},{"title":"常见的报错以及解决方式","url":"/2022/01/25/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8A%A5%E9%94%99%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/","content":"<h2 id=\"Deep-Learning\">Deep Learning</h2>\n<h3 id=\"tqdm\">tqdm</h3>\n<ul>\n<li>使用tqdm对迭代对象时，如果出现<code>'module' object is not callable</code>则将<code>import tqdm</code>改为<code>tqdm</code></li>\n</ul>\n","categories":["Code"],"tags":["error"]},{"title":"图神经网络概述","url":"/2022/03/19/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/","content":"<h2 id=\"状态更新与输出\">状态更新与输出</h2>\n<p>最早的图神经网络的理论基础是不动点理论。给定一张图$G$，每个节点都有其自身特征$X_v$，每个边也有其自身特征$X_{(u,v)}$。GNN的学习目标就是获得每个结点的图感知的隐藏状态，即：对于每个节点，其隐藏状态包含来自邻居节点的信息。那如何让每个节点都能感知到图上的其他节点呢？GNN通过迭代式更新所有节点的隐藏状态来实现，在t+1时刻，节点的隐藏状态按照如下方式更新：</p>\n<p><img src=\"https://i.imgur.com/2vgW7gB.png\" alt=\"picture 8\"></p>\n<p>其中f就是隐藏状态的更新函数，$x_co[v]$是与节点v相邻的边的特征，$x_ne[v]$是节点v的邻居节点的特征，$h_n^te[v]$是邻居节点在t时刻的隐藏状态。神经网络需要做的就是拟合这个函数f。</p>\n<span id=\"more\"></span>\n<p>显然对于不同的节点，他们相邻的边或者点的个数不一定是相同的，那这个f函数的输入就是不定长的，怎么解决这个问题呢？我们可以在f的内部先将不定长的参数转变成一个固定的参数，比如说所有隐状态的和作为隐状态的代表。举个例子：</p>\n<p><img src=\"https://i.imgur.com/AdE1gjq.png\" alt=\"picture 45\"></p>\n<p>假设节点5是中心节点，隐藏状态更新的公式如图所示。公式的中心思想：不断利用当前时刻邻居节点的隐藏状态作为部分输入来生成下一时刻中心节点的隐藏状态，直到每个节点的隐藏状态变化幅度很小。</p>\n<p>但是状态更新公式仅仅描述了如何获取每个节点的隐状态，我们还需要一个函数g来描述如何适应下游任务。比如，下游任务是判断各节点是否为水军账号</p>\n<p>$$<br>\no_v=g(h_v,x_v)<br>\n$$</p>\n<p>整个流程可以使用下面这张图表达</p>\n<p><img src=\"https://i.imgur.com/JV7M8Ow.png\" alt=\"picture 46\"></p>\n<p>直到$T_n$时刻各个节点的隐藏状态收敛，每个节点后面接一个g就可以得到节点的输出。对于不同的图，节点的收敛时刻可能不同，收敛是通过两个时刻的p-范数差值和某个阈值$\\epsilon$。</p>\n<p><img src=\"https://i.imgur.com/xxyvPCL.png\" alt=\"picture 47\"></p>\n<h2 id=\"不动点理论\">不动点理论</h2>\n<p>这里的不动点理论专指巴纳赫不动点理论(Banach’s Fixed Point Theorem)。首先我们用F表示若干个f堆叠得到的一个函数，那么图上所有节点的状态更新公式可以写成</p>\n<p><img src=\"https://i.imgur.com/IF5e2Zf.png\" alt=\"picture 48\"></p>\n<p>不动点定理指的就是，不论$H^0$是什么，只要F是个压缩映射，$H^0$经过不断迭代都会收敛到某一个固定的点，称之为不动点。</p>\n<h3 id=\"压缩映射\">压缩映射</h3>\n<p><img src=\"https://i.imgur.com/ryRG4FY.png\" alt=\"picture 3\"></p>\n<p>上图的实线就是映射F，任意两个点x，y经过映射后变成F(x),F(y)。经过F变换后的空间一定比原空间小，这样经过不断的迭代压缩，最终原空间上的所有点都会被映射到同一个点上。</p>\n<p>那既然f是由神经网络实现的，如何实现才能保证他是个压缩映射呢？</p>\n<h2 id=\"具体实现\">具体实现</h2>\n<p>具体实现中，f可以是意见简单前馈神经网络实现，比如只是简单地将f的几个参数凭借在一起然后做个加和。</p>\n<p><img src=\"https://i.imgur.com/bYmBx17.png\" alt=\"picture 10\"></p>\n<p>但如何保证f是个压缩映射呢？只需要限制f对H的偏导数矩阵的大小就可以了，本质上是通过对雅可比矩阵的惩罚项来实现的。代数中有个定理：f为压缩映射的等价条件是f的梯度（也就是对H的导数）要小于1。</p>\n<p>我们使用$\\left|x\\right|$表示x在这个空间上的范数。范数是一个标量是向量的长度或者模。这里我们将x简化为1维的，左边间的差值可以看作向量在空间中的距离，可以推导出：</p>\n<p><img src=\"https://i.imgur.com/JGORo9H.png\" alt=\"picture 11\"></p>\n<p>推广一下，即得到雅可比矩阵的罚项需要满足其范数小于等于c等价于压缩映射的条件。根据拉格朗日乘子法，将有约束问题变成带罚项的无约束优化问题，训练的目标可表示成如下形式：</p>\n<p>$$<br>\nJ=\\operatorname{Loss}+\\lambda \\cdot \\max \\left(\\frac{|\\partial F N N|}{|\\partial \\mathbf{h}|}-c, 0\\right), c \\in(0,1)<br>\n$$</p>\n<h2 id=\"模型学习\">模型学习</h2>\n<p>虽然每个节点都会有隐藏状态和输出，但并不是每个节点都有监督信号。比如，社交网络中只有部分用户被明确标记为水军，这就构成了典型的节点二分类问题。</p>\n<p>模型的损失就可以由这些有监督的信号的节点得到。假设监督节点由p个，模型损失可以形式化为：</p>\n<p><img src=\"https://i.imgur.com/6LVIkvo.png\" alt=\"picture 12\"></p>\n<p>反向传播计算梯度的过程：</p>\n<ol>\n<li>调用f若干次，比如$T_n$次，直到$h_v^{T_n}$收敛。</li>\n<li>此时每个结点的隐藏状态接近不动点的解。</li>\n<li>对于有监督信号的结点，将其隐藏状态通过 g 得到输出，进而算出模型的损失</li>\n</ol>\n<h2 id=\"GNN与RNN\">GNN与RNN</h2>\n<p>大家可以发现，GNN与RNN的不论是前向还是反向传播的算法，都是非常相似的。实际上确实如此，我们用下图来解释两者设计上的不同：</p>\n<p><img src=\"https://i.imgur.com/fOPCggK.png\" alt=\"picture 49\"></p>\n<p>假设在GNN上存在三个节点x1,x2,x3,同样RNN中存在一个序列（x1,x2,x3），他们的区别主要在于：</p>\n<ol>\n<li>GNN的基础理论是不动点，所以其沿时间展开的长度是动态的，根据收敛条件决定，RNN沿时间展开的长度就等于序列本身的长度。</li>\n<li>GNN每次时间步的输入都是所有节点v的特征，而RNN每次是对应时刻的对应输入。同时，时间步之间的信息流也不同，前者由边决定，后者由序列的顺序决定。</li>\n<li>GNN采用AP算法反向传播优化，RNN使用BPTT优化。前者对收敛性有要求，后者没有。</li>\n<li>GNN循环调用f是为了得到每个节点稳定的隐状态，因此只有在隐状态收敛之后才能输出；RNN在每个时间步上都可以输出，比如语言模型。</li>\n</ol>\n<h2 id=\"GNN的局限性\">GNN的局限性</h2>\n<ul>\n<li>GNN只将边作为了一种传播手段，并未区分不同边的功能。虽然我们可以在特征构造阶段$(X_{(u,v)})$为不同类型的边赋予不同的特征，但相比于其他输入，边对节点隐藏状态的影响实在有限。GNN没有为边设置独立的可学习参数，就意味着无法通过模型学习到边的某些特性。</li>\n<li>如果把GNN应用在图表示的场景中，使用不动点理论并不合适。主要因为基于不动点的收敛会导致节点之间的隐藏状态之间存在较多的信息共享，导致节点状态太过于光滑，属于节点自身的特征信息匮乏。</li>\n</ul>\n<p>下面这张来自维基百科的图可以形象地解释什么是 Over Smooth，其中我们把整个布局视作一张图，每个像素点与其上下左右以及斜上下左右8个像素点相邻，这决定了信息在图上的流动路径。初始时，蓝色表示没有信息量，如果用向量的概念表达即为空向量；绿色，黄色与红色各自有一部分信息量，表达为非空的特征向量。在图上，信息主要从三块有明显特征的区域向其邻接的像素点流动。一开始不同像素点的区分非常明显，但在向不动点过渡的过程中，所有像素点都取向一致，最终整个系统形成均匀分布。这样，虽然每个像素点都感知到了全局的信息，但我们无法根据它们最终的隐藏状态区分它们。比如说，根据最终的状态，我们是无法得知哪些像素点最开始时在绿色区域。</p>\n<p><img src=\"https://images.cnblogs.com/cnblogs_com/SivilTaram/1510485/o_image-9-over-smooth.gif\" alt=\"picture 5\"></p>\n<h2 id=\"门控图神经网络\">门控图神经网络</h2>\n<p>既然RNN和GNN存在如此多的相似点，是否可以用类似RNN的方法定义GNN呢？于是，门控图神经网络（GGNN）出现了。虽然类似，但实际上差别很大，最核心点在于门控神经网络不以不动点理论为基础。意味着：f不再需要是一个压缩映射；迭代不需要达到收敛才可以输出，可以固定迭代步长；优化算法也从AP算法转向BPTT。</p>\n<h3 id=\"状态更新\">状态更新</h3>\n<p>与图神经网络定义的范式一致，GGNN也有两个过程：状态更新与输出。相比GNN而言，它主要的区别来源于状态更新阶段。GGNN参考了GRU的设计，把邻居节点的信息视为输入，节点本身状态视为隐藏状态，状态更新函数如下：</p>\n<p><img src=\"https://i.imgur.com/OxrJiqQ.png\" alt=\"picture 13\"></p>\n<p>观察上式，除了GRU式的设计之外，GGNN还针对不同类型的边引入了可学习的参数W。每种edge对应一个$W_{edge}$，这样就可以处理异构图。</p>\n<p>但是，GNN中需要作为输入的节点特征$X_v$没有出现在GGNN公式中，但是这个特征对于预测非常重要！</p>\n<p>为了解决这个问题，GGNN将节点特征作为隐藏状态初始化的一部分。重新回顾GGNN的流程：</p>\n<ol>\n<li>用节点特征初始化各个节点的（部分）隐藏状态</li>\n<li>对整张图按照上述状态更新公式固定迭代若干步</li>\n<li>对部分有监督信号的节点求得模型损失，利用BPTT算法反向传播求得$W_edge$和GRU参数梯度</li>\n</ol>\n<h3 id=\"实例1：到达判断\">实例1：到达判断</h3>\n<p>比如说给定一张图G，开始结点 S，对于任意一个结点 E，模型判断开始结点是否可以通过图游走至该结点。同样地，这也可以转换成一个对结点的二分类问题，即可以到达和不能到达。下图即描述了这样的过程：</p>\n<p><img src=\"https://i.imgur.com/9v9XVfd.png\" alt=\"picture 50\"></p>\n<p>图中的黄色结点即开始结点S，绿色结点是我们希望判断的结点E，我们这里称其为结束结点。那么相比于其他结点，这两个结点具有一定特殊性。那我们就可以使用第1维为1来表示开始结点，第2维为1来表示结束结点。最后在对结束结点分类时，如果其隐藏状态的第1维被赋予得到了一个非0的实数值，那意味着它可以到达。</p>\n<p>从初始化的流程我们也可以看出GNN与GGNN的区别：GNN依赖于不动点理论，所以每个结点的隐藏状态即使使用随机初始化都会收敛到不动点；GGNN则不同，不同的初始化对GGNN最终的结果影响很大。</p>\n<p>下一篇博客中会继续介绍图卷积神经网络，摆脱了基于循环的方法，开始走向多层神经网络。</p>\n<a href=\"/2022/03/19/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/\" title=\"图神经网络概述\">图神经网络概述</a>\n<a href=\"/2022/03/19/%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/\" title=\"图卷积神经网络概述\">图卷积神经网络概述</a>\n<a href=\"/2022/03/19/%E8%8A%82%E7%82%B9%E8%A1%A8%E7%A4%BA%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%9B%BE%E8%A1%A8%E7%A4%BA/\" title=\"节点表示如何生成图表示\">节点表示如何生成图表示</a>","categories":["图神经网络"],"tags":["GNN 综述"]},{"title":"桃子你好","url":"/2022/01/10/%E6%A1%83%E5%AD%90%E4%BD%A0%E5%A5%BD/","content":""},{"title":"概念漂移入门","url":"/2022/03/26/%E6%A6%82%E5%BF%B5%E6%BC%82%E7%A7%BB%E5%85%A5%E9%97%A8/","content":"<p>数据可能会随着时间的变化而变化，这会使得预测模型中预测变差并且降级，这种改变数据中潜在关系的问题在机器学习领域中被称为概念漂移。</p>\n<p>本文主要注重于三点：</p>\n<ul>\n<li>数据随时间的变化问题</li>\n<li>什么是概念漂移及其定义方式</li>\n<li>如何在自己的预测建模问题中处理概念偏差</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"随时间变化的数据\">随时间变化的数据</h2>\n<p>预测建模是从历史中学习模型并且使用模型对我们不知道答案的新数据进行预测的问题。</p>\n<p>本质上就是一个映射函数<code>y=f(x)</code>。</p>\n<p>通常来说，这种映射被认为是静态的，即从历史数据中学习的映射对将来的新数据同样适用，其间关系不会改变。</p>\n<p>但是在一些情况下，这种输入输出的关系会随时间变化发生改变。而这些改变可能是非常重要的，会导致我们的模型失灵。反过来，我们可以检测这些变化，如果检测到了的话，就适时更新学习的模型来反映这些变化。</p>\n<h2 id=\"什么是概念漂移\">什么是概念漂移</h2>\n<p>机器学习和数据挖掘中的概念漂移指的是随着时间的推移，潜在问题中输入和输出数据之间关系的变化。在其他邻域这种变化可能被称作“协变量移位”，“数据集移位”或者“非平稳性”。</p>\n<p>例如，天气数据中的一个概念可能是未在温度数据中明确指定的季节，但可能影响温度数据。另一个例子可能是随着时间的推移客户购买行为可能受到经济实力的影响，其中经济实力没有在数据中明确规定。这些元素也称为“隐藏上下文”。</p>\n<p>对数据的更改可以采取任何形式。从概念上讲，更容易考虑这样一种情况，即变化存在一定的时间一致性，使得在特定时间段内收集的数据显示出相同的关系，并且这种关系随时间平滑变化。</p>\n<p>每种情况可能需要不同的概念漂移检测和处理方案。通常，经常性变化和长期趋势被认为是系统性的，可以明确地识别和处理。</p>\n<p>概念漂移可能出现在监督学习问题上，其中进行预测并且随时间收集数据。这些传统上称为在线学习问题，考虑到数据随时间的变化。</p>\n<p>存在按时间排序预测的域，例如时间序列预测和流数据的预测，其中概念漂移的问题更可能并且应该明确地测试和解决。</p>\n<h2 id=\"如何解决概念漂移\">如何解决概念漂移</h2>\n<h3 id=\"1-什么都不做\">1. 什么都不做</h3>\n<p>开发一次得到最佳模型，应用于将来的所有数据。这应该是与其他方法比较的起点和基线，如果数据集可能出现概念漂移，可以通过两种方式使用静态模型：</p>\n<ol>\n<li><strong>概念漂移检测</strong>：检测静态模型随时间的性能，如果性能下降，说明可能出现概念漂移现象</li>\n<li><strong>基线表现</strong>：使用静态模型的性能作为基准，比较干预后的性能</li>\n</ol>\n<h3 id=\"2-定期重新适应\">2. 定期重新适应</h3>\n<p>使用更新的历史数据定期更新静态模型，比如可以使用前一时期收集的数据每月或者每年更新模型。还可以涉及对模型进行反向测试，以便在重新拟合静态模型时选择合适数量的历史数据。</p>\n<h3 id=\"3-定期更新\">3. 定期更新</h3>\n<p>一些机器学习模型可以定期更新。这是比先前方法（周期性重新拟合）效率更高，其中并不完全丢弃静态模型，而是将现有状态用作适合过程的七点，使用最新的数据样本来更新模型拟合。该方法适用于使用权重或者系数的大多数机器学习算法，比如回归算法和神经网络。</p>\n<h3 id=\"4-重量数据\">4. 重量数据</h3>\n<p>某些算放允许权衡输入数据的重要性。这种情况下可以使用与数据年龄成反比的加权，以便更多地关注最新数据（较高权重），并且较少的关注最近数据（较小权重）。</p>\n<h3 id=\"5-了解变化\">5. 了解变化</h3>\n<p>可以在静态模型保持不变的情况下使用集合方法，但是新模型学习基于更新近的数据中的关系来校正来自静态模型的预测。</p>\n<p>这可以被认为是增强型集合（仅在精神上），其中后续模型校正来自先前模型的预测。这里的关键区别在于后续模型适用于不同的和更新的数据，而不是相同数据集的加权形式，如AdaBoost和梯度增强的情况。</p>\n<h3 id=\"6-检测并选择模型\">6. 检测并选择模型</h3>\n<p>对于某些问题域，可以设计系统来检测变化并选择特定的和不同的模型来进行预测。</p>\n<p>这可能适用于预期过去可能发生突然变化并且可以在将来检查的域。它还假设可以开发熟练的模型来处理每个可检测的数据更改。</p>\n<p>例如，突然变化可以是范围内的特定观察或观察，或者一个或多个输入变量的分布的变化。</p>\n<h3 id=\"7-数据准备\">7. 数据准备</h3>\n<p>在某些领域，例如时间序列问题，数据可能会随着时间的推移而发生变化。</p>\n<p>在这些类型的问题中，通常以这样的方式准备数据，即通过差分去除随时间的数据的系统变化，例如趋势和季节性。</p>\n<p>这很常见，它被内置到ARIMA模型等经典线性方法中。</p>\n<p>通常，我们不会将数据的系统变化视为概念漂移的问题，因为它可以直接处理。相反，这些示例可能是一种思考问题的有用方法，可以帮助您使用标准化，缩放，预测等方式以特定方式预测变更和准备数据，从而减轻或至少减少变更对输入变量的影响。</p>\n","categories":["概念漂移"],"tags":["综述"]},{"title":"从零开始实现一个分布式缓存","url":"/2022/04/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/","content":"<h2 id=\"前言\">前言</h2>\n<h3 id=\"分布式缓存\">分布式缓存</h3>\n<p>第一次请求时将一些耗时操作的结果暂存，以后遇到相同请求就直接返回暂存的数据。这是大部分人对于缓存的理解。比如我们访问一个网页，网页和引用的JS/CSS等静态文件，根据不同的策略会缓存在本地或者CDN服务器，下次访问就会觉得很快了</p>\n<span id=\"more\"></span>\n<p>缓存中最简单的莫过于存储在内存中的键值对缓存了。说到键值对，很容易想到的是字典(dict)类型，Go 语言中称之为 map。那直接创建一个 map，每次有新数据就往 map 中插入不就好了，这不就是键值对缓存么？这样做有什么问题呢？</p>\n<p>1）内存不够了怎么办？</p>\n<p>那就随机删掉几条数据好了。随机删掉好呢？还是按照时间顺序好呢？或者是有没有其他更好的淘汰策略呢？不同数据的访问频率是不一样的，优先删除访问频率低的数据是不是更好呢？数据的访问频率可能随着时间变化，那优先删除最近最少访问的数据可能是一个更好的选择。我们需要实现一个合理的淘汰策略。</p>\n<p>2）并发写入冲突了怎么办？</p>\n<p>对缓存的访问，一般不可能是串行的。map 是没有并发保护的，应对并发的场景，修改操作(包括新增，更新和删除)需要加锁。</p>\n<p>3）单机性能不够怎么办？</p>\n<p>单台计算机的资源是有限的，计算、存储等都是有限的。随着业务量和访问量的增加，单台机器很容易遇到瓶颈。如果利用多台计算机的资源，并行处理提高性能就要缓存应用能够支持分布式，这称为水平扩展(scale horizontally)。与水平扩展相对应的是垂直扩展(scale vertically)，即通过增加单个节点的计算、存储、带宽等，来提高系统的性能，硬件的成本和性能并非呈线性关系，大部分情况下，分布式系统是一个更优的选择。</p>\n<p>4）…</p>\n<h3 id=\"关于GeeCache\">关于GeeCache</h3>\n<p>设计一个分布式缓存系统，需要考虑资源控制、淘汰策略、并发、分布式节点通信等各个方面的问题。而且，针对不同的应用场景，还需要在不同的特性之间权衡，例如，是否需要支持缓存更新？还是假定缓存在淘汰之前是不允许改变的。不同的权衡对应着不同的实现。</p>\n<p>groupcache 是 Go 语言版的 memcached，目的是在某些特定场合替代 memcached。groupcache 的作者也是 memcached 的作者。无论是了解单机缓存还是分布式缓存，深入学习这个库的实现都是非常有意义的。</p>\n<p>GeeCache 基本上模仿了 groupcache 的实现，为了将代码量限制在 500 行左右（groupcache 约 3000 行），裁剪了部分功能。但总体实现上，还是与 groupcache 非常接近的。</p>\n<h2 id=\"LRU缓存淘汰策略\">LRU缓存淘汰策略</h2>\n<h3 id=\"LRU算法实现\">LRU算法实现</h3>\n<h4 id=\"核心数据结构\">核心数据结构</h4>\n<p><img src=\"https://i.imgur.com/zHzjrlO.png\" alt=\"picture 2\"></p>\n<p>这张图很好地表示了 LRU 算法最核心的 2 个数据结构</p>\n<ul>\n<li>绿色的是字典(map)，存储键和值的映射关系。这样根据某个键(key)查找对应的值(value)的复杂是O(1)，在字典中插入一条记录的复杂度也是O(1)。</li>\n<li>红色的是双向链表(double linked list)实现的队列。将所有的值放到双向链表中，这样，当访问到某个值时，将其移动到队尾的复杂度是O(1)，在队尾新增一条记录以及删除一条记录的复杂度均为O(1)。</li>\n</ul>\n<p>接下来我们创建一个包含字典和双向链表的结构体类型 Cache，方便实现后续的增删查改操作。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> lru</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;container/list&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tmaxBytes <span class=\"keyword\">int64</span></span><br><span class=\"line\">\tnbytes   <span class=\"keyword\">int64</span></span><br><span class=\"line\">\tll       *list.List</span><br><span class=\"line\">\tcache    <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*list.Element</span><br><span class=\"line\">\t<span class=\"comment\">// 可选的，当一个entry被清除的时候会执行</span></span><br><span class=\"line\">\tonEvicted <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key <span class=\"keyword\">string</span>, value Value)</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 双向列表节点的数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> entry <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tkey <span class=\"keyword\">string</span></span><br><span class=\"line\">\tvalue Value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Value 接口类型，用Len来计算它携带了多少byte的数据</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Value <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tLen() <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在这里我们直接使用 Go 语言标准库实现的双向链表list.List。</li>\n<li>字典的定义是 map[string]*list.Element，键是字符串，值是双向链表中对应节点的指针。</li>\n<li>maxBytes 是允许使用的最大内存，nbytes 是当前已使用的内存，OnEvicted 是某条记录被移除时的回调函数，可以为 nil。</li>\n<li>键值对 entry 是双向链表节点的数据类型，在链表中仍保存每个值对应的 key 的好处在于，淘汰队首节点时，需要用 key 从字典中删除对应的映射。</li>\n<li>为了通用性，我们允许值是实现了 Value 接口的任意类型，该接口只包含了一个方法 Len() int，用于返回值所占用的内存大小。</li>\n</ul>\n<p>为了方便实例化Cache，实现New函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// New 构建一个Cache实例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(maxBytes <span class=\"keyword\">int64</span>, onEvicted <span class=\"keyword\">func</span>(<span class=\"keyword\">string</span>, Value)</span>) *<span class=\"title\">Cache</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Cache&#123;</span><br><span class=\"line\">\t\tmaxBytes:  maxBytes,</span><br><span class=\"line\">\t\tll:        list.New(),</span><br><span class=\"line\">\t\tcache:     <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*list.Element),</span><br><span class=\"line\">\t\tonEvicted: onEvicted,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"查找功能\">查找功能</h4>\n<p>查找主要有 2 个步骤，第一步是从字典中找到对应的双向链表的节点，第二步，将该节点移动到队尾。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Get 查找某个键对应的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Cache)</span> <span class=\"title\">Get</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(value Value, ok <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ele, ok := c.cache[key]; ok &#123;</span><br><span class=\"line\">\t\tc.ll.MoveToFront(ele)</span><br><span class=\"line\">\t\tkv := ele.Value.(*entry)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kv.value, <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果键对应的链表节点存在，则将对应节点移动到队尾，并返回查找到的值。</li>\n<li>c.ll.MoveToFront(ele)，即将链表中的节点 ele 移动到队尾（双向链表作为队列，队首队尾是相对的，在这里约定 front 为队尾）</li>\n</ul>\n<h4 id=\"删除-2\">删除</h4>\n<p>这里的删除，实际上是缓存淘汰。即移除最近最少访问的节点（队首）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// RemoveOldest 删除掉队尾的节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Cache)</span> <span class=\"title\">RemoveOldest</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//获取应该移除的节点（即队尾节点）</span></span><br><span class=\"line\">\tele := c.ll.Back()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ele != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//首先从队列中移除节点</span></span><br><span class=\"line\">\t\tc.ll.Remove(ele)</span><br><span class=\"line\">\t\t<span class=\"comment\">//然后从获取该节点对应的entry</span></span><br><span class=\"line\">\t\tkv := ele.Value.(*entry)</span><br><span class=\"line\">\t\t<span class=\"comment\">//从cache中删除掉这个节点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">delete</span>(c.cache, kv.key)</span><br><span class=\"line\">\t\tc.nbytes -= <span class=\"keyword\">int64</span>(<span class=\"built_in\">len</span>(kv.key)) + <span class=\"keyword\">int64</span>(kv.value.Len())</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c.onEvicted != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tc.onEvicted(kv.key, kv.value)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>c.ll.Back() 取到队首节点，从链表中删除。</li>\n<li>delete(c.cache, kv.key)，从字典中 c.cache 删除该节点的映射关系。</li>\n<li>更新当前所用的内存 c.nbytes。</li>\n<li>如果回调函数 OnEvicted 不为 nil，则调用回调函数。</li>\n</ul>\n<h4 id=\"增加-修改\">增加/修改</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Add 增加键值对映射</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Cache)</span> <span class=\"title\">Add</span><span class=\"params\">(key <span class=\"keyword\">string</span>, value Value)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果已经存在该键</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ele, ok := c.cache[key]; ok &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将键移到队首</span></span><br><span class=\"line\">\t\tc.ll.MoveToFront(ele)</span><br><span class=\"line\">\t\tkv := ele.Value.(*entry)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新键对应的值</span></span><br><span class=\"line\">\t\tc.nbytes += <span class=\"keyword\">int64</span>(value.Len()) - <span class=\"keyword\">int64</span>(kv.value.Len())</span><br><span class=\"line\">\t\tkv.value=value</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果该键不存在，需要在list和cache中都增加一个新的键值对</span></span><br><span class=\"line\">\t\tele:=c.ll.PushFront(&amp;entry&#123;key: key,value: value&#125;)</span><br><span class=\"line\">\t\tc.cache[key]=ele</span><br><span class=\"line\">\t\tc.nbytes+=<span class=\"keyword\">int64</span>(<span class=\"built_in\">len</span>(key))+<span class=\"keyword\">int64</span>(value.Len())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> c.maxBytes!=<span class=\"number\">0</span> &amp;&amp; c.maxBytes&lt;c.nbytes&#123;</span><br><span class=\"line\">\t\tc.RemoveOldest()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，为了方便测试，我们实现 Len() 用来获取添加了多少条数据。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Len the number of cache entries</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Cache)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.ll.Len()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试\">测试</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> lru</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> String <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(d String)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(d)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCache_Get</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tlru := New(<span class=\"keyword\">int64</span>(<span class=\"number\">0</span>), <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\tlru.Add(<span class=\"string\">&quot;weirdo&quot;</span>, String(<span class=\"string\">&quot;1234&quot;</span>))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v, ok := lru.Get(<span class=\"string\">&quot;weirdo&quot;</span>); !ok || <span class=\"keyword\">string</span>(v.(String)) != <span class=\"string\">&quot;1234&quot;</span> &#123;</span><br><span class=\"line\">\t\tt.Fatalf(<span class=\"string\">&quot;cache hit weirdo=1234 failed&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, ok := lru.Get(<span class=\"string\">&quot;peach&quot;</span>); ok &#123;</span><br><span class=\"line\">\t\tt.Fatalf(<span class=\"string\">&quot;cache miss key2 failed&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCache_RemoveOldest</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tk1, k2, k3 := <span class=\"string\">&quot;weirdo&quot;</span>, <span class=\"string\">&quot;peach&quot;</span>, <span class=\"string\">&quot;bye&quot;</span></span><br><span class=\"line\">\tv1, v2, v3 := <span class=\"string\">&quot;23&quot;</span>, <span class=\"string\">&quot;22&quot;</span>, <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">\t<span class=\"built_in\">cap</span> := <span class=\"built_in\">len</span>(k1 + k2 + v1 + v2)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlru := New(<span class=\"keyword\">int64</span>(<span class=\"built_in\">cap</span>), <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\tlru.Add(k1, String(v1))</span><br><span class=\"line\">\tlru.Add(k2, String(v2))</span><br><span class=\"line\">\tlru.Add(k3, String(v3))</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, ok := lru.Get(<span class=\"string\">&quot;weirdo&quot;</span>); ok || lru.Len() != <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\tt.Fatalf(<span class=\"string\">&quot;Removeoldest weirdo failed&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestOnEvicted</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tkeys := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">\tcallback := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key <span class=\"keyword\">string</span>, value Value)</span></span> &#123;</span><br><span class=\"line\">\t\tkeys = <span class=\"built_in\">append</span>(keys, key)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlru := New(<span class=\"keyword\">int64</span>(<span class=\"number\">10</span>), callback)</span><br><span class=\"line\">\tlru.Add(<span class=\"string\">&quot;key1&quot;</span>, String(<span class=\"string\">&quot;123456&quot;</span>))</span><br><span class=\"line\">\tlru.Add(<span class=\"string\">&quot;k2&quot;</span>, String(<span class=\"string\">&quot;k2&quot;</span>))</span><br><span class=\"line\">\tlru.Add(<span class=\"string\">&quot;k3&quot;</span>, String(<span class=\"string\">&quot;k3&quot;</span>))</span><br><span class=\"line\">\tlru.Add(<span class=\"string\">&quot;k4&quot;</span>, String(<span class=\"string\">&quot;k4&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">\texpect := []<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;key1&quot;</span>, <span class=\"string\">&quot;k2&quot;</span>&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !reflect.DeepEqual(expect, keys) &#123;</span><br><span class=\"line\">\t\tt.Fatalf(<span class=\"string\">&quot;call onEnvicted failed,expect keys equals to %s&quot;</span>, expect)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"单机并发缓存\">单机并发缓存</h2>\n<h3 id=\"sync-Mutex\">sync.Mutex</h3>\n<p>多个协程(goroutine)同时读写同一个变量，在并发度较高的情况下，会发生冲突。确保一次只有一个协程(goroutine)可以访问该变量以避免冲突，这称之为互斥，互斥锁可以解决这个问题。</p>\n<p>sync.Mutex 是 Go 语言标准库提供的一个互斥锁，当一个协程(goroutine)获得了这个锁的拥有权后，其它请求锁的协程(goroutine) 就会阻塞在 Lock() 方法的调用上，直到调用 Unlock() 锁被释放。</p>\n<p>接下来举一个简单的例子，假设有10个并发的协程打印了同一个数字100，为了避免重复打印，实现了printOnce(num int) 函数，使用集合 set 记录已打印过的数字，如果数字已打印过，则不再打印。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">bool</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printOnce</span><span class=\"params\">(num <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, exist := set[num]; !exist &#123;</span><br><span class=\"line\">\t\tfmt.Println(num)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tset[num] = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> printOnce(<span class=\"number\">100</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们运行 go run . 会发生什么情况呢？</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">go</span> run .</span><br><span class=\"line\"><span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<p>有时候打印 2 次，有时候打印 4 次，有时候还会触发 panic，因为对同一个数据结构set的访问冲突了。接下来用互斥锁的Lock()和Unlock() 方法将冲突的部分包裹起来：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> m sync.Mutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">bool</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printOnce</span><span class=\"params\">(num <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tm.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, exist := set[num]; !exist &#123;</span><br><span class=\"line\">\t\tfmt.Println(num)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tset[num] = <span class=\"literal\">true</span></span><br><span class=\"line\">\tm.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> printOnce(<span class=\"number\">100</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"支持并发读写\">支持并发读写</h3>\n<p>上一篇节 GeeCache 第一天 实现了 LRU 缓存淘汰策略。接下来我们使用 sync.Mutex 封装 LRU 的几个方法，使之支持并发的读写。在这之前，我们抽象了一个只读数据结构 ByteView 用来表示缓存值，是 GeeCache 主要的数据结构之一。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> geecache</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// A ByteView holds an immutable view of bytes.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ByteView <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tb []<span class=\"keyword\">byte</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Len returns the view&#x27;s length</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v ByteView)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(v.b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ByteSlice returns a copy of the data as a byte slice.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v ByteView)</span> <span class=\"title\">ByteSlice</span><span class=\"params\">()</span> []<span class=\"title\">byte</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cloneBytes(v.b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// String returns the data as a string, making a copy if necessary.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v ByteView)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">string</span>(v.b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cloneBytes</span><span class=\"params\">(b []<span class=\"keyword\">byte</span>)</span> []<span class=\"title\">byte</span></span> &#123;</span><br><span class=\"line\">\tc := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"built_in\">len</span>(b))</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(c, b)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ByteView 只有一个数据成员，b []byte，b 将会存储真实的缓存值。选择 byte 类型是为了能够支持任意的数据类型的存储，例如字符串、图片等。</li>\n<li>实现 Len() int 方法，我们在 lru.Cache 的实现中，要求被缓存对象必须实现 Value 接口，即 Len() int 方法，返回其所占的内存大小。</li>\n<li>b 是只读的，使用 ByteSlice() 方法返回一个拷贝，防止缓存值被外部程序修改。</li>\n</ul>\n<p>接下来就可以为 lru.Cache 添加并发特性了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> geecache</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;GeeCache/geecache/lru&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> cache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tmu         sync.Mutex</span><br><span class=\"line\">\tlru        *lru.Cache</span><br><span class=\"line\">\tcacheBytes <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *cache)</span> <span class=\"title\">add</span><span class=\"params\">(key <span class=\"keyword\">string</span>, value ByteView)</span></span> &#123;</span><br><span class=\"line\">\tc.mu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> c.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.lru == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tc.lru = lru.New(c.cacheBytes, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc.lru.Add(key, value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *cache)</span> <span class=\"title\">get</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(value ByteView, ok <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\tc.mu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> c.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.lru == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v, ok := c.lru.Get(key); ok &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v.(ByteView), ok</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>cache.go 的实现非常简单，实例化 lru，封装 get 和 add 方法，并添加互斥锁 mu。</li>\n<li>在 add 方法中，判断了 c.lru 是否为 nil，如果等于 nil 再创建实例。这种方法称之为延迟初始化(Lazy Initialization)，一个对象的延迟初始化意味着该对象的创建将会延迟至第一次使用该对象时。主要用于提高性能，并减少程序内存要求。</li>\n</ul>\n<h3 id=\"主体结构Group\">主体结构Group</h3>\n<p>Group 是 GeeCache 最核心的数据结构，负责与用户的交互，并且控制缓存值存储和获取的流程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">   是</span><br><span class=\"line\">接收 key --&gt; 检查是否被缓存 -----&gt; 返回缓存值 ⑴</span><br><span class=\"line\">                |  否                         是</span><br><span class=\"line\">                |-----&gt; 是否应当从远程节点获取 -----&gt; 与远程节点交互 --&gt; 返回缓存值 ⑵</span><br><span class=\"line\">                            |  否</span><br><span class=\"line\">                            |-----&gt; 调用`回调函数`，获取值并添加到缓存 --&gt; 返回缓存值 ⑶</span><br></pre></td></tr></table></figure>\n<p>接下来我们将实现流程 ⑴ 和 ⑶，远程交互的部分后续再实现。</p>\n<h4 id=\"回调Getter\">回调Getter</h4>\n<p>我们思考一下，如果缓存不存在，应从数据源（文件，数据库等）获取数据并添加到缓存中。GeeCache 是否应该支持多种数据源的配置呢？不应该，一是数据源的种类太多，没办法一一实现；二是扩展性不好。如何从源头获取数据，应该是用户决定的事情，我们就把这件事交给用户好了。因此，我们设计了一个回调函数(callback)，在缓存不存在时，调用这个函数，得到源数据。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> geecache</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Getter <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tGet(key <span class=\"keyword\">string</span>) ([]<span class=\"keyword\">byte</span>, error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GetterFunc 用一个函数实现Getter</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> GetterFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f GetterFunc)</span> <span class=\"title\">Get</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> f(key)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义接口 Getter 和 回调函数 Get(key string)([]byte, error)，参数是 key，返回值是 []byte。<br>\n定义函数类型 GetterFunc，并实现 Getter 接口的 Get 方法。<br>\n函数类型实现某一个接口，称之为接口型函数，方便使用者在调用时既能够传入函数作为参数，也能够传入实现了该接口的结构体作为参数。</p>\n<h4 id=\"Group的定义\">Group的定义</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A Group is a cache namespace and associated data loaded spread over</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Group <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tname      <span class=\"keyword\">string</span></span><br><span class=\"line\">\tgetter    Getter</span><br><span class=\"line\">\tmainCache cache</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tmu     sync.RWMutex</span><br><span class=\"line\">\tgroups = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*Group)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewGroup create a new instance of Group</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewGroup</span><span class=\"params\">(name <span class=\"keyword\">string</span>, cacheBytes <span class=\"keyword\">int64</span>, getter Getter)</span> *<span class=\"title\">Group</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> getter == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;nil Getter&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> mu.Unlock()</span><br><span class=\"line\">\tg := &amp;Group&#123;</span><br><span class=\"line\">\t\tname:      name,</span><br><span class=\"line\">\t\tgetter:    getter,</span><br><span class=\"line\">\t\tmainCache: cache&#123;cacheBytes: cacheBytes&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgroups[name] = g</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GetGroup returns the named group previously created with NewGroup, or</span></span><br><span class=\"line\"><span class=\"comment\">// nil if there&#x27;s no such group.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GetGroup</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> *<span class=\"title\">Group</span></span> &#123;</span><br><span class=\"line\">\tmu.RLock()</span><br><span class=\"line\">\tg := groups[name]</span><br><span class=\"line\">\tmu.RUnlock()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>一个 Group 可以认为是一个缓存的命名空间，每个 Group 拥有一个唯一的名称 name。比如可以创建三个 Group，缓存学生的成绩命名为 scores，缓存学生信息的命名为 info，缓存学生课程的命名为 courses。</li>\n<li>第二个属性是 getter Getter，即缓存未命中时获取源数据的回调(callback)。</li>\n<li>第三个属性是 mainCache cache，即一开始实现的并发缓存。</li>\n<li>构建函数 NewGroup 用来实例化 Group，并且将 group 存储在全局变量 groups 中。</li>\n<li>GetGroup 用来特定名称的 Group，这里使用了只读锁 RLock()，因为不涉及任何冲突变量的写操作。</li>\n</ul>\n<h4 id=\"Group的Get方法\">Group的Get方法</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Get value for a key from cache</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">Get</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(ByteView, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> key == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ByteView&#123;&#125;, fmt.Errorf(<span class=\"string\">&quot;key is required&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v, ok := g.mainCache.get(key); ok &#123;</span><br><span class=\"line\">\t\tlog.Println(<span class=\"string\">&quot;[GeeCache] hit&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g.load(key)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">load</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(value ByteView, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g.getLocally(key)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">getLocally</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(ByteView, error)</span></span> &#123;</span><br><span class=\"line\">\tbytes, err := g.getter.Get(key)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ByteView&#123;&#125;, err</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvalue := ByteView&#123;b: cloneBytes(bytes)&#125;</span><br><span class=\"line\">\tg.populateCache(key, value)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> value, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">populateCache</span><span class=\"params\">(key <span class=\"keyword\">string</span>, value ByteView)</span></span> &#123;</span><br><span class=\"line\">\tg.mainCache.add(key, value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Get 方法实现了上述所说的流程 ⑴ 和 ⑶。</li>\n<li>流程 ⑴ ：从 mainCache 中查找缓存，如果存在则返回缓存值。</li>\n<li>流程 ⑶ ：缓存不存在，则调用 load 方法，load 调用 getLocally（分布式场景下会调用 getFromPeer 从其他节点获取），getLocally 调用用户回调函数 g.getter.Get() 获取源数据，并且将源数据添加到缓存 mainCache 中（通过 populateCache 方法）</li>\n</ul>\n<h3 id=\"测试-2\">测试</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> db = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>&#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;weirdo&quot;</span>: <span class=\"string\">&quot;23&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;peach&quot;</span>:  <span class=\"string\">&quot;22&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;love&quot;</span>:   <span class=\"string\">&quot;21&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGroup_Get</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tloadCounts := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>, <span class=\"built_in\">len</span>(db))</span><br><span class=\"line\">\tgee := NewGroup(<span class=\"string\">&quot;source&quot;</span>, <span class=\"number\">2</span>&lt;&lt;<span class=\"number\">10</span>, GetterFunc(</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(<span class=\"string\">&quot;[SlowDB] search key&quot;</span>, key)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> v, ok := db[key]; ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> _, ok := loadCounts[key]; !ok &#123;</span><br><span class=\"line\">\t\t\t\t\tloadCounts[key] = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tloadCounts[key] += <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> []<span class=\"keyword\">byte</span>(v), <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;%s not exist&quot;</span>, key)</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t))</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> db &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果取出来的值和db中的值不同</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> view, err := gee.Get(k); err != <span class=\"literal\">nil</span> || view.String() != v &#123;</span><br><span class=\"line\">\t\t\tt.Fatalf(<span class=\"string\">&quot;failed to get value of %s&quot;</span>, k)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果取到值的过程调用了多次回调函数，说明根本就没存在缓存里</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _, err := gee.Get(k); err != <span class=\"literal\">nil</span> || loadCounts[k] &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\tt.Fatalf(<span class=\"string\">&quot;cache %s miss&quot;</span>, k)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> view, err := gee.Get(<span class=\"string\">&quot;unknown&quot;</span>); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tt.Fatalf(<span class=\"string\">&quot;the value of unknow should be empty, but %s got&quot;</span>, view)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个测试用例中，我们主要测试了 2 种情况</p>\n<ul>\n<li>1）在缓存为空的情况下，能够通过回调函数获取到源数据。</li>\n<li>2）在缓存已经存在的情况下，是否直接从缓存中获取，为了实现这一点，使用 loadCounts 统计某个键调用回调函数的次数，如果次数大于1，则表示调用了多次回调函数，没有缓存。</li>\n</ul>\n<h2 id=\"HTTP服务端\">HTTP服务端</h2>\n<h3 id=\"GeeCache-HTTP服务端\">GeeCache HTTP服务端</h3>\n<p>分布式缓存需要实现节点间通信，建立基于 HTTP 的通信机制是比较常见和简单的做法。如果一个节点启动了 HTTP 服务，那么这个节点就可以被其他节点访问。今天我们就为单机节点搭建 HTTP Server。</p>\n<p>首先我们创建一个结构体 HTTPPool，作为承载节点间 HTTP 通信的核心数据结构（包括服务端和客户端，今天只实现服务端）。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> geecache</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> defaultBasePath = <span class=\"string\">&quot;/_geecache/&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> HTTPPool <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tself     <span class=\"keyword\">string</span> <span class=\"comment\">// 该节点的URL，比如&quot;https://example.net:8000&quot;</span></span><br><span class=\"line\">\tbasePath <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewHTTPPool</span><span class=\"params\">(self <span class=\"keyword\">string</span>)</span> *<span class=\"title\">HTTPPool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;HTTPPool&#123;</span><br><span class=\"line\">\t\tself:     self,</span><br><span class=\"line\">\t\tbasePath: defaultBasePath,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>HTTPPool 只有 2 个参数，一个是 self，用来记录自己的地址，包括主机名/IP 和端口。</li>\n<li>另一个是 basePath，作为节点间通讯地址的前缀，默认是 /_geecache/，那么 <a href=\"http://example.com/_geecache/\">http://example.com/_geecache/</a> 开头的请求，就用于节点间的访问。因为一个主机上还可能承载其他的服务，加一段 Path 是一个好习惯。比如，大部分网站的 API 接口，一般以 /api 作为前缀。</li>\n</ul>\n<p>接下来，实现最为核心的 ServeHTTP 方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *HTTPPool)</span> <span class=\"title\">Log</span><span class=\"params\">(format <span class=\"keyword\">string</span>, v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">&quot;[Server %s] %s&quot;</span>, p.self, fmt.Sprintf(format, v...))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *HTTPPool)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !strings.HasPrefix(r.URL.Path, p.basePath) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;HTTPPool serving unexpected path:&quot;</span> + r.URL.Path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tp.Log(<span class=\"string\">&quot;%s %s&quot;</span>, r.Method, r.URL.Path)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 服务器上的路径是/basepath/groupname/key</span></span><br><span class=\"line\">\tparts := strings.SplitN(r.URL.Path[<span class=\"built_in\">len</span>(p.basePath):], <span class=\"string\">&quot;/&quot;</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(parts) != <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\thttp.Error(w, <span class=\"string\">&quot;bad request&quot;</span>, http.StatusBadRequest)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgroupName := parts[<span class=\"number\">0</span>]</span><br><span class=\"line\">\tkey := parts[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">\tgroup := GetGroup(groupName)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> group == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\thttp.Error(w, <span class=\"string\">&quot;no such group:&quot;</span>+groupName, http.StatusNotFound)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tview,err:=group.Get(key)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err!=<span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\thttp.Error(w,err.Error(),http.StatusInternalServerError)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tw.Header().Set(<span class=\"string\">&quot;Content-Type&quot;</span>,<span class=\"string\">&quot;application/octet-stream&quot;</span>)</span><br><span class=\"line\">\tw.Write(view.ByteSlice())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ServeHTTP 的实现逻辑是比较简单的，首先判断访问路径的前缀是否是 basePath，不是返回错误。</li>\n<li>我们约定访问路径格式为 /<basepath>/<groupname>/<key>，通过 groupname 得到 group 实例，再使用 group.Get(key) 获取缓存数据。</li>\n<li>最终使用 w.Write() 将缓存值作为 httpResponse 的 body 返回。</li>\n</ul>\n<h3 id=\"测试-3\">测试</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;geecache&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>&#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;Tom&quot;</span>:  <span class=\"string\">&quot;630&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;Jack&quot;</span>: <span class=\"string\">&quot;589&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;Sam&quot;</span>:  <span class=\"string\">&quot;567&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tgeecache.NewGroup(<span class=\"string\">&quot;scores&quot;</span>, <span class=\"number\">2</span>&lt;&lt;<span class=\"number\">10</span>, geecache.GetterFunc(</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(<span class=\"string\">&quot;[SlowDB] search key&quot;</span>, key)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> v, ok := db[key]; ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> []<span class=\"keyword\">byte</span>(v), <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;%s not exist&quot;</span>, key)</span><br><span class=\"line\">\t\t&#125;))</span><br><span class=\"line\"></span><br><span class=\"line\">\taddr := <span class=\"string\">&quot;localhost:9999&quot;</span></span><br><span class=\"line\">\tpeers := geecache.NewHTTPPool(addr)</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;geecache is running at&quot;</span>, addr)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(addr, peers))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>同样地，我们使用 map 模拟了数据源 db。</li>\n<li>创建一个名为 scores 的 Group，若缓存为空，回调函数会从 db 中获取数据并返回。</li>\n<li>使用 http.ListenAndServe 在 9999 端口启动了 HTTP 服务。</li>\n</ul>\n<h2 id=\"一致性哈希\">一致性哈希</h2>\n<h3 id=\"为什么使用一致性哈希\">为什么使用一致性哈希</h3>\n<h4 id=\"我该访问谁\">我该访问谁</h4>\n<p>对于分布式缓存来说，当一个节点接收到请求，如果该节点并没有存储缓存值，那么它面临的难题是，从谁那获取数据？自己，还是节点1, 2, 3, 4… 。假设包括自己在内一共有 10 个节点，当一个节点接收到请求时，随机选择一个节点，由该节点从数据源获取数据。</p>\n<p>假设第一次随机选取了节点 1 ，节点 1 从数据源获取到数据的同时缓存该数据；那第二次，只有 1/10 的可能性再次选择节点 1, 有 9/10 的概率选择了其他节点，如果选择了其他节点，就意味着需要再一次从数据源获取数据，一般来说，这个操作是很耗时的。这样做，一是缓存效率低，二是各个节点上存储着相同的数据，浪费了大量的存储空间。</p>\n<p>那有什么办法，对于给定的 key，每一次都选择同一个节点呢？使用 hash 算法也能够做到这一点。那把 key 的每一个字符的 ASCII 码加起来，再除以 10 取余数可以吗？当然可以，这可以认为是自定义的 hash 算法。</p>\n<h4 id=\"节点数量变化了怎么办\">节点数量变化了怎么办</h4>\n<p>简单求取 Hash 值解决了缓存性能的问题，但是没有考虑节点数量变化的场景。假设，移除了其中一台节点，只剩下 9 个，那么之前 hash(key) % 10 变成了 hash(key) % 9，也就意味着几乎缓存值对应的节点都发生了改变。即几乎所有的缓存值都失效了。节点在接收到对应的请求时，均需要重新去数据源获取数据，容易引起 缓存雪崩。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">缓存雪崩：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。常因为缓存服务器宕机，或缓存设置了相同的过期时间引起。</span><br></pre></td></tr></table></figure>\n<p>那如何解决这个问题呢？一致性哈希算法可以。</p>\n<h3 id=\"算法原理\">算法原理</h3>\n<h4 id=\"步骤\">步骤</h4>\n<p>一致性哈希算法将 key 映射到 2^32 的空间中，将这个数字首尾相连，形成一个环。</p>\n<ul>\n<li>计算节点/机器(通常使用节点的名称、编号和 IP 地址)的哈希值，放置在环上。</li>\n<li>计算 key 的哈希值，放置在环上，顺时针寻找到的第一个节点，就是应选取的节点/机器。</li>\n</ul>\n<p><img src=\"https://i.imgur.com/bwtzmdF.png\" alt=\"picture 1\"></p>\n<p>环上有 peer2，peer4，peer6 三个节点，key11，key2，key27 均映射到 peer2，key23 映射到 peer4。此时，如果新增节点/机器 peer8，假设它新增位置如图所示，那么只有 key27 从 peer2 调整到 peer8，其余的映射均没有发生改变。</p>\n<p>也就是说，一致性哈希算法，在新增/删除节点时，只需要重新定位该节点附近的一小部分数据，而不需要重新定位所有的节点，这就解决了上述的问题。</p>\n<h4 id=\"数据倾斜问题\">数据倾斜问题</h4>\n<p>如果服务器的节点过少，容易引起 key 的倾斜。例如上面例子中的 peer2，peer4，peer6 分布在环的上半部分，下半部分是空的。那么映射到环下半部分的 key 都会被分配给 peer2，key 过度向 peer2 倾斜，缓存节点间负载不均。</p>\n<p>为了解决这个问题，引入了虚拟节点的概念，一个真实节点对应多个虚拟节点。</p>\n<p>假设 1 个真实节点对应 3 个虚拟节点，那么 peer1 对应的虚拟节点是 peer1-1、 peer1-2、 peer1-3（通常以添加编号的方式实现），其余节点也以相同的方式操作。</p>\n<ul>\n<li>第一步，计算虚拟节点的 Hash 值，放置在环上。</li>\n<li>第二步，计算 key 的 Hash 值，在环上顺时针寻找到应选取的虚拟节点，例如是 peer2-1，那么就对应真实节点 peer2。</li>\n</ul>\n<p>虚拟节点扩充了节点的数量，解决了节点较少的情况下数据容易倾斜的问题。而且代价非常小，只需要增加一个字典(map)维护真实节点与虚拟节点的映射关系即可。</p>\n<h3 id=\"go语言实现\">go语言实现</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> consistenthash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;hash/crc32&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Hash <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(data []<span class=\"keyword\">byte</span>)</span> <span class=\"title\">uint32</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Map <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\thash     Hash</span><br><span class=\"line\">\t<span class=\"comment\">//虚拟节点的倍数</span></span><br><span class=\"line\">\treplicas <span class=\"keyword\">int</span></span><br><span class=\"line\">\tkeys     []<span class=\"keyword\">int</span></span><br><span class=\"line\">\thashMap  <span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(replicas <span class=\"keyword\">int</span>,fn Hash)</span>*<span class=\"title\">Map</span></span>&#123;</span><br><span class=\"line\">\tm:=&amp;Map&#123;</span><br><span class=\"line\">\t\treplicas: replicas,</span><br><span class=\"line\">\t\thash: fn,</span><br><span class=\"line\">\t\thashMap: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">string</span>),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> m.hash==<span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\tm.hash=crc32.ChecksumIEEE</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>定义了函数类型 Hash，采取依赖注入的方式，允许用于替换成自定义的 Hash 函数，也方便测试时替换，默认为 crc32.ChecksumIEEE 算法。</li>\n<li>Map 是一致性哈希算法的主数据结构，包含 4 个成员变量：Hash 函数 hash；虚拟节点倍数 replicas；哈希环 keys；虚拟节点与真实节点的映射表 hashMap，键是虚拟节点的哈希值，值是真实节点的名称。</li>\n<li>构造函数 New() 允许自定义虚拟节点倍数和 Hash 函数。</li>\n</ul>\n<p>接下来，实现添加真实节点/机器的 Add() 方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Add 向hash表中添加几个key</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Map)</span> <span class=\"title\">Add</span><span class=\"params\">(keys ...<span class=\"keyword\">string</span>)</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _,key :=<span class=\"keyword\">range</span> keys&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>;i&lt;m.replicas;i++&#123;</span><br><span class=\"line\">\t\t\tkeyHashed:=<span class=\"keyword\">int</span>(m.hash([]<span class=\"keyword\">byte</span>(strconv.Itoa(i)+key)))</span><br><span class=\"line\">\t\t\tm.keys=<span class=\"built_in\">append</span>(m.keys,keyHashed)</span><br><span class=\"line\">\t\t\tm.hashMap[keyHashed]=key</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tsort.Ints(m.keys)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Add 函数允许传入 0 或 多个真实节点的名称。</li>\n<li>对每一个真实节点 key，对应创建 m.replicas 个虚拟节点，虚拟节点的名称是：strconv.Itoa(i) + key，即通过添加编号的方式区分不同虚拟节点。</li>\n<li>使用 m.hash() 计算虚拟节点的哈希值，使用 append(m.keys, hash) 添加到环上。</li>\n<li>在 hashMap 中增加虚拟节点和真实节点的映射关系。</li>\n<li>最后一步，环上的哈希值排序。</li>\n</ul>\n<p>最后一步，实现选择节点的 Get() 方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Map)</span> <span class=\"title\">Get</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(m.keys)==<span class=\"number\">0</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tkeyHashed:=<span class=\"keyword\">int</span>(m.hash([]<span class=\"keyword\">byte</span>(key)))</span><br><span class=\"line\">\t<span class=\"comment\">//采用二分搜索</span></span><br><span class=\"line\">\tidx:=sort.Search(<span class=\"built_in\">len</span>(m.keys), <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> m.keys[i]&gt;=keyHashed</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> m.hashMap[m.keys[idx%<span class=\"built_in\">len</span>(m.keys)]]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>选择节点就非常简单了，第一步，计算 key 的哈希值。</li>\n<li>第二步，顺时针找到第一个匹配的虚拟节点的下标 idx，从 m.keys 中获取到对应的哈希值。如果 idx == len(m.keys)，说明应选择 m.keys[0]，因为 m.keys 是一个环状结构，所以用取余数的方式来处理这种情况。</li>\n<li>第三步，通过 hashMap 映射得到真实的节点。<br>\n至此，整个一致性哈希算法就实现完成了。</li>\n</ul>\n<h3 id=\"测试-4\">测试</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> consistenthash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;strconv&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestHashing</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\thash := New(<span class=\"number\">3</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key []<span class=\"keyword\">byte</span>)</span> <span class=\"title\">uint32</span></span> &#123;</span><br><span class=\"line\">\t\ti, _ := strconv.Atoi(<span class=\"keyword\">string</span>(key))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">uint32</span>(i)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//根据上面的hash的定义，下面增加的节点会产生如下的键：1，3，6，11，13，16，21，23，26</span></span><br><span class=\"line\">\thash.Add(<span class=\"string\">&quot;6&quot;</span>, <span class=\"string\">&quot;3&quot;</span>, <span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\ttestCases := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;1&quot;</span>:  <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;21&quot;</span>: <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;23&quot;</span>: <span class=\"string\">&quot;3&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;27&quot;</span>: <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> testCases &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> hash.Get(k) != v &#123;</span><br><span class=\"line\">\t\t\tt.Errorf(<span class=\"string\">&quot;Asking for %s,should have yield %s&quot;</span>, k, v)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\thash.Add(<span class=\"string\">&quot;8&quot;</span>)</span><br><span class=\"line\">\t<span class=\"comment\">//27应该要映射到8了</span></span><br><span class=\"line\">\ttestCases[<span class=\"string\">&quot;27&quot;</span>] = <span class=\"string\">&quot;8&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> testCases &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> hash.Get(k) != v &#123;</span><br><span class=\"line\">\t\t\tt.Errorf(<span class=\"string\">&quot;Asking for %s, should have yielded %s&quot;</span>, k, v)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要进行测试，那么我们需要明确地知道每一个传入的 key 的哈希值，那使用默认的 crc32.ChecksumIEEE 算法显然达不到目的。所以在这里使用了自定义的 Hash 算法。自定义的 Hash 算法只处理数字，传入字符串表示的数字，返回对应的数字即可。</p>\n<ul>\n<li>一开始，有 2/4/6 三个真实节点，对应的虚拟节点的哈希值是 02/12/22、04/14/24、06/16/26。</li>\n<li>那么用例 2/11/23/27 选择的虚拟节点分别是 02/12/24/02，也就是真实节点 2/2/4/2。</li>\n<li>添加一个真实节点 8，对应虚拟节点的哈希值是 08/18/28，此时，用例 27 对应的虚拟节点从 02 变更为 28，即真实节点 8。</li>\n</ul>\n<h2 id=\"分布式节点\">分布式节点</h2>\n<h3 id=\"流程回顾\">流程回顾</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  是</span><br><span class=\"line\">接收 key --&gt; 检查是否被缓存 -----&gt; 返回缓存值 ⑴</span><br><span class=\"line\">                |  否                         是</span><br><span class=\"line\">                |-----&gt; 是否应当从远程节点获取 -----&gt; 与远程节点交互 --&gt; 返回缓存值 ⑵</span><br><span class=\"line\">                            |  否</span><br><span class=\"line\">                            |-----&gt; 调用`回调函数`，获取值并添加到缓存 --&gt; 返回缓存值 ⑶</span><br></pre></td></tr></table></figure>\n<p>我们在之前描述了 geecache 的流程。在这之前已经实现了流程 ⑴ 和 ⑶，今天实现流程 ⑵，从远程节点获取缓存值。</p>\n<p>我们进一步细化流程 ⑵：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">使用一致性哈希选择节点        是                                    是</span><br><span class=\"line\">    |-----&gt; 是否是远程节点 -----&gt; HTTP 客户端访问远程节点 --&gt; 成功？-----&gt; 服务端返回返回值</span><br><span class=\"line\">                    |  否                                    ↓  否</span><br><span class=\"line\">                    |----------------------------&gt; 回退到本地节点处理。</span><br></pre></td></tr></table></figure>\n<h3 id=\"抽象PeerPicker\">抽象PeerPicker</h3>\n<p>在这里，抽象出 2 个接口，PeerPicker 的 PickPeer() 方法用于根据传入的 key 选择相应节点 PeerGetter。<br>\n接口 PeerGetter 的 Get() 方法用于从对应 group 查找缓存值。PeerGetter 就对应于上述流程中的 HTTP 客户端。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> geecache</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PeerPicker is the interface that must be implemented to locate</span></span><br><span class=\"line\"><span class=\"comment\">// the peer that owns a specific key.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PeerPicker <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tPickPeer(key <span class=\"keyword\">string</span>) (peer PeerGetter, ok <span class=\"keyword\">bool</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PeerGetter is the interface that must be implemented by a peer.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PeerGetter <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tGet(group <span class=\"keyword\">string</span>, key <span class=\"keyword\">string</span>) ([]<span class=\"keyword\">byte</span>, error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"节点选择和HTTP客户端\">节点选择和HTTP客户端</h3>\n<p>首先创建具体的 HTTP 客户端类 httpGetter，实现 PeerGetter 接口。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> httpGetter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tbaseURL <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *httpGetter)</span> <span class=\"title\">Get</span><span class=\"params\">(group <span class=\"keyword\">string</span>, key <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tu := fmt.Sprintf(</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;%v%v/%v&quot;</span>,</span><br><span class=\"line\">\t\th.baseURL,</span><br><span class=\"line\">\t\turl.QueryEscape(group),</span><br><span class=\"line\">\t\turl.QueryEscape(key),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tres, err := http.Get(u)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> res.Body.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;server returned: %v&quot;</span>, res.Status)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbytes, err := ioutil.ReadAll(res.Body)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;reading response body: %v&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> bytes, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> _ PeerGetter = (*httpGetter)(<span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>baseURL 表示将要访问的远程节点的地址，例如 <a href=\"http://example.com/_geecache/%E3%80%82\">http://example.com/_geecache/。</a></li>\n<li>使用 http.Get() 方式获取返回值，并转换为 []bytes 类型。</li>\n</ul>\n<p>第二步，为 HTTPPool 添加节点选择的功能。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tdefaultBasePath = <span class=\"string\">&quot;/_geecache/&quot;</span></span><br><span class=\"line\">\tdefaultReplicas = <span class=\"number\">50</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// HTTPPool implements PeerPicker for a pool of HTTP peers.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> HTTPPool <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// this peer&#x27;s base URL, e.g. &quot;https://example.net:8000&quot;</span></span><br><span class=\"line\">\tself        <span class=\"keyword\">string</span></span><br><span class=\"line\">\tbasePath    <span class=\"keyword\">string</span></span><br><span class=\"line\">\tmu          sync.Mutex <span class=\"comment\">// guards peers and httpGetters</span></span><br><span class=\"line\">\tpeers       *consistenthash.Map</span><br><span class=\"line\">\thttpGetters <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*httpGetter <span class=\"comment\">// keyed by e.g. &quot;http://10.0.0.2:8008&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>新增成员变量 peers，类型是一致性哈希算法的 Map，用来根据具体的 key 选择节点。</li>\n<li>新增成员变量 httpGetters，映射远程节点与对应的 httpGetter。每一个远程节点对应一个 httpGetter，因为 httpGetter 与远程节点的地址 baseURL 有关。</li>\n</ul>\n<p>第三步，实现 PeerPicker 接口。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Set 更新pool的peers列表信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *HTTPPool)</span> <span class=\"title\">Set</span><span class=\"params\">(peers ...<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\tp.mu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> p.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\tp.peers = consistenthash.New(defaultReplicas, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\tp.peers.Add(peers...)</span><br><span class=\"line\">\tp.httpGetters = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*httpGetter, <span class=\"built_in\">len</span>(peers))</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, peer := <span class=\"keyword\">range</span> peers &#123;</span><br><span class=\"line\">\t\tp.httpGetters[peer] = &amp;httpGetter&#123;baseURL: peer + p.basePath&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PickPeer 找到对应的存储的节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *HTTPPool)</span> <span class=\"title\">PickPeer</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(PeerGetter, <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\tp.mu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> p.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> peer := p.peers.Get(key); peer != <span class=\"string\">&quot;&quot;</span> &amp;&amp; peer != p.self &#123;</span><br><span class=\"line\">\t\tp.Log(<span class=\"string\">&quot;Pick peer %s&quot;</span>, peer)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p.httpGetters[peer], <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>,<span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Set() 方法实例化了一致性哈希算法，并且添加了传入的节点。</li>\n<li>并为每一个节点创建了一个 HTTP 客户端 httpGetter。</li>\n<li>PickerPeer() 包装了一致性哈希算法的 Get() 方法，根据具体的 key，选择节点，返回节点对应的 HTTP 客户端。<br>\n至此，HTTPPool 既具备了提供 HTTP 服务的能力，也具备了根据具体的 key，创建 HTTP 客户端从远程节点获取缓存值的能力。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A Group is a cache namespace and associated data loaded spread over</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Group <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tname      <span class=\"keyword\">string</span></span><br><span class=\"line\">\tgetter    Getter</span><br><span class=\"line\">\tmainCache cache</span><br><span class=\"line\">\tpeers     PeerPicker</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RegisterPeers registers a PeerPicker for choosing remote peer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">RegisterPeers</span><span class=\"params\">(peers PeerPicker)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> g.peers != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;RegisterPeerPicker called more than once&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tg.peers = peers</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">load</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(value ByteView, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> g.peers != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> peer, ok := g.peers.PickPeer(key); ok &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> value, err = g.getFromPeer(peer, key); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> value, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tlog.Println(<span class=\"string\">&quot;[GeeCache] Failed to get from peer&quot;</span>, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g.getLocally(key)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">getFromPeer</span><span class=\"params\">(peer PeerGetter, key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(ByteView, error)</span></span> &#123;</span><br><span class=\"line\">\tbytes, err := peer.Get(g.name, key)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ByteView&#123;&#125;, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ByteView&#123;b: bytes&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>新增 RegisterPeers() 方法，将 实现了 PeerPicker 接口的 HTTPPool 注入到 Group 中。</li>\n<li>新增 getFromPeer() 方法，使用实现了 PeerGetter 接口的 httpGetter 从访问远程节点，获取缓存值。</li>\n<li>修改 load 方法，使用 PickPeer() 方法选择节点，若非本机节点，则调用 getFromPeer() 从远程获取。若是本机节点或失败，则回退到 getLocally()。</li>\n</ul>\n<h3 id=\"main函数测试\">main函数测试</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> db = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>&#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;Tom&quot;</span>:  <span class=\"string\">&quot;630&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;Jack&quot;</span>: <span class=\"string\">&quot;589&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;Sam&quot;</span>:  <span class=\"string\">&quot;567&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createGroup</span><span class=\"params\">()</span> *<span class=\"title\">geecache</span>.<span class=\"title\">Group</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> geecache.NewGroup(<span class=\"string\">&quot;scores&quot;</span>, <span class=\"number\">2</span>&lt;&lt;<span class=\"number\">10</span>, geecache.GetterFunc(</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(<span class=\"string\">&quot;[SlowDB] search key&quot;</span>, key)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> v, ok := db[key]; ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> []<span class=\"keyword\">byte</span>(v), <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;%s not exist&quot;</span>, key)</span><br><span class=\"line\">\t\t&#125;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startCacheServer</span><span class=\"params\">(addr <span class=\"keyword\">string</span>, addrs []<span class=\"keyword\">string</span>, gee *geecache.Group)</span></span> &#123;</span><br><span class=\"line\">\tpeers := geecache.NewHTTPPool(addr)</span><br><span class=\"line\">\tpeers.Set(addrs...)</span><br><span class=\"line\">\tgee.RegisterPeers(peers)</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;geecache is running at&quot;</span>, addr)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(addr[<span class=\"number\">7</span>:], peers))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startAPIServer</span><span class=\"params\">(apiAddr <span class=\"keyword\">string</span>, gee *geecache.Group)</span></span> &#123;</span><br><span class=\"line\">\thttp.Handle(<span class=\"string\">&quot;/api&quot;</span>, http.HandlerFunc(</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t\t\tkey := r.URL.Query().Get(<span class=\"string\">&quot;key&quot;</span>)</span><br><span class=\"line\">\t\t\tview, err := gee.Get(key)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tw.Header().Set(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/octet-stream&quot;</span>)</span><br><span class=\"line\">\t\t\tw.Write(view.ByteSlice())</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;))</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;fontend server is running at&quot;</span>, apiAddr)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(apiAddr[<span class=\"number\">7</span>:], <span class=\"literal\">nil</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> port <span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> api <span class=\"keyword\">bool</span></span><br><span class=\"line\">\tflag.IntVar(&amp;port, <span class=\"string\">&quot;port&quot;</span>, <span class=\"number\">8001</span>, <span class=\"string\">&quot;Geecache server port&quot;</span>)</span><br><span class=\"line\">\tflag.BoolVar(&amp;api, <span class=\"string\">&quot;api&quot;</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;Start a api server?&quot;</span>)</span><br><span class=\"line\">\tflag.Parse()</span><br><span class=\"line\"></span><br><span class=\"line\">\tapiAddr := <span class=\"string\">&quot;http://localhost:9999&quot;</span></span><br><span class=\"line\">\taddrMap := <span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">string</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"number\">8001</span>: <span class=\"string\">&quot;http://localhost:8001&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">8002</span>: <span class=\"string\">&quot;http://localhost:8002&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">8003</span>: <span class=\"string\">&quot;http://localhost:8003&quot;</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> addrs []<span class=\"keyword\">string</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> addrMap &#123;</span><br><span class=\"line\">\t\taddrs = <span class=\"built_in\">append</span>(addrs, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgee := createGroup()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> api &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> startAPIServer(apiAddr, gee)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstartCacheServer(addrMap[port], []<span class=\"keyword\">string</span>(addrs), gee)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>main 函数的代码比较多，但是逻辑是非常简单的。</p>\n<ul>\n<li>startCacheServer() 用来启动缓存服务器：创建 HTTPPool，添加节点信息，注册到 gee 中，启动 HTTP 服务（共3个端口，8001/8002/8003），用户不感知。</li>\n<li>startAPIServer() 用来启动一个 API 服务（端口 9999），与用户进行交互，用户感知。</li>\n<li>main() 函数需要命令行传入 port 和 api 2 个参数，用来在指定端口启动 HTTP 服务。</li>\n</ul>\n<h2 id=\"防止缓存击穿\">防止缓存击穿</h2>\n<h3 id=\"缓存雪崩、缓存击穿和缓存穿透\">缓存雪崩、缓存击穿和缓存穿透</h3>\n<ul>\n<li>缓存雪崩：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的 key 设置了相同的过期时间等引起。</li>\n<li>缓存击穿：一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时DB请求量大、压力骤增。</li>\n<li>缓存穿透：查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB，导致宕机。</li>\n</ul>\n<h3 id=\"singleflight的实现\">singleflight的实现</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">之前的测试结果</span><br><span class=\"line\">2020/02/16 21:17:45 [Server http://localhost:8003] Pick peer http://localhost:8001</span><br><span class=\"line\">2020/02/16 21:17:45 [Server http://localhost:8003] Pick peer http://localhost:8001</span><br><span class=\"line\">2020/02/16 21:17:45 [Server http://localhost:8003] Pick peer http://localhost:8001</span><br></pre></td></tr></table></figure>\n<p>我们并发了 N 个请求 ?key=Tom，8003 节点向 8001 同时发起了 N 次请求。假设对数据库的访问没有做任何限制的，很可能向数据库也发起 N 次请求，容易导致缓存击穿和穿透。即使对数据库做了防护，HTTP 请求是非常耗费资源的操作，针对相同的 key，8003 节点向 8001 发起三次请求也是没有必要的。那这种情况下，我们如何做到只向远端节点发起一次请求呢？</p>\n<p>geecache 实现了一个名为 singleflight 的 package 来解决这个问题。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> singleflight</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> call <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\twg  sync.WaitGroup</span><br><span class=\"line\">\tval <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">\terr error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Group <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tmu sync.Mutex       <span class=\"comment\">// protects m</span></span><br><span class=\"line\">\tm  <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*call</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>call 代表正在进行中，或已经结束的请求。使用 sync.WaitGroup 锁避免重入。</li>\n<li>Group 是 singleflight 的主数据结构，管理不同 key 的请求(call)。</li>\n</ul>\n<p>实现Do方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">Do</span><span class=\"params\">(key <span class=\"keyword\">string</span>, fn <span class=\"keyword\">func</span>()</span> <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span>) <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class=\"line\">\tg.mu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> g.m == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tg.m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*call)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class=\"line\">\t\tg.mu.Unlock()</span><br><span class=\"line\">\t\tc.wg.Wait()</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> c.val, c.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc := <span class=\"built_in\">new</span>(call)</span><br><span class=\"line\">\tc.wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\tg.m[key] = c</span><br><span class=\"line\">\tg.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\tc.val, c.err = fn()</span><br><span class=\"line\">\tc.wg.Done()</span><br><span class=\"line\"></span><br><span class=\"line\">\tg.mu.Lock()</span><br><span class=\"line\">\t<span class=\"built_in\">delete</span>(g.m, key)</span><br><span class=\"line\">\tg.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.val, c.err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Do 方法，接收 2 个参数，第一个参数是 key，第二个参数是一个函数 fn。Do 的作用就是，针对相同的 key，无论 Do 被调用多少次，函数 fn 都只会被调用一次，等待 fn 调用结束了，返回返回值或错误。</p>\n<h3 id=\"singleflight的使用、\">singleflight的使用、</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Group <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tname      <span class=\"keyword\">string</span></span><br><span class=\"line\">\tgetter    Getter</span><br><span class=\"line\">\tmainCache cache</span><br><span class=\"line\">\tpeers     PeerPicker</span><br><span class=\"line\">\t<span class=\"comment\">// use singleflight.Group to make sure that</span></span><br><span class=\"line\">\t<span class=\"comment\">// each key is only fetched once</span></span><br><span class=\"line\">\tloader *singleflight.Group</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewGroup</span><span class=\"params\">(name <span class=\"keyword\">string</span>, cacheBytes <span class=\"keyword\">int64</span>, getter Getter)</span> *<span class=\"title\">Group</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">\tg := &amp;Group&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\tloader:    &amp;singleflight.Group&#123;&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">load</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(value ByteView, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// each key is only fetched once (either locally or remotely)</span></span><br><span class=\"line\">\t<span class=\"comment\">// regardless of the number of concurrent callers.</span></span><br><span class=\"line\">\tviewi, err := g.loader.Do(key, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> g.peers != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> peer, ok := g.peers.PickPeer(key); ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> value, err = g.getFromPeer(peer, key); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> value, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tlog.Println(<span class=\"string\">&quot;[GeeCache] Failed to get from peer&quot;</span>, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> g.getLocally(key)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> viewi.(ByteView), <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改 geecache.go 中的 Group，添加成员变量 loader，并更新构建函数 NewGroup。</li>\n<li>修改 load 函数，将原来的 load 的逻辑，使用 <a href=\"http://g.loader.Do\">g.loader.Do</a> 包裹起来即可，这样确保了并发场景下针对相同的 key，load 过程只会调用一次。</li>\n</ul>\n<h2 id=\"使用protobuf通信\">使用protobuf通信</h2>\n<h3 id=\"为什么使用protobuf\">为什么使用protobuf</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">protobuf 即 Protocol Buffers，Google 开发的一种数据描述语言，是一种轻便高效的结构化数据存储格式，与语言、平台无关，可扩展可序列化。protobuf 以二进制方式存储，占用空间小。</span><br></pre></td></tr></table></figure>\n<p>使用 protobuf 的目的非常简单，为了获得更高的性能。传输前使用 protobuf 编码，接收方再进行解码，可以显著地降低二进制传输的大小。另外一方面，protobuf 可非常适合传输结构化数据，便于通信字段的扩展。<a href=\"https://geektutu.com/post/quick-go-protobuf.html\">go protobuf简明教程</a></p>\n<p>使用 protobuf 一般分为以下 2 步：</p>\n<ul>\n<li>按照 protobuf 的语法，在 .proto 文件中定义数据结构，并使用 protoc 生成 Go 代码（.proto 文件是跨平台的，还可以生成 C、Java 等其他源码文件）。</li>\n<li>在项目代码中引用生成的 Go 代码。</li>\n</ul>\n<h3 id=\"使用protobuf通信-2\">使用protobuf通信</h3>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">&quot;proto3&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> geecachepb;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">Request</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> <span class=\"keyword\">group</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> key = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">Response</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">bytes</span> value = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">service</span> <span class=\"title\">GroupCache</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">rpc</span> Get(Request) <span class=\"keyword\">returns</span> (Response)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Request 包含 2 个字段， group 和 cache，这与我们之前定义的接口 /_geecache/<group>/<name> 所需的参数吻合。</li>\n<li>Response 包含 1 个字段，bytes，类型为 byte 数组，与之前吻合。</li>\n</ul>\n","categories":["go"],"tags":["分布式cache"]},{"title":"简单易懂地理解LSTM","url":"/2022/03/23/%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E5%9C%B0%E7%90%86%E8%A7%A3LSTM/","content":"<h2 id=\"lstm结构\">lstm结构</h2>\n<p><img src=\"https://i.imgur.com/YTwGUXM.png\" alt=\"picture 5\"></p>\n<p>相较于传统的RNN只有一个状态值传递，lstm传递了两个状态，其中c(cell state)变化地比较慢，而h(hidden state)则在不同节点下往往有很大的区别</p>\n<span id=\"more\"></span>\n<h2 id=\"深入lstm结构\">深入lstm结构</h2>\n<p>首先用lstm当前的输入和上层传递过来的$h^{t-1}$拼接训练得到四个状态</p>\n<p><img src=\"https://i.imgur.com/T581bEb.png\" alt=\"picture 6\"></p>\n<p>接下来介绍这四个状态在LSTM内部的使用</p>\n<p><img src=\"https://i.imgur.com/Vsx3k7N.png\" alt=\"picture 7\"></p>\n<p>lstm主要有三个阶段：</p>\n<ol>\n<li>忘记阶段。对上个节点传过来的输入做选择性忘记。即通过$z^f$作为忘记门控，来控制上一个状态的$c^{t-1}$</li>\n<li>选择记忆。将这个阶段的输入进行有选择性地记忆。选择门控信号由$z^i$控制。到这里将这两步的结果进行相加就可以得到传递给下一时间步的$c^t$</li>\n<li>输出阶段。通过$z^0$控制当前状态的输出应该是什么。</li>\n</ol>\n","categories":["DeepLearning"],"tags":["LSTM"]},{"title":"简单易懂地理解GRU","url":"/2022/03/23/%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E5%9C%B0%E7%90%86%E8%A7%A3GRU/","content":"<h2 id=\"GRU的输入输出结构\">GRU的输入输出结构</h2>\n<p>它的输入是当前时刻的输入$x^t$和上一时刻传递过来的隐状态$h^{t-1}$，通过对这两个数据的结合进行操作，会得到当前节点的输出$y^t$和传递给下一个节点的隐状态$h^t$</p>\n<span id=\"more\"></span>\n<p><img src=\"https://i.imgur.com/Lb0dS15.png\" alt=\"picture 1\"></p>\n<h2 id=\"GRU的内部结构\">GRU的内部结构</h2>\n<p>其中有两个门控状态。r控制重置门，z控制更新门，具体计算过程如下图所示</p>\n<p><img src=\"https://i.imgur.com/25vkcJn.png\" alt=\"picture 2\"></p>\n<p>得到门控信号之后，首先使用重置门的数据来得到重置后的$h^{t-1’}=h^{t-1}\\odot r$，再将$h^{t-1’}$与输入进行拼接得到下图</p>\n<p><img src=\"https://i.imgur.com/ulcM3RC.png\" alt=\"picture 3\"></p>\n<p>这里的$h’$主要包含了当前输入的$x^t$数据，相当于记忆了当前时刻的状态。</p>\n<p>最后一步是进行更新，更新表达式如下</p>\n<p><img src=\"https://i.imgur.com/U9JlMYQ.png\" alt=\"picture 4\"></p>\n","categories":["DeepLearning"],"tags":["GRU"]},{"title":"节点表示如何生成图表示","url":"/2022/03/19/%E8%8A%82%E7%82%B9%E8%A1%A8%E7%A4%BA%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%9B%BE%E8%A1%A8%E7%A4%BA/","content":"<h2 id=\"图读出操作\">图读出操作</h2>\n<p>顾名思义，图读出操作就是用来生成图表示的。它的核心要义在于：操作本身要对节点顺序不敏感。</p>\n<p>为什么是这样呢？因为在欧氏空间中如果一张图片旋转了，那么他就是新的图片了；但在非欧氏空间中，如果一个图旋转一下，比如重新编号，形成的图仍然是原图。这就是典型的图重构问题。下面两个图是等价的</p>\n<p><img src=\"https://i.imgur.com/1lrMMsW.png\" alt=\"picture 35\"></p>\n<p>为了使得同构图能够保持一致，图读出的操作就需要对节点顺序不敏感。数学上能表达这种操作的函数称为对称函数。</p>\n<p>接下来介绍两中方法实现图读出操作：<strong>基于统计的方法</strong>和<strong>基于学习的方法</strong></p>\n<span id=\"more\"></span>\n<h2 id=\"基于统计的方法\">基于统计的方法</h2>\n<p>有学者提出用类似直方图的方法对每维数据分布进行建模。假设我们有100个介于[-3,1]之间的数字，如果我们直接将他们求和，就看不出他们的分布情况；而如果我们将[-3,1]分成4个子区域，分开统计各个区域的和就能略微发现一些原始数据分布特征，如下图</p>\n<p><img src=\"https://i.imgur.com/YT5Y8pE.png\" alt=\"picture 36\"></p>\n<p>如果要实现上面这个做法，应该怎么做呢？很简单，举个例子，给定3个数据点，他们的特征向量（2D）分别是[-2,1],[-1,2]和[-1,1]。如果直接求和，全局的特征向量是[-2±1±1,1+2+1]即[-4,4]。如果采取上述直方图的方式，则可能会得到一个这样的全局特征向量<code>[-2, -1 + -1, 1 + 1, 2]</code>（第1,2维代表从原先的第1维统计的直方图,对应的区域为<code>[-2,1),[1,2)</code>,第3,4维的含义类似）。但在实践中并没有使用这种方法，而是采用高斯函数来实现名为模糊直方图的操作。</p>\n<p><img src=\"https://i.imgur.com/T5HHZvP.png\" alt=\"picture 37\"></p>\n<p>模糊直方图的原理也很简单：预先定义几个特征值区域的边界为各个高斯分布的均匀值，并且预设好方差。对于任一特征值，根据其与各个高斯分布交点的纵坐标作为其落入该区域的数值，然后将所有数值归一化。比如，图上的[1.8]与三个高斯分布交点分别在0，0.3，0.9处，归一化一下可以用一个三维向量<code>[0.0,0.25,0.75]</code>表示。</p>\n<h2 id=\"基于学习的方法\">基于学习的方法</h2>\n<p>基于统计的方法的坏处在于它没办法参数化，间接地难以表示节点到图向量的“复杂过程”。基于学习的方法就是希望用神经网络来拟合这个过程。</p>\n<h3 id=\"采样加全连接\">采样加全连接</h3>\n<p>最简单的做法，取固定数量节点，通过全连接层得到图表示。这里不论是随机采样，还是根据某些规则采样，都需要得到确定数量的节点，不够就填充。公式也很简单（$H^L指的是将采样到的节点表示拼在一起）：</p>\n<p><img src=\"https://i.imgur.com/4wwS4yv.png\" alt=\"picture 38\"></p>\n<p>这种方法很难适用于规模差距很大的图。比如训练时见过的图只有几百个节点，但测试的图可能有上千个节点，很难泛化。</p>\n<h3 id=\"全局节点\">全局节点</h3>\n<p>这种做法动机很简单，考虑到图同构问题和基于统计的方法，从节点的表示生成最终图表示主要有两个难点：</p>\n<ol>\n<li>难以找到一个合适的根节点（图的根节点一般都是根据领域知识确定的，比如前面第一篇中讲到的化合物分类）</li>\n<li>如果直接用基于统计的方法对各个节点一视同仁，无法区别对待（比如某些重要的节点信息更多，就应该表达得更多）</li>\n</ol>\n<p>那直接引入一个全局节点代表这张图的根节点，把他跟图中的每个节点通过一种特殊的边连接，最终拿这个节点的表示作为整个图的表示，岂不是很棒？</p>\n<h3 id=\"可微池化\">可微池化</h3>\n<p>上面的两中方法都比较简单，不会层次化地去获得图表示。因此又有研究者提出了一种层次化的图的表示，而这依赖于他们提出的可微池化技术。简单来说就是，他不希望各个节点一次性得到图的表示，而是希望通过一个逐渐压缩信息的过程，来得到最终图的表示。如下图所示：</p>\n<p><img src=\"https://i.imgur.com/QCFr9Db.png\" alt=\"picture 39\"></p>\n<p>相比于一般先通过GCN获取所有节点表示，再通过方法汇总得到图的最终表示的方法，DiffPool同时完成了两个任务：<strong>节点聚类</strong>和<strong>节点表示</strong>。</p>\n<p>这两个任务是由两个不共享参数的GCN模块分别完成的，下文用SC和NR分别表示这两个模块。NR模块和传统GCN一样，输入是各个节点隐藏状态，通过图上的传播，输出是传播后各个节点的i傲视。SC模块则不同，虽然输入也是各节点的隐藏表示，但输出是各节点属于不同聚类簇的概率（这里每一层聚类簇的数目是预先定义的）。上图中最左侧每个节点右上方的表格就代表这个。举个例子，假设本层子图有6个节点，将各个节点输出的簇分类概率堆叠在一起，就可以得到矩阵$S^l$，如下图所示（三个颜色代表三个聚类簇。实际中，聚类矩阵不是离散变量，而是连续变量）</p>\n<p><img src=\"https://i.imgur.com/eDLJ1Nn.png\" alt=\"picture 40\"></p>\n<p>用$A_l$表示第l层子图节点的邻接关系，$A^0$即是图的邻接矩阵，$N_l$表示第l层节点的个数，$H^l$表示第l层子图各个节点表示堆叠而成的隐状态矩阵，DiffPool通过如下公式得到新子图中各个节点的表示：</p>\n<p><img src=\"https://i.imgur.com/B53yvW6.png\" alt=\"picture 41\"></p>\n<p>除了表示各个节点的表示之外，还有一个很重要的事情是生成新子图$A^{l+1}$的邻接关系</p>\n<p><img src=\"https://i.imgur.com/dEP1ZEr.png\" alt=\"picture 42\"></p>\n<a href=\"/2022/03/19/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/\" title=\"图神经网络概述\">图神经网络概述</a>\n<a href=\"/2022/03/19/%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/\" title=\"图卷积神经网络概述\">图卷积神经网络概述</a>\n<a href=\"/2022/03/19/%E8%8A%82%E7%82%B9%E8%A1%A8%E7%A4%BA%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%9B%BE%E8%A1%A8%E7%A4%BA/\" title=\"节点表示如何生成图表示\">节点表示如何生成图表示</a>","categories":["图神经网络"],"tags":["GCN 综述"]},{"title":"Hellinger Distance Based Drift Detection for Nonstationary Environments","url":"/2022/04/14/Hellinger-Distance-Based-Drift-Detection-for-Nonstationary-Environments/","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>本文作者将改变决策边界的突然的数据分布变化定义为concept change，逐渐的数据分布的变化定义为概念漂移。但是如果在不需要仔细区分两者的情况下，使用概念漂移作为其统一名称，因为概念漂移更难检测一点。</p>\n<span id=\"more\"></span>\n\n<p>流式数据中有两种漂移检测方法：</p>\n<ul>\n<li>被动检测：每次获取到新数据的时候，学习器都假设漂移已经发生，然后根据现有的数据分布更新分类器，不管是否真的发生漂移。</li>\n<li>主动检测：持续显式地监视数据以检测是否发生漂移，只有发生漂移的时候，算法才会采取行动，比如用最近的数据更新分类器或者创建一个新的分类器来学习当前的数据。</li>\n</ul>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>HDDDM的总体特征：</p>\n<ul>\n<li>数据块：基于批的</li>\n<li>使用的信息：原始特征（不依赖于分类的准确率）</li>\n<li>检测漂移的模式：显式</li>\n<li>指定分类器还是不限分类器：不限分类器</li>\n</ul>\n<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>该检测方法的动机是检测在一系列的批数据中是否发生了漂移。选择Hellinger距离作为衡量依据是因为没有对数据的分布进行假设并且Hellinger距离使该方法能够测量两个顺序时间戳上数据分布的变化。</p>\n<p>HDDDM使用当前数据分布和参考分布（就是最新的一些数据）之间的距离Hellinger距离。该距离和KL散度相似，都是f散度的一个实例，不同点在于Hellinger散度是对称度量。此外，H散度是一个有界距离度量：对于两个概率密度函数为P和Q的分布，H散度是 $\\delta_H(P,Q)\\in[0,\\sqrt{2}]$ 。如果 $\\delta_H(P,Q)&#x3D;0$ ，说明两个概率密度函数是完全相同的；如果 $\\delta_H(P,Q)&#x3D;\\sqrt{2}$ ，说明两个概率密度函数是完全不同的。</p>\n<p>举个例子说，考虑具有类中心以圆形模式移动的高斯的两类旋转混合，其中每一个分布都表示一个不同的类（下图所示）。类均值可以通过参数化方程给出 $\\mu_1^{(t)}&#x3D;[cos\\theta_t,sin\\theta_t]^T,\\mu_2^{(t)}&#x3D;-\\mu_1^(t),\\theta_t&#x3D;\\frac{2\\pi c}{N}t$ ，固定的类协方差矩阵为 $\\epsilon_1&#x3D;\\epsilon_2&#x3D;0.5*I$ ，其中c是圆的数量，t是时间戳（从0到N-1），I是一个2x2的单位矩阵。</p>\n<p><img src=\"https://i.imgur.com/I3YriW6.png\" alt=\"picture 2\">  </p>\n<p>Hellinger距离能够展示新数据集 $D_k$ 和基准数据集 $D_1$ 之间的相似度。下图给出了类1、类2和整个数据集上的散度的Hellinger距离。我们发现Hellinger距离随着 $\\theta$ 的变化而变得不同。并且当 $\\theta_1$ 和 $\\theta_k$ 相近的时候，H距离就很小（t&#x3D;0，200，400，600）。</p>\n<p><img src=\"https://i.imgur.com/TzQxK4a.png\" alt=\"picture 3\">  </p>\n<p>另外，如果控制不同时间的数据分布是相同的话，不同时间的数据H距离就会是一个很小的常数，但是不是0。这是因为类均值的一些不同和采样出来的随机性导致的。</p>\n<h3 id=\"假设\"><a href=\"#假设\" class=\"headerlink\" title=\"假设\"></a>假设</h3><p>该方法做出了三个假设：</p>\n<ul>\n<li>有标签的训练数据集是以批形式送入漂移检测算法的，H距离是在两个数据分布的直方图上计算的。如果只能一条一条地获取数据的话，可以积累数据来形成直方图以供计算。</li>\n<li>数据分布具有有限的范围： 当 $x\\leq T_1$ ，$P(X\\leq x)&#x3D;0$；当 $x\\geq T_2$ ， $P(X \\geq x)$ , 其中 $T_1&lt;T_2$ 是有限实数（前面描述的就是数据的分布范围是有限的不是无限的）。我们将直方图中用于计算H距离的bin的数量固定为 $\\lfloor \\sqrt{N} \\rfloor$ ，其中N是每一个时间步上获取到的数据的数量。当然，这个值可以根据先前经验来设置，但是如果对这方面不熟悉的话，就用 $\\sqrt{N}$ 就可以了。</li>\n<li>为了服从真实的增量学习的设置，每个样本都只会被算法获取一次。</li>\n</ul>\n<h3 id=\"漂移检测算法\"><a href=\"#漂移检测算法\" class=\"headerlink\" title=\"漂移检测算法\"></a>漂移检测算法</h3><p>下图是HDDDM的伪代码</p>\n<p><img src=\"https://i.imgur.com/hEeGsF1.png\" alt=\"picture 4\">  </p>\n<p>算法初始化 $\\lambda &#x3D;1,D_\\lambda &#x3D;D_1$ 其中 $\\lambda$ 是上一次发生漂移的时间步。 $D_1$ 是D的初始化，后续的 $D_\\lambda$ 的更新如下所述。</p>\n<p>算法先根据 $D_t,D_\\lambda$ 构建直方图P和Q，他们的bin都为 $\\lfloor \\sqrt{N} \\rfloor$，N是当前batch的数据数量。两个直方图的H距离会通过下面的公式进行计算。先单独计算每一个特征的H距离，然后所有特征的距离的平均值作为最终的距离。</p>\n<p><img src=\"https://i.imgur.com/5tmN1Qh.png\" alt=\"picture 5\">  </p>\n<p>其中d是数据的维数，$P_{i,k}(Q_{i,k})$  是在直方图中关于特征k的第i个bin的数值。然后计算 $\\epsilon(t)$ ，即当前时间步的H散度和上一时间步的H散度。将这两个之间的差距和一个阈值进行比较，来决定差距是否足够大到称之为一个漂移。这里的阈值采用了一个自适应的方法，能够跟着时间步自动调整。其实就是将基准数据集的时间步开始到当前时间步的前一时间步的 $\\epsilon(t)$ 求一个平均值，然后再求其标准差。</p>\n<p>真实的阈值 $\\beta(t)$ 就是用下面的公式求。作者这里提出了两种方法来求，一种基于标准差，另一种基于置信度。</p>\n<p>第一种的计算公式如下</p>\n<p><img src=\"https://i.imgur.com/u2P1ZQM.png\" alt=\"picture 6\">  </p>\n<p>其中 $\\gamma$ 是一个正实数，表示标准差改变多少就认为足够多了。</p>\n<p>第二种的计算公式如下，</p>\n<p><img src=\"https://i.imgur.com/zF90WCy.png\" alt=\"picture 7\">  </p>\n<p>如果检测到漂移的话，我们需要对基准数据分布进行重置，重置为当前批次；如果没有检测到漂移的话，就将当前数据信息放到基准数据分布中，如下所示：</p>\n<p><img src=\"https://i.imgur.com/HlZK3EK.png\" alt=\"picture 8\">  </p>\n","categories":["异常检测"]},{"title":"Unsupervised Concept Drift DetectionUsing a Student–Teacher Approach","url":"/2022/04/17/Unsupervised-Concept-Drift-DetectionUsing-a-Student%E2%80%93Teacher-Approach/","content":"<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>作者提出了一个基于学生-教师的方法。本质上是构建一个辅助模型来模仿主模型的行为。运行过程中，使用老师模型来预测新的实例并且监控学生模型的模仿损失以检测概念漂移。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>使用教师-学生模型通过检测学生模型的模仿损失来判断漂移。模仿损失是一个学生预测和老师预测之间的差异函数。概念漂移发生时，它导致类的先验概率发生变化或预测变量的类条件概率发生变化。我们假设这些变化会破坏教师和学生模型之间的集体行为。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>该方法主要有三个步骤：</p>\n<ul>\n<li>创建主模型T</li>\n<li>创建学生模型S，模仿主模型的行为</li>\n<li>部署主模型T并且基于S的损失进行漂移检测</li>\n</ul>\n<h3 id=\"创建老师和学生模型\"><a href=\"#创建老师和学生模型\" class=\"headerlink\" title=\"创建老师和学生模型\"></a>创建老师和学生模型</h3><p>$D_{tr}(X,y)$ 表示可以获取的训练数据，用它来训练分类器T。该模型用于预测数据流中传来的样本，我们称之为 $X_{new}$ 。我们用T来预测 $D_{tr}(X,y)$ 得到 $\\hat{y}<em>{T,tr}$ 。然后构建一个新的数据集 $D</em>{tr}(x,\\hat{y}_T)$ 用于训练学生分类器S。</p>\n<h3 id=\"漂移检测\"><a href=\"#漂移检测\" class=\"headerlink\" title=\"漂移检测\"></a>漂移检测</h3><p>由于我们真实标签是无法获取的，所以无法计算主模型T的损失，但是我们能够衡量学生模型的，对于学生来说它的标签就是老师给的，然后再和他自己预测的结果做一个损失。</p>\n<p>实际上，这个方法的本质可以理解为检测学生模型的错误率，以此来达到类似有监督学习的效果。</p>\n<p>当漂移发生时，会导致类的先验概率 $p(y|X)$ 的改变。而这一变化会扰动学生模型的损失。因此，监视这一损失就足够获取到漂移信息了。</p>\n","categories":["异常检测"]},{"title":"Know-GNN: An Explainable Knowledge-Guided Graph Neural Network for Fraud Detection","url":"/2022/04/22/Know-GNN-An-Explainable-Knowledge-Guided-Graph-Neural-Network-for-Fraud-Detection/","content":"<h2 id=\"摘要\">摘要</h2>\n<p>欺诈检测会有两个挑战：</p>\n<ul>\n<li>现实中的欺诈检测缺少带标签的样本</li>\n<li>最新的基于机器学习的检测方法缺少可解释性</li>\n</ul>\n<p>作者提出了一个知识引导的GNN称为Know-GNN，使用专业知识去粗略地去给数据进行打标然后使用一个可解释的半监督方法训练一个欺诈检测器。采用了 <strong>图函数依赖(Graph Functional Dependency,GFD)</strong> 作为知识的统一表示来打标并且给出检测结果的解释。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言\">引言</h2>\n<p>KnowGNN的总体结构如下图。打标前，通过标记有标签数据来初始化GFD的可靠性。然后采用了一个使用噪声样本的训练方法（联合训练）来使用无标签数据和有标签数据共同训练GNN。最后在联合训练网络中增加一个attention机制来决定检测结果的可靠性向量，该向量表明每个GFD规则对欺诈检测的结果做出了多少贡献。</p>\n<p><img src=\"https://i.imgur.com/XJhBLn9.png\" alt=\"picture 1\"></p>\n<h2 id=\"方法\">方法</h2>\n<h3 id=\"结构\">结构</h3>\n<p>结构如上图。最初的节点分为两部分，一部分有标签称为 $V_{lab}$ ，一部分没有标签（金标）称为 $V_{unlab}$ 。无标签数据通过带有可靠性向量的GFD规则打标。由这些规则打标的数据被认为是噪声。</p>\n<p>每次联合训练的epoch前，通过伪随机方法对噪声数据进行采样成噪声标签 $N_{data}$ 。金标数据以同样的大小对 $V_{data}$ 采样成为金标 $G_{data}$ 。这两个数据集分别用于训练噪声网络f和黄金网络g。在每个训练周期中，通过图注意力机制聚合每个邻居信息之后，选取topk个最小损失的数据放入另一个网络中作为有用的知识来更新参数。网络自身也拿出topk-2个最小损失的数据一起来更新自己。网络选用自身数据和传来的数据的比例通过 $\\sigma_{se}$ 控制。</p>\n<p>每个训练周期结束后，噪声网络被用于对无标签数据再次打标并且更新可靠性向量。</p>\n<h3 id=\"无标签数据的打标\">无标签数据的打标</h3>\n<h4 id=\"图函数依赖-GFD\">图函数依赖(GFD)</h4>\n<p>图函数依赖表示为 $Q[\\overline{x}](X \\rightarrow Y)$ ，其中 $Q[\\overline{x}]$ 是图模式，X和Y是 $\\overline{x}$ 的两个文字集合。比如说下图中，GFD规则识别普通银行卡可以表示为 $Q[\\overline{x}](X \\rightarrow Y)$ 。其中 $Q[\\overline{x}]$ 就是整张图的模式，$X={F_a(Card)=(Workplace=‘Beijing’;Credit\\lt 100);$ $F_a(e)=(transferAmount \\gt 1000;transferType =‘loan’)},Y={F_a(SP)=(bankLevel=3;operatorID=ABC;isFraud=True)}$ 。 这个表达式说明如果交易满足图中的模式，并且GFD约束了X，那么下图中红框的服务提供端就是欺诈。</p>\n<p><img src=\"https://i.imgur.com/q9S13bb.png\" alt=\"picture 2\"></p>\n<h4 id=\"可靠性（RE）\">可靠性（RE）</h4>\n<p>RE是用来定义可以被网络f更新的数据的噪声等级的。 $v_{RE}$ 是欺诈实例的可靠性向量，其中包含所有能够识别该实例的GFD规则的RE，其他GFD规则被置为0。噪声数据的可靠性等于 $v_{RE}$ 中的最小值。黄金数据的可靠性向量与噪声数据的计算相同，因此黄金数据的可靠性 RE 设置为 1。</p>\n<p>GFD规则的RE初始化通过使用规则对黄金数据打标并且使用F1得分作为其RE。RE的下边界设置为0.8。</p>\n<h3 id=\"Know-GNN\">Know-GNN</h3>\n<p>作者使用GAT作为算法的基本方法。节点i的向量 $h_i$ 是由它的特征向量 $\\overline{h_i}$ 和他的可靠性向量 $v_{RE}$ 拼接起来的。邻接节点的聚合和图注意力网络的方法是一样的</p>\n<p><img src=\"https://i.imgur.com/4OXhhYL.png\" alt=\"picture 3\"></p>\n<p>网络的损失函数使用交叉熵求得。黄金网络g是一个经典的GAT。作者修改了具有可靠性的交叉熵损失，以适应 Noisy 网络 f 的标签不确定性。</p>\n<p><img src=\"https://i.imgur.com/B40z7l1.png\" alt=\"picture 4\"></p>\n<p>在交叉熵损失中增加了log(RE)，表名可靠性越高，惩罚就越小。此外，可靠性向量 $v_{RE}$ 和可靠性通过下式更新</p>\n<p><img src=\"https://i.imgur.com/5bax3wO.png\" alt=\"picture 5\"></p>\n<p>可靠性通过可靠性向量中的最小的非零值更新。</p>\n","categories":["图神经网络"],"tags":["欺诈检测"]},{"title":"gRPC基础学习","url":"/2022/04/26/gRPC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","content":"<h2 id=\"gRPC如何生成代码\">gRPC如何生成代码</h2>\n<p>客户端上会有一个存根，提供和服务器上相同的方法，由gRPC自动生成。当调用其中方法的时候，存根会在后台调用gRPC框架，通过网络与服务器交换信息。</p>\n<p><img src=\"https://i.imgur.com/CpGtllp.png\" alt=\"picture 1\"></p>\n<p>为了服务器和客户端能够生成存根，我们首先需要写一个API的契约，在一个protocol buffer中编写服务及其有效负载的描述</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax=&quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">package proto;</span><br><span class=\"line\"></span><br><span class=\"line\">service Greeter&#123;</span><br><span class=\"line\">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;;</span><br><span class=\"line\">  rpc SayList (HelloRequest) returns (stream HelloReply) &#123;&#125;;</span><br><span class=\"line\">  rpc SayRecord (stream HelloRequest) returns (HelloReply) &#123;&#125;;</span><br><span class=\"line\">  rpc SayRoute(stream HelloRequest) returns (stream HelloReply);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloRequest&#123;</span><br><span class=\"line\">  string name=1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloReply&#123;</span><br><span class=\"line\">  string message=1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个proto文件中，服务器和客户端的存根通过协议缓冲区编译器（protoc）生成。根据编程语言的不同，需要告诉编译器使用正确的gRPC插件。</p>\n<h2 id=\"gRPC的秘密武器\">gRPC的秘密武器</h2>\n<h3 id=\"为什么选择HTTP-2\">为什么选择HTTP/2</h3>\n<p>gRPC 使用 HTTP/2 作为其传输协议，因此它继承了 HTTP/2 提供的一些强大功能，例如二进制帧，与其他基于文本的协议相比，它具有高性能和健壮、传输更轻、解码更安全。而且因为它是二进制的，所以它与协议缓冲区是一个很好的组合。</p>\n<p>在 HTTP/2 中可以进行多路复用，这意味着客户端和服务器可以通过单个 TCP 连接并行发送多个请求和响应。这将有助于减少延迟并提高网络利用率。</p>\n<p>HTTP/2 还使用 HPACK 压缩标头，这将降低开销成本并提高性能。</p>\n<p>最后，HTTP/2 允许服务器推送，其中来自客户端的 1 个请求，服务器可以发送回多个响应。在许多情况下，当服务器确切地知道客户端需要什么资源并在它们被请求之前发送它们时，这对于减少客户端和服务器之间的往返延迟非常有价值。</p>\n<p>可以用这个演示来看HTTP/2比1.1快多少<a href=\"http://www.http2demo.io/\">速度比较链接</a></p>\n<h3 id=\"HTTP-2工作原理\">HTTP/2工作原理</h3>\n<p>有一个 TCP 连接可以承载多个双向流。每个流都有一个唯一的标识符，并携带多个双向消息。</p>\n<p>每条消息，可以是请求或响应，都被分解成多个二进制帧。帧是承载不同类型数据的最小单位，例如 HEADERS、SETTINGS、PRIORITY、DATA 等。</p>\n<p>事实上，这些流实际上并没有单独流动，而是它们的帧在连接上交错，到达另一端时会重新组合。多亏了这个二进制成帧层，HTTP/2 中的流多路复用成为可能。</p>\n<h3 id=\"HTTP-2和HTTP-1-1\">HTTP/2和HTTP/1.1</h3>\n<ul>\n<li>2是二进制协议，1是文本协议</li>\n<li>2中会压缩标头，1中是纯文本</li>\n<li>2允许多路复用，1不允许</li>\n<li>2中可以在单个连接中发多个请求和响应，1中只能一个</li>\n<li>服务器推送可以用2，但不能用1</li>\n</ul>\n<h2 id=\"gRPC和REST，何时使用gRPC\">gRPC和REST，何时使用gRPC</h2>\n<p>gRPC 使用 Protocol Buffer 来序列化有效载荷数据，它是二进制的，更小，而 REST 使用 JSON，它是文本，更大。</p>\n<p>gRPC 中的 API 契约是严格的，需要在 proto 文件中明确定义。在 REST 中，它通常是松散的和可选的。如果需要，我们可以通过 OpenAPI 定义它，但这不是强制性的。</p>\n<p>gRPC 和 REST 通信都使用 TLS/SSL 保护。</p>\n<p>流式传输在 gRPC 中是双向的，而在 REST 中只有一种方式从客户端到服务器的请求。</p>\n<p>因此，对于我们迄今为止提到的大多数事情，gRPC 都比 REST 更好。然而，有一件事是 REST 还是更好的，</p>\n<p>那是浏览器支持。虽然所有浏览器都完全支持 REST，但对 gRPC 的支持是有限的，并且需要带有代理层的gRPC-web在 HTTP/1 和 HTTP/2 之间进行转换。</p>\n<p>微服务是 gRPC 真正闪耀的地方，因为它支持低延迟和高吞吐量的通信，以及强大的 API 合约。</p>\n<p>gRPC 也适用于多语言环境，因为它为许多编程语言提供了开箱即用的代码生成。</p>\n<p>点对点实时通信也是 gRPC 的一个好地方，因为它对双向流有很好的支持。</p>\n<p>最后，gRPC 是移动应用程序 (android/ios) 等网络受限环境的绝佳选择，因为它具有轻量级的消息格式。</p>\n<h2 id=\"定义protobuf并且生成go代码\">定义protobuf并且生成go代码</h2>\n<p>注意消息的名字应该是UpperCamelCase，字段的名字应该是lower_snake_case。</p>\n<p>我们可以使用许多内置的标量值数据类型，例如：string、bool、byte、float、double和许多其他整数类型。我们还可以使用我们自己的数据类型，例如枚举或其他消息。</p>\n<p>每个消息字段都应该分配一个唯一的标签。并且标签比字段名更重要，因为 protobuf 将使用它来序列化消息。</p>\n<p>标记只是一个任意整数，最小值为 1，最大值为 2 29 - 1，但从 19000 到 19999 的数字除外，因为它们是为内部协议缓冲区实现保留的。</p>\n<p>请注意，从 1 到 15 的标签只需要 1 个字节进行编码，而从 16 到 2047 的标签需要 2 个字节。所以你应该明智地使用它们，比如：为非常频繁出现的字段保存从 1 到 15 的标签。</p>\n<p>请记住，标签不需要是有序的（或连续的），但对于消息的同级字段，它们必须是唯一的。</p>\n<h3 id=\"定义CPU消息\">定义CPU消息</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// /proto/processor_message.proto</span><br><span class=\"line\"></span><br><span class=\"line\">syntax = &quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">option go_package=&quot;../pb&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message CPU &#123;</span><br><span class=\"line\">  string brand = 1;</span><br><span class=\"line\">  string name = 2;</span><br><span class=\"line\">  uint32 number_cores = 3;</span><br><span class=\"line\">  uint32 number_threads = 4;</span><br><span class=\"line\">  double min_ghz = 5;</span><br><span class=\"line\">  double max_ghz = 6;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先安装protoc-gen-go和gRPC库</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get -u google.golang.org/grpc</span><br><span class=\"line\">go get -u github.com/golang/protobuf/protoc-gen-go@v1.3.2</span><br></pre></td></tr></table></figure>\n<p>之后可以执行此命令,生成go代码</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">protoc --go_out=plugins=grpc:pb proto/*.proto</span><br></pre></td></tr></table></figure>\n<p>此时的项目目录为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pcbook</span><br><span class=\"line\">├── proto</span><br><span class=\"line\">│   └── processor_message.proto</span><br><span class=\"line\">├── pb</span><br><span class=\"line\">│   └── processor_message.pb.go</span><br><span class=\"line\">└── main.go</span><br></pre></td></tr></table></figure>\n<h3 id=\"编写Makefile\">编写Makefile</h3>\n<p>我们用来生成代码的命令很长，所以当我们更新proto文件并想重新生成代码时，输​​入不是很方便。因此，让我们使用一个简短的命令创建一个 Makefile 来执行此操作。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">gen:</span></span><br><span class=\"line\">    protoc --proto_path=proto proto/*.proto --go_out=plugins=grpc:pb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">    rm pb/*.go </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">run:</span></span><br><span class=\"line\">    go run main.go</span><br></pre></td></tr></table></figure>\n<h2 id=\"协议缓冲区深入研究\">协议缓冲区深入研究</h2>\n<h3 id=\"一个文件中的多条消息\">一个文件中的多条消息</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax = &quot;proto3&quot;;</span><br><span class=\"line\">import &quot;memory_message.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message CPU &#123;</span><br><span class=\"line\">  string brand = 1;</span><br><span class=\"line\">  string name = 2;</span><br><span class=\"line\">  uint32 number_cores = 3;</span><br><span class=\"line\">  uint32 number_threads = 4;</span><br><span class=\"line\">  double min_ghz = 5;</span><br><span class=\"line\">  double max_ghz = 6;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message GPU &#123;</span><br><span class=\"line\">  string brand = 1;</span><br><span class=\"line\">  string name = 2;</span><br><span class=\"line\">  double min_ghz = 3;</span><br><span class=\"line\">  double max_ghz = 4;</span><br><span class=\"line\">  Memory memory=5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义类型：消息和枚举\">自定义类型：消息和枚举</h3>\n<p>内存是一个非常流行的术语，可以在其他地方使用，例如 RAM 或存储（持久驱动器）。它有许多不同的度量单位，例如千字节、兆字节、千兆字节或太字节。所以我将它定义为自定义类型，在一个单独的memory_message.proto文件中，以便我们以后可以重用它。</p>\n<p>首先，我们需要定义测量单位。为此，我们将使用枚举。因为这个单元应该只存在于内存的上下文中，所以我们应该将它定义为内存消息中的嵌套类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax = &quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message Memory &#123;</span><br><span class=\"line\">  enum Unit &#123;</span><br><span class=\"line\">    UNKNOWN = 0;</span><br><span class=\"line\">    BIT = 1;</span><br><span class=\"line\">    BYTE = 2;</span><br><span class=\"line\">    KILOBYTE = 3;</span><br><span class=\"line\">    MEGABYTE = 4;</span><br><span class=\"line\">    GIGABYTE = 5;</span><br><span class=\"line\">    TERABYTE = 6;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  uint64 value = 1;</span><br><span class=\"line\">  Unit unit = 2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>惯例是，始终使用特殊值作为枚举的默认值并为其分配标签 0。然后我们添加其他单位，从 BIT 到 TERABYTE。</p>\n<p>内存消息将有 2 个字段：一个用于值，另一个用于单位。</p>\n<h3 id=\"定义存储消息\">定义存储消息</h3>\n<p>让我们继续我们的项目。我将为storage_message.proto文件中的存储创建一条新消息。</p>\n<p>存储可以是硬盘驱动器或固态驱动器。所以我们应该Driver用这两个值定义一个枚举。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax =&quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">option go_package=&quot;../pb&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;proto/memory_message.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message Storage&#123;</span><br><span class=\"line\">  enum Drive&#123;</span><br><span class=\"line\">    UNKNOWN=0;</span><br><span class=\"line\">    HDD=1;</span><br><span class=\"line\">    SSD=2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Drive driver=1;</span><br><span class=\"line\">  Memory memory=2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"定义键盘消息\">定义键盘消息</h3>\n<p>接下来，我们将定义键盘消息。它可以具有 QWERTY、QWERTZ 或 AZERTY 布局。供您参考，QWERTZ 在德国被广泛使用。在法国，AZERTY 更受欢迎。</p>\n<p>键盘可以背光或不背光，因此我们使用布尔字段。很简单，对吧？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax=&quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">option go_package=&quot;../pb&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message Keyboard&#123;</span><br><span class=\"line\">  enum Layout&#123;</span><br><span class=\"line\">    UNKONWN=0;</span><br><span class=\"line\">    QWERTY=1;</span><br><span class=\"line\">    QWERTZ=2;</span><br><span class=\"line\">    AZERTY=3;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Layout layout=1;</span><br><span class=\"line\">  bool backlit=2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"定义屏幕消息\">定义屏幕消息</h3>\n<p>现在让我们写一个更复杂的信息：屏幕。它有一个嵌套的消息类型：Resolution. 我们这里使用嵌套类型的原因是：分辨率是一个与屏幕有着紧密联系的实体，它单独存在时没有任何意义。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax=&quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">option go_package=&quot;../pb&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message Screen&#123;</span><br><span class=\"line\">  message Resolution&#123;</span><br><span class=\"line\">    uint32 width=1;</span><br><span class=\"line\">    uint32 height=2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  enum Panel&#123;</span><br><span class=\"line\">    UNKNOWN=0;</span><br><span class=\"line\">    IPS=1;</span><br><span class=\"line\">    OLED=2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  float size_inch=1;</span><br><span class=\"line\">  Resolution resolution =2;</span><br><span class=\"line\">  Panel panel =3;</span><br><span class=\"line\">  bool multitouch=4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样，我们有一个屏幕面板的枚举，可以是 IPS 或 OLED。然后屏幕尺寸以英寸为单位。最后是一个布尔字段来判断它是否是多点触控屏幕。</p>\n<h3 id=\"定义笔记本电脑消息\">定义笔记本电脑消息</h3>\n<p>我想基本上我们已经定义了笔记本电脑的所有必要组件。现在让我们定义笔记本电脑消息。</p>\n<p>它有一个字符串类型的唯一标识符。此 ID 将由服务器自动生成。它有一个品牌和一个名字。然后是CPU和RAM。我们需要导入其他 proto 文件来使用这些类型。</p>\n<p>一台笔记本电脑可以有多个 GPU，所以我们使用repeated关键字告诉 protoc 这是一个 GPU 列表。</p>\n<p>同样，笔记本电脑有多个存储也是正常的，所以这个字段也应该重复。</p>\n<p>笔记本的重量如何？比方说，我们允许以千克或磅为单位指定它。为了做到这一点，我们可以使用一个新的关键字：oneof.</p>\n<p>在这个块中，我们定义了 2 个字段，一个用于公斤，另一个用于磅。请记住，当您使用oneof字段组时，只有最后分配的字段才会保留其值。</p>\n<p>然后我们再添加 2 个字段：美元价格和笔记本电脑的发布年份。最后，我们需要一个时间戳字段来存储我们系统中记录的最后更新时间。</p>\n<p>Timestamp 是 Google 已经定义好的众所周知的类型之一，所以我们只需要导入包并使用它。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax=&quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">option go_package=&quot;../pb&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;proto/memory_message.proto&quot;;</span><br><span class=\"line\">import &quot;proto/processor_message.proto&quot;;</span><br><span class=\"line\">import &quot;proto/storage_message.proto&quot;;</span><br><span class=\"line\">import &quot;proto/screen_message.proto&quot;;</span><br><span class=\"line\">import &quot;proto/keyboard_message.proto&quot;;</span><br><span class=\"line\">import &quot;google/protobuf/timestamp.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message Laptop&#123;</span><br><span class=\"line\">  string id=1;</span><br><span class=\"line\">  string brand=2;</span><br><span class=\"line\">  string name=3;</span><br><span class=\"line\">  CPU cpu=4;</span><br><span class=\"line\">  Memory ram=5;</span><br><span class=\"line\">  repeated GPU gpus=6;</span><br><span class=\"line\">  repeated Storage storages=7;</span><br><span class=\"line\">  Screen screen=8;</span><br><span class=\"line\">  Keyboard keyboard=9;</span><br><span class=\"line\">  oneof weight&#123;</span><br><span class=\"line\">    double weight_kg=10;</span><br><span class=\"line\">    double weight_lb=11;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  double price_usd=12;</span><br><span class=\"line\">  uint32 release_year=13;</span><br><span class=\"line\">  google.protobuf.Timestamp updated_at=14;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后就可以一并生成go文件了</p>\n","categories":["go"],"tags":["RPC框架"]}]