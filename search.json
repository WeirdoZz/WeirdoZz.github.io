[{"title":"DDG-DA:Data Distribution Generation for Predictable Concept Drift Adaptation","url":"/2022/03/28/DDG-DA-Data-Distribution-Generation-for-Predictable-Concept-Drift-Adaptation/","content":"<h2 id=\"摘要\">摘要</h2>\n<p>文章作者并不是顺着前人的思路做漂移检测和漂移适应，而是提出一个DDG-DA方法直接预测数据分布的变化并且改善模型的表现。具体来说就是，先训练一个预测器来估计未来的数据分布，然后使用它来生成样本，最后在生成的数据集上训练模型。</p>\n<p><a href=\"https://github.com/microsoft/qlib/tree/main/examples/benchmarks_dynamic/DDG-DA\">github链接</a></p>\n<span id=\"more\"></span>\n<h2 id=\"引言\">引言</h2>\n<p>之前的方法都是在检测到概念漂移之后对模型进行调整，但是这样的话就始终和概念漂移之间差了一个时间步，总是会慢半拍。但是其实实际上概念漂移的发生往往也是有迹可循的并不是完全随机。比如下图，作者绘制了三个现实任务的数据流轨迹：股价、电力负荷和太阳辐射照度。每个点都表示数据分布，其中按照时间对每个点进行了连线，我们发现大部分情况下数据分布的变化还是有规律的，不规律的漂移只是偶然发生。这样其实就是说存在预测概念漂移趋势的可能性。</p>\n<p><img src=\"https://i.imgur.com/HWf0230.png\" alt=\"picture 15\"></p>\n<p>本文注重于预测未来的数据分布，使用DDG-DA方法来预测下个时间步的数据分布，这样模型的下游学习任务能够在预测分布的数据样本上训练而不仅仅是知道要发生概念漂移。在实操中，DDG-DA被设计成一个动态的数据生成器，能够从过去数据中生成服从分布的数据。但是在现实中训练一个这样的能够最大化预测数据和真实数据相似度的数据生成器是难度很大的。为了解决这个问题，作者首先通过在数据分布下学习一个模型来表示数据分布，然后创建一个可微的分布距离来训练数据生成器。为了验证方法的有效性，作者还做了一个完整的理论分析来证明传统分布距离（比如kl散度）和本方法的等价。</p>\n<h2 id=\"方法设计\">方法设计</h2>\n<p><img src=\"https://i.imgur.com/M59yAlD.png\" alt=\"picture 1\"></p>\n<h3 id=\"总体设计\">总体设计</h3>\n<p>在上图中，训练数据和测试数据随着时间发生改变。对于每一个时间步t，任务$task^{(t)}:=(D_{train}^{(t)},D_{test}^{(t)})$目的是学习一个新的模型以调整当前在历史数据上训练的模型并且最小化$D_{test}^{(t)}$上的损失。模型可以根据内存大小在时间步t使用一个有限的$D_{train}^{(t)}$，它是从训练分布为$p_{train}^{t}(x,y)$的训练数据中取样来的，$D_{test}^{(t)}$是从分布为$p_{test}^{(t)}$的测试数据中取样来的。这两个分布可能是不同的，因此会对预测精度有不好的影响。</p>\n<p><strong>DDG-DA学习</strong>。 为了减小这种差距，DDG-DA(表示为$M_{\\Theta}$)尝试对概念漂移建模并且预测测试数据的分布$p_{test}^{(t)}(x,y)$。DDG-DA的框架已经在上图中解释了。DDG-DA就像一个加权数据采样器在$D_{train}^{(t)}$上进行重新采样并且创建一个新的训练数据集$D_{resam}^{(t)}(\\Theta)$，它的数据分布为$p_{resam}^{(t)}(x,y;\\Theta)$（也就是我们假设的测试集的数据分布）。DDG-DA会去最小化这个分布和真实的测试分布之间的差距。</p>\n<p>在DDG-DA的训练过程中，$M_{\\Theta}$在$task^{(t)} \\in Task_{train}$通过最小化预测分布和实际分布的差距来进行学习。从$Task_{train}$中学来的知识是用于转变成$Task_{Test}$中的新任务的。</p>\n<p><strong>DDG-DA预测</strong>。 预测模型是在训练数据上重新采样后的数据集上训练的，然后放到测试数据集上进行测试。训练集分布概率对于这个模型的精度是至关重要的，由于我们前面DDG-DA已经学到了一个最小化测试数据和重新采样数据分布之间差距的模式，所以该重新采样的数据相比于训练集应该更像测试集，所以在测试集上会有一个比较好的结果。</p>\n<p><strong>一个例子</strong>。作者举了一个股价趋势预测的场景。为了解决概念漂移，每个月都基于过去两年的历史数据重新训练一个模型。每次重新训练模型以解决概念漂移被称作一个task。比如，第一个任务$task^{(2011/01)}$包含了训练数据$D_{train}^{(2011/01)}$（包含2009/01-2010/12的数据）和一个月的测试数据$D_{test}^{(2011/01)}$。DDG-DA会在$D_{train}^{(2011/01)}$基础上创建一个$D_{resam}^{(2011/01)}(\\Theta)$用于训练预测模型。每个月都会产生一个新的task，这些task按照时间顺序排序并且以2016年作为分割，前面的相当于训练集，后面的相当于测试集。</p>\n<h3 id=\"模型设计和学习过程\">模型设计和学习过程</h3>\n<p><img src=\"https://i.imgur.com/CiLLHSG.png\" alt=\"picture 2\"></p>\n<h4 id=\"特征设计\">特征设计</h4>\n<p>历史数据的分布信息对于预测$D_{test}^{(t)}$的分布是很有用的，因此将他作为DDG-DA的输入。DDG-DA可以表示为$q_{train}^{(t)}=M_{\\Theta}(g(D_{train}^{(t)}))$。g是一个特征提取器，它将$D_{train}^{(t)}$作为输入并且输出历史数据分布信息。$M_{\\Theta}$使用提取后的信息然后输出重新采样的分布概率用于在$D_{train}^{(t)}$上采样。</p>\n<h4 id=\"目标函数\">目标函数</h4>\n<p>$M_{\\Theta}$接收提取后的特征然后输出分布概率。DDG-DA的学习目的就是最小化预测分布和真实分布差距。作者注重于最重要的漂移主体$p(y|x)$并且认为测试数据分布和重新采样的数据分布的差距次之。DDG-DA的损失可以表示为：</p>\n<p><img src=\"https://i.imgur.com/D4vfGYw.png\" alt=\"picture 3\"></p>\n<p>其中$D_{KL}$是KL散度。</p>\n<p>对于未知变量假设正态分布是合理的并且经常用于最大似然估计。在这种估计下，$p_{test}^{(t)}(y|x)=N(y_{test}^{(t)}(x),\\sigma)$并且$p_{resam}^{(t)}(y|x)=N(y_{resam}^{(t)}(x;\\Theta),\\sigma)$，其中$\\sigma$是常量。</p>\n<p>公式1中的resample的数据集的估计期望可以描述为</p>\n<p><img src=\"https://i.imgur.com/cUcBhVS.png\" alt=\"picture 4\"></p>\n<p>结合所有的训练任务的损失，DDG-DA的优化目标能够描述为</p>\n<p><img src=\"https://i.imgur.com/rf2t4TR.png\" alt=\"picture 5\"></p>\n<h4 id=\"优化\">优化</h4>\n<p>这一部分主要讲解公式2的优化过程。为了能够近似估计$y_{resam}^{(t)}(x;\\Theta)$，DDG-DA在$D_{sample}^{(t)(\\Theta)}$建立了一个回归代理模型$y_{proxy}(x;\\phi)^{(t)}$。代理模型的优化可以描述为</p>\n<p><img src=\"https://i.imgur.com/iZ5adHj.png\" alt=\"picture 6\"></p>\n<p>DDG-DA的学习过程就是一个两层优化问题。上层的目标是用$y_{proxy}(x;\\phi)^{(t)}$代替$y_{resam}^{(t)}(x;\\Theta)$。下层的优化公式4可以被视作一个约束项。</p>\n<p>DDG-DA的总体双层优化公式：</p>\n<p><img src=\"https://i.imgur.com/NDZeZhZ.png\" alt=\"picture 7\"></p>\n<p>其中$\\Theta$是DDG-DA的参数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">对于上面这些公式，其感性的理解就是，我们有一个DDG-DA模型，从已有的训练集中抽取一部分样本用它们的分布表示测试集的分布，</span><br><span class=\"line\"></span><br><span class=\"line\">然后怎么判断这个模型抽取的样本是不是准确呢？这时候就需要第二个模型，它学习我们重采样的数据的x-y的映射关系，</span><br><span class=\"line\"></span><br><span class=\"line\">这样将测试集中的所有的x输入得到y_hat，然后用y_hat和y放入损失函数，求得损失，再进行反向传播优化。</span><br></pre></td></tr></table></figure>\n<p>优化公式2的阻碍主要在于公式4的下级部分无法以封闭的形式解决。argmin通常来说是不可微的，这使得许多的优化算法（比如梯度下降）无法在公式4上进行优化。</p>\n<p>DDG-DA采用了一个使用封闭式解法的模型作为$y_{proxy}(x;\\phi)^{(t)}$。为了简单，作者选用了线性模型$h(x;\\phi_{(t)})=x\\phi^{(t)}$。$M_\\Theta$输出的$q_{train}^{(t)}$可以被视为学习预测模型时的重采样权重。公式4的损失函数就可以描述为：</p>\n<p><img src=\"https://i.imgur.com/ifbPBgr.png\" alt=\"picture 8\"></p>\n<p>其中$X^{(t)},y^{(t)},Q^{(t)}$是将多个样本连接起来的特征，标签和$D_{train}^{(t)}$上的重采样概率。</p>\n<p>这等价于一个权重线性回归，$\\phi^{(t)}$有一个正规化闭式解</p>\n<p><img src=\"https://i.imgur.com/rUC2pR1.png\" alt=\"picture 9\"></p>\n<p>这样公式4的闭式解使得分布距离可微。这样简单有效的优化算法就可以用来训练DDG-DA了。</p>\n<h2 id=\"实验\">实验</h2>\n<p>实验主要是回答两个问题：</p>\n<ol>\n<li>该模型在预测概念漂移上能够超过SOTA方法</li>\n<li>该模型能否在不同场景下生成不同的预测模型</li>\n</ol>\n<h3 id=\"实验结果\">实验结果</h3>\n<p>针对第一个问题，对于模型无关的方法，作者使用的是相同模型不同方法，得出实验结果如下</p>\n<p><img src=\"https://i.imgur.com/XkiqMMU.png\" alt=\"picture 10\"></p>\n<p>针对第二个问题，作者尝试了很多模型无关的方法进行不同场景和不同模型的预测比较，结果如下</p>\n<p><img src=\"https://i.imgur.com/5caxUkX.png\" alt=\"picture 11\"></p>\n","categories":["概念漂移"]},{"title":"GORM学习","url":"/2022/03/06/GORM%E5%AD%A6%E4%B9%A0/","content":"<h2 id=\"使用docker快速创建MySql实例\">使用docker快速创建MySql实例</h2>\n<p>首先需要安装docker，具体安装方法已经在<a href=\"https://weirdozz.github.io/2022/01/28/%E4%BD%BF%E7%94%A8golang+postgres+docker%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/\">使用golang+postgres+docker进行开发</a>中进行过讲述了。</p>\n<p>用如下命令创建一个容器环境</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run --name mysql8019 -p 13306:3306 -e MYSQL_ROOT_PASSWORD=root1234 -d mysql:8.0.19</span><br></pre></td></tr></table></figure>\n<p>然后再启动一个<code>MySQL Client</code>连接到上面的环境</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it xxxx bash</span><br></pre></td></tr></table></figure>\n<p>然后在环境中创建一个数据库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE DATABASE db1;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<h2 id=\"使用GORM操作MySQL\">使用GORM操作MySQL</h2>\n<p>以下是对数据库中表的增删改查</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    db, err := gorm.Open(<span class=\"string\">&quot;mysql&quot;</span>, <span class=\"string\">&quot;root:123@(127.0.0.1:13306)/db1?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> db.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建表 自动迁移（把结构体和数据表进行对应）</span></span><br><span class=\"line\">    db.AutoMigrate(&amp;UserInfo&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建记录</span></span><br><span class=\"line\">    u1 := UserInfo&#123;</span><br><span class=\"line\">        <span class=\"number\">1</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;weirdo&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;male&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;guitar&quot;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    db.Create(&amp;u1)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 查询数据,查询第一条数据 保存到u</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> u UserInfo</span><br><span class=\"line\">    db.First(&amp;u)</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%#v\\n&quot;</span>, u)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 更新数据</span></span><br><span class=\"line\">    db.Model(&amp;u).Update(<span class=\"string\">&quot;hobby&quot;</span>, <span class=\"string\">&quot;双色球&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除</span></span><br><span class=\"line\">    db.Delete(&amp;u)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"GORM-Model定义\">GORM Model定义</h2>\n<p>我们需要在代码中定义模型与数据库中的数据表进行映射，在GORM中模型通常是正常定义的结构体、基本的go类型或者他们的指针。</p>\n<h3 id=\"gorm-Model\">gorm.Model</h3>\n<p>为了方便模型的定义，GORM内置了一个gorm.Model结构体。其中包含了<code>ID</code>,<code>CreatedAt</code>,<code>UpdateAt</code>,<code>DeleteAt</code>字段</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// gorm.Model 定义</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Model <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  ID        <span class=\"keyword\">uint</span> <span class=\"string\">`gorm:&quot;primary_key&quot;`</span></span><br><span class=\"line\">  CreatedAt time.Time</span><br><span class=\"line\">  UpdatedAt time.Time</span><br><span class=\"line\">  DeletedAt *time.Time</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以将他嵌入到我们自己的模型中</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将 `ID`, `CreatedAt`, `UpdatedAt`, `DeletedAt`字段注入到`User`模型中</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  gorm.Model</span><br><span class=\"line\">  Name <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>模型定义的示例</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  gorm.Model</span><br><span class=\"line\">  Name         <span class=\"keyword\">string</span></span><br><span class=\"line\">  Age          sql.NullInt64</span><br><span class=\"line\">  Birthday     *time.Time</span><br><span class=\"line\">  Email        <span class=\"keyword\">string</span>  <span class=\"string\">`gorm:&quot;type:varchar(100);unique_index&quot;`</span></span><br><span class=\"line\">  Role         <span class=\"keyword\">string</span>  <span class=\"string\">`gorm:&quot;size:255&quot;`</span> <span class=\"comment\">// 设置字段大小为255</span></span><br><span class=\"line\">  MemberNumber *<span class=\"keyword\">string</span> <span class=\"string\">`gorm:&quot;unique;not null&quot;`</span> <span class=\"comment\">// 设置会员号（member number）唯一并且不为空</span></span><br><span class=\"line\">  Num          <span class=\"keyword\">int</span>     <span class=\"string\">`gorm:&quot;AUTO_INCREMENT&quot;`</span> <span class=\"comment\">// 设置 num 为自增类型</span></span><br><span class=\"line\">  Address      <span class=\"keyword\">string</span>  <span class=\"string\">`gorm:&quot;index:addr&quot;`</span> <span class=\"comment\">// 给address字段创建名为addr的索引</span></span><br><span class=\"line\">  IgnoreMe     <span class=\"keyword\">int</span>     <span class=\"string\">`gorm:&quot;-&quot;`</span> <span class=\"comment\">// 忽略本字段</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"主键、表名、列名的约定\">主键、表名、列名的约定</h2>\n<h3 id=\"主键\">主键</h3>\n<p>gorm默认会使用名为ID的字段作为表的主键，如果我们想要设置主键的话就用结构体tag进行设置</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  ID   <span class=\"keyword\">string</span> <span class=\"comment\">// 名为`ID`的字段会默认作为表的主键</span></span><br><span class=\"line\">  Name <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用`AnimalID`作为主键</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  AnimalID <span class=\"keyword\">int64</span> <span class=\"string\">`gorm:&quot;primary_key&quot;`</span></span><br><span class=\"line\">  Name     <span class=\"keyword\">string</span></span><br><span class=\"line\">  Age      <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"表名\">表名</h3>\n<p>表名默认是结构体的复数形式，如果想要修改表的名字的话可以通过对结构体设置一个<code>TableName()</code>函数进行设置。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;&#125; <span class=\"comment\">// 默认表名是 `users`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将 User 的表名设置为 `profiles`</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(User)</span> <span class=\"title\">TableName</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;profiles&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(u User)</span> <span class=\"title\">TableName</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> u.Role == <span class=\"string\">&quot;admin&quot;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;admin_users&quot;</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;users&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 禁用默认表名的复数形式，如果置为 true，则 `User` 的默认表名是 `user`</span></span><br><span class=\"line\">db.SingularTable(<span class=\"literal\">true</span>)</span><br></pre></td></tr></table></figure>\n<p>也可以通过<code>Table()</code>指定表名</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用User结构体创建名为`deleted_users`的表</span></span><br><span class=\"line\">db.Table(<span class=\"string\">&quot;deleted_users&quot;</span>).CreateTable(&amp;User&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> deleted_users []User</span><br><span class=\"line\">db.Table(<span class=\"string\">&quot;deleted_users&quot;</span>).Find(&amp;deleted_users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM deleted_users;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Table(<span class=\"string\">&quot;deleted_users&quot;</span>).Where(<span class=\"string\">&quot;name = ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>).Delete()</span><br><span class=\"line\"><span class=\"comment\">//// DELETE FROM deleted_users WHERE name = &#x27;jinzhu&#x27;;</span></span><br></pre></td></tr></table></figure>\n<p>gorm还支持更改默认的表名称规则,自己指定的表名不受影响</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">gorm.DefaultTableNameHandler = <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(db *gorm.DB, defaultTableName <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span>  &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;prefix_&quot;</span> + defaultTableName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"列名\">列名</h3>\n<p>默认命名规则和表名是一样的，由下划线分割连接并且全部小写。同样也可以用结构体tag进行修改。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Animal <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  AnimalId    <span class=\"keyword\">int64</span>     <span class=\"string\">`gorm:&quot;column:beast_id&quot;`</span>         <span class=\"comment\">// set column name to `beast_id`</span></span><br><span class=\"line\">  Birthday    time.Time <span class=\"string\">`gorm:&quot;column:day_of_the_beast&quot;`</span> <span class=\"comment\">// set column name to `day_of_the_beast`</span></span><br><span class=\"line\">  Age         <span class=\"keyword\">int64</span>     <span class=\"string\">`gorm:&quot;column:age_of_the_beast&quot;`</span> <span class=\"comment\">// set column name to `age_of_the_beast`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"GORM的增删改查\">GORM的增删改查</h2>\n<h3 id=\"创建记录\">创建记录</h3>\n<p>先要定义模型</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ID           <span class=\"keyword\">int64</span></span><br><span class=\"line\">    Name         <span class=\"keyword\">string</span></span><br><span class=\"line\">    Age          <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后把模型和数据库的表对应起来</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.AutoMigrate(&amp;User&#123;&#125;)</span><br></pre></td></tr></table></figure>\n<p>最后创建记录并且存到表中</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">user:=User&#123;</span><br><span class=\"line\">    Name:<span class=\"string\">&quot;weirdo&quot;</span>,</span><br><span class=\"line\">    Age:<span class=\"number\">18</span>，</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">db.Create(&amp;user)</span><br></pre></td></tr></table></figure>\n<p>可以通过tag定义字段的默认值</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  ID   <span class=\"keyword\">int64</span></span><br><span class=\"line\">  Name <span class=\"keyword\">string</span> <span class=\"string\">`gorm:&quot;default:&#x27;小王子&#x27;&quot;`</span></span><br><span class=\"line\">  Age  <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是：创建记录的时候所有字段的零值不会存入到数据库中，但是会使用他们的默认值。如果想避免这种情况的话就使用指针或者<code>Scanner.Valuer</code>接口。</p>\n<ul>\n<li>指针方式</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用指针</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  ID   <span class=\"keyword\">int64</span></span><br><span class=\"line\">  Name *<span class=\"keyword\">string</span> <span class=\"string\">`gorm:&quot;default:&#x27;小王子&#x27;&quot;`</span></span><br><span class=\"line\">  Age  <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">user := User&#123;Name: <span class=\"built_in\">new</span>(<span class=\"keyword\">string</span>), Age: <span class=\"number\">18</span>&#125;</span><br><span class=\"line\">db.Create(&amp;user)  <span class=\"comment\">// 此时数据库中该条记录name字段的值就是&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>Scanner/Valuer方式</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用 Scanner/Valuer</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ID <span class=\"keyword\">int64</span></span><br><span class=\"line\">    Name sql.NullString <span class=\"string\">`gorm:&quot;default:&#x27;小王子&#x27;&quot;`</span> <span class=\"comment\">// sql.NullString 实现了Scanner/Valuer接口</span></span><br><span class=\"line\">    Age  <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">user := User&#123;Name: sql.NullString&#123;<span class=\"string\">&quot;&quot;</span>, <span class=\"literal\">true</span>&#125;, Age:<span class=\"number\">18</span>&#125;</span><br><span class=\"line\">db.Create(&amp;user)  <span class=\"comment\">// 此时数据库中该条记录name字段的值就是&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"查询\">查询</h3>\n<p>一般查询</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据主键查询第一条记录</span></span><br><span class=\"line\">db.First(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users ORDER BY id LIMIT 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 随机获取一条记录</span></span><br><span class=\"line\">db.Take(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users LIMIT 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据主键查询最后一条记录</span></span><br><span class=\"line\">db.Last(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users ORDER BY id DESC LIMIT 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询所有的记录</span></span><br><span class=\"line\">db.Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询指定的某条记录(仅当主键为整型时可用)</span></span><br><span class=\"line\">db.First(&amp;user, <span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE id = 10;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"where-条件\">where 条件</h4>\n<p>普通sql查询</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Get first matched record</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name = ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; limit 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Get all matched records</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name = ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &lt;&gt;</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name &lt;&gt; ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name &lt;&gt; &#x27;jinzhu&#x27;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IN</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name IN (?)&quot;</span>, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;jinzhu&quot;</span>, <span class=\"string\">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name in (&#x27;jinzhu&#x27;,&#x27;jinzhu 2&#x27;);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// LIKE</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name LIKE ?&quot;</span>, <span class=\"string\">&quot;%jin%&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name LIKE &#x27;%jin%&#x27;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// AND</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name = ? AND age &gt;= ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>, <span class=\"string\">&quot;22&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; AND age &gt;= 22;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Time</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;updated_at &gt; ?&quot;</span>, lastWeek).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE updated_at &gt; &#x27;2000-01-01 00:00:00&#x27;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// BETWEEN</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;created_at BETWEEN ? AND ?&quot;</span>, lastWeek, today).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE created_at BETWEEN &#x27;2000-01-01 00:00:00&#x27; AND &#x27;2000-01-08 00:00:00&#x27;;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>struct map查询</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Struct</span></span><br><span class=\"line\">db.Where(&amp;User&#123;Name: <span class=\"string\">&quot;jinzhu&quot;</span>, Age: <span class=\"number\">20</span>&#125;).First(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20 LIMIT 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Map</span></span><br><span class=\"line\">db.Where(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;jinzhu&quot;</span>, <span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">20</span>&#125;).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 20;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主键的切片</span></span><br><span class=\"line\">db.Where([]<span class=\"keyword\">int64</span>&#123;<span class=\"number\">20</span>, <span class=\"number\">21</span>, <span class=\"number\">22</span>&#125;).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE id IN (20, 21, 22);</span></span><br></pre></td></tr></table></figure>\n<p>同样的，通过结构体查询时，GORM会只通过非零值字段查询，即字段如果为零值，将不会被用于查询。这一点同样可以通过Scanner/Valuer解决。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Where(&amp;User&#123;Name: <span class=\"string\">&quot;jinzhu&quot;</span>, Age: <span class=\"number\">0</span>&#125;).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Not条件\">Not条件</h4>\n<p>就是与where相反，取非我们给出条件的数据</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Not(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; LIMIT 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Not In</span></span><br><span class=\"line\">db.Not(<span class=\"string\">&quot;name&quot;</span>, []<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;jinzhu&quot;</span>, <span class=\"string\">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name NOT IN (&quot;jinzhu&quot;, &quot;jinzhu 2&quot;);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Not In slice of primary keys</span></span><br><span class=\"line\">db.Not([]<span class=\"keyword\">int64</span>&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;).First(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE id NOT IN (1,2,3);</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Not([]<span class=\"keyword\">int64</span>&#123;&#125;).First(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Plain SQL</span></span><br><span class=\"line\">db.Not(<span class=\"string\">&quot;name = ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>).First(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE NOT(name = &quot;jinzhu&quot;);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Struct</span></span><br><span class=\"line\">db.Not(User&#123;Name: <span class=\"string\">&quot;jinzhu&quot;</span>&#125;).First(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Or条件\">Or条件</h4>\n<p>就是同时满足几个条件的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Where(<span class=\"string\">&quot;role = ?&quot;</span>, <span class=\"string\">&quot;admin&quot;</span>).Or(<span class=\"string\">&quot;role = ?&quot;</span>, <span class=\"string\">&quot;super_admin&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE role = &#x27;admin&#x27; OR role = &#x27;super_admin&#x27;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Struct</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(User&#123;Name: <span class=\"string\">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Map</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;name = &#x27;jinzhu&#x27;&quot;</span>).Or(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;jinzhu 2&quot;</span>&#125;).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; OR name = &#x27;jinzhu 2&#x27;;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"内联条件\">内联条件</h4>\n<p>当内联条件和多个立即执行方法一起使用的时候不会传递给后面的立即执行方法，即只对当前方法的条件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据主键获取记录 (只适用于整形主键)</span></span><br><span class=\"line\">db.First(&amp;user, <span class=\"number\">23</span>)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE id = 23 LIMIT 1;</span></span><br><span class=\"line\"><span class=\"comment\">// 根据主键获取记录, 如果它是一个非整形主键</span></span><br><span class=\"line\">db.First(&amp;user, <span class=\"string\">&quot;id = ?&quot;</span>, <span class=\"string\">&quot;string_primary_key&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE id = &#x27;string_primary_key&#x27; LIMIT 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Plain SQL</span></span><br><span class=\"line\">db.Find(&amp;user, <span class=\"string\">&quot;name = ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Find(&amp;users, <span class=\"string\">&quot;name &lt;&gt; ? AND age &gt; ?&quot;</span>, <span class=\"string\">&quot;jinzhu&quot;</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE name &lt;&gt; &quot;jinzhu&quot; AND age &gt; 20;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Struct</span></span><br><span class=\"line\">db.Find(&amp;users, User&#123;Age: <span class=\"number\">20</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE age = 20;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Map</span></span><br><span class=\"line\">db.Find(&amp;users, <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">20</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"额外查询选项\">额外查询选项</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为查询 SQL 添加额外的 SQL 操作</span></span><br><span class=\"line\">db.Set(<span class=\"string\">&quot;gorm:query_option&quot;</span>, <span class=\"string\">&quot;FOR UPDATE&quot;</span>).First(&amp;user, <span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE id = 10 FOR UPDATE;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"FirstOrInit\">FirstOrInit</h4>\n<p>获取匹配到的第一个数据，如果不存在的话，用给定条件初始化一个新的对象（仅支持struct和map条件）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 未找到</span></span><br><span class=\"line\">db.FirstOrInit(&amp;user, User&#123;Name: <span class=\"string\">&quot;non_existing&quot;</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// user -&gt; User&#123;Name: &quot;non_existing&quot;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找到</span></span><br><span class=\"line\">db.Where(User&#123;Name: <span class=\"string\">&quot;Jinzhu&quot;</span>&#125;).FirstOrInit(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span></span><br><span class=\"line\">db.FirstOrInit(&amp;user, <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;jinzhu&quot;</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Attrs\">Attrs</h4>\n<p>如果记录没有找到的话，就用参数初始化struct</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 未找到</span></span><br><span class=\"line\">db.Where(User&#123;Name: <span class=\"string\">&quot;non_existing&quot;</span>&#125;).Attrs(User&#123;Age: <span class=\"number\">20</span>&#125;).FirstOrInit(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM USERS WHERE name = &#x27;non_existing&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">//// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Where(User&#123;Name: <span class=\"string\">&quot;non_existing&quot;</span>&#125;).Attrs(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">20</span>).FirstOrInit(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM USERS WHERE name = &#x27;non_existing&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">//// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找到</span></span><br><span class=\"line\">db.Where(User&#123;Name: <span class=\"string\">&quot;Jinzhu&quot;</span>&#125;).Attrs(User&#123;Age: <span class=\"number\">30</span>&#125;).FirstOrInit(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM USERS WHERE name = jinzhu&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Assign\">Assign</h4>\n<p>不管记录是否找到，都会用参数初始化struct</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 未找到</span></span><br><span class=\"line\">db.Where(User&#123;Name: <span class=\"string\">&quot;non_existing&quot;</span>&#125;).Assign(User&#123;Age: <span class=\"number\">20</span>&#125;).FirstOrInit(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// user -&gt; User&#123;Name: &quot;non_existing&quot;, Age: 20&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 找到</span></span><br><span class=\"line\">db.Where(User&#123;Name: <span class=\"string\">&quot;Jinzhu&quot;</span>&#125;).Assign(User&#123;Age: <span class=\"number\">30</span>&#125;).FirstOrInit(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM USERS WHERE name = jinzhu&#x27;;</span></span><br><span class=\"line\"><span class=\"comment\">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 30&#125;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>另外，还有<code>FirstOrCreate</code>和<code>Attrs</code>、<code>Assign</code>相结合，它就是比上面的多一个向数据库中添加或者修改数据的动作。</p>\n<h4 id=\"高级查询\">高级查询</h4>\n<ul>\n<li><strong>子查询</strong></li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Where(<span class=\"string\">&quot;amount &gt; ?&quot;</span>, db.Table(<span class=\"string\">&quot;orders&quot;</span>).Select(<span class=\"string\">&quot;AVG(amount)&quot;</span>).Where(<span class=\"string\">&quot;state = ?&quot;</span>, <span class=\"string\">&quot;paid&quot;</span>).SubQuery()).Find(&amp;orders)</span><br><span class=\"line\"><span class=\"comment\">// SELECT * FROM &quot;orders&quot;  WHERE &quot;orders&quot;.&quot;deleted_at&quot; IS NULL AND (amount &gt; (SELECT AVG(amount) FROM &quot;orders&quot;  WHERE (state = &#x27;paid&#x27;)));</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>选择字段</strong></li>\n</ul>\n<p>指定我们想要检索出的字段，默认是选择全部字段</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Select(<span class=\"string\">&quot;name, age&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT name, age FROM users;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Select([]<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;age&quot;</span>&#125;).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT name, age FROM users;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Table(<span class=\"string\">&quot;users&quot;</span>).Select(<span class=\"string\">&quot;COALESCE(age,?)&quot;</span>, <span class=\"number\">42</span>).Rows()</span><br><span class=\"line\"><span class=\"comment\">//// SELECT COALESCE(age,&#x27;42&#x27;) FROM users;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>排序</strong></li>\n</ul>\n<p>指定从数据库中检索出记录的顺序。设置第二个参数 reorder 为 true ，可以覆盖前面定义的排序条件。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Order(<span class=\"string\">&quot;age desc, name&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 多字段排序</span></span><br><span class=\"line\">db.Order(<span class=\"string\">&quot;age desc&quot;</span>).Order(<span class=\"string\">&quot;name&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users ORDER BY age desc, name;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 覆盖排序</span></span><br><span class=\"line\">db.Order(<span class=\"string\">&quot;age desc&quot;</span>).Find(&amp;users1).Order(<span class=\"string\">&quot;age&quot;</span>, <span class=\"literal\">true</span>).Find(&amp;users2)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users ORDER BY age desc; (users1)</span></span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users ORDER BY age; (users2)</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>数量</strong></li>\n</ul>\n<p>指定从数据库检索出的最大记录数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Limit(<span class=\"number\">3</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users LIMIT 3;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -1 取消 Limit 条件</span></span><br><span class=\"line\">db.Limit(<span class=\"number\">10</span>).Find(&amp;users1).Limit(<span class=\"number\">-1</span>).Find(&amp;users2)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users LIMIT 10; (users1)</span></span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users; (users2)</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>偏移</strong></li>\n</ul>\n<p>指定开始返回记录前要跳过的记录数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Offset(<span class=\"number\">3</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users OFFSET 3;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -1 取消 Offset 条件</span></span><br><span class=\"line\">db.Offset(<span class=\"number\">10</span>).Find(&amp;users1).Offset(<span class=\"number\">-1</span>).Find(&amp;users2)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users OFFSET 10; (users1)</span></span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users; (users2)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"更新\">更新</h3>\n<h4 id=\"更新所有字段\">更新所有字段</h4>\n<p><code>Save()</code>会更新该对象的所有字段，即使没有赋值</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.First(&amp;user)</span><br><span class=\"line\"></span><br><span class=\"line\">user.Name = <span class=\"string\">&quot;七米&quot;</span></span><br><span class=\"line\">user.Age = <span class=\"number\">99</span></span><br><span class=\"line\">db.Save(&amp;user)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">////  UPDATE `users` SET `created_at` = &#x27;2020-02-16 12:52:20&#x27;, `updated_at` = &#x27;2020-02-16 12:54:55&#x27;, `deleted_at` = NULL, `name` = &#x27;七米&#x27;, `age` = 99, `active` = true  WHERE `users`.`deleted_at` IS NULL AND `users`.`id` = 1</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"更新修改字段\">更新修改字段</h4>\n<p><code>Update</code> <code>Updates</code>只会修改指定字段。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 更新单个属性，如果它有变化</span></span><br><span class=\"line\">db.Model(&amp;user).Update(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据给定的条件更新单个属性</span></span><br><span class=\"line\">db.Model(&amp;user).Where(<span class=\"string\">&quot;active = ?&quot;</span>, <span class=\"literal\">true</span>).Update(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111 AND active=true;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 map 更新多个属性，只会更新其中有变化的属性</span></span><br><span class=\"line\">db.Model(&amp;user).Updates(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">18</span>, <span class=\"string\">&quot;active&quot;</span>: <span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27;, age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 struct 更新多个属性，只会更新其中有变化且为非零值的字段</span></span><br><span class=\"line\">db.Model(&amp;user).Updates(User&#123;Name: <span class=\"string\">&quot;hello&quot;</span>, Age: <span class=\"number\">18</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27;, age=18, updated_at = &#x27;2013-11-17 21:34:10&#x27; WHERE id = 111;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 警告：当使用 struct 更新时，GORM只会更新那些非零值的字段</span></span><br><span class=\"line\"><span class=\"comment\">// 对于下面的操作，不会发生任何更新，&quot;&quot;, 0, false 都是其类型的零值</span></span><br><span class=\"line\">db.Model(&amp;user).Updates(User&#123;Name: <span class=\"string\">&quot;&quot;</span>, Age: <span class=\"number\">0</span>, Active: <span class=\"literal\">false</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"更新选定字段或者忽略选定字段\">更新选定字段或者忽略选定字段</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Model(&amp;user).Select(<span class=\"string\">&quot;name&quot;</span>).Updates(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">18</span>, <span class=\"string\">&quot;active&quot;</span>: <span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27;, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Model(&amp;user).Omit(<span class=\"string\">&quot;name&quot;</span>).Updates(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">18</span>, <span class=\"string\">&quot;active&quot;</span>: <span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET age=18, active=false, updated_at=&#x27;2013-11-17 21:34:10&#x27; WHERE id=111;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"无hooks更新\">无hooks更新</h4>\n<p>上面的更新操作都会默认执行<code>BeforeUpdate</code>和<code>AfterUpdate</code>方法，用于更新<code>UpdatedAt</code>时间戳，如果不想使用这些方法的话，可以使用<code>UpdateColumn</code>、<code>UpdateColumns</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 更新单个属性，类似于 `Update`</span></span><br><span class=\"line\">db.Model(&amp;user).UpdateColumn(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27; WHERE id = 111;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 更新多个属性，类似于 `Updates`</span></span><br><span class=\"line\">db.Model(&amp;user).UpdateColumns(User&#123;Name: <span class=\"string\">&quot;hello&quot;</span>, Age: <span class=\"number\">18</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id = 111;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"批量更新\">批量更新</h4>\n<p>批量更新的时候hook函数是不会执行的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Table(<span class=\"string\">&quot;users&quot;</span>).Where(<span class=\"string\">&quot;id IN (?)&quot;</span>, []<span class=\"keyword\">int</span>&#123;<span class=\"number\">10</span>, <span class=\"number\">11</span>&#125;).Updates(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">18</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27;, age=18 WHERE id IN (10, 11);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 struct 更新时，只会更新非零值字段，若想更新所有字段，请使用map[string]interface&#123;&#125;</span></span><br><span class=\"line\">db.Model(User&#123;&#125;).Updates(User&#123;Name: <span class=\"string\">&quot;hello&quot;</span>, Age: <span class=\"number\">18</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET name=&#x27;hello&#x27;, age=18;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 `RowsAffected` 获取更新记录总数</span></span><br><span class=\"line\">db.Model(User&#123;&#125;).Updates(User&#123;Name: <span class=\"string\">&quot;hello&quot;</span>, Age: <span class=\"number\">18</span>&#125;).RowsAffected</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用SQL表达式更新\">使用SQL表达式更新</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//先获取表中的第一条数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> user User</span><br><span class=\"line\">db.First(&amp;user)</span><br><span class=\"line\"></span><br><span class=\"line\">db.Model(&amp;user).Update(<span class=\"string\">&quot;age&quot;</span>, gorm.Expr(<span class=\"string\">&quot;age * ? + ?&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">100</span>))</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE `users` SET `age` = age * 2 + 100, `updated_at` = &#x27;2020-02-16 13:10:20&#x27;  WHERE `users`.`id` = 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Model(&amp;user).Updates(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;age&quot;</span>: gorm.Expr(<span class=\"string\">&quot;age * ? + ?&quot;</span>, <span class=\"number\">2</span>, <span class=\"number\">100</span>)&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age * &#x27;2&#x27; + &#x27;100&#x27;, &quot;updated_at&quot; = &#x27;2020-02-16 13:05:51&#x27; WHERE `users`.`id` = 1;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Model(&amp;user).UpdateColumn(<span class=\"string\">&quot;age&quot;</span>, gorm.Expr(<span class=\"string\">&quot;age - ?&quot;</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age - 1 WHERE &quot;id&quot; = &#x27;1&#x27;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Model(&amp;user).Where(<span class=\"string\">&quot;age &gt; 10&quot;</span>).UpdateColumn(<span class=\"string\">&quot;age&quot;</span>, gorm.Expr(<span class=\"string\">&quot;age - ?&quot;</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE &quot;users&quot; SET &quot;age&quot; = age - 1 WHERE &quot;id&quot; = &#x27;1&#x27; AND quantity &gt; 10;</span></span><br></pre></td></tr></table></figure>\n<p>这里需要注意，要对整个表修改的话Model()的括号中必须是对应的空结构体，否则只对对应的数据进行修改。</p>\n<h3 id=\"删除\">删除</h3>\n<h4 id=\"删除记录\">删除记录</h4>\n<p>注意：删除记录的时候，要确保主键字段有值，GORM会通过主键去删除记录，如果主键为空，GORM会删除该model的所有记录。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除现有记录</span></span><br><span class=\"line\">db.Delete(&amp;email)</span><br><span class=\"line\"><span class=\"comment\">//// DELETE from emails where id=10;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 为删除 SQL 添加额外的 SQL 操作</span></span><br><span class=\"line\">db.Set(<span class=\"string\">&quot;gorm:delete_option&quot;</span>, <span class=\"string\">&quot;OPTION (OPTIMIZE FOR UNKNOWN)&quot;</span>).Delete(&amp;email)</span><br><span class=\"line\"><span class=\"comment\">//// DELETE from emails where id=10 OPTION (OPTIMIZE FOR UNKNOWN);</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"批量删除\">批量删除</h4>\n<p>删除全部匹配的记录</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Where(<span class=\"string\">&quot;email LIKE ?&quot;</span>, <span class=\"string\">&quot;%jinzhu%&quot;</span>).Delete(Email&#123;&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.Delete(Email&#123;&#125;, <span class=\"string\">&quot;email LIKE ?&quot;</span>, <span class=\"string\">&quot;%jinzhu%&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">//// DELETE from emails where email LIKE &quot;%jinzhu%&quot;;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"软删除\">软删除</h4>\n<p>当一个表中有<code>DeletedAt</code>字段，它将会自动获得软删除功能。删除时会记录删除时间而不会真正从表中移除数据。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Delete(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE id = 111;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 批量删除</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;age = ?&quot;</span>, <span class=\"number\">20</span>).Delete(&amp;User&#123;&#125;)</span><br><span class=\"line\"><span class=\"comment\">//// UPDATE users SET deleted_at=&quot;2013-10-29 10:23&quot; WHERE age = 20;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询记录时会忽略被软删除的记录</span></span><br><span class=\"line\">db.Where(<span class=\"string\">&quot;age = 20&quot;</span>).Find(&amp;user)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Unscoped 方法可以查询被软删除的记录</span></span><br><span class=\"line\">db.Unscoped().Where(<span class=\"string\">&quot;age = 20&quot;</span>).Find(&amp;users)</span><br><span class=\"line\"><span class=\"comment\">//// SELECT * FROM users WHERE age = 20;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"物理删除\">物理删除</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Unscoped 方法可以物理删除记录</span></span><br><span class=\"line\">db.Unscoped().Delete(&amp;order)</span><br><span class=\"line\"><span class=\"comment\">//// DELETE FROM orders WHERE id=10;</span></span><br></pre></td></tr></table></figure>","categories":["后端"],"tags":["gorm"]},{"title":"EvolveGCN:Evolving Graph Convolutional Networks for Dynamic Graphs","url":"/2022/03/16/EvolveGCN-Evolving-Graph-Convolutional-Networks-for-Dynamic-Graphs/","content":"<h2 id=\"摘要\">摘要</h2>\n<p>归功于对于欧几里得数据（排列整齐，能够很容易找到邻居节点，就在旁边不偏不倚，如图片、视频、语音等）的深度学习的广泛使用，在非欧几里得领域出现了许多有创造性的神经网络，作为其中的代表，图表示学习慢慢回到主流研究方向。随着图神经网络在静态场景下应用的成功，作者更进一步接近实际应用场景，其中的图是动态变化的。现存的方法主要是应用节点嵌入并且用RNN来规范嵌入从而学习时间动态性。这些方法需要知道节点在整个时间跨度上的信息而且不能用于频繁变化的节点集。在一些极端场景下，节点集在不同的时间步上可能是完全不同的。</p>\n<p>为了解决这个问题，作者提出EvolveGCN，跟着时间维度调节图卷积网络而不需要使用节点嵌入。该方法通过RNN来获取图序列的动态从而调整GCN的参数。参数的调整考虑到了两种结构。</p>\n<p>作者在连接预测、边分类和节点分类三个任务上评估了提出的方法，效果相当好。<a href=\"https://github.com/IBM/EvolveGCN\">github开源代码链接</a></p>\n<h2 id=\"引言\">引言</h2>\n<p>图是无处不在的数据结构，用于对实体间的成对交互进行建模。相较于欧几里得数据，通过图进行学习会遭遇很多独特的问题，包括他们的组合性质和可扩展性瓶颈。</p>\n<p>目前使用图学习的神经网络主要集中于给定的静态图。而在现实应用中，图结构通常是动态的（比如一个人的社交网络是会随着时间不断改变的）。这种情况下需要更新节点嵌入来获取其变化。</p>\n<p>作者基于用于静态图的图神经网络，通过引入循环机制来更新网络参数从而应用于动态场景。<strong>大量的 GNN 通过递归地聚合来自单跳邻域的节点嵌入来执行信息融合</strong>。网络的大部分参数是每一层中节点嵌入的线性变换。</p>\n<p>许多相近的方法都是使用GNN来提取特征然后使用RNN来学习提取到的特征（节点嵌入）中的序列信息。最后为时间轴上所有的图学习到一个单一的GNN模型。这些模型的缺点在于他们需要获取节点在整个时间跨度上的信息并且难以保证在未来某个新节点上的表现。</p>\n<p>实际应用中，除了会在训练之后产生新的节点之外，节点本身也可能频繁地出现或者消失，这使得节点嵌入的方法是有问题的因为RNN难以学习到这种无规律的行为。</p>\n<p>为了解决这些问题，作者提出了在每一个时间步上使用RNN来调节GCN模型的参数。这个方法能够高效地执行模型调整，集中于模型本身而非节点嵌入。因此，不限制节点位置的改变。此外，对于未来图中会出现的新节点EvolceGCN仍然很敏感。</p>\n<p>注意，GCN的参数是不训练的，他们是根据RNN得来的，因此只有RNN的参数是训练得来的。通过这种方式，参数的数量不会随着时间增加而增加而且模型就像一个经典RNN一样可控。</p>\n<span id=\"more\"></span>\n<h2 id=\"方法\">方法</h2>\n<p>作者用下标$t$作为时间索引，上标$l$作为GCN层索引。为了避免符号混乱，作者假设所有的图都有n个节点。在时间步$t$上，输入数据由一对$(A_t \\in R^{n \\times n},X_t \\in R^{n \\times d})$组成，其中前者是图邻接矩阵，后者是输入节点的特征矩阵。$X_t$的每一行都是一个相应节点的d维特征向量。</p>\n<h3 id=\"图卷积神经网络（GCN）\">图卷积神经网络（GCN）</h3>\n<p>一个GCN由多个图卷积层构成，和感知器类似，但是额外多一个由频谱卷积驱动的邻域聚合步骤。在时间步t时，第l层获取到邻接矩阵$A_t$和节点嵌入矩阵$H_t^{(l)}$作为输入，然后使用权重矩阵$W_t^{(l)}$来更新节点嵌入矩阵，使其变为$H_t^{(l+1)}$作为输出。数学上可以表示为</p>\n<p><img src=\"https://i.imgur.com/JWHAXje.png\" alt=\"picture 19\"></p>\n<p>其中$\\widehat{A}_{t}$是$A_t$的正规化，其定义为</p>\n<p>$$<br>\n\\widehat{A}=\\widetilde{D}^{-\\frac{1}{2} } \\widetilde{A} \\widetilde{D}^{-\\frac{1}{2} }, \\quad \\widetilde{A}=A+I, \\quad \\widetilde{D}=\\operatorname{diag}\\left(\\sum_{j} \\widetilde{A}_{i j}\\right)<br>\n$$</p>\n<p>$\\sigma$是激活函数（比如ReLU），要添加到除了输出层之外的所有层。嵌入矩阵的初始值维节点特征，比如（$H_t^{(0)}$=X_t）。如果存在L个图卷积层，对于输出层而言，$\\sigma$是恒等函数，不做任何变换，此时$H_t^{(L)}$包含了图节点从初始特征开始的变换的高级表示；或者也可以是softmax函数，$H_t^{(L)}$是预测概率。</p>\n<p>下图是EvolveGCN的示意图，每一个时间步都包含一个由时间索引的GCN。GCN的参数是权重矩阵$W_t^{(l)}$，不同时间步t和不同层其值会不同。</p>\n<p><img src=\"https://i.imgur.com/fpWN55x.png\" alt=\"picture 1\"></p>\n<p>图卷积会在特定时间发生但是会沿着卷积层生成新的信息。下图解释了每一层的计算过程。$H_t^{(l)}$,$W_t^{(l)}$和$H_t{(l+1)}$的关系在图的中间部分有解释。</p>\n<p><img src=\"https://i.imgur.com/rT6G3TJ.png\" alt=\"picture 2\"></p>\n<h3 id=\"GCN参数的调节\">GCN参数的调节</h3>\n<p>本文方法的核心在于GCN的参数（也就是变换矩阵$W_t^{(l)}$）在时间步t上基于现在和历史信息的更新。为了实现这个目标，有两种使用RNN的选择：</p>\n<ol>\n<li>将$W_t^{l}$视为动态系统的隐藏层。作者使用GRU来更新隐藏层。输入信息是节点嵌入矩阵$H_t^{l}$。可以解释为：</li>\n</ol>\n<p><img src=\"https://i.imgur.com/p6Tx3VC.png\" alt=\"picture 21\"></p>\n<p>这里的GRU可以替换为其他的RNN结构，只要对于$W_t^{l}$,$H_t^{l}$和$W_{t-1}^{(l)}$的定义是清晰的就可以。上图中的-H版本就是这个方法。</p>\n<ol start=\"2\">\n<li>将$W_t^{(l)}$作为动态系统的输出（在下一个时间步又会变成输入）。作者在这里使用的是LSTM。LSTM通过使用context cell本身就包含了系统信息，类似于GRU中的隐藏层。在这个RNN结构中，节点嵌入矩阵是用不到的，可以解释为：</li>\n</ol>\n<p><img src=\"https://i.imgur.com/CBDoEIg.png\" alt=\"picture 22\"></p>\n<p>同样这里LSTM也可以替换成别的结构。</p>\n<h3 id=\"进化图卷积单元\">进化图卷积单元</h3>\n<p>将上面两小节的结构相结合就得到最总的EGCU。基于GCN中变换矩阵的变化方式，可以有两种版本：</p>\n<p><img src=\"https://i.imgur.com/QtUQb8v.png\" alt=\"picture 3\"></p>\n<p>将这些EGCU从下至上地进行连接，就能获得一个时间步上多层的GCN。之后随着时间变化再水平铺开，这些EGCU就会形成一个$H_t^{(l)}$和$W_t^{(l)}$的变化信息流。</p>\n<h3 id=\"GRU版本的实现\">GRU版本的实现</h3>\n<p>可以使用标准GRU实现，但是需要做两个扩展：</p>\n<ol>\n<li>将输入从向量扩展为矩阵（因为隐藏层是GCN的参数）</li>\n<li>将输入的列数和隐藏层的列数相匹配</li>\n</ol>\n<p>扩展为矩阵很直接：只需要简单地将列向量一个接一个排在一起形成矩阵。换句话说，用相同的GRU来处理GCN参数的每一列。作者通过以下算法实现这个功能，其中所有的变量都是局部变量。</p>\n<p><img src=\"https://i.imgur.com/lHkt56O.png\" alt=\"picture 4\"></p>\n<p>假设隐状态的列数为k，作者的方法是将所有节点嵌入向量汇总为k个代表向量。下方的算法给出了一个比较常用的汇总方法。通过这个方法将矩阵$X_t$视为输入并且产生一个只有k行的矩阵$Z_t$。该方法需要一个参数向量p，并且要独立于时间轴t。这个向量用于计算行的权重，其中有着最高权重的k行被选为输出</p>\n<p><img src=\"https://i.imgur.com/VEr6QwK.png\" alt=\"picture 3\"></p>\n<p>通过上面两个函数g和summarize我们就可以总结出RNN结构的具体工作内容</p>\n<p><img src=\"https://i.imgur.com/KDVVeck.png\" alt=\"picture 23\"></p>\n<h4 id=\"GRU基本原理\">GRU基本原理</h4>\n<p><img src=\"https://i.imgur.com/oLQtJQv.png\" alt=\"picture 12\"></p>\n<p>如上图所示是一个基本的GRU工作中的一环，GRU本身有两个门重置门和更新门。</p>\n<p>可以这么理解，每个门中有三个参数，对当前输入做变换的变换矩阵$W_1$，对上一时刻传过来的隐状态做变换的变换矩阵$W_2$,和一个偏置值。此外还有一个候选隐状态的控制参数，也是由这三个类型的数据组成的。</p>\n<p>经过这两个门的转换之后，可以得到两个矩阵重置门矩阵R和更新门矩阵U。</p>\n<p>然后对于重置门矩阵，再将他放到候选隐状态参数中做一个变换，得到一个和应该要输出的隐状态相同的候选隐状态。</p>\n<p>然后结合上一层的隐状态和这一层的候选隐状态得到这一层真正传递下去的隐状态。这时结合就需要用到更新门矩阵Z了，本质上Z是一个行向量或者说列向量，公式为：</p>\n<p><img src=\"https://i.imgur.com/e1U0iWX.png\" alt=\"picture 2\"></p>\n<h3 id=\"LSTM版本的实现\">LSTM版本的实现</h3>\n<p>该版本的实现基本与上面是相同的，见下面的伪代码</p>\n<p><img src=\"https://i.imgur.com/n9qGXgg.png\" alt=\"picture 4\"></p>\n<h3 id=\"版本的选用\">版本的选用</h3>\n<p>实际应用中需要根据数据集选用不同的版本。如果节点特征矩阵包含很多信息，GRU版本就会更加有效，因为他在rnn结构中包含了额外的节点嵌入；相反，如果节点特征包含信息较少而图结构相对而言比较重要的话，LSTM版本就会更加有效。</p>\n<h2 id=\"个人理解\">个人理解</h2>\n<p>本质上就是每个时刻的GCN每层的模型作为一个序列，这样就可以用RNN学习这个序列的变化，所以本文的重点就是GCN模型中的各层权重W的学习和演化。</p>\n<p>而两个版本的不同之处在于，GRU同时需要两个矩阵：当前的节点嵌入矩阵和当前时刻GCN的权重W。而LSTM只需要权重W不需要考虑节点嵌入矩阵的信息。</p>\n","categories":["图神经网络"],"tags":["动态GCN"]},{"title":"Learning under Concept Drift : A Review","url":"/2022/03/26/Learning-under-Concept-Drift-A-Review/","content":"<h2 id=\"摘要-3\">摘要</h2>\n<p>概念漂移描述的是数据流随时间的潜在分布的不可预见的变化。概念漂移研究的包括漂移检测、理解和适应的方法技术。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-3\">引言</h2>\n<p>概念漂移是指模型要预测的目标变量的静态属性会随着时间以一种不可预见的方式变化。一旦概念漂移发生，过去数据所产生的模式将不再适用于新数据，会产生糟糕的性能表现。</p>\n<p>概念漂移在现实场景中很常见。比如手机使用行为的变化，如下图，可以看出手机用户使用的分布已经从“打电话”向“照相”再到“联网”做出了变动。</p>\n<p><img src=\"https://i.imgur.com/n1NjFiv.png\" alt=\"picture 1\"></p>\n<p>近些年的研究致力于更加有挑战性的问题，比如，如何准确地在非结构化并且噪声很强的数据集上检测概念漂移，如何有效地以可解释性的方式理解概念漂移，如何通过相关知识对概念漂移做出反应。解决这些问题能够赋予预测和决定任务在变化场景下的适应能力。</p>\n<p>传统机器学习有两个主要组成部分：训练和预测。在概念漂移下进行学习有三个新组成部分：漂移检测（是否发生漂移）、漂移理解（什么时间，因为什么，在哪里发生漂移）、漂移适应（对已经发生的漂移做出反应），如下图。</p>\n<p><img src=\"https://i.imgur.com/ErsAUKE.png\" alt=\"picture 2\"></p>\n<h2 id=\"问题描述\">问题描述</h2>\n<h3 id=\"概念漂移的定义和来源\">概念漂移的定义和来源</h3>\n<p>概念漂移的首次提出是有学者指出噪音数据在不同的时间会转变成非噪音数据。这些变化可能是由于不可直接衡量的隐变量的变化引起的。通常来说，概念漂移定义如下：<br>\nneq<br>\n给定时间周期[0,t]，一组样本，表示为 $S_{0,t}=\\left{d_0,\\dots,d_t\\right}$ ，其中 $d_i=(X_i,y_i)$ 是一个观测（或者一个数据样本），$X_i$是特征向量，$y_i$是标签，$S_{0,t}$服从特定分布$F_{0,t}(X,y)$。概念漂移发生在时间步t+1，如果$F_{0,t}(X,y)\\neq F_{t+1,\\infin }(X,y)$，表示为$\\exists t:P_t(X,y)\\neq P_{t+1}(X,y)$。</p>\n<p>由于概念漂移是由X和y在时间t的联合概率决定的，可以表示为$P_t(X,y)=P_t(X)\\times P_{t+1}(y|X)$，那么概念漂移的发生就会有三种原因：</p>\n<ul>\n<li>$P_t(y|X) = P_{t+1}(y|X) \\And P_t(X) \\neq P_{t+1}(X)$，这种情况下发生变化的仅仅是$P_t(X)$，由于$P_t(X)$的变化不会影响决策边界，这也被认为是虚拟漂移</li>\n<li>$P_t(y|X) \\neq P_{t+1}(y|X) \\And P_t(X) = P_{t+1}(X)$，这种情况下会导致决策边界的改变并且引发学习进度的下降，被称为事实漂移</li>\n<li>$P_t(y|X) \\neq P_{t+1}(y|X) \\And P_t(X) \\neq P_{t+1}(X)$，概念漂移对两者的改变都比较关注，因为两者的改变都会传递出学习环境的重要信息</li>\n</ul>\n<p><img src=\"https://i.imgur.com/FRjYUEJ.png\" alt=\"picture 3\"></p>\n<p>上图展示了这三种漂移的区别。第一种是特征空间的漂移，第二种是决策边界的漂移，而在现实世界中往往两者是同时发生的。</p>\n<h3 id=\"概念漂移的类型\">概念漂移的类型</h3>\n<p>概念漂移通常分为四类，如下图所示：</p>\n<p>对类型1-3的概念漂移适应的研究注重于如何最小化精度下降并且在概念转换的过程中获得最快的恢复速度。相反的，类型4强调使用历史概念，即如何用最短时间找到最佳匹配的历史概念。</p>\n<p><img src=\"https://i.imgur.com/wBD6Kkr.png\" alt=\"picture 6\"></p>\n<p>中间概念这个词被用来描述概念之间转变的过程。因为概念漂移的发生并不是在某个精确时间点，它是一个长期的过程。因此中间概念就在这个过程中产生了，他可能是两个概念的混合，比如增量漂移，也可以是其中一个概念，比如渐进漂移。</p>\n<h2 id=\"概念漂移检测\">概念漂移检测</h2>\n<h3 id=\"漂移检测的总体框架\">漂移检测的总体框架</h3>\n<p>漂移检测指的是通过识别变化点或者变化时间间隔描述和量化概念漂移的技术和机制。总体框架包含4个阶段：</p>\n<ol>\n<li><strong>数据检索</strong>。从数据流中检索数据块。一个单独的数据样本不足以推断数据整体分布，知晓如何组织数据块来形成一个有意义的模式或者知识在数据流分析任务中是非常重要的。</li>\n<li><strong>数据建模</strong>。抽象检索的数据并且提取包含敏感信息的关键特征，即一旦漂移对系统影响比较大的特征。这一阶段是非必须的，因为其主要是降维或者降采样来满足内存和在线速度的需求。</li>\n<li><strong>测试统计数据计算</strong>。不相似度或者距离估计的衡量。量化漂移的严重性并且为假设形成测试统计数据。这是概念漂移检测面临的最有挑战性的方面。</li>\n<li><strong>假设测试</strong>。使用一个特定的假设测试来估计变化的统计学显著性或者p-value。能够判断变化是由于概念漂移造成的而不是噪音或者随机采样的偏差。</li>\n</ol>\n<p><img src=\"https://i.imgur.com/Qz83MTV.png\" alt=\"picture 7\"></p>\n<h3 id=\"概念漂移检测算法\">概念漂移检测算法</h3>\n<h4 id=\"基于错误率的漂移检测\">基于错误率的漂移检测</h4>\n<p>引用量最多的算法是Drift Detection Method（DDM）。这是首个定义了警告等级和漂移等级的算法。</p>\n<p><img src=\"https://i.imgur.com/aSJI8Bu.png\" alt=\"picture 8\"></p>\n<p>阶段一通过一个时间窗实现的，如上图所示。当新的数据样本能够评估时，DDM会检测时间窗内总体的错误率是否有显著增加。如果观察到的错误率变化达到警告等级，DDM就会开始构建一个新的学习器同时使用旧学习器做预测。如果变化达到漂移等级，旧的学习器就会被新学习器取代。为了获取在线错误率，DDM需要一个分类器来做预测。这个过程将训练数据转变为学习模型，这是第二阶段。阶段3的测试统计数据构成在线错误率。假设检验阶段(第四阶段)通过估计在线错误率的分布，计算预警级别和漂移阈值进行假设检验。</p>\n<p>其他还有很多算法变体，这里就不一一赘述。</p>\n<h4 id=\"基于数据分布的漂移检测\">基于数据分布的漂移检测</h4>\n<p>用一个距离函数来量化历史数据和新数据的分布的差异度。如果度在统计学上存在明显不同，系统就会触发模型升级过程。这些算法不仅能够准确识别漂移时间，也能够提供漂移的位置信息。但是，这些算法往往会需要较高的算力。此外，该类算法还会需要用户预定义历史数据窗口和新数据窗口。通常采用的方法是两个滑动窗口，历史数据的窗口固定而新数据的窗口不断滑动。</p>\n<p><img src=\"https://i.imgur.com/39QZ3bH.png\" alt=\"picture 9\"></p>\n<h2 id=\"漂移的适应\">漂移的适应</h2>\n<h3 id=\"训练一个新的模型\">训练一个新的模型</h3>\n<p><img src=\"https://i.imgur.com/t8j9ydc.png\" alt=\"picture 10\"></p>\n<p>也许应对概念漂移最直接的方法是用最新的数据重新训练一个新的模型来代替过时的模型，如图所示。需要一个明确的概念漂移检测器来决定何时重新训练模型（漂移检测）。该方法通常采用窗口策略来保存最新的数据用于再训练和/或保留旧数据用于分布变化测试。配对学习者遵循这一策略，使用两个学习者：稳定学习者和反应性学习者。如果稳定学习者经常对反应性学习者正确分类的实例进行错误分类，则会检测到一个新的概念，并将稳定学习者替换为反应性学习者。该方法简单易懂，易于实现，可应用于数据流中的任何一点。</p>\n<p>当采用基于窗口的策略时，必须进行权衡，以确定合适的窗口大小。小窗口可以更好地反映最新的数据分布，但大窗口为训练新模型提供了更多的数据。ADWIN是一种流行的窗口方案算法，旨在缓解这一问题。与大多数早期的工作不同，它不需要用户预先猜测正在比较的窗口的固定大小；相反，它检查窗口的所有可能的剪切，并根据两个子窗口之间的变化率计算最佳子窗口大小。找到最优窗口切割后，删除包含旧数据的窗口，并用最新的窗口数据训练新模型。</p>\n<p>研究人员并没有直接对模型进行再训练，而是尝试将漂移检测过程与特定机器学习算法的再训练过程结合起来。DELM扩展了传统的ELM算法，通过自适应地调整隐藏层节点的数量来处理概念漂移。当分类错误率增加时（这可能表明概念漂移的出现），更多的节点被添加到网络层以提高其逼近能力。同样，FP-ELM是一种ELM扩展方法，它通过在ELM模型中引入遗忘参数来适应漂移。基于ELM的方法的并行版本也被开发用于概念漂移下的高速分类任务。OS-ELM是另一种在线学习的抑制因子模型集成，它使用有序聚合（OA）技术集成ELM，克服了定义最佳集成规模的问题。</p>\n<h3 id=\"模型聚合（用于recurring-drift）\">模型聚合（用于recurring drift）</h3>\n<p>在重复出现的概念漂移的情况下，保留和重用旧模型可以节省为重复概念重新训练新模型所做的大量工作。这是使用集成方法处理概念漂移的核心思想。近年来，集成方法在流数据挖掘领域受到了广泛的关注。集成方法包括一组可能具有不同类型或不同参数的基本分类器。每个基地的产量分类器是利用一定的投票规则组合起来预测新到达的数据。许多自适应集成方法已经被开发出来，目的是通过扩展经典集成方法或创建特定的自适应投票规则来处理概念漂移。图14示出了一个例子，其中当概念漂移发生时，新的基本分类器被添加到集成中。</p>\n<p><img src=\"https://i.imgur.com/sLtI8UF.png\" alt=\"picture 11\"></p>\n","categories":["概念漂移"],"tags":["综述"]},{"title":"Human-level concept learning through probabilistic program induction","url":"/2022/03/25/Human-level-concept-learning-through-probabilistic-program-induction/","content":"<h2 id=\"摘要-4\">摘要</h2>\n<p>人类学习一个新的概念通常只需要从极其少量的实例中就能进行概括归纳，但是机器学习算法则需要大量的样本才能达到相同的精度。</p>\n<p>此外人类学习的比机器学习的具有更丰富更广泛的拓展，人类可以基于现有的类创建新的抽象对象类别，而机器分类器不会执行这些额外的功能，即便要执行，也会需要一个专门的新算法。</p>\n<p><img src=\"https://i.imgur.com/eytNsjy.png\" alt=\"picture 1\"></p>\n<p>对于这些新算法面临的挑战在于：</p>\n<ul>\n<li>人们如何从少量例子学习新的概念？</li>\n<li>人们如何学习抽象、丰富、灵活的表示？</li>\n<li>如何从稀疏的数据中成功学习，同时产生如此丰富的表示？</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"引言-4\">引言</h2>\n<p>本文介绍了一个贝叶斯程序学习（BPL）框架，能够仅从一个示例中学习一大类视觉概念，并且以人类几乎无法区分的方式进行泛化。</p>\n<p>概念用简单的概率程序进行表示。这样，丰富的概念就可以从更简单的概念组合构成。</p>\n<p>学习则是通过构建最能解释贝叶斯标准下的观察结果的程序来进行的，而模型去学会学习是通过开发层次鲜艳，允许之前对相关概念的经验来简化新概念的学习。简单来说就是，该框架可以通过重用现有的程序片段来构建新的程序，捕捉因果和组合。</p>\n<h2 id=\"贝叶斯程序学习\">贝叶斯程序学习</h2>\n<p>BPL通过学习简单的随机程序来表示概念，通过下图中的part(A,iii),subpart(A,ii)和空间关系(A,iv)来构建他们。</p>\n<p>BPL定义了一个生成模型，可以通过新的方式组合part和subpart来对新类型的概念进行采样。</p>\n<p>每个新的类型也被表示为一个生成模型，并且产生了新概念的实例(A,v)，这样BPL就成为了生成模型的生成模型。最后用原始数据的格式对生成的实例进行展示。</p>\n<p>在随后的评估任务中，既不使用产生的数据，也不使用该集合中的任何字母，这些任务只提供新字符的原始图像。</p>\n<p>手写字符的类型$\\Psi$是part、subpart和空间关系的抽象模式。字符的part$S_i$是按下笔开始到提起笔结束的笔画，而subpart则是由短暂的停笔所分隔的更原始的动作。</p>\n<p>首先是type层面的内容：</p>\n<p>为了构建一个新的字符类型，首先需要采样k个parts并且对于每一个part i=1…k取$n_i$个subparts。一个part $S_i$的模板是通过从一组离散原始的动作中采样来的subpart构成的,这些原始动作是从背景集中学来的，这样下一个动作的概率会依赖上一个动作。然后通过对每一个subparts之间的控制点和尺度参数进行取样将parts表示成参数化的曲线。最后parts之间的位置关系由$R_i$决定。</p>\n<p>到这一步的时候就已经得到字符的解析结构了，接下来就要进入到token层面的过程了：</p>\n<p>首先引入适当的噪声来生成笔画曲线S(m)，然后从背景集中得到笔画空间位置关系结合上一笔，取样就能得到part的开始位置。然后进行放射变换A(m)并加入适当噪声。最后通过随机补偿函数得到二值图像，画出轨迹。</p>\n<p><img src=\"https://i.imgur.com/RqMOnN2.png\" alt=\"picture 2\"></p>\n<p>字符的token$\\theta^{(m)}$是通过执行part和关系并且对墨迹流向建模产生的。</p>\n"},{"title":"Distilling the Knowledge in a Neural Network","url":"/2022/01/16/KnowledgeDistill/","content":"<h2 id=\"摘要-5\">摘要</h2>\n<p>提升机器学习算法性能的最简单方式就是在相同数据集上训练足够多的模型然后对他们的预测取平均值。但是使用多个模型的组合相当繁琐，而且对于大部分使用者来说其计算代价太大，尤其是每个模型都是大型的神经网络的时候。Caruana提出可以将集合模型的知识压缩到一个单独模型中，这会使得知识更容易使用。Hinton使用了一个不同的压缩技术对这一方法进行了改进发展。该方法在MNIST数据集上获取了很好的表现，并且Hinton证明了通过蒸馏一组模型中的知识到一个单独模型中，能够极大提升大量应用在商业系统中传统模型的性能。Hinton还提出了由一个或者多个完整模型和专家模型组合而成的集合，该集合能够分辨更细的类，这是完整模型所无法做到的。这些专家模型可以快速并行训练</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-5\">引言</h2>\n<p>许多昆虫在年幼时为了获取营养往往是一种形态，而成年后为了繁殖和迁徙往往又是另外一种形态。在大规模机器学习中，我们在训练和部署阶段往往会使用非常相似的模型，即便他们的需求不同：对于语音和目标识别任务，训练过程必须在相当大的、高度冗余的数据集中提取结构，但他不必进行实时处理并且有很大的计算量。但是，在部署到大量的用户阶段，就会在计算资源和一些潜在方面由更严格的限制。从昆虫中可以得到启发，我们在训练阶段可以用一个非常复杂的模型，它可以是多个模型的组合也可以本身是一个强正则化的大模型。一旦模型训练好了之后，我们就可以通过以中心的训练方法：蒸馏，来讲繁琐模型中的知识转移到更适合部署的小模型上。</p>\n<p>阻挡这一有前景的方法继续深入的一大问题是我们往往使用模型中参数的值来定义知识，而这时的我们很难去知道如何才能改变模型的结构而不改变其中的知识。将知识从任何实例化中解放出来的更加抽象的观点是它知识一个输入向量到输出向量的映射关系。对于大型的分类模型，正常的目标是去最大化正确类别的平均对数概率，但是这样的副作用是其他类的可能性的值差距不大（比如正确答案是猫，而预测成老虎的概率理应比海豚的概率大的多，但是在这种情况下，会使得这两者差距很小）。</p>\n<p>目前一个广泛接受的观点是，用于训练的目标函数应当尽可能地反映使用者真实的目的。尽管如此，当真实目标是更好地泛化到新数据的时候，训练模型通常是为了优化在训练集上的性能。训练模型以很好地泛化显然会更好，但这需要有关正确泛化方法的信息，而这种信息往往是比较难以获取到的。但是，当我们将大模型中的知识蒸馏到小模型中的时候，我们能够训练小模型以大模型的方式进行泛化。</p>\n<p>一个简单的将繁琐模型的繁华能力转移到小模型中的方法是使用大模型产生的类别概率作为“软目标”训练小模型。在转移阶段，我们可以使用相同的训练集或者转移集。如果繁琐模型是由许多简单模型组成的，可以去这些小模型的算术或者集合平均值作为软目标。当软目标有着较高的熵的时候，每一个训练样本都会比硬目标提供更多的信息，并且每个样本之间的梯度变化较小，因此小模型可以在一个更少的数据集上用更大的学习率进行训练。</p>\n<p>对于MNIST这种繁琐模型能够获得超高准确率的分类任务来说，有许多信息是藏在模型学习到的函数中的。比如，某一种2的写法被预测成3的概率是 $10^{-6}$ 而预测成3的概率是 $10^{-9}$ 而另一种写法可能由另外一种概率。这是一个能够定义数据上更加丰富的相似度结构的信息，但是在转移阶段他对交叉熵损失函数的影响非常小因为它的值非常接近于0。Hinton提出的蒸馏方法通过不断提高最终softmax层的temperature参数直到繁琐模型产生一个合适的软目标输出。然后在训练小模型的时候使用相同的温度参数来匹配软目标。</p>\n<p>用来训练小模型的转移集可以完全由无标签数据组成，当然我们也可以使用原始数据集。Hinton发现使用原始训练集效果也不错，尤其是当我们在目标函数中加一小项，使小模型同时利用真实标签和软目标进行预测的时候。</p>\n<h2 id=\"蒸馏\">蒸馏</h2>\n<p>神经网络通过softmax层将logits $z_i$ 计算转变为一个类别概率 $q_i$，计算公式如下：</p>\n<p>$$<br>\nq_{i}=\\frac{\\exp \\left(z_{i} / T\\right)}{\\sum_{j} \\exp \\left(z_{j} / T\\right)} \\tag{1}<br>\n$$</p>\n<p>其中T是温度参数，默认为1。使用较高的温度参数会在类别概率上形成较为平滑的分布。</p>\n<p>在最简单的蒸馏形式中，通过在转移集上训练模型并且使用繁琐模型在高温度下产生的softmax作为软目标来转移知识。在训练小模型的时候，温度参数不便。但是训练过后在使用模型的时候要将温度设回默认值。</p>\n<p>当转移集中所有或者部分样本的标签是已知的情况下，这种方法可以通过同时训练小模型来产生正确标签来获得巨大提升。一个方法是使用真实标签来调整软目标，但是Hinton发现了一个更好的方法，只需要给不同的目标函数加上一个权重。第一个目标函数是软目标的交叉熵并且这个交叉熵的计算是用相同温度的小模型的softmax和繁琐模型生成的软目标计算得来的。第二个目标函数是和真实标签的交叉熵损失函数。Hinton发现将第二个函数的权重设的比较低能够获得较好的结果。由于软目标产生梯度幅度为 $1/T^2$ ，在使用硬、软目标的时候都需要乘以 $T^2$ 。这能够保证在用元参数进行实验时候的温度变化不会影响软、硬目标的影响。</p>\n<h3 id=\"比较logits是蒸馏的一个特例\">比较logits是蒸馏的一个特例</h3>\n<p>转移集中的每一个样本在小模型中的logit $z_i$ 都会贡献一个交叉熵梯度，$dC/dz_i$ 。如果繁琐模型的logits是 $v_i$ ，会产生概率 $p_i$ ，并且转移训练的过程是在温度T下进行的话，梯度如下：</p>\n<p>$$<br>\n\\frac{\\partial C}{\\partial z_{i}}=\\frac{1}{T}\\left(q_{i}-p_{i}\\right)=\\frac{1}{T}\\left(\\frac{e^{z_{i} / T}}{\\sum_{j} e^{z_{j} / T}}-\\frac{e^{v_{i} / T}}{\\sum_{j} e^{v_{j} / T}}\\right) \\tag{2}<br>\n$$</p>\n<p>如果温度足够高的话可以近似如下：</p>\n<p>$$<br>\n\\frac{\\partial C}{\\partial z_{i}} \\approx \\frac{1}{T}\\left(\\frac{1+z_{i} / T}{N+\\sum_{j} z_{j} / T}-\\frac{1+v_{i} / T}{N+\\sum_{j} v_{j} / T}\\right) \\tag{3}<br>\n$$</p>\n<p>此时如果我们假设logits对于每个样本都是零均值分布的，则上式可以简化为：</p>\n<p>$$<br>\n\\frac{\\partial C}{\\partial z_{i}} \\approx \\frac{1}{N T^{2}}\\left(z_{i}-v_{i}\\right) \\tag{4}<br>\n$$</p>\n<p><strong>因此在高温度的情况下，蒸馏就等价于最小化 $1/2(z_i-v_i)^2$（logits是零均值分布的情况下）。在低温情况下，蒸馏不会过于注重比平均负标签负得多得多的logits的匹配。这是有潜在优势的，因为这些logits几乎完全不受繁琐模型使用的损失函数的限制，因此他们非常嘈杂。另一方面，这些有很多负数的logits可能会传递繁琐模型获取到的知识的有用信息。对于这些不同影响的掌握是一个经验问题。Hinton表明当小模型太小而不能够获取繁琐模型的全部知识的情况下，中等的温度作用最好，因为它会忽略过大的负数logits。</strong> （这段我也不是很理解）</p>\n<h2 id=\"在非常大的数据集上训练专家模型集合\">在非常大的数据集上训练专家模型集合</h2>\n<p>训练模型的集合是一个很简单的利用并行计算的方法，并且集合在测试阶段需要太多计算的问题可以通过蒸馏来解决。但是模型集合另一个重要的问题是：如果单独的一个模型是超大的神经网络并且数据集也非常大的情况下，即便是用并行计算，其计算消耗也是非常大的。</p>\n<p>在这一节中，Hinton给出了这样的一个数据集的例子，并且展示学习集中于类的不同可混淆子集专家模型是如何减少计算总量的。集中于做细粒度分类的专家模型的主要问题就是他们非常容易过拟合而Hinton展示这种问题是如何通过使用软目标避免的。</p>\n<h3 id=\"JFT数据集\">JFT数据集</h3>\n<p>JFT是一个google内部数据集有1亿张图像，15000个类。</p>\n<h3 id=\"专家模型\">专家模型</h3>\n<p>当类别数量非常多的情况下，繁琐模型做成一个集合是非常有意义的，这个集合中以当包含一个在所有数据上训练的通才模型和在一些高度相似易混淆的子类上训练的专家模型（比如蘑菇的不同种类）。这种专家模型的softmax输出可以更小，通过将其他类统一视作一个单独的垃圾类。</p>\n<p>为了减少过拟合和分担学习低级特征检测器的任务，每一个专家模型都用通才模型的权重初始化。这些权重在之后训练专家模型的时候进行调整，训练集一半是该专家模型的特定子集一半是从完整训练集中随机取样。在训练过后，我们能够通过以专家模型过采样的比例的log来增加垃圾类的logit以修正偏差训练集。</p>\n","categories":["Incremental Learning"],"tags":["Hinton"]},{"title":"Learning with drift detection","url":"/2022/03/28/Learning-with-drift-detection/","content":"<h2 id=\"摘要-6\">摘要</h2>\n<p>机器学习中的大部分工作都是假设样本是根据静态概率分布随机生成的。本文作者主要研究了学习生成样本的类别概率分布从何时开始随着时间变化，提出了一个检测样本概率分布变化的方法。文章的一个中心点就是上下文的概念：一组静态分布的连续样本。本文主要通过控制在线错误率来进行漂移检测。统计学的理论保证了分布是静态是，错误率会下降，分布是动态时，错误率会上涨。对于现实环境，作者还定义了一个警告等级和漂移等级。如果在一系列样本中错误率升高达到了这两个等级，那么就会定义一个新的环境。算法会仅用达到警告等级的那个样本之前的样本作为数据集新训练一个模型。</p>\n<span id=\"more\"></span>\n<h2 id=\"追踪概念漂移\">追踪概念漂移</h2>\n<p>解决概念漂移的方法大致可以分成两类：</p>\n<ol>\n<li>每隔一段时间训练一个新的模型，不需要考虑概念漂移到底有没有发生。</li>\n<li>首先检测概念漂移，然后让模型去学习漂移后的变化。</li>\n</ol>\n<p>对于第一种方法可以设置一个时间窗，但是难点在于时间窗的大小，时间窗如果比较小，虽然能很快对概念漂移做出反应，但是在比较稳定的时期会影响模型的表现；如果时间窗比较大，虽然能提供比较好的表现和稳定的结果但是对概念漂移的发生不敏感。</p>\n<p>第二种方法需要检测概念漂移的发生，因此会监控一些指标（比如表现性能，数据属性等）。如果检测到了概念漂移，就会对模型进行调整。如果使用自适应的时间窗的话就会根据概念飘逸的程度进行自动调节。总体规则是，如果概念漂移发生则时间窗要减小，否则时间窗会增大。</p>\n<h2 id=\"漂移检测方法\">漂移检测方法</h2>\n<p>在本文中作者是假设数据一个一个来，当然，要是扩展为一批一批来也很简单。当样本到来时，模型需要做出预测。只有在预测完成之后环境才会给模型一个反馈（这个样本的label）。</p>\n<p>假设存在一组样本$(x_i,y_i)$，对于一个样本集，错误是一个随机变量。n个样本中的一个发生错误的概率服从二项分布。对于序列样本中的每一个时间点i，错误率是观察到错误的概率，$p_i$，标准差为$s_i=\\sqrt{\\frac{p_i\\times (1-p_i)}{i}}$。</p>\n<p>统计学理论保证了即使样本类分布是静态的，错误率会随着样本数量增加而减少。所以如果错误率出现明显上升的时候就表明类分布发生了变化，现在的模型可能已经不适用了。</p>\n<p>考虑到前后环境是静态时概率分布不会发生改变，n&gt;30时的样本错误率的$1-\\frac{\\alpha}{2}$置信区间大约为$p_i \\pm \\alpha \\times s_i$。参数$\\alpha$取决于置信度。漂移检测方法在训练期间会管理两个值$p_{min}$,$s_{min}$。每当新的样本的$p_i+s_i$小于$p_{min}$,$s_{min}$时，都会进行更新。</p>\n<p>作者使用一个警告等级来定义前后环境的合适窗口大小。环境窗口应当包含新环境中的旧样本和旧环境中最少的样本。假设在样本序列中存在一个样本i和其对应的 $p_i$ 。实验中低于置信度95%的时候就会触发警告，即 $p_i+s_i \\geq p_{min}+2<em>s_{min}$ 。漂移的置信度设为 $99%$ ，即 $p_i+s_i \\geq p_{min}+3</em>s_{min}$ 就认定为发生漂移。如果一组样本中错误率在样本 $k_w$ 的时候达到警告等级，在样本 $k_d$ 的时候达到漂移等级，这时候就会定义一个新的前后环境，该环境从 $k_w$ 开始，并且会用 $k_w$, $k_d$ 之间的数据新训练一个模型。当然也会存在错误率达到警告等级之后又降下去的现象，我们认为这种现象是错误警告，不需要改变前后环境。下图展示了动态窗口的结构。</p>\n<p><img src=\"https://i.imgur.com/Se2GUNb.png\" alt=\"picture 14\"></p>\n<p>该方法能够被用到任何模型中。能够直接在线上和增量算法中使用。从一个实用观点来看的话，该方法做的就是选择更加符合实际情况的训练集。</p>\n","categories":["概念漂移"]},{"title":"LightGBM的时间序列预测","url":"/2022/01/20/LightGBM%E7%9A%84%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B/","content":"<h2 id=\"决策树和梯度提升树简介\">决策树和梯度提升树简介</h2>\n<p>以下是表格数据的一个样例。其中列出了5个人物的信息，包括年龄、性别、职业、是否每天使用电脑这4个维度，我们希望利用这些信息构建机器学习模型，来预测一个人是否喜欢电脑游戏。因此，这4个维度的信息即是数据的特征，而是否喜欢电脑游戏则是数据的标签。每一行的数据是一个样本。</p>\n<p>表1</p>\n<table>\n<thead>\n<tr>\n<th>年龄</th>\n<th>性别</th>\n<th>职业</th>\n<th>是否每天使用电脑</th>\n<th>是否喜欢电脑游戏</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>12</td>\n<td>男</td>\n<td>学生</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>13</td>\n<td>女</td>\n<td>学生</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>36</td>\n<td>女</td>\n<td>护士</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>60</td>\n<td>男</td>\n<td>退休</td>\n<td>否</td>\n<td>否</td>\n</tr>\n<tr>\n<td>57</td>\n<td>女</td>\n<td>退休</td>\n<td>否</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<p>表格数据的特征类型可大致归为数值特征与类别特征这两大类。其中，数值特征的数值大小具有意义，不同特征值之间可以进行大小的比较，表1中的年龄就属于数值特征。而类别特征的不能比较大小，而是表示样本的一种属性，例如表1中的职业、性别等等。</p>\n<span id=\"more\"></span>\n<h3 id=\"决策树的基本结构\">决策树的基本结构</h3>\n<p>决策树是一种基于决策规则的树结构模型。下图是基于表1中数据的决策树的一个例子。该决策树使用表1中的特征预测了每个人是否喜爱电脑游戏。</p>\n<p><img src=\"https://i.imgur.com/3cFe97Y.png\" alt=\"picture 1\"></p>\n<p>样本从决策树的根节点出发，经过一系列的决策条件之后到达叶子节点。例如，对于表1中的第一个样本，由于其年龄不超过15岁，并且性别为男性，故会到达决策树最左边的叶子节点。决策树的每个叶子节点都包含一个常数预测值，作为所有落在该叶子上的样本的预测结果。</p>\n<h3 id=\"决策树的分类\">决策树的分类</h3>\n<p>决策树的分类方法有许多。最常见的是根据其叶子上输出的类型进行分类。叶子上预测值为类别的，称为分类树，用于分类任务。叶子上预测值为实数值的，称为回归树，用于回归任务。上图中的决策树就是一个分类树。</p>\n<h3 id=\"决策树的训练\">决策树的训练</h3>\n<p>同其他有监督学习方法一样，决策树的训练本身也是以优化某个目标函数为目的的。例如，对于回归问题，目标函数可以是最小化均方误差；对于分类问题，目标函数可以是最小化分类错误率。 但是，要找到一个最优的决策树结构非常困难，故决策树的训练通常使用自顶向下的贪心方法。流程如下：</p>\n<ol>\n<li>在训练的开始，决策树仅有一个根节点，所有的训练数据都被分配在根节点上（这时候的根节点也是叶子节点）。</li>\n<li>在当前每片叶子上，遍历所有可能的决策条件，并记录下对优化目标函数贡献（我们称这一贡献为分割增益，即split gain）最大的决策条件，作为该叶子的最优决策条件。</li>\n<li>选取一些叶子，将选中的每片叶子分割为两片新的叶子，同时将这些叶子上的训练数据按照最优决策条件划分到两片新的叶子上。</li>\n<li>对新的叶子赋予预测值，使落在该叶子上的这部分训练数据的目标函数值最优。</li>\n</ol>\n<p>循环以上过程，直到决策树达到预定的规模，或者没有合适的决策条件（例如，所有叶子上的决策条件都有损于目标函数的优化）为止。 需要特别说明的是，在步骤3中选取哪些叶子进行分割有两种常见的方式。第一种是按层分割，即每次分割现存的所有叶子节点。按层分割训练出来的决策树是一个完全二叉树。第二种是按叶子分割，每次只选取当前对优化目标函数最有效的那片叶子。按叶子分割产生的决策树不一定是完全二叉树，因此结构更加灵活。下图展示了两种分割的区别。</p>\n<p><img src=\"https://i.imgur.com/ofGBFqu.png\" alt=\"picture 2\"></p>\n<p>下图展示了以表1为训练数据，以最小化分类错误率为目标、按叶子分割的分类树训练过程。首先让我们关注一下每片叶子上的预测值。正如上面步骤4中所提到的，每片叶子上的预测值，是以最小化该片叶子上数据的分类错误率为目的的。例如，一开始所有数据点都在根节点上，这5条数据中，只有1条的标签为“是”，其余的标签均为“否”，因此一开始根节点上的预测值为否。分割了根节点之后，得到的紫色叶子上有一条数据标签为“是”，其他为“否”，对该叶子赋予“是”或“否”都没有区别，我们随机赋予它“是”作为预测值。 总结而言，对于最小化分类错误率的分类任务，一片叶子上的最优预测值是该片叶子上所有训练数据标签最多归属的类别。 对于最小化均方误差的回归任务，容易得到一片叶子上的最优预测值，就是该片叶子上所有训练数据的标签均值。</p>\n<p>接着我们来完整地查看这个决策树的训练过程。 在训练的一开始，分类错误率为⅕，且容易发现，不管在根节点上选择哪个决策条件，都不能降低分类错误率。因此，我们随机选取年龄是否超过15岁作为根节点的最优分割条件。分割好根节点之后，我们发现右边的子节点上的数据标签已经属于同一类别（都是“否”），它所对应的那部分训练数据的分类错误率已经是0，因此不需要对右边的子节点继续进行分割。考虑左边的子节点，显然，只有用性别作为决策条件才能够分开左边子节点上的两条数据，让训练误差达到0。</p>\n<p><img src=\"https://i.imgur.com/4juLbOA.png\" alt=\"picture 3\"></p>\n<h3 id=\"决策树的正则\">决策树的正则</h3>\n<p>可以想象，只要我们不停地分割叶子节点，且训练集中不存在两条完全相同但标签不同的数据，最后一定可以让决策树完全拟合训练数据的标签，只是这样训练出来的决策树的通常只是在过拟合训练数据，泛化能力较差。因此，除了直接限制决策树的规模之外，在决策树的训练过程中通常会引入一些正则化的限制。常见的有： 1. 叶子上的训练数据不能少于一个阈值。 2. 分割叶子带来的目标函数的改进量不能低于某个阈值。</p>\n<h3 id=\"梯度提升树\">梯度提升树</h3>\n<p>由于单个决策树的拟合能力有限，常通过集成学习的方式将许多决策树综合起来。其中梯度提升树（Gradient Boosted Decision Trees，GBDT）就是一种强有力的决策树集成学习算法，它通过训练一系列的回归树，使得预测值不断逼近目标。GBDT是一个迭代算法，每个迭代都会训练一棵新的回归树，这棵回归树的训练算法与普通的回归树并没有区别。不同的是它所使用的标签，具体如下。</p>\n<p>用 $t_i$ 表示第i轮迭代得到的回归树。那么，在进行完前k轮迭代之后，GBDT对训练数据点(x,y)（其中x为特征，y为标签）的预测值为 $f_k(x)=\\sum_{i=1}^k t_i(x)$ 。则第k+1轮迭代训练使用的数据标签为 $-\\frac{\\partial l(y, \\hat{y})}{\\partial \\hat{y}}|_{\\hat{y} = t_k(x_i)}$ 。 其中 $l(y,\\hat{y})$ 表示单个样本点对损失函数的贡献。例如，当损失函数为均方误差时， $l(y, \\hat{y}) = \\frac{1}{2}(y - \\hat{y}) ^ 2$ 。因此，在第k+1轮迭代训练的决策树，实际上是拟合当前GBDT预测值对损失函数的负梯度。如果损失函数为均方误差，则负梯度为 $f_k(x)-y$ ，这实际上就是当前预测值与标签y的残差。</p>\n<p>前面提到决策树有分类树和回归树。而GBDT只使用回归树，那么GBDT如何处理分类任务呢？虽然，GBDT直接的预测输出是实数值，而不是类别，但是与逻辑回归类似，可以通过sigmoid函数或者softmax转化成分类概率。并以最小化cross-entropy作为训练目标。</p>\n<p>除了决策树本身的正则化手段之外，梯度提升树也有一些正则化方式，主要包括： 1. 在训练好一棵决策树之后，将它的输出乘上一个小的系数（通常小于1）。这一过程称为shrinkage，这个系数可以看作是GBDT的学习率。注意到沿着一个点的负梯度方向，通常只有在该点的领域附近才能带来损失函数的下降，如果走得太远，损失函数可能不降反升。shrinkage在这一点上，与神经网络梯度优化方法的训练中的学习率的作用是一致的。此外，大量的实验表明GBDT使用适当的学习率有助于提高泛化性能。 2. 每个决策树只采样一部分训练数据和特征进行训练。这样做一方面可以提高每个决策树的训练速度；另一方面，使用样本采样时，每个子模型看到了不同的数据集。虽然这些数据集都是整个训练集的子集，但是一定程度上避免了所有子模型过分集中精力去优化整个训练集上的表现，从而缓解了过拟合，也使得在不同测试集上的表现更加稳定。 3. 对回归树叶子的预测值进行L2正则。具体来说，在训练第k+1棵决策树时，在损失函数当中加入一项 $\\beta \\sum_{l \\in t_{k+1}} w_l^2$ ，其中 $l\\in t_{k+1}$ 表示决策树 $t_{k+1}$ 中的所有叶子，w_l表示叶子l上的预测值。</p>\n<h2 id=\"LightGBM\">LightGBM</h2>\n<p>在性能方面，LightGBM的特点主要包括：</p>\n<ol>\n<li>率先支持了按叶子分割的决策树训练方式。在更早的GBDT开源实现中，均采用按层分割的决策树训练。正如上文介绍决策树训练的部分提到的，按叶子分割的方式更加灵活。使用相同叶子数量的情况下，按叶子分割可以更加充分地拟合训练数据。</li>\n<li>对类别特征的直接支持。在决策树的基本结构中，提到了决策树基于类别特征进行的分割，是选出类别特征所有取值中的一个子集 $\\mathcal{C}$ 作为判断条件。若一个样本的该类别特征值在 $\\mathcal{C}$ 中，则将被划分到左边的子节点，否则划分到右边的子节点。然而，要遍历所有这样的 $\\mathcal{C}$ 并选出最优的一个，代价十分巨大。假设一个类别特征共有K种不同的取值，则需要考虑的子集 $\\mathcal{C}$ 的数量为 $2^{K-1}-1$ 。在实际的数据中，很容易出现K达到上万甚至几十万的情况。因此，穷举所有的子集 $\\mathcal{C}$ 的代价是不可接受的。因此，在GBDT中对类别特征常见的处理方式，是将它们通过编码转换成数值特征。LightGBM提供了一种高效地寻找最优子集 $\\mathcal{C}$ 的方法，因此用户无需对类别特征进行额外的预处理。具体来说，在查找类别特征在某片叶子上的最优分割条件时，LightGBM首先将类别特征值按照某个统计量进行排序，然后按照这个顺序从左往右遍历不同的取值，并依次考虑将左边的全部取值作为子集 $\\mathcal{C}$ 。关于排序使用的统计量这里不展开介绍，但是使用这个统计量，就可以保证选取出来的 $\\mathcal{C}$ 一定是最优的。不过，由于选取的子集是 $2^{K-1}-1$ 个中最优的，因此这个方法很容易过拟合数据，尤其是在拥有每种类别特征值的训练样本数量较少的情况下。故LightGBM引入了三个对类别特征分割进行正则化的超参数，分别是: - max_cat_threshold，该参数限制子集 $\\mathcal{C}$ 的最大允许规模。 - cat_smooth，该参数用于对排序使用的统计量进行平滑操作。 - cat_l2，该参数用于增加使用类别特征时的L2正则权重。 要让LightGBM对类别特征的直接支持达到比较好的效果，必须很仔细地调整好这三个参数，缓解过拟合。</li>\n</ol>\n<p>在效率方面，LightGBM的特性主要包括:</p>\n<ol>\n<li>率先使用特征直方图来加速最优分割条件的查找。所谓的直方图优化，就是对每个特征构建一个直方图，在直方图中的每个区间中，累积了计算分割增益所需要的统计量。在查找一个特征的最优分割点，只考虑从直方图的区间边界中进行选取。通常直方图的区间数量不需要太多，几十个到两百多个就可以取得很好的结果。减少候选分割点的数量还可以起到一定的正则化作用。此外，LightGBM还采用了直方图做差的技巧。具体来说，由于直方图每个区间中累积的统计量是按数据进行累加得到的，因此一个特征在父节点中的直方图就等于在两个子节点中的直方图之和。故对属于同一个父节点的两个子节点，我们只需要对其中一个数据量较少的节点构建直方图，而另一个节点的直方图可以从父节点的直方图中减去其兄弟节点的直方图来得到。使用直方图做差可以让直方图的构建加速至少两倍。</li>\n<li>基于梯度的单边样本采样(Gradient-based One-side Sampling，简称GOSS)。与随机森林类似，GBDT每一轮迭代可以只选取一部分数据进行训练。这样做一方面可以降低每轮迭代的训练开销，另一方面也可以提高模型的泛化性能。一般的样本采样方法是随机采样。但是在GBDT的训练中，样本的重要性是有区别的。由于每轮的决策树拟合的标签是当前每个样本的负梯度，故需要根据当前轮次的梯度进行分割增益的计算，因此梯度绝对值的大小很大程度上决定了样本对计算分割增益的贡献。因此，LightGBM提出了一种基于梯度的采样方法GOSS。假设训练数据总量为N，在训练每个决策树之前，GOSS首先选出梯度绝对值最大的a\\times N样本，然后从剩下的样本中，再随机选取 $b\\times N$ 个样本，并将随机选取的这b\\times N个样本的梯度值乘上 $\\frac{1-a}{b}$ ，从而保证采样后的样本梯度和是采样前的一个无偏估计（这样做是因为叶子上的分割增益的计算与梯度之和有关）。使用GOSS，可以在相同的采样率下，取得比随机采样更好的训练结果。</li>\n<li>互斥特征捆绑(Exclusive Feature Bundling，简称EFB)。在表格数据中，常常会遇到一些特征，它们只在很少的一部分训练数据上有取值，而在大部分训练数据上都是缺失的。这样的特征称为稀疏特征。EFB将稀疏特征分组，并将每个分组合并为一个稠密特征，从而减少了训练中的实际特征数量，优化了存储空间并提高最有分割条件的查找速度。合并的原则，是尽可能地减少同组内不同稀疏特征之间的冲突（当两个稀疏特征在同一个数据点都有取值时，我们称之为一个冲突）。</li>\n<li>LightGBM设计了一种改进的数据分布式方案，称为投票分布式(parallel voting trees)。与数据分布式一样，投票分布式将数据按行分配到不同的机器上，并使用本地数据构造不完整的直方图。但是构造完直方图之后，投票分布式只会选取一小部分特征，通过与其他机器的通信得到这些特征的全局直方图，这样就。这些特征的选取方式如下：首先每台机器使用本地不完整的直方图，计算出每个特征的最优分割增益，并选出增益最大的K个特征。记这台机器给这K个特征各投了一票。最后统计每个特征在所有机器中所得的票数，选出的票最高的2K个特征，只通信获得这2K个特征的全局直方图。实验表明投票分布式可以在不降低准确率的前提下减少通信时间，从而提高分布式训练的效率。</li>\n</ol>\n<p><a href=\"https://microsoft.github.io/ai-edu/%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B/B16-%E5%9F%BA%E4%BA%8ELightGBM%E7%9A%84%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B/index.html#%E5%9F%BA%E4%BA%8Elightgbm%E7%9A%84%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B\">具体案例</a></p>\n","categories":["MachineLearning"],"tags":["LightGBM，GBDT"]},{"title":"Unsupervised Concept Drift Detection with a Discriminative Classifier","url":"/2022/04/08/Unsupervised-Concept-Drift-Detection-with-a-Discriminative-Classifier/","content":"<h2 id=\"摘要-7\">摘要</h2>\n<p>作者提出了一个无监督的方法D3，它使用一个带有滑动窗口的分类器通过监视特征空间的变化来检测概念漂移。这个方法可以和已有的分类器一起使用，即便该分类器本身并没有漂移适应机制。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-6\">引言</h2>\n<p>漂移检测主要有两种类型：有监督和无监督。无监督要求数据到了之后标签就要到，有监督则不需要。大多数情况下，有监督方法是检测分类器的表现，当表现下降的时候就说明要发生概念漂移了。而无监督方法主要研究特征的属性。</p>\n<p>本文提出的方法中，通过周期性地训练测试一个分类器来使它能够分别新样本的分布是否和就样本差不多。在批处理设置中与之相类似的问题是训练和测试分布不同的协变量移位适应，用的和本文相近的方法来检测和更正协变量移位。在流处理设置中，本文是第一个提出使用分类器来做漂移检测任务的。</p>\n<h2 id=\"问题定义\">问题定义</h2>\n<p>流分类是发生在数据流中，在时间和内存限制下的监督学习问题。数据流由按序到来的数据$D=\\left{(X_0,y_0),(X_1,y_1),\\dots,(X_t,y_t),\\dots \\right}$组成。其中数据的类别$y_t$只有在测试之后才能获取。</p>\n<p>t时刻的概念表示为$p_t(X,y)$，这样漂移检测就变成了一个判断输入X和标签y的联合分布是否和上一个时间步不一样。</p>\n<p><img src=\"https://i.imgur.com/OiEohiL.png\" alt=\"picture 1\"></p>\n<p>漂移检测的初始目标是设计一个能够和分类模型合作的方法，根据检测到的漂移改进模型，从而提供对于数据分布变化的适应性，最终提升模型的分类表现。</p>\n<h2 id=\"D3（Discriminative-Drift-Detector）方法\">D3（Discriminative Drift Detector）方法</h2>\n<p><img src=\"https://i.imgur.com/dK9AnlV.png\" alt=\"picture 2\"></p>\n<p>使用一个固定尺寸的滑动窗口，包含俩个集合，一个为旧数据，一个为新数据。训练一个简单分类器来区分这些集合，然后根据分类表现来判断是否发生漂移。</p>\n<p>理想状态下，可以通过估计他们的分布和计算他们之间的变化（如kl散度）来观察是否发生漂移。但是这在流数据模式下代价很大，因为需要不断重复估计且我们想要即时的结果。我们想要的仅仅是观察新旧集合是否连续不同，而不是估计他们的分布。学习分布之间的差异其实就足够检测概念漂移了。</p>\n<p>作者使用滑动窗口W，旧数据数量为w，新数据数量为wp，其中p是旧数据占新数据的比例。在初始化阶段，整个窗口为空，我们等待它装满。然后开始第一次检查，引入一个自由变量s，旧样本标记为old并且赋值为0，剩下的样本标记为new并且赋值为1。然后用s作为标签训练一个逻辑回归模型作为分类器来分辨old和new。</p>\n<p>使用AUC作为散度的度量，表示模型能分别两个类的能力。如果能很好分辨两个类的话说明发生了漂移，否则说明没有发生。为此，对AUC设置一个阈值$\\tau$作为发生漂移的分界。</p>\n<p><img src=\"https://i.imgur.com/6TMAow7.png\" alt=\"picture 3\"></p>\n<p>如前面的过程图所示，分类器分类之后会有两个结果：</p>\n<ol>\n<li>AUC大于等于阈值，这时说明发生漂移，然后就需要丢弃所有旧样本，放入新的样本。</li>\n<li>AUC小于等于阈值，这时说明没漂移，丢弃wp(也就是新样本数量)个旧样本，然后放入新样本。</li>\n</ol>\n<p>虽然新旧样本的数量是超参数，我们总会把旧样本数量设的更大。因为需要这一部分数据足够描述当前的分布并且尽量能够覆盖多的特征空间。但是也不能太大，否则可能包含多个不同的概念。由于新数据相对来说很少，因此选择一个在类不均衡场景下能够有效工作的度量是非常有必要的，为此作者选择了AUC，因为它适用于这种场景。</p>\n<h2 id=\"个人感觉这个方法的缺点\">个人感觉这个方法的缺点</h2>\n<p>使用滑动窗口的方法存在一个共同缺点就是窗口的选择，窗口过大可能永远不会检测到漂移，过小可能一直检测到漂移。</p>\n","categories":["概念漂移"]},{"title":"Dynamic Adapting Window Independence Drift Detection(DAWIDD)","url":"/2022/04/11/Dynamic-Adapting-Window-Independence-Drift-Detection-DAWIDD/","content":"<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>许多线上学习方法都包含漂移检测模块来对数据的变化做出检测和反应。但是，可靠的漂移检测算法存在一个具有挑战性的问题，不断变化的漂移特征和缺少反应漂移的参数化模型，这一问题在数据维度较高时更加明显。本文作者提出了DAWIDD的漂移检测方法，旨在对各种漂移特征进行非参的漂移检测。为此，作者在相应的漂移过程中建立了漂移发生与特定随机变量的依赖性的数学等价。这使得漂移检测无需依赖参数化模型，可以进行独立测试，这样的方案对于检测不同类型的漂移足够鲁棒。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>作者的贡献点在于：</p>\n<ol>\n<li>对用于文献中的两种不同的漂移的概念进行了形式化，即作为概率变化的漂移和作为损失函数变化的漂移，并且对他们的等价性做了证明。</li>\n<li>根据漂移过程中随机变量的独立性提供了一个新的漂移的数学表征，并且证明了这种形式化与文献中使用的漂移概念的等价。</li>\n</ol>\n<h2 id=\"概念漂移的定义\"><a href=\"#概念漂移的定义\" class=\"headerlink\" title=\"概念漂移的定义\"></a>概念漂移的定义</h2><h3 id=\"定义1\"><a href=\"#定义1\" class=\"headerlink\" title=\"定义1\"></a>定义1</h3><p>漂移过程 $(p_t,P_T)$ 是由一个[0,1]上的概率测度和 $R^d$ 上的测度集合 $p_t,t\\in [0,1]$构成，这样从t到 $p_t(A)$ 的映射对于每一个 $A \\subset R^d$，都是可测量的。</p>\n<p>对于每一个漂移过程(p_t,P_T)，存在一个在 $R^d\\times [0,1]$ 上的概率测度P，定义为：</p>\n<p><img src=\"https://i.imgur.com/Jwr26yo.png\" alt=\"picture 1\">  </p>\n<p>其中 $B \\subset [0,1],A \\subset R^d$ 。在后面我们将这个定义表示为 $p_t \\otimes P_T$ 。</p>\n<h3 id=\"定义2\"><a href=\"#定义2\" class=\"headerlink\" title=\"定义2\"></a>定义2</h3><p>如果 $p_t \\neq p_s$ 仅在 $P_T$ 为空集情况下成立，则称 $p_t$ 没有发生漂移。</p>\n<p><strong>引理1.</strong> (p_t,P_T)是漂移过程，则以下三点等价：</p>\n<ul>\n<li>$p_t$ 没有漂移</li>\n<li>在 $P_T$ 中存在 $P_X&#x3D;P_t$</li>\n<li>存在 $P_X$ 使得 $p_t \\otimes P_T &#x3D; P_X \\times P_T$</li>\n</ul>\n<h3 id=\"将损失的改变作为漂移的预测\"><a href=\"#将损失的改变作为漂移的预测\" class=\"headerlink\" title=\"将损失的改变作为漂移的预测\"></a>将损失的改变作为漂移的预测</h3><p>作者想要通过说明在哪些场景下损失变化作为预测和上述定义的漂移是等价的来证实基于损失的预测方法。</p>\n<h3 id=\"定义3\"><a href=\"#定义3\" class=\"headerlink\" title=\"定义3\"></a>定义3</h3><p>H作为假设类， $R^d$ 作为测度空间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">证明看不懂，直接跳过，总而言之作者就是证明了其提出的概念漂移的定义和传统的概念漂移检测方法检测到漂移时的情况是一样的。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"DAWIDD\"><a href=\"#DAWIDD\" class=\"headerlink\" title=\"DAWIDD\"></a>DAWIDD</h3><p>将漂移检测设计为一个依赖测试：给定 $X_1,\\dots ,X_n$ 作为样本，增加一个时间的随机变量 $T_i$ ，就变成了 $(X_1,T_1),\\dots,(X_n,T_n)$ 。通过对于 $X_i$ 和 $T_i$ 之间的独立性测试我们能够获得一个漂移检测器。</p>\n<p>执行独立性测试我们需要一个固定数量的样本，可以通过一个滑窗来实现。如果检测到漂移，将样本从窗口中移除达到最小值；如果没有，当窗口超微指定大小时，随机移除样本。这样做比数据流上的滑窗在数据上更稳定。比如说移除掉的旧样本恰好能够很好地表示一个渐进漂移。随机移除样本的合理性由下面的引理给出：</p>\n<p><strong>引理2.</strong> $(p_t,P_T)$ 和 $q_t,Q_T$ 是漂移过程。假设 $P_T(A)&#x3D;0 &#x3D;&gt; Q_T(A)&#x3D;0$ 对于任意 $A\\subset[0,1]$ 成立且 $p_t&#x3D;q_t$ 对于所有 $t\\in [0,1]$ 成立，则若 $p_t$ 没有漂移那么 $q_t$ 也没有漂移。</p>\n<p><img src=\"https://i.imgur.com/i4eyB9C.png\" alt=\"picture 1\">  </p>\n","categories":["概念漂移"]},{"title":"go web 编程","url":"/2022/03/09/go-web-%E7%BC%96%E7%A8%8B/","content":"<h2 id=\"web基础\">web基础</h2>\n<h3 id=\"web工作方式\">web工作方式</h3>\n<h4 id=\"http请求包\">http请求包</h4>\n<p>Request 包分为 3 部分，第一部分叫 Request line（请求行）, 第二部分叫 Request header（请求头）, 第三部分是 body（主体）。header 和 body 之间有个空行，请求包的例子所示:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">GET /domains/example/ HTTP/1.1      // 请求行: 请求方法 请求 URI HTTP 协议/协议版本</span><br><span class=\"line\">Host：www.iana.org               // 服务端的主机名</span><br><span class=\"line\">User-Agent：Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4          // 浏览器信息</span><br><span class=\"line\">Accept：text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8  // 客户端能接收的 mine</span><br><span class=\"line\">Accept-Encoding：gzip,deflate,sdch       // 是否支持流压缩</span><br><span class=\"line\">Accept-Charset：UTF-8,*;q=0.5        // 客户端字符编码集</span><br><span class=\"line\">// 空行,用于分割请求头和消息体</span><br><span class=\"line\">// 消息体,请求资源参数,例如 POST 传递的参数</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://i.imgur.com/uTPJIPq.png\" alt=\"picture 1\"></p>\n<p>fiddler抓取的GET信息</p>\n<p><img src=\"https://i.imgur.com/1ZOWDms.png\" alt=\"picture 3\"></p>\n<p>fiddler抓取的POST信息</p>\n<p>可以看出GET请求体为空，POST请求体存在内容。</p>\n<ul>\n<li>GET提交的数据放在URL后用<code>?</code>分割URL和传输数据，不同参数间用<code>&amp;</code>相连。POST方法是将提交的数据放在HTTP包的body中</li>\n<li>GET提交的数据有限（因为URL的长度有限），POST方法无限</li>\n<li>GET提交方法存在安全问题，比如账户密码用GET提交的话会显式地展示在URL上</li>\n</ul>\n<span id=\"more\"></span>\n<h4 id=\"http响应包\">http响应包</h4>\n<p>http的response包</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK                     // 状态行</span><br><span class=\"line\">Server: nginx/1.0.8                 // 服务器使用的 WEB 软件名及版本</span><br><span class=\"line\">Date: Tue, 30 Oct 2012 04:14:25 GMT     // 发送时间</span><br><span class=\"line\">Content-Type: text/html             // 服务器发送信息的类型</span><br><span class=\"line\">Transfer-Encoding: chunked          // 表示发送 HTTP 包是分段发的</span><br><span class=\"line\">Connection: keep-alive              // 保持连接状态</span><br><span class=\"line\">Content-Length: 90                  // 主体内容长度</span><br><span class=\"line\">// 空行 用来分割消息头和主体</span><br><span class=\"line\">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;... // 消息体</span><br></pre></td></tr></table></figure>\n<h3 id=\"搭建一个web服务器\">搭建一个web服务器</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayhelloName</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    r.ParseForm()  <span class=\"comment\">// 解析参数，默认是不会解析的</span></span><br><span class=\"line\">    fmt.Println(r.Form)  <span class=\"comment\">// 这些信息是输出到服务器端的打印信息</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;path&quot;</span>, r.URL.Path)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;scheme&quot;</span>, r.URL.Scheme)</span><br><span class=\"line\">    fmt.Println(r.Form[<span class=\"string\">&quot;url_long&quot;</span>])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> r.Form &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;key:&quot;</span>, k)</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;val:&quot;</span>, strings.Join(v, <span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Hello astaxie!&quot;</span>) <span class=\"comment\">// 这个写入到 w 的是输出到客户端的</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, sayhelloName) <span class=\"comment\">// 设置访问的路由</span></span><br><span class=\"line\">    err := http.ListenAndServe(<span class=\"string\">&quot;:9090&quot;</span>, <span class=\"literal\">nil</span>) <span class=\"comment\">// 设置监听的端口</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"go如何使得web工作\">go如何使得web工作</h3>\n<h4 id=\"http包运行机制\">http包运行机制</h4>\n<p><img src=\"https://i.imgur.com/AD1s9gm.png\" alt=\"picture 4\"></p>\n<ul>\n<li>创建 Listen Socket, 监听指定的端口，等待客户端请求到来。</li>\n<li>Listen Socket 接受客户端的请求，得到 Client Socket, 接下来通过 Client Socket 与客户端通信。</li>\n<li>处理客户端的请求，首先从 Client Socket 读取 HTTP 请求的协议头，如果是 POST 方法，还可能要读取客户端提交的数据，然后交给相应的 handler 处理请求，handler 处理完毕准备好客户端需要的数据，通过 Client Socket 写给客户端。</li>\n</ul>\n<p>下面的代码来自go的http包的源码，通过下面代码可以看到整个http处理过程</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">Serve</span><span class=\"params\">(l net.Listener)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> l.Close()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tempDelay time.Duration <span class=\"comment\">// how long to sleep on accept failure</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        rw, e := l.Accept()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> e != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果发生了网络错误的话，可以等待一会后再重试</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> tempDelay == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                    tempDelay = <span class=\"number\">5</span> * time.Millisecond</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    tempDelay *= <span class=\"number\">2</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> max := <span class=\"number\">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class=\"line\">                    tempDelay = max</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                log.Printf(<span class=\"string\">&quot;http: Accept error: %v; retrying in %v&quot;</span>, e, tempDelay)</span><br><span class=\"line\">                time.Sleep(tempDelay)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tempDelay = <span class=\"number\">0</span></span><br><span class=\"line\">        c, err := srv.newConn(rw)<span class=\"comment\">//创建一个connection</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">go</span> c.serve()<span class=\"comment\">//创建一个新的goroutine，将参数扔给conn去服务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后怎么具体分配到相应的函数来处理请求呢？conn先解析request:<code>c.readRequest()</code>，然后获取相应的handler：<code>handler:=c.server.Handler</code>，即我们刚才在调用的<code>ListenAndServe</code>时的第二个参数，我们传入的是nil因此会取默认值<code>handler=DefaultServeMux</code>，这个变量就是一个路由器，用来匹配url跳转到相应的handle函数。我们也设置了handle函数<code>http.HandleFunc(&quot;/&quot;,sayHello)</code>，这就是注册了<code>/</code>的路由规则。</p>\n<p>当请求为<code>/</code>的时候，DefaultServeMux会调用ServeHTTP方法，其内部就是调用sayHello，最后通过写入response的信息反馈到客户端</p>\n<p>以下是详细的工作过程</p>\n<p><img src=\"https://i.imgur.com/VDo4ZQr.png\" alt=\"picture 5\"></p>\n<h3 id=\"http包详解\">http包详解</h3>\n<h4 id=\"ServeMux的自定义\">ServeMux的自定义</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> ServeMux <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    mu sync.RWMutex   <span class=\"comment\">// 锁，由于请求涉及到并发处理，因此这里需要一个锁机制</span></span><br><span class=\"line\">    m  <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]muxEntry  <span class=\"comment\">// 路由规则，一个 string 对应一个 mux 实体，这里的 string 就是注册的路由表达式</span></span><br><span class=\"line\">    hosts <span class=\"keyword\">bool</span> <span class=\"comment\">// 是否在任意的规则中带有 host 信息</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> muxEntry <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    explicit <span class=\"keyword\">bool</span>   <span class=\"comment\">// 是否精确匹配</span></span><br><span class=\"line\">    h        Handler <span class=\"comment\">// 这个路由表达式对应哪个 handler</span></span><br><span class=\"line\">    pattern  <span class=\"keyword\">string</span>  <span class=\"comment\">// 匹配字符串</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    ServeHTTP(ResponseWriter, *Request)  <span class=\"comment\">// 路由实现器</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们可以看到Handler接口需要实现ServeHTTP方法，但是我们自己的sayHello并没有实现这个方法，为什么能作为handler func被添加呢？</p>\n<p>因为http包中还有一个类型<code>HandlerFunc</code>，它默认实现了ServeHTTP这个接口我们定义的函数<code>sayHello</code>就是它调用之后的结果。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> HandlerFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ResponseWriter, *Request)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ServeHTTP calls f(w, r).</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f HandlerFunc)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class=\"line\">    f(w, r)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样路由器里面存储了相应的路由规则之后，具体的请求是怎么发放的呢？默认的路由器实现了ServeHTTP：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.RequestURI == <span class=\"string\">&quot;*&quot;</span> &#123;</span><br><span class=\"line\">        w.Header().Set(<span class=\"string\">&quot;Connection&quot;</span>, <span class=\"string\">&quot;close&quot;</span>)</span><br><span class=\"line\">        w.WriteHeader(StatusBadRequest)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    h, _ := mux.Handler(r)</span><br><span class=\"line\">    h.ServeHTTP(w, r)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>路由器接收到请求了之后，如果是<code>*</code>就关闭链接，否则的话调用<code>mux.Handler</code>返回对应设置路由的处理handler，然后执行<code>h.SerceHTTP(w,r)</code></p>\n<p>那么<code>mux.Handler(r)</code>是怎么处理的呢？</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handler</span><span class=\"params\">(r *Request)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.Method != <span class=\"string\">&quot;CONNECT&quot;</span> &#123;<span class=\"comment\">//如果r是非连接请求的话</span></span><br><span class=\"line\">        <span class=\"comment\">//p初始化为URL路径</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> p := cleanPath(r.URL.Path); p != r.URL.Path &#123;</span><br><span class=\"line\">            _, pattern = mux.handler(r.Host, p)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> RedirectHandler(p, StatusMovedPermanently), pattern</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> mux.handler(r.Host, r.URL.Path)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">handler</span><span class=\"params\">(host, path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    mux.mu.RLock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> mux.mu.RUnlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Host-specific pattern takes precedence over generic ones</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> mux.hosts &#123;</span><br><span class=\"line\">        <span class=\"comment\">//将host和path组合</span></span><br><span class=\"line\">        h, pattern = mux.match(host + path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> h == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        h, pattern = mux.match(path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> h == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        h, pattern = NotFoundHandler(), <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原来他是根据用户请求的 URL 和路由器里面存储的 map 去匹配的，当匹配到之后返回存储的 handler，调用这个 handler 的 ServeHTTP 接口就可以执行到相应的函数了。</p>\n<p>通过上面这个介绍，我们了解了整个路由过程，Go 其实支持外部实现的路由器 ListenAndServe 的第二个参数就是用以配置外部路由器的，它是一个 Handler 接口，即外部路由器只要实现了 Handler 接口就可以，我们可以在自己实现的路由器的 ServeHTTP 里面实现自定义路由功能。</p>\n<p>如下代码所示，我们自己实现了一个简易的路由器</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> MyMux <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *MyMux)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.URL.Path == <span class=\"string\">&quot;/&quot;</span> &#123;</span><br><span class=\"line\">        sayhelloName(w, r)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    http.NotFound(w, r)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayhelloName</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Hello myroute!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    mux := &amp;MyMux&#123;&#125;</span><br><span class=\"line\">    http.ListenAndServe(<span class=\"string\">&quot;:9090&quot;</span>, mux)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>梳理一下整个代码的执行过程</p>\n<ul>\n<li>首先调用<code>Http.HandleFunc</code>\n<ol>\n<li>调用了<code>DefaultServeMux</code>的<code>HandleFunc</code></li>\n<li>调用了<code>DefaultServeMux</code>的<code>Handle</code></li>\n<li>往<code>DefaultServeMux</code>的<code>map[string]muxEntry</code>中增加对应的handler和路由规则</li>\n</ol>\n</li>\n<li>其次调用http.ListenAndServe(“:9090”,nil)\n<ol>\n<li>实例化Server</li>\n<li>调用Server的ListenAndServe()</li>\n<li>调用<code>net.Listen(&quot;tcp&quot;,addr)</code></li>\n<li>启动一个for循环，在循环体中Accept请求</li>\n<li>对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务<code>go c.serve()</code></li>\n<li>读取每个请求的内容<code>w,err:=c.readRequest()</code></li>\n<li>判断handler是否为空，如果没有设置handler，则默认设置为<code>DefaultServeMux</code></li>\n<li>调用handler的ServeHttp</li>\n<li>根据request选择handler，并且进入其ServeHTTP函数中</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"表单\">表单</h2>\n<h3 id=\"处理表单的输入\">处理表单的输入</h3>\n<p>下面是一个表单递交的例子</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;/login&quot;</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;post&quot;</span>&gt;</span></span><br><span class=\"line\">    用户名:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span>&gt;</span></span><br><span class=\"line\">    密码:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;登录&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>将以上表单递交到<code>/login</code>，当用户点击login之后，会跳转到这个路由，我们就首先要判断这是通过什么方式传递过来的。</p>\n<p>这在http包中可以用一个很简单的方式获取</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;html/template&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sayhelloName</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    r.ParseForm()       <span class=\"comment\">// 解析 url 传递的参数，对于 POST 则解析响应包的主体（request body）</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意:如果没有调用 ParseForm 方法，下面无法获取表单的数据</span></span><br><span class=\"line\">    fmt.Println(r.Form) <span class=\"comment\">// 这些信息是输出到服务器端的打印信息</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;path&quot;</span>, r.URL.Path)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;scheme&quot;</span>, r.URL.Scheme)</span><br><span class=\"line\">    fmt.Println(r.Form[<span class=\"string\">&quot;url_long&quot;</span>])</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> r.Form &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;key:&quot;</span>, k)</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;val:&quot;</span>, strings.Join(v, <span class=\"string\">&quot;&quot;</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Hello astaxie!&quot;</span>) <span class=\"comment\">// 这个写入到 w 的是输出到客户端的</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">login</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;method:&quot;</span>, r.Method) <span class=\"comment\">// 获取请求的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.Method == <span class=\"string\">&quot;GET&quot;</span> &#123;</span><br><span class=\"line\">        t, _ := template.ParseFiles(<span class=\"string\">&quot;login.gtpl&quot;</span>)</span><br><span class=\"line\">        log.Println(t.Execute(w, <span class=\"literal\">nil</span>))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        err := r.ParseForm()   <span class=\"comment\">// 解析 url 传递的参数，对于 POST 则解析响应包的主体（request body）</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// handle error http.Error() for example</span></span><br><span class=\"line\">          log.Fatal(<span class=\"string\">&quot;ParseForm: &quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 请求的是登录数据，那么执行登录的逻辑判断</span></span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;username:&quot;</span>, r.Form[<span class=\"string\">&quot;username&quot;</span>])</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;password:&quot;</span>, r.Form[<span class=\"string\">&quot;password&quot;</span>])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, sayhelloName)       <span class=\"comment\">// 设置访问的路由</span></span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/login&quot;</span>, login)         <span class=\"comment\">// 设置访问的路由</span></span><br><span class=\"line\">    err := http.ListenAndServe(<span class=\"string\">&quot;:9090&quot;</span>, <span class=\"literal\">nil</span>) <span class=\"comment\">// 设置监听的端口</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>request.Form</code>是一个url.Values类型，里面存储的是对应的类似键值对的信息</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">v := url.Values&#123;&#125;</span><br><span class=\"line\">v.Set(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Ava&quot;</span>)</span><br><span class=\"line\">v.Add(<span class=\"string\">&quot;friend&quot;</span>, <span class=\"string\">&quot;Jess&quot;</span>)</span><br><span class=\"line\">v.Add(<span class=\"string\">&quot;friend&quot;</span>, <span class=\"string\">&quot;Sarah&quot;</span>)</span><br><span class=\"line\">v.Add(<span class=\"string\">&quot;friend&quot;</span>, <span class=\"string\">&quot;Zoe&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// v.Encode() == &quot;name=Ava&amp;friend=Jess&amp;friend=Sarah&amp;friend=Zoe&quot;</span></span><br><span class=\"line\">fmt.Println(v.Get(<span class=\"string\">&quot;name&quot;</span>))</span><br><span class=\"line\">fmt.Println(v.Get(<span class=\"string\">&quot;friend&quot;</span>))</span><br><span class=\"line\">fmt.Println(v[<span class=\"string\">&quot;friend&quot;</span>])</span><br></pre></td></tr></table></figure>\n<h3 id=\"预防跨站脚本\">预防跨站脚本</h3>\n<p>现在的网页大部分内容是动态加载的，这会导致容易受到“跨站脚本攻击”（XSS）的威胁。</p>\n<p>对XSS的防护应该结合以下两种方法：</p>\n<ul>\n<li>验证所有输入数据，有效检测攻击</li>\n<li>对所有输出数据进行适当处理，防止已经成功注入的脚本在浏览器运行</li>\n</ul>\n<p>go里面自带的几个函数可以帮我们进行转义</p>\n<ul>\n<li>func HTMLEscape (w io.Writer, b [] byte) // 把 b 进行转义之后写到 w</li>\n<li>func HTMLEscapeString (s string) string // 转义 s 之后返回结果字符串</li>\n<li>func HTMLEscaper (args …interface {}) string // 支持多个参数一起转义，返回结果字符串</li>\n</ul>\n<p>我们可以看4.1小节的例子</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">fmt.Println(<span class=\"string\">&quot;username:&quot;</span>, template.HTMLEscapeString(r.Form.Get(<span class=\"string\">&quot;username&quot;</span>))) <span class=\"comment\">// 输出到服务器端</span></span><br><span class=\"line\">fmt.Println(<span class=\"string\">&quot;password:&quot;</span>, template.HTMLEscapeString(r.Form.Get(<span class=\"string\">&quot;password&quot;</span>)))</span><br><span class=\"line\">template.HTMLEscape(w, []<span class=\"keyword\">byte</span>(r.Form.Get(<span class=\"string\">&quot;username&quot;</span>))) <span class=\"comment\">// 输出到客户端</span></span><br></pre></td></tr></table></figure>\n<p>如果我们输入的username是<code>&lt;script&gt;alert()&lt;/script&gt;</code>,浏览器上就会出现alert提示。</p>\n<p>这个包可以帮助我们过滤html标签，但是我们只想要输出这个看起来正常的信息应该怎么做呢？</p>\n<p>比如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;text/template&quot;</span></span><br><span class=\"line\">...</span><br><span class=\"line\">t, err := template.New(<span class=\"string\">&quot;foo&quot;</span>).Parse(<span class=\"string\">`&#123;&#123;define &quot;T&quot;&#125;&#125;Hello, &#123;&#123;.&#125;&#125;!&#123;&#123;end&#125;&#125;`</span>)</span><br><span class=\"line\">err = t.ExecuteTemplate(out, <span class=\"string\">&quot;T&quot;</span>, <span class=\"string\">&quot;&lt;script&gt;alert(&#x27;you have been pwned&#x27;)&lt;/script&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello, &lt;script&gt;alert(&#x27;you have been pwned&#x27;)&lt;/script&gt;!</span><br></pre></td></tr></table></figure>\n<p>或者将其中的<code>&quot;&lt;script&gt;alert('you have been pwned')&lt;/script&gt;&quot;</code>改成<code>template.HTML(&quot;&lt;script&gt;alert('you have been pwned')&lt;/script&gt;&quot;)</code></p>\n<h3 id=\"验证表单的输入\">验证表单的输入</h3>\n<p>开发web的一个重要原则，不要相信用户输入的任何信息。所以我们需要对用户输入进行验证。通常有两种验证方式，一种是在页面端的js验证，一种是在服务器端的验证，我们主要关注如何在服务器端验证。</p>\n<h4 id=\"必填字段\">必填字段</h4>\n<p>如果我们想确保从表单中获取一个值，比如前面提到的用户名，可以用len函数获取字符串长度，比如</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(r.Form[<span class=\"string\">&quot;username&quot;</span>][<span class=\"number\">0</span>])==<span class=\"number\">0</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 为空的处理</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>r.Form</code>对不同表单元素有不同处理，对于空文本框、空文本区域以及文件上传，元素的值为空值，而如果是未选中的复选框和单选按钮，根本不会被<code>r.Form</code>获取到，应用上面的程序就会出错。因此我们需要用<code>r.Form.Get()</code>来获取值，如果字段不存在会返回空，但是这个方法只能取一个值，如果要取map的值，就必须要用上面的方法</p>\n<h4 id=\"数字\">数字</h4>\n<p>如果想要确保一个表单的输入框必须是数字，我们想要判断是正整数的话，先转成int，然后处理</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">getint,err:=strconv.Atoi(r.Form.Get(<span class=\"string\">&quot;age&quot;</span>))</span><br><span class=\"line\"><span class=\"keyword\">if</span> err!=<span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 数字转化出错了，那么可能就不是数字</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 接下来就可以判断这个数字的大小范围了</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> getint &gt;<span class=\"number\">100</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 太大了</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也可以使用正则匹配</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> m, _ := regexp.MatchString(<span class=\"string\">&quot;^[0-9]+$&quot;</span>, r.Form.Get(<span class=\"string\">&quot;age&quot;</span>)); !m &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般来说，尽量避免使用复杂的正则表达式，因为效率会比较低。</p>\n<h4 id=\"中文\">中文</h4>\n<p>有时我们需要对中文进行验证，目前我们有两种验证中文的方式，可以使用<code>unicode</code>包提供的<code>func Is(rangeTab *RangeTable, r rune) bool</code>来验证，也可以使用正则表达式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> m, _ := regexp.MatchString(<span class=\"string\">&quot;^\\\\p&#123;Han&#125;+$&quot;</span>, r.Form.Get(<span class=\"string\">&quot;realname&quot;</span>)); !m &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外包括邮箱、手机号码等都可以使用正则表达式来进行验证，这里就不一一赘述。</p>\n<h4 id=\"下拉菜单\">下拉菜单</h4>\n<p>如果我们需要判断表单里面的<code>&lt;select&gt;</code>的下拉菜单中是否有元素被选中，有时候攻击者会伪造一个菜单中不存在的值发送给服务器，我们如何判断呢？</p>\n<p>比如，我们的select是这样的一些元素</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;fruit&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;apple&quot;</span>&gt;</span>apple<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;pear&quot;</span>&gt;</span>pear<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;banana&quot;</span>&gt;</span>banana<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们可以这样来验证</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">slice:=[]<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;apple&quot;</span>,<span class=\"string\">&quot;pear&quot;</span>,<span class=\"string\">&quot;banana&quot;</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">v := r.Form.Get(<span class=\"string\">&quot;fruit&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> _, item := <span class=\"keyword\">range</span> slice &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> item == v &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>对于单选按钮也可以采用相同的验证方法。</p>\n<h4 id=\"日期和时间\">日期和时间</h4>\n<p>想要确定用户填写的日期是否有效的话，可以利用time包</p>\n<h3 id=\"防止多次递交表单\">防止多次递交表单</h3>\n<p>有些时候一些帖子后面会有多条重复的记录，这通常是误操作。但是如果是某项投票中，有人估计多次重复提交的话我们该怎么防止呢？</p>\n<p>解决方案是在表单中添加一个带有唯一值的隐藏字段，验证表单时先验证这个表单是否已经验证过了，如果是的话就拒绝再次提交。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;interest&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;football&quot;</span>&gt;</span>足球</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;interest&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;basketball&quot;</span>&gt;</span>篮球</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;interest&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;tennis&quot;</span>&gt;</span>网球    </span><br><span class=\"line\">用户名:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span>&gt;</span></span><br><span class=\"line\">密码:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;hidden&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;token&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;&#123;&#123;.&#125;&#125;&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;登录&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>我们在模板中增加了一个隐藏字段<code>token</code>，它的值我们通过时间戳（MD5）来获取唯一值，然后存储到服务器。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">login</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;method:&quot;</span>, r.Method) <span class=\"comment\">// 获取请求的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.Method == <span class=\"string\">&quot;GET&quot;</span> &#123;</span><br><span class=\"line\">        crutime := time.Now().Unix()</span><br><span class=\"line\">        h := md5.New()</span><br><span class=\"line\">        io.WriteString(h, strconv.FormatInt(crutime, <span class=\"number\">10</span>))</span><br><span class=\"line\">        token := fmt.Sprintf(<span class=\"string\">&quot;%x&quot;</span>, h.Sum(<span class=\"literal\">nil</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">        t, _ := template.ParseFiles(<span class=\"string\">&quot;login.gtpl&quot;</span>)</span><br><span class=\"line\">        t.Execute(w, token)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 请求的是登录数据，那么执行登录的逻辑判断</span></span><br><span class=\"line\">        r.ParseForm()</span><br><span class=\"line\">        token := r.Form.Get(<span class=\"string\">&quot;token&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> token != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 验证 token 的合法性</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 不存在 token 报错</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;username length:&quot;</span>, <span class=\"built_in\">len</span>(r.Form[<span class=\"string\">&quot;username&quot;</span>][<span class=\"number\">0</span>]))</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;username:&quot;</span>, template.HTMLEscapeString(r.Form.Get(<span class=\"string\">&quot;username&quot;</span>))) <span class=\"comment\">// 输出到服务器端</span></span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;password:&quot;</span>, template.HTMLEscapeString(r.Form.Get(<span class=\"string\">&quot;password&quot;</span>)))</span><br><span class=\"line\">        template.HTMLEscape(w, []<span class=\"keyword\">byte</span>(r.Form.Get(<span class=\"string\">&quot;username&quot;</span>))) <span class=\"comment\">// 输出到客户端</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"处理文件上传\">处理文件上传</h3>\n<p>要使表单能够上传文件，首先要添加form的<code>enctype</code>属性，<code>enctype</code>属性有如下三种情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">application/x-www-form-urlencoded   表示在发送前编码所有字符（默认）</span><br><span class=\"line\">multipart/form-data   不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。</span><br><span class=\"line\">text/plain    空格转换为 &quot;+&quot; 加号，但不对特殊字符编码。</span><br></pre></td></tr></table></figure>\n<p>在服务器端，我们增加一个handlerFunc</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">http.HandleFunc(<span class=\"string\">&quot;/upload&quot;</span>, upload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理 /upload  逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">upload</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;method:&quot;</span>, r.Method) <span class=\"comment\">// 获取请求的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.Method == <span class=\"string\">&quot;GET&quot;</span> &#123;</span><br><span class=\"line\">        crutime := time.Now().Unix()</span><br><span class=\"line\">        h := md5.New()</span><br><span class=\"line\">        io.WriteString(h, strconv.FormatInt(crutime, <span class=\"number\">10</span>))</span><br><span class=\"line\">        token := fmt.Sprintf(<span class=\"string\">&quot;%x&quot;</span>, h.Sum(<span class=\"literal\">nil</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">        t, _ := template.ParseFiles(<span class=\"string\">&quot;upload.gtpl&quot;</span>)</span><br><span class=\"line\">        t.Execute(w, token)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        r.ParseMultipartForm(<span class=\"number\">32</span> &lt;&lt; <span class=\"number\">20</span>)</span><br><span class=\"line\">        file, handler, err := r.FormFile(<span class=\"string\">&quot;uploadfile&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            fmt.Println(err)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\">        fmt.Fprintf(w, <span class=\"string\">&quot;%v&quot;</span>, handler.Header)</span><br><span class=\"line\">        f, err := os.OpenFile(<span class=\"string\">&quot;./test/&quot;</span>+handler.Filename, os.O_WRONLY|os.O_CREATE, <span class=\"number\">0666</span>)  <span class=\"comment\">// 此处假设当前目录下已存在test目录</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            fmt.Println(err)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">defer</span> f.Close()</span><br><span class=\"line\">        io.Copy(f, file)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上面的代码可以看到，处理文件上传我们需要调用 r.ParseMultipartForm，里面的参数表示 maxMemory，调用 ParseMultipartForm 之后，上传的文件存储在 maxMemory 大小的内存里面，如果文件大小超过了 maxMemory，那么剩下的部分将存储在系统的临时文件中。我们可以通过 r.FormFile 获取上面的文件句柄，然后实例中使用了 io.Copy 来存储文件。</p>\n<p>通过上面的实例我们可以发现文件处理的主要三步：</p>\n<ul>\n<li>表单中增加 enctype=“multipart/form-data”</li>\n<li>服务端调用 r.ParseMultipartForm, 把上传的文件存储在内存和临时文件中</li>\n<li>使用 r.FormFile 获取文件句柄，然后对文件进行存储等处理。</li>\n</ul>\n<p>文件 handler 是 multipart.FileHeader, 里面存储了如下结构信息</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> FileHeader <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Filename <span class=\"keyword\">string</span></span><br><span class=\"line\">    Header   textproto.MIMEHeader</span><br><span class=\"line\">    <span class=\"comment\">// contains filtered or unexported fields</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"客户端上传文件\">客户端上传文件</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;bytes&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;io/ioutil&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;mime/multipart&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">postFile</span><span class=\"params\">(filename <span class=\"keyword\">string</span>, targetUrl <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    bodyBuf := &amp;bytes.Buffer&#123;&#125;</span><br><span class=\"line\">    bodyWriter := multipart.NewWriter(bodyBuf)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 关键的一步操作</span></span><br><span class=\"line\">    fileWriter, err := bodyWriter.CreateFormFile(<span class=\"string\">&quot;uploadfile&quot;</span>, filename)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;error writing to buffer&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 打开文件句柄操作</span></span><br><span class=\"line\">    fh, err := os.Open(filename)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;error opening file&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> fh.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// iocopy</span></span><br><span class=\"line\">    _, err = io.Copy(fileWriter, fh)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    contentType := bodyWriter.FormDataContentType()</span><br><span class=\"line\">    bodyWriter.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">    resp, err := http.Post(targetUrl, contentType, bodyBuf)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> resp.Body.Close()</span><br><span class=\"line\">    resp_body, err := ioutil.ReadAll(resp.Body)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(resp.Status)</span><br><span class=\"line\">    fmt.Println(<span class=\"keyword\">string</span>(resp_body))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sample usage</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    target_url := <span class=\"string\">&quot;http://localhost:9090/upload&quot;</span></span><br><span class=\"line\">    filename := <span class=\"string\">&quot;./astaxie.pdf&quot;</span></span><br><span class=\"line\">    postFile(filename, target_url)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"session和数据存储\">session和数据存储</h2>\n<p>cookie是客户端机制，将用户数据保存在客户端；session是服务器端的机制，用类似散列表的结构来保存信息，每个网站访客都会分配一个唯一标识符，sessionID。他的存放形式有两种：经过url传递或者保存在客户端的cookie中，当然也可以保存到数据库中，但是这样效率低。</p>\n<h3 id=\"session和cookie\">session和cookie</h3>\n<p>cookie简而言之就是在本地保存用户操作的历史信息（包括登录信息），并在用户再次访问该站点的时候将本地cookie发送给服务器完成验证</p>\n<p><img src=\"https://i.imgur.com/H39aGop.png\" alt=\"picture 1\"></p>\n<p>session简而言之就是在服务器上保留用户操作的历史信息。使用session id来标识session，由服务器产生，保证随机性和唯一性。但是在这种情况下，仍然需要将发送请求的客户端与session进行对应，所以可以借助cookie机制来获取session id也可以通过get方式将id提交给服务器。</p>\n<p><img src=\"https://i.imgur.com/96ZoX9F.png\" alt=\"picture 2\"></p>\n<h3 id=\"go设置cookie\">go设置cookie</h3>\n<p>go中通过net/http包中的SetCookie来设置</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">http.SetCookie(w ResponseWriter, cookie *Cookie)</span><br></pre></td></tr></table></figure>\n<p>cookie是一个结构体，我们看一下其中的内容</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Cookie <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name       <span class=\"keyword\">string</span></span><br><span class=\"line\">    Value      <span class=\"keyword\">string</span></span><br><span class=\"line\">    Path       <span class=\"keyword\">string</span></span><br><span class=\"line\">    Domain     <span class=\"keyword\">string</span></span><br><span class=\"line\">    Expires    time.Time</span><br><span class=\"line\">    RawExpires <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MaxAge=0 means no &#x27;Max-Age&#x27; attribute specified.</span></span><br><span class=\"line\"><span class=\"comment\">// MaxAge&lt;0 means delete cookie now, equivalently &#x27;Max-Age: 0&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// MaxAge&gt;0 means Max-Age attribute present and given in seconds</span></span><br><span class=\"line\">    MaxAge   <span class=\"keyword\">int</span></span><br><span class=\"line\">    Secure   <span class=\"keyword\">bool</span></span><br><span class=\"line\">    HttpOnly <span class=\"keyword\">bool</span></span><br><span class=\"line\">    Raw      <span class=\"keyword\">string</span></span><br><span class=\"line\">    Unparsed []<span class=\"keyword\">string</span> <span class=\"comment\">// Raw text of unparsed attribute-value pairs</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个简单的设置cookie的例子</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">expiration := time.Now()</span><br><span class=\"line\">expiration = expiration.AddDate(<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">cookie := http.Cookie&#123;Name: <span class=\"string\">&quot;username&quot;</span>, Value: <span class=\"string\">&quot;astaxie&quot;</span>, Expires: expiration&#125;</span><br><span class=\"line\">http.SetCookie(w, &amp;cookie)</span><br></pre></td></tr></table></figure>\n<h3 id=\"go读取cookie\">go读取cookie</h3>\n<p>有两种方式</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单独读一个指定的cookie</span></span><br><span class=\"line\">cookie, _ := r.Cookie(<span class=\"string\">&quot;username&quot;</span>)</span><br><span class=\"line\">fmt.Fprint(w, cookie)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将cookie中的记录全部读出</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _, cookie := <span class=\"keyword\">range</span> r.Cookies() &#123;</span><br><span class=\"line\">    fmt.Fprint(w, cookie.Name)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"session\">session</h3>\n<p>session 机制是一种服务器端的机制，服务器使用一种类似于散列表的结构 (也可能就是使用散列表) 来保存信息。</p>\n<p>但程序需要为某个客户端的请求创建一个 session 的时候，服务器首先检查这个客户端的请求里是否包含了一个 session 标识－称为 session id，如果已经包含一个 session id 则说明以前已经为此客户创建过 session，服务器就按照 session id 把这个 session 检索出来使用 (如果检索不到，可能会新建一个，这种情况可能出现在服务端已经删除了该用户对应的 session 对象，但用户人为地在请求的 URL 后面附加上一个 JSESSION 的参数)。如果客户请求不包含 session id，则为此客户创建一个 session 并且同时生成一个与此 session 相关联的 session id，这个 session id 将在本次响应中返回给客户端保存。</p>\n<h2 id=\"go如何使用session\">go如何使用session</h2>\n<p>生成session的三个步骤：</p>\n<ul>\n<li>生成sessionID</li>\n<li>开辟数据存储空间，一般是在内存中创建相应数据结构，但是这样断电的话所有数据会丢失。为此，可以将会话数据写到文件中或者存储到数据库中，虽然会增加IO开销，但是可以实现session的持久化</li>\n<li>将sessionID发送给客户端</li>\n</ul>\n<p>上面步骤中，最重要的是如何发送sessionID。根据HTTP协议，数据可以放到请求行、头域或者body中，因此一般用两种方式：</p>\n<ul>\n<li>cookie：服务端通过设置cookie头就可以将session标识符传送到客户端，客户端之后每次请求都会带上这个标识符。一般包含session信息的cookie会将失效时间设置为0，即浏览器进程关闭时。</li>\n<li>URL重写：在返回给用户的页面里所有的URL后面追加session标识符，这样用户无论点击相应页面的哪个链接或者表单都会带上sessionID。虽然比较麻烦，但是在用户禁用cookie的情况下是首选方案</li>\n</ul>\n<h3 id=\"go实现session管理\">go实现session管理</h3>\n<h4 id=\"session管理设计\">session管理设计</h4>\n<p>session管理涉及以下几个因素：</p>\n<ul>\n<li>全局session管理器</li>\n<li>保证sessionid的全局唯一性</li>\n<li>为每个客户关联一个session</li>\n<li>session的存储（内存、文件、数据库）</li>\n<li>session过期处理</li>\n</ul>\n<h4 id=\"session管理器\">session管理器</h4>\n<p>定义一个全局的session管理器</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Manager <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    cookieName  <span class=\"keyword\">string</span>     <span class=\"comment\">// private cookiename</span></span><br><span class=\"line\">    lock        sync.Mutex <span class=\"comment\">// protects session</span></span><br><span class=\"line\">    provider    Provider</span><br><span class=\"line\">    maxLifeTime <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewManager</span><span class=\"params\">(provideName, cookieName <span class=\"keyword\">string</span>, maxLifeTime <span class=\"keyword\">int64</span>)</span> <span class=\"params\">(*Manager, error)</span></span> &#123;</span><br><span class=\"line\">    provider, ok := provides[provideName]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;session: unknown provide %q (forgotten import?)&quot;</span>, provideName)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Manager&#123;provider: provider, cookieName: cookieName, maxLifeTime: maxLifeTime&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>go实现整个流程应该也是这样的，在main包中创建一个全局的session管理器</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> globalSessions *session.Manager</span><br><span class=\"line\"><span class=\"comment\">// 然后在 init 函数中初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    globalSessions, _ = NewManager(<span class=\"string\">&quot;memory&quot;</span>, <span class=\"string\">&quot;gosessionid&quot;</span>, <span class=\"number\">3600</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>session保存在服务器端，它可以以任何方式存储，因此我们抽象出一个Provider接口，用以表征session管理器底层的存储结构</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Provider <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//新建一个session并且返回</span></span><br><span class=\"line\">    SessionInit(sid <span class=\"keyword\">string</span>) (Session, error)</span><br><span class=\"line\">    <span class=\"comment\">//返回sid代表的session变量，不存在就新建并且返回</span></span><br><span class=\"line\">    SessionRead(sid <span class=\"keyword\">string</span>) (Session, error)</span><br><span class=\"line\">    <span class=\"comment\">//销毁sid表示的session变量</span></span><br><span class=\"line\">    SessionDestroy(sid <span class=\"keyword\">string</span>) error</span><br><span class=\"line\">    <span class=\"comment\">//根据生命周期来删除过期数据</span></span><br><span class=\"line\">    SessionGC(maxLifeTime <span class=\"keyword\">int64</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>session接口需要实现的功能就是增删改查</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Session <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Set(key, value <span class=\"keyword\">interface</span>&#123;&#125;) error <span class=\"comment\">// set session value</span></span><br><span class=\"line\">    Get(key <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"keyword\">interface</span>&#123;&#125;  <span class=\"comment\">// get session value</span></span><br><span class=\"line\">    Delete(key <span class=\"keyword\">interface</span>&#123;&#125;) error     <span class=\"comment\">// delete session value</span></span><br><span class=\"line\">    SessionID() <span class=\"keyword\">string</span>                <span class=\"comment\">// back current sessionID</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面根据需要注册存储session的结构的register函数的实现</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> provides = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Provider)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过名称激活一个provider，如果已经调用过一次的话就panic</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Register</span><span class=\"params\">(name <span class=\"keyword\">string</span>, provider Provider)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> provider == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;session: Register provider is nil&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> _, dup := provides[name]; dup &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;session: Register called twice for provider &quot;</span> + name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    provides[name] = provider</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"全局唯一的sessionID\">全局唯一的sessionID</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(manager *Manager)</span> <span class=\"title\">sessionId</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    b := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"number\">32</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> _, err := rand.Read(b); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> base64.URLEncoding.EncodeToString(b)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"session创建\">session创建</h3>\n<p>我们需要将用户和session相关联，下面这个函数就是检测是否已经由session与当前用户关联，如果没有就创建</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(manager *Manager)</span> <span class=\"title\">SessionStart</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span> <span class=\"params\">(session Session)</span></span> &#123;</span><br><span class=\"line\">    manager.lock.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> manager.lock.Unlock()</span><br><span class=\"line\">    cookie, err := r.Cookie(manager.cookieName)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> || cookie.Value == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">        sid := manager.sessionId()</span><br><span class=\"line\">        session, _ = manager.provider.SessionInit(sid)</span><br><span class=\"line\">        cookie := http.Cookie&#123;Name: manager.cookieName, Value: url.QueryEscape(sid), Path: <span class=\"string\">&quot;/&quot;</span>, HttpOnly: <span class=\"literal\">true</span>, MaxAge: <span class=\"keyword\">int</span>(manager.maxLifeTime)&#125;</span><br><span class=\"line\">        http.SetCookie(w, &amp;cookie)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        sid, _ := url.QueryUnescape(cookie.Value)</span><br><span class=\"line\">        session, _ = manager.provider.SessionRead(sid)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用前面的login操作来演示session的作用</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">login</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    sess := globalSessions.SessionStart(w, r)</span><br><span class=\"line\">    r.ParseForm()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.Method == <span class=\"string\">&quot;GET&quot;</span> &#123;</span><br><span class=\"line\">        t, _ := template.ParseFiles(<span class=\"string\">&quot;login.gtpl&quot;</span>)</span><br><span class=\"line\">        w.Header().Set(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;text/html&quot;</span>)</span><br><span class=\"line\">        t.Execute(w, sess.Get(<span class=\"string\">&quot;username&quot;</span>))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        sess.Set(<span class=\"string\">&quot;username&quot;</span>, r.Form[<span class=\"string\">&quot;username&quot;</span>])</span><br><span class=\"line\">        http.Redirect(w, r, <span class=\"string\">&quot;/&quot;</span>, <span class=\"number\">302</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"session存储\">session存储</h3>\n<p>基于内存的session存储接口的实现</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> memory</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;container/list&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/astaxie/session&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> pder = &amp;Provider&#123;list: list.New()&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> SessionStore <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    sid          <span class=\"keyword\">string</span>                      <span class=\"comment\">// session id唯一标示</span></span><br><span class=\"line\">    timeAccessed time.Time                   <span class=\"comment\">// 最后访问时间</span></span><br><span class=\"line\">    value        <span class=\"keyword\">map</span>[<span class=\"keyword\">interface</span>&#123;&#125;]<span class=\"keyword\">interface</span>&#123;&#125; <span class=\"comment\">// session里面存储的值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置session中的key value并且更新最后访问时间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(st *SessionStore)</span> <span class=\"title\">Set</span><span class=\"params\">(key, value <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    st.value[key] = value</span><br><span class=\"line\">    pder.SessionUpdate(st.sid)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//根据给定键获取session中的值，并且更新最终访问时间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(st *SessionStore)</span> <span class=\"title\">Get</span><span class=\"params\">(key <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">interface</span></span>&#123;&#125; &#123;</span><br><span class=\"line\">    pder.SessionUpdate(st.sid)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> v, ok := st.value[key]; ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//删除给定键的键值对，更新最终访问时间</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(st *SessionStore)</span> <span class=\"title\">Delete</span><span class=\"params\">(key <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">delete</span>(st.value, key)</span><br><span class=\"line\">    pder.SessionUpdate(st.sid)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//获取sessionID</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(st *SessionStore)</span> <span class=\"title\">SessionID</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> st.sid</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Provider <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    lock     sync.Mutex               <span class=\"comment\">// 用来锁</span></span><br><span class=\"line\">    sessions <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*list.Element <span class=\"comment\">// 用来存储在内存</span></span><br><span class=\"line\">    list     *list.List               <span class=\"comment\">// 用来做 gc</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pder *Provider)</span> <span class=\"title\">SessionInit</span><span class=\"params\">(sid <span class=\"keyword\">string</span>)</span> <span class=\"params\">(session.Session, error)</span></span> &#123;</span><br><span class=\"line\">    pder.lock.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> pder.lock.Unlock()</span><br><span class=\"line\">    v := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">interface</span>&#123;&#125;]<span class=\"keyword\">interface</span>&#123;&#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">    newsess := &amp;SessionStore&#123;sid: sid, timeAccessed: time.Now(), value: v&#125;</span><br><span class=\"line\">    element := pder.list.PushFront(newsess)</span><br><span class=\"line\">    pder.sessions[sid] = element</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newsess, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pder *Provider)</span> <span class=\"title\">SessionRead</span><span class=\"params\">(sid <span class=\"keyword\">string</span>)</span> <span class=\"params\">(session.Session, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> element, ok := pder.sessions[sid]; ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> element.Value.(*SessionStore), <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        sess, err := pder.SessionInit(sid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sess, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pder *Provider)</span> <span class=\"title\">SessionDestroy</span><span class=\"params\">(sid <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> element, ok := pder.sessions[sid]; ok &#123;</span><br><span class=\"line\">        <span class=\"built_in\">delete</span>(pder.sessions, sid)</span><br><span class=\"line\">        pder.list.Remove(element)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pder *Provider)</span> <span class=\"title\">SessionGC</span><span class=\"params\">(maxlifetime <span class=\"keyword\">int64</span>)</span></span> &#123;</span><br><span class=\"line\">    pder.lock.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> pder.lock.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        element := pder.list.Back()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> element == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (element.Value.(*SessionStore).timeAccessed.Unix() + maxlifetime) &lt; time.Now().Unix() &#123;</span><br><span class=\"line\">            pder.list.Remove(element)</span><br><span class=\"line\">            <span class=\"built_in\">delete</span>(pder.sessions, element.Value.(*SessionStore).sid)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(pder *Provider)</span> <span class=\"title\">SessionUpdate</span><span class=\"params\">(sid <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    pder.lock.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> pder.lock.Unlock()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> element, ok := pder.sessions[sid]; ok &#123;</span><br><span class=\"line\">        element.Value.(*SessionStore).timeAccessed = time.Now()</span><br><span class=\"line\">        pder.list.MoveToFront(element)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    pder.sessions = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*list.Element, <span class=\"number\">0</span>)</span><br><span class=\"line\">    session.Register(<span class=\"string\">&quot;memory&quot;</span>, pder)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"文本处理\">文本处理</h2>\n<h3 id=\"XML处理\">XML处理</h3>\n<p>假设服务器上生成了如下的xml的配置文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servers</span> <span class=\"attr\">version</span>=<span class=\"string\">&quot;1&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">serverName</span>&gt;</span>Shanghai_VPN<span class=\"tag\">&lt;/<span class=\"name\">serverName</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">serverIP</span>&gt;</span>127.0.0.1<span class=\"tag\">&lt;/<span class=\"name\">serverIP</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">serverName</span>&gt;</span>Beijing_VPN<span class=\"tag\">&lt;/<span class=\"name\">serverName</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">serverIP</span>&gt;</span>127.0.0.2<span class=\"tag\">&lt;/<span class=\"name\">serverIP</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servers</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"解析XML\">解析XML</h4>\n<p>我们可以通过xml包的<code>Unmarshal</code>来达到我们的目的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Unmarshal</span><span class=\"params\">(data []<span class=\"keyword\">byte</span>, v <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<p>data接收的是XML数据流，v是需要输出的结构，可以把XML转换为任意格式。这里我们主要看转换成struct，因为他们都有类似树结构的特征。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/xml&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;io/ioutil&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Recurlyservers <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    XMLName     xml.Name <span class=\"string\">`xml:&quot;servers&quot;`</span></span><br><span class=\"line\">    Version     <span class=\"keyword\">string</span>   <span class=\"string\">`xml:&quot;version,attr&quot;`</span></span><br><span class=\"line\">    Svs         []server <span class=\"string\">`xml:&quot;server&quot;`</span></span><br><span class=\"line\">    Description <span class=\"keyword\">string</span>   <span class=\"string\">`xml:&quot;,innerxml&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    XMLName    xml.Name <span class=\"string\">`xml:&quot;server&quot;`</span></span><br><span class=\"line\">    ServerName <span class=\"keyword\">string</span>   <span class=\"string\">`xml:&quot;serverName&quot;`</span></span><br><span class=\"line\">    ServerIP   <span class=\"keyword\">string</span>   <span class=\"string\">`xml:&quot;serverIP&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    file, err := os.Open(<span class=\"string\">&quot;servers.xml&quot;</span>) <span class=\"comment\">// For read access.     </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;error: %v&quot;</span>, err)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\">    data, err := ioutil.ReadAll(file)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;error: %v&quot;</span>, err)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    v := Recurlyservers&#123;&#125;</span><br><span class=\"line\">    err = xml.Unmarshal(data, &amp;v)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;error: %v&quot;</span>, err)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    fmt.Println(v)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子会输出如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&#123; servers&#125; 1 [&#123;&#123; server&#125; Shanghai_VPN 127.0.0.1&#125; &#123;&#123; server&#125; Beijing_VPN 127.0.0.2&#125;]</span><br><span class=\"line\">&lt;server&gt;</span><br><span class=\"line\">    &lt;serverName&gt;Shanghai_VPN&lt;/serverName&gt;</span><br><span class=\"line\">    &lt;serverIP&gt;127.0.0.1&lt;/serverIP&gt;</span><br><span class=\"line\">&lt;/server&gt;</span><br><span class=\"line\">&lt;server&gt;</span><br><span class=\"line\">    &lt;serverName&gt;Beijing_VPN&lt;/serverName&gt;</span><br><span class=\"line\">    &lt;serverIP&gt;127.0.0.2&lt;/serverIP&gt;</span><br><span class=\"line\">&lt;/server&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到struct的字段后面多了一些<code>xml:&quot;serverName&quot;</code>的内容，这是struct的特性，在后面加上tag用来辅助反射，我们看一下Unmarshal的定义</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Unmarshal</span><span class=\"params\">(data []<span class=\"keyword\">byte</span>, v <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<p>两个参数，一个是XML数据流，另一个是存储的对应类型，目前来说支持struct、slice和string，XML包内部通过反射进行数据映射，因此v里面的字段必须导出。</p>\n<p>那XML元素和字段怎么对应呢？这是有优先级顺序的，首先读取struct tag，如果没有就读取字段名。<strong>需要注意的是，解析时tag、字段名和XML元素都是对大小写敏感的</strong>。</p>\n<ul>\n<li>如果struct的一个字段是string或者[]byte类型且它的tag含有<code>&quot;,innerxml&quot;</code>，Unmarshal会将此字段所对应的元素内的所有内嵌的原始XML累加到此字段上，如上面例子中的Description。</li>\n<li>如果 struct 中有一个叫做 XMLName，且类型为 <a href=\"http://xml.Name\">xml.Name</a> 字段，那么在解析的时候就会保存这个 element 的名字到该字段，如上面例子中的 servers。</li>\n<li>如果某个 struct 字段的 tag 定义中含有 XML 结构中 element 的名称，那么解析的时候就会把相应的 element 值赋值给该字段，如上 servername 和 serverip 定义。</li>\n<li>如果某个 struct 字段的 tag 定义了中含有 <code>&quot;,attr&quot;</code>，那么解析的时候就会将该结构所对应的 element 的与字段同名的属性的值赋值给该字段，如上 version 定义。</li>\n<li>如果某个 struct 字段的 tag 定义 型如 “a&gt;b&gt;c”, 则解析的时候，会将 xml 结构 a 下面的 b 下面的 c 元素的值赋值给该字段。</li>\n<li>如果某个 struct 字段的 tag 定义了 “-”, 那么不会为该字段解析匹配任何 xml 数据。</li>\n<li>如果 struct 字段后面的 tag 定义了 “,any”，如果他的子元素在不满足其他的规则的时候就会匹配到这个字段。</li>\n<li>如果某个 XML 元素包含一条或者多条注释，那么这些注释将被累加到第一个 tag 含有 “,comments” 的字段上，这个字段的类型可能是 [] byte 或 string, 如果没有这样的字段存在，那么注释将会被抛弃。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">注意： 为了正确解析，go 语言的 xml 包要求 struct 定义中的所有字段必须是可导出的（即首字母大写）</span><br></pre></td></tr></table></figure>\n<h4 id=\"输出XML\">输出XML</h4>\n<p>如果我们不是要解析而是要生成，该如何实现呢？</p>\n<p>xml包中提供了<code>Marshal</code>和<code>MarshalIndent</code>，他们的区别是后者会增加前缀和缩进</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Marshal</span><span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MarshalIndent</span><span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;, prefix, indent <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure>\n<p>两个函数都是用来生成xml的结构定义类型数据，返回XML的数据流。我们来看一下如何输出如上的XML</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/xml&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Servers <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    XMLName xml.Name <span class=\"string\">`xml:&quot;servers&quot;`</span></span><br><span class=\"line\">    Version <span class=\"keyword\">string</span>   <span class=\"string\">`xml:&quot;version,attr&quot;`</span></span><br><span class=\"line\">    Svs     []server <span class=\"string\">`xml:&quot;server&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ServerName <span class=\"keyword\">string</span> <span class=\"string\">`xml:&quot;serverName&quot;`</span></span><br><span class=\"line\">    ServerIP   <span class=\"keyword\">string</span> <span class=\"string\">`xml:&quot;serverIP&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    v := &amp;Servers&#123;Version: <span class=\"string\">&quot;1&quot;</span>&#125;</span><br><span class=\"line\">    v.Svs = <span class=\"built_in\">append</span>(v.Svs, server&#123;<span class=\"string\">&quot;Shanghai_VPN&quot;</span>, <span class=\"string\">&quot;127.0.0.1&quot;</span>&#125;)</span><br><span class=\"line\">    v.Svs = <span class=\"built_in\">append</span>(v.Svs, server&#123;<span class=\"string\">&quot;Beijing_VPN&quot;</span>, <span class=\"string\">&quot;127.0.0.2&quot;</span>&#125;)</span><br><span class=\"line\">    output, err := xml.MarshalIndent(v, <span class=\"string\">&quot;  &quot;</span>, <span class=\"string\">&quot;    &quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;error: %v\\n&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    os.Stdout.Write([]<span class=\"keyword\">byte</span>(xml.Header))</span><br><span class=\"line\"></span><br><span class=\"line\">    os.Stdout.Write(output)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出信息如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span><br><span class=\"line\">&lt;servers version=<span class=\"string\">&quot;1&quot;</span>&gt;</span><br><span class=\"line\">&lt;server&gt;</span><br><span class=\"line\">    &lt;serverName&gt;Shanghai_VPN&lt;/serverName&gt;</span><br><span class=\"line\">    &lt;serverIP&gt;<span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>&lt;/serverIP&gt;</span><br><span class=\"line\">&lt;/server&gt;</span><br><span class=\"line\">&lt;server&gt;</span><br><span class=\"line\">    &lt;serverName&gt;Beijing_VPN&lt;/serverName&gt;</span><br><span class=\"line\">    &lt;serverIP&gt;<span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.2</span>&lt;/serverIP&gt;</span><br><span class=\"line\">&lt;/server&gt;</span><br><span class=\"line\">&lt;/servers&gt;</span><br></pre></td></tr></table></figure>\n<p>之所以其中会有<code>os.Stdout.Write([]byte(xml.Header))</code>,是因为这两个函数都是不带xml信息头的，为了生成正确的xml文件，我们需要使用xml包预定义的header。</p>\n<p>可以看到<code>Marshal</code>函数接收的参数v是interface{}，那么它根据什么规则来生成相应的文件呢？</p>\n<ul>\n<li>v是array或者slice，则输出每一个元素，类似于value</li>\n<li>v是指针，会Marshal指针指向的内容，如果为空什么都不输出</li>\n<li>v是interface，处理interface包含的数据</li>\n<li>v是其他，输出这个数据类型所拥有的字段信息</li>\n</ul>\n<p>那生成的XML文件中的element的名字由什么决定呢？按照以下优先级</p>\n<ul>\n<li>v是struct，XMLName的tag中定义的名称</li>\n<li>类型为xml.Name的名叫XMLName的字段的值</li>\n<li>通过struct中字段的tag获取</li>\n<li>通过struct的字段名用来获取</li>\n<li>marshal的类型名称</li>\n</ul>\n<p>那么应该如何设置struct中字段的tag信息来控制最终生成的xml文件呢？</p>\n<ul>\n<li>XMLName 不会被输出</li>\n<li>tag 中含有 “-” 的字段不会输出</li>\n<li>tag 中含有 “name,attr”，会以 name 作为属性名，字段值作为值输出为这个  XML 元素的属性，如上 version 字段所描述</li>\n<li>tag 中含有 “,attr”，会以这个 struct 的字段名作为属性名输出为 XML 元 素的属性，类似上一条，只是这个 name 默认是字段名了。</li>\n<li>tag 中含有 “,chardata”，输出为 xml 的 character data 而非 element。</li>\n<li>tag 中含有 “,innerxml”，将会被原样输出，而不会进行常规的编码过程<br>\ntag 中含有 “,comment”，将被当作 xml 注释来输出，而不会进行常规的编码过程，字段值中不能含有 “–” 字符串</li>\n<li>tag 中含有 “omitempty”, 如果该字段的值为空值那么该字段就不会被输出到 XML，空值包括：false、0、nil 指针或 nil 接口，任何长度为 0 的 array, slice, map 或者 string</li>\n<li>tag 中含有 “a&gt;b&gt;c”，那么就会循环输出三个元素 a 包含 b，b 包含 c，例如如下代码就会输出</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">FirstName string   `xml:&quot;name&gt;first&quot;`</span><br><span class=\"line\">LastName  string   `xml:&quot;name&gt;last&quot;`</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;name&gt;</span><br><span class=\"line\">&lt;first&gt;Asta&lt;/first&gt;</span><br><span class=\"line\">&lt;last&gt;Xie&lt;/last&gt;</span><br><span class=\"line\">&lt;/name&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"JSON处理\">JSON处理</h3>\n<p>上一小节的例子的JSON表示如下</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;servers&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;serverName&quot;</span>: <span class=\"string\">&quot;Shanghai_VPN&quot;</span>, </span><br><span class=\"line\">            <span class=\"attr\">&quot;serverIP&quot;</span>: <span class=\"string\">&quot;127.0.0.1&quot;</span></span><br><span class=\"line\">        &#125;, </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"attr\">&quot;serverName&quot;</span>: <span class=\"string\">&quot;Beijing_VPN&quot;</span>, </span><br><span class=\"line\">            <span class=\"attr\">&quot;serverIP&quot;</span>: <span class=\"string\">&quot;127.0.0.2&quot;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"解析JSON到结构体\">解析JSON到结构体</h4>\n<p>假如有了上述JSON串，如何对他进行解析呢？</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Unmarshal</span><span class=\"params\">(data []<span class=\"keyword\">byte</span>, v <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<p>通过这个函数我们可以解析JSON，代码如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ServerName <span class=\"keyword\">string</span></span><br><span class=\"line\">    ServerIP   <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Serverslice <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Servers []Server</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s Serverslice</span><br><span class=\"line\">    str := <span class=\"string\">`&#123;&quot;servers&quot;:[&#123;&quot;serverName&quot;:&quot;Shanghai_VPN&quot;,&quot;serverIP&quot;:&quot;127.0.0.1&quot;&#125;,&#123;&quot;serverName&quot;:&quot;Beijing_VPN&quot;,&quot;serverIP&quot;:&quot;127.0.0.2&quot;&#125;]&#125;`</span></span><br><span class=\"line\">    json.Unmarshal([]<span class=\"keyword\">byte</span>(str), &amp;s)</span><br><span class=\"line\">    fmt.Println(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码中我们首先定义了json数据对应的结构体，数组对应slice，字段名对应json里面的key，那么解析的时候怎么将json数据和struct字段相匹配呢？比如json中的key是<code>Foo</code>，怎么找对应的字段呢？</p>\n<ul>\n<li>首先查找tag中含有<code>Foo</code>的可以导出的struct字段（首字母大写）</li>\n<li>其次查找字段名是<code>Foo</code>的导出字段</li>\n<li>最后查找类似<code>FOO</code>或者<code>FoO</code>这样的除了首字母之外其他大小写不敏感的导出字段</li>\n</ul>\n<h4 id=\"解析到interface\">解析到interface</h4>\n<p>上面的解析建立在我们知道被解析的json数据的结构下采取的方案，如果我们不知道被解析的数据的格式呢？</p>\n<p>interface{}可以处理任意数据类型，其正好可以用于存储解析的未知结构的json数据的结果。json包中采取<code>map[string]interface&#123;&#125;</code>和<code>[]interface&#123;&#125;</code>结构来存储任意JSON对象和数组。</p>\n<p>go类型和json类型对应关系如下</p>\n<ul>\n<li>bool :JSON booleans</li>\n<li>float64 :JSON numbers</li>\n<li>string :JSON strings</li>\n<li>nil :JSON null</li>\n</ul>\n<p>现在假设有以下JSON数据</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">b := []<span class=\"keyword\">byte</span>(<span class=\"string\">`&#123;&quot;Name&quot;:&quot;Wednesday&quot;,&quot;Age&quot;:6,&quot;Parents&quot;:[&quot;Gomez&quot;,&quot;Morticia&quot;]&#125;`</span>)</span><br></pre></td></tr></table></figure>\n<p>如果我们在不知道内部结构的情况下将他解析到interface{}中</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">err := json.Unmarshal(b, &amp;f)</span><br></pre></td></tr></table></figure>\n<p>这个时候f里面存储了一个map类型，他们的key是string，值存储在空的interface{}里面</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">f = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;Name&quot;</span>: <span class=\"string\">&quot;Wednesday&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Age&quot;</span>:  <span class=\"number\">6</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Parents&quot;</span>: []<span class=\"keyword\">interface</span>&#123;&#125;&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;Gomez&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Morticia&quot;</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要通过断言的方式来访问这些数据</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">m := f.(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> m &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> vv := v.(<span class=\"keyword\">type</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">string</span>:</span><br><span class=\"line\">        fmt.Println(k, <span class=\"string\">&quot;is string&quot;</span>, vv)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">int</span>:</span><br><span class=\"line\">        fmt.Println(k, <span class=\"string\">&quot;is int&quot;</span>, vv)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"keyword\">float64</span>:</span><br><span class=\"line\">        fmt.Println(k,<span class=\"string\">&quot;is float64&quot;</span>,vv)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> []<span class=\"keyword\">interface</span>&#123;&#125;:</span><br><span class=\"line\">        fmt.Println(k, <span class=\"string\">&quot;is an array:&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i, u := <span class=\"keyword\">range</span> vv &#123;</span><br><span class=\"line\">            fmt.Println(i, u)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        fmt.Println(k, <span class=\"string\">&quot;is of a type I don&#x27;t know how to handle&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以发现，通过interface{}和类型断言的结合，就可以解析未知结构的json数据了</p>\n<p>上述是官方提供的解决方案，但用起来不是很方便，<code>simplejson</code>包在处理未知结构的json时相当方便，例子如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">js, err := simplejson.NewJson([]<span class=\"keyword\">byte</span>(<span class=\"string\">`&#123;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;test&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;array&quot;: [1, &quot;2&quot;, 3],</span></span><br><span class=\"line\"><span class=\"string\">        &quot;int&quot;: 10,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;float&quot;: 5.150,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;bignum&quot;: 9223372036854775807,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;string&quot;: &quot;simplejson&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;bool&quot;: true</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;`</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">arr, _ := js.Get(<span class=\"string\">&quot;test&quot;</span>).Get(<span class=\"string\">&quot;array&quot;</span>).Array()</span><br><span class=\"line\">i, _ := js.Get(<span class=\"string\">&quot;test&quot;</span>).Get(<span class=\"string\">&quot;int&quot;</span>).Int()</span><br><span class=\"line\">ms := js.Get(<span class=\"string\">&quot;test&quot;</span>).Get(<span class=\"string\">&quot;string&quot;</span>).MustString()</span><br></pre></td></tr></table></figure>\n<h4 id=\"生成json\">生成json</h4>\n<p>通过JSON包里的<code>Marshal</code>来处理</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Marshal</span><span class=\"params\">(v <span class=\"keyword\">interface</span>&#123;&#125;)</span><span class=\"params\">([]<span class=\"keyword\">byte</span>,error)</span></span></span><br></pre></td></tr></table></figure>\n<p>假设我们还是需要生成上面的服务器列表信息，看下面的例子</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ServerName <span class=\"keyword\">string</span></span><br><span class=\"line\">    ServerIP   <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Serverslice <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Servers []Server</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s Serverslice</span><br><span class=\"line\">    s.Servers = <span class=\"built_in\">append</span>(s.Servers, Server&#123;ServerName: <span class=\"string\">&quot;Shanghai_VPN&quot;</span>, ServerIP: <span class=\"string\">&quot;127.0.0.1&quot;</span>&#125;)</span><br><span class=\"line\">    s.Servers = <span class=\"built_in\">append</span>(s.Servers, Server&#123;ServerName: <span class=\"string\">&quot;Beijing_VPN&quot;</span>, ServerIP: <span class=\"string\">&quot;127.0.0.2&quot;</span>&#125;)</span><br><span class=\"line\">    b, err := json.Marshal(s)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        fmt.Println(<span class=\"string\">&quot;json err:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(<span class=\"keyword\">string</span>(b))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&quot;Servers&quot;:[&#123;&quot;ServerName&quot;:&quot;Shanghai_VPN&quot;,&quot;ServerIP&quot;:&quot;127.0.0.1&quot;&#125;,&#123;&quot;ServerName&quot;:&quot;Beijing_VPN&quot;,&quot;ServerIP&quot;:&quot;127.0.0.2&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到上面的都是首字母大写，如果想用小写首字母怎么办呢，用结构体的tag来实现</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ServerName <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;serverName&quot;`</span></span><br><span class=\"line\">    ServerIP   <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;serverIP&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Serverslice <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Servers []Server <span class=\"string\">`json:&quot;servers&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>针对json的输出，定义tag的时候需要注意：</p>\n<ul>\n<li>字段的 tag 是 “-”，那么这个字段不会输出到 JSON</li>\n<li>tag 中带有自定义名称，那么这个自定义名称会出现在 JSON 的字段名中，例如上面例子中 serverName</li>\n<li>tag 中如果带有 “omitempty” 选项，那么如果该字段值为空，就不会输出到 JSON 串中</li>\n<li>如果字段类型是 bool, string, int, int64 等，而 tag 中带有 “,string” 选项，那么这个字段在输出到 JSON 的时候会把该字段对应的值转换成 JSON 字符串</li>\n</ul>\n","categories":["go"],"tags":["web"]},{"title":"Semi-Supervised Classification With Graph Convolutional Networks","url":"/2022/03/20/Semi-Supervised-Classification-With-Graph-Convolutional-Networks/","content":"<h2 id=\"引言-8\">引言</h2>\n<p>文章主要围绕对仅有少部分节点存在标签的图节点进行分类任务。这个问题可以被认为是基于图的半监督学习，通过某种基于图的正则化来平滑图上的标签信息，比如在损失函数中增加一个图拉普拉斯正则化。</p>\n<p><img src=\"https://i.imgur.com/q31vbLg.png\" alt=\"picture 44\"></p>\n<p>其中$L_0$是有标签部分的损失项，函数f是一个可微函数，$\\lambda$是一个权重参数，X是节点的特征向量矩阵，$\\delta =D-A$是一个未归一化的图拉普拉斯矩阵，A是邻接矩阵，D是度矩阵。**公式一是居于相邻节点可能会共享相同标签的假设下的。**然而这种假设会限制模型的能力，因为图的边不一定是表示节点相似性的，可能是不相似性！</p>\n<p>文中作者直接使用神经网络模型$f(X,A)$来编码整个图结构并且在所有有监督的节点上获取loss进行训练，因此就避免了损失函数中基于图的显示正则化。在图的邻接矩阵上调节函数f会使得模型能够从监督损失中分配梯度信息并且使它既能学习有标签也能学习无标签节点的表示。</p>\n<p>主要贡献有两点：</p>\n<ol>\n<li>提出了一个简单有效的神经网络模型的传播规则，能够直接用于图并且展示了它是如何从一阶近似的谱图卷积得来的。</li>\n<li>解释了这种模型是如何应用于快速且可扩展的节点半监督分类任务中的。</li>\n</ol>\n<span id=\"more\"></span>\n<h2 id=\"图的快速近似卷积\">图的快速近似卷积</h2>\n<p>下面是本文中GCN的逐层传播规则：</p>\n<p><img src=\"https://i.imgur.com/dEpVbPD.png\" alt=\"picture 51\"></p>\n<p>其中$\\widetilde{A}=A+I_N$是带有自连接的邻接矩阵，$\\tilde{D}$就是根据$\\tilde{A}$的来的度矩阵，$W^{(l)}$是各层独立的可训练的权重参数，$\\sigma$是激活函数，$H^{(l)} \\in R^{N \\times D}$是第l层的隐藏状态矩阵,$H^{(0)}=X$。</p>\n<h3 id=\"谱图卷积\">谱图卷积</h3>\n<p>谱卷积定义为信号x和过滤器$g_\\theta \\times =Ug_\\theta U^Tx $在傅里叶域上的乘法</p>\n<p><img src=\"https://i.imgur.com/c7vuiU7.png\" alt=\"picture 52\"></p>\n<p>其中U是归一化拉普拉斯的特征向量组成的矩阵，$L=L_N-D^{- \\frac{1}{2}}AD^{- \\frac{1}{2}}=U\\Lambda U^T$，$U^Tx$是对x的图傅里叶转换。我们可以将$g_\\theta$理解成对L的特征值的函数，比如$g_\\theta(\\Lambda)$。但是计算公式3的计算成本太高，并且对于大的图更是如此。为此，有人提出$g_\\theta (\\Lambda)$可以由车比雪夫多项式的前k部分估计出来</p>\n<p><img src=\"https://i.imgur.com/L1Monm9.png\" alt=\"picture 53\"></p>\n<p>其中$\\tilde{\\Lambda}=\\frac{2}{\\lambda_{max}} \\Lambda - I_N$，$\\lambda_{max}$是L的最大特征值。车比雪夫多项式可以递归地定义为$T_k(x)=2xT_{k-1}(x)-T_{k-2}(x)$,其中$T_0(x)=1$,$T_1(x)=x$。</p>\n<p>回到我们的定义上，现在我们有</p>\n<p><img src=\"https://i.imgur.com/sWHyYb3.png\" alt=\"picture 54\"></p>\n<p>可以看出这个表达式只关心节点的k阶邻居，这使得它的计算复杂度直线下降。</p>\n<h3 id=\"逐层的线性模型\">逐层的线性模型</h3>\n<p>因此根据公式5可以堆叠多个基于图卷积的神经网络层，每一层之后更一个逐点的非线性层。现在我们对逐层的卷积操作进行限制，使它只关注一阶邻居，即K=1，这样的话就是在拉普拉斯图谱上进行一个线性操作。</p>\n<p>用这种方式仍然可以通过叠加这样的层来恢复丰富的卷积滤波器函数。我们期望这种模型能够减轻在图的局部邻接关系上的过拟合问题。此外，这样的逐层线性转化使我们能够构建更深的模型。</p>\n<p>我们近似将$\\lambda =2$，这样公式5就可以简化为：</p>\n<p><img src=\"https://i.imgur.com/LXQcZ2B.png\" alt=\"picture 55\"></p>\n<p>实际应用中我们可以限制参数的数量来解决过拟合问题，并且最小化每一层的计算量。这样我们可以得到以下公式</p>\n<p><img src=\"https://i.imgur.com/BNLrisG.png\" alt=\"picture 56\"></p>\n<p>其中$\\theta =\\theta_{1}^{‘} =-\\theta_{1}^{’}$。但是重复这一操作会导致数值不稳定出现梯度消失/爆炸。为了解决这一问题，这里做了个小trick，邻接矩阵使用包含自邻接关系，度矩阵也包含自邻接关系。</p>\n<p>这样我们就可以将具有C个输入通道的信号矩阵$X\\in R^{N\\times C}$和过滤器或者特征图定义为下式</p>\n<p><img src=\"https://i.imgur.com/jJj90Ec.png\" alt=\"picture 57\"></p>\n<h2 id=\"自监督节点分类\">自监督节点分类</h2>\n<h3 id=\"举例\">举例</h3>\n<p>我们假设一个两层的GCN用于半监督节点分类。我们先在一个预处理步骤中计算出$\\tilde{A}=\\tilde{D}^{-\\frac{1}{2}}\\tilde{A}\\tilde{D}^{-\\frac{1}{2}}$。前向传播公式如下</p>\n<p><img src=\"https://i.imgur.com/h5iMkZD.png\" alt=\"picture 58\"></p>\n<p>其中，$W^{(0)}\\in R^{C\\times H}$是第一个隐藏层的参数，$W^{(1)}\\in R^{H\\times F}$是输出层的参数。然后我们在所有的有标签样本上计算交叉熵损失</p>\n<p><img src=\"https://i.imgur.com/Jtsg0ac.png\" alt=\"picture 59\"></p>\n<p>下图是图卷积层的示意图</p>\n<p><img src=\"https://i.imgur.com/JGUN9Vu.png\" alt=\"picture 60\"></p>\n<h2 id=\"文章中公式的详细理解\">文章中公式的详细理解</h2>\n<p>首先我们有了一张图和他的基本信息，注意这里每个节点的向量可以是通过一些embeding方式得到的，不是重点。</p>\n<p><img src=\"https://i.imgur.com/ldUPSX0.png\" alt=\"picture 61\"></p>\n<p>那我们怎么获取到周遭节点的信息来辅助更新本节点的信息呢？可以用邻接矩阵和全部节点的特征组成的矩阵进行乘法，下图可以直观地展示出为什么能够获得邻居节点的信息</p>\n<p><img src=\"https://i.imgur.com/LPPsfou.png\" alt=\"picture 13\"></p>\n<p>当然，这样做还是有缺点的：</p>\n<ol>\n<li>缺少该节点本身的特征信息</li>\n<li>如果一个节点连接的邻居特别多或者特别少，用这种sum方法就会出现梯度爆炸或者梯度消失的问题。此外神经网络对输入信息的值比较敏感，因此需要归一化</li>\n</ol>\n<p>对于问题一解决办法很简单，邻接矩阵包含自邻接信息就可以了。</p>\n<p>对于问题二，一般做矩阵的缩放是乘以一个对角阵实现的。自然而然我们会想到使用度矩阵来实现。这里的度矩阵同样应该是包含自邻接关系的。使用度矩阵的逆，就可以实现邻接节点特征求和之后的取平均了。如下图所示</p>\n<p><img src=\"https://i.imgur.com/ZqluyWD.png\" alt=\"picture 63\"></p>\n<p>但是我们会发现，因为对角阵是在邻接矩阵左边乘的，所以实际上，只是用了$D_{ii}$对邻接矩阵的行进行了缩放，而没有对列进行。如下图所示</p>\n<p><img src=\"https://i.imgur.com/rDiJJK0.png\" alt=\"picture 64\"></p>\n<p>既然如此，我们可以尝试在右边再乘一个度矩阵的逆，这样不就行列都能得到缩放了吗？但是需要注意这里的原理是邻接矩阵是一个对称阵，所以其第i行和第i列是一样的，因此才可以这么做。</p>\n<p><img src=\"https://i.imgur.com/qYMvgrE.png\" alt=\"picture 65\"></p>\n<p>新的缩放方法给出了一个平均的权重，我们做的改进就是让他对邻接关系少的节点赋予更高的权重，这样能够减少邻接关系多的节点的影响。</p>\n<p>需要注意，我们对缩放矩阵进行归一化的时候一般做两次，一次对行一次对列，这是最常用的方式。也是文中作者使用的方式。</p>\n<p><img src=\"https://i.imgur.com/kphpELZ.png\" alt=\"picture 66\"></p>\n<p>卷积层的数量意味着一个节点的特征能够传播的距离。假如我们只有一层的话，那只能获取到邻居的信息，所有节点同时聚合自己邻居的信息。但如果我们堆叠多层，一个节点的邻居就能够包含其自身邻居的信息，经过聚合后当前节点就能够获得更远的节点的信息。</p>\n<p>但是一般我们不希望有太多层，经过6-7次跳跃，我们几乎已经可以聚合整张图的信息了。</p>\n","categories":["图神经网络"],"tags":["GCN"]},{"title":"go语言圣经学习","url":"/2022/01/15/go%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F%E5%AD%A6%E4%B9%A0/","content":"<h2 id=\"入门\">入门</h2>\n<h3 id=\"命令行参数\">命令行参数</h3>\n<p><code>os</code>包提供了一些与餐佐系统交互的函数和变量。命令行参数可以从os包的Args变量中获取；os包外部使用os.Args访问该变量。</p>\n<p>os.Args变量是一个字符串(string)的切片(slice)。os.Args[0]是命令本身的名字，其他元素是程序启动时传给他的参数。</p>\n<p>下面是echo命令的一个实现，其作用是将命令行参数打印成一行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s, sep <span class=\"keyword\">string</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">len</span>(os.Args); i++ &#123;</span><br><span class=\"line\">        <span class=\"comment\">//连接sep（为空或者为空格）和命令行参数</span></span><br><span class=\"line\">        s += sep + os.Args[i]</span><br><span class=\"line\">        sep = <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p>另外一种版本</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    s, sep := <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, arg := <span class=\"keyword\">range</span> os.Args[<span class=\"number\">1</span>:] &#123;</span><br><span class=\"line\">        s += sep + arg</span><br><span class=\"line\">        sep = <span class=\"string\">&quot; &quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第三种</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(strings.Join(os.Args[<span class=\"number\">1</span>:], <span class=\"string\">&quot; &quot;</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"查找重复行\">查找重复行</h3>\n<p>Unix中的uniq命令，作用是寻找相邻的重复行。</p>\n<p>第一个版本答应标准输入中重复出现的行，以重复次数开头</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;bufio&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    counts := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    input := bufio.NewScanner(os.Stdin)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> input.Scan() &#123;</span><br><span class=\"line\">        counts[input.Text()]++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> ignoring potential errors from input.Err()</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> line, n := <span class=\"keyword\">range</span> counts &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%d\\t%s\\n&quot;</span>, n, line)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很多程序要么从标准输入中读取数据，如上面的例子所示，要么从一系列具名文件中读取数据。dup程序的下个版本读取标准输入或是使用os.Open打开各个具名文件，并操作它们。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;bufio&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    counts := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    files := os.Args[<span class=\"number\">1</span>:]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(files) == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        countLines(os.Stdin, counts)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, arg := <span class=\"keyword\">range</span> files &#123;</span><br><span class=\"line\">            f, err := os.Open(arg)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                fmt.Fprintf(os.Stderr, <span class=\"string\">&quot;dup2: %v\\n&quot;</span>, err)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            countLines(f, counts)</span><br><span class=\"line\">            f.Close()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line, n := <span class=\"keyword\">range</span> counts &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%d\\t%s\\n&quot;</span>, n, line)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">countLines</span><span class=\"params\">(f *os.File, counts <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    input := bufio.NewScanner(f)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> input.Scan() &#123;</span><br><span class=\"line\">        counts[input.Text()]++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> ignoring potential errors from input.Err()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前两个版本都是以“流”模式读取输入，并且根据需要拆分成多行。下面的方法是一口气把数据全部放到内存中，一次分割为多行，然后处理他们。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;io/ioutil&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    counts := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, filename := <span class=\"keyword\">range</span> os.Args[<span class=\"number\">1</span>:] &#123;</span><br><span class=\"line\">        data, err := ioutil.ReadFile(filename)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            fmt.Fprintf(os.Stderr, <span class=\"string\">&quot;dup3: %v\\n&quot;</span>, err)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _, line := <span class=\"keyword\">range</span> strings.Split(<span class=\"keyword\">string</span>(data), <span class=\"string\">&quot;\\n&quot;</span>) &#123;</span><br><span class=\"line\">            counts[line]++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line, n := <span class=\"keyword\">range</span> counts &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> n &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;%d\\t%s\\n&quot;</span>, n, line)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"GIF动画\">GIF动画</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;image&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;image/color&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;image/gif&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;math/rand&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> palette = []color.Color&#123;color.White, color.Black&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    whiteIndex = <span class=\"number\">0</span> <span class=\"comment\">// first color in palette</span></span><br><span class=\"line\">    blackIndex = <span class=\"number\">1</span> <span class=\"comment\">// next color in palette</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// The sequence of images is deterministic unless we seed</span></span><br><span class=\"line\">    <span class=\"comment\">// the pseudo-random number generator using the current time.</span></span><br><span class=\"line\">    <span class=\"comment\">// Thanks to Randall McPherson for pointing out the omission.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//使用当前时间作为随机种子</span></span><br><span class=\"line\">    rand.Seed(time.Now().UTC().UnixNano())</span><br><span class=\"line\">    lissajous(os.Stdout)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">lissajous</span><span class=\"params\">(out io.Writer)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> (</span><br><span class=\"line\">        cycles  = <span class=\"number\">5</span>     <span class=\"comment\">// 完整的x震荡器转数</span></span><br><span class=\"line\">        res     = <span class=\"number\">0.001</span> <span class=\"comment\">// 角转</span></span><br><span class=\"line\">        size    = <span class=\"number\">100</span>   <span class=\"comment\">// 画布覆盖范围</span></span><br><span class=\"line\">        nframes = <span class=\"number\">64</span>    <span class=\"comment\">// 动画帧数</span></span><br><span class=\"line\">        delay   = <span class=\"number\">8</span>     <span class=\"comment\">// 10ms为单位的帧之间的延迟</span></span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    freq := rand.Float64() * <span class=\"number\">3.0</span> <span class=\"comment\">// y震荡器的相关频率</span></span><br><span class=\"line\">    anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br><span class=\"line\">    phase := <span class=\"number\">0.0</span> <span class=\"comment\">// 相位差</span></span><br><span class=\"line\">    <span class=\"comment\">//刻画每一帧的图像</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; nframes; i++ &#123;</span><br><span class=\"line\">        rect := image.Rect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>*size+<span class=\"number\">1</span>, <span class=\"number\">2</span>*size+<span class=\"number\">1</span>)</span><br><span class=\"line\">        img := image.NewPaletted(rect, palette)</span><br><span class=\"line\">        <span class=\"comment\">//刻画当前帧的完整图像</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> t := <span class=\"number\">0.0</span>; t &lt; cycles*<span class=\"number\">2</span>*math.Pi; t += res &#123;</span><br><span class=\"line\">            x := math.Sin(t)</span><br><span class=\"line\">            y := math.Sin(t*freq + phase)</span><br><span class=\"line\">            img.SetColorIndex(size+<span class=\"keyword\">int</span>(x*size+<span class=\"number\">0.5</span>), size+<span class=\"keyword\">int</span>(y*size+<span class=\"number\">0.5</span>),</span><br><span class=\"line\">                blackIndex)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        phase += <span class=\"number\">0.1</span></span><br><span class=\"line\">        anim.Delay = <span class=\"built_in\">append</span>(anim.Delay, delay)</span><br><span class=\"line\">        anim.Image = <span class=\"built_in\">append</span>(anim.Image, img)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    gif.EncodeAll(out, &amp;anim) <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> ignoring encoding errors</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>lissajous函数内部有两层嵌套的for循环。外层循环会循环64次，每一次都会生成一个单独的动画帧。它生成了一个包含两种颜色的201*201大小的图片，白色和黑色。所有像素点都会被默认设置为其零值（也就是调色板palette里的第0个值），这里我们设置的是白色。每次外层循环都会生成一张新图片，并将一些像素设置为黑色。其结果会append到之前结果之后。这里我们用到了append内置函数，将结果append到anim中的帧列表末尾，并设置一个默认的80ms的延迟值。循环结束后所有的延迟值被编码进了GIF图片中，并将结果写入到输出流。out这个变量是io.Writer类型，这个类型支持把输出结果写到很多目标，很快我们就可以看到例子。</p>\n<p>我们可以用color.RGBA{0xRR, 0xGG, 0xBB, 0xff}来得到#RRGGBB这个色值，三个十六进制的字符串分别代表红、绿、蓝像素。</p>\n<p>下面这个命令会在当前目录下产生一个GIF动画。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ go build gopl.io/ch1/lissajous</span><br><span class=\"line\">$ ./lissajous &gt;out.gif</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取URL\">获取URL</h3>\n<p>对于很多现代应用来说，访问互联网上的信息和访问本地文件系统一样重要。Go语言在net这个强大package的帮助下提供了一系列的package来做这件事情，使用这些包可以更简单地用网络收发信息，还可以建立更底层的网络连接，编写服务器程序。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;io/ioutil&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, url := <span class=\"keyword\">range</span> os.Args[<span class=\"number\">1</span>:] &#123;</span><br><span class=\"line\">        resp, err := http.Get(url)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            fmt.Fprintf(os.Stderr, <span class=\"string\">&quot;fetch: %v\\n&quot;</span>, err)</span><br><span class=\"line\">            os.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        b, err := ioutil.ReadAll(resp.Body)</span><br><span class=\"line\">        resp.Body.Close()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            fmt.Fprintf(os.Stderr, <span class=\"string\">&quot;fetch: reading %s: %v\\n&quot;</span>, url, err)</span><br><span class=\"line\">            os.Exit(<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;%s&quot;</span>, b)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Web服务\">Web服务</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, handler) <span class=\"comment\">// each request calls handler</span></span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(<span class=\"string\">&quot;localhost:8000&quot;</span>, <span class=\"literal\">nil</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// handler echoes the Path component of the request URL r.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;URL.Path = %q\\n&quot;</span>, r.URL.Path)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>main函数将所有发送到/路径下的请求和handler函数关联起来，/开头的请求其实就是所有发送到当前站点上的请求，服务监听8000端口。发送到这个服务的“请求”是一个http.Request类型的对象，这个对象中包含了请求中的一系列相关字段，其中就包括我们需要的URL。当请求到达服务器时，这个请求会被传给handler函数来处理，这个函数会将/hello这个路径从请求的URL中解析出来，然后把其发送到响应中，这里我们用的是标准输出流的fmt.Fprintf。</p>\n<p>让我们在后台运行这个服务程序。如果你的操作系统是Mac OS X或者Linux，那么在运行命令的末尾加上一个&amp;符号，即可让程序简单地跑在后台，windows下可以在另外一个命令行窗口去运行这个程序。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ go run src/gopl.io/ch1/server1/main.go &amp;</span><br></pre></td></tr></table></figure>\n<p>现在可以通过命令行来发送客户端请求了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ go build gopl.io/ch1/fetch</span><br><span class=\"line\">$ ./fetch http://localhost:8000</span><br><span class=\"line\">URL.Path = &quot;/&quot;</span><br><span class=\"line\">$ ./fetch http://localhost:8000/help</span><br><span class=\"line\">URL.Path = &quot;/help&quot;</span><br></pre></td></tr></table></figure>\n<p>在这个服务的基础上叠加特性是很容易的。一种比较实用的修改是为访问的url添加某种状态。比如，下面这个版本输出了同样的内容，但是会对请求的次数进行计算；对URL的请求结果会包含各种URL被访问的总次数，直接对/count这个URL的访问要除外。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mu sync.Mutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> count <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, handler)</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/count&quot;</span>, counter)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(<span class=\"string\">&quot;localhost:8000&quot;</span>, <span class=\"literal\">nil</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// handler echoes the Path component of the requested URL.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    mu.Lock()</span><br><span class=\"line\">    count++</span><br><span class=\"line\">    mu.Unlock()</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;URL.Path = %q\\n&quot;</span>, r.URL.Path)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// counter echoes the number of calls so far.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">counter</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    mu.Lock()</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Count %d\\n&quot;</span>, count)</span><br><span class=\"line\">    mu.Unlock()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个服务器有两个请求处理函数，根据请求的url不同会调用不同的函数：对/count这个url的请求会调用到counter这个函数，其它的url都会调用默认的处理函数。如果你的请求pattern是以/结尾，那么所有以该url为前缀的url都会被这条规则匹配。在这些代码的背后，服务器每一次接收请求处理时都会另起一个goroutine，这样服务器就可以同一时间处理多个请求。然而在并发情况下，假如真的有两个请求同一时刻去更新count，那么这个值可能并不会被正确地增加；这个程序可能会引发一个严重的bug：竞态条件。为了避免这个问题，我们必须保证每次修改变量的最多只能有一个goroutine，这也就是代码里的mu.Lock()和mu.Unlock()调用将修改count的所有行为包在中间的目的。</p>\n<h2 id=\"程序结构\">程序结构</h2>\n<h3 id=\"命名\">命名</h3>\n<p>Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。<strong>大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。</strong></p>\n<p>如果一个名字是在函数内部定义，那么它就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的Printf函数就是导出的，可以在fmt包外部访问。包本身的名字一般总是用小写字母。</p>\n<h3 id=\"声明\">声明</h3>\n<p>声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。</p>\n<p>一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。每个源文件中以包的声明语句开始，说明该源文件是属于哪个包。包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要（译注：函数内部的名字则必须先声明之后才能使用）。</p>\n<h3 id=\"变量\">变量</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">var 变量名字 类型 = 表达式</span><br></pre></td></tr></table></figure>\n<p>其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。</p>\n<h4 id=\"指针\">指针</h4>\n<p>一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字。</p>\n<p>如果用“var x int”声明语句声明一个x变量，那么&amp;x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是<code>*int</code>，指针被称之为“指向int类型的指针”。如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时<code>*p</code>表达式对应p指针指向的变量的值。一般<code>*p</code>表达式读取指针指向的变量的值，这里为int类型的值，同时因为<code>*p</code>对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。</p>\n<p>变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受&amp;取地址操作。</p>\n<p>在Go语言中，返回函数中局部变量的地址也是安全的。例如下面的代码，调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = f()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span> *<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    v := <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;v</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每次调用f函数都将返回不同的结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">fmt.Println(f() == f()) // &quot;false&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"new函数\">new函数</h4>\n<p>另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code>。</p>\n<p>用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)。换言之，new函数类似是一种语法糖，而不是一个新的基础概念。</p>\n<p>new函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活。</p>\n<h4 id=\"变量的生命周期\">变量的生命周期</h4>\n<p>Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。</p>\n<p>因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。</p>\n<p>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> global *<span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x <span class=\"keyword\">int</span></span><br><span class=\"line\">    x = <span class=\"number\">1</span></span><br><span class=\"line\">    global = &amp;x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">g</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    y := <span class=\"built_in\">new</span>(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    *y = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量<code>*y</code>将是不可达的，也就是说可以马上被回收的。因此，<code>*y</code>并没有从函数g中逃逸，编译器可以选择在栈上分配<code>*y</code>的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。</p>\n<h3 id=\"类型\">类型</h3>\n<p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type 类型名字 底层类型</span><br></pre></td></tr></table></figure>\n<p>类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。</p>\n<p>为了说明类型声明，我们将不同温度单位分别定义为不同的类型：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> tempconv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Celsius <span class=\"keyword\">float64</span>    <span class=\"comment\">// 摄氏温度</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Fahrenheit <span class=\"keyword\">float64</span> <span class=\"comment\">// 华氏温度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    AbsoluteZeroC Celsius = <span class=\"number\">-273.15</span> <span class=\"comment\">// 绝对零度</span></span><br><span class=\"line\">    FreezingC     Celsius = <span class=\"number\">0</span>       <span class=\"comment\">// 结冰点温度</span></span><br><span class=\"line\">    BoilingC      Celsius = <span class=\"number\">100</span>     <span class=\"comment\">// 沸水温度</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CToF</span><span class=\"params\">(c Celsius)</span> <span class=\"title\">Fahrenheit</span></span> &#123; <span class=\"keyword\">return</span> Fahrenheit(c*<span class=\"number\">9</span>/<span class=\"number\">5</span> + <span class=\"number\">32</span>) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FToC</span><span class=\"params\">(f Fahrenheit)</span> <span class=\"title\">Celsius</span></span> &#123; <span class=\"keyword\">return</span> Celsius((f - <span class=\"number\">32</span>) * <span class=\"number\">5</span> / <span class=\"number\">9</span>) &#125;</span><br></pre></td></tr></table></figure>\n<p>我们在这个包声明了两种类型：Celsius和Fahrenheit分别对应不同的温度单位。它们虽然有着相同的底层类型float64，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误；因此需要一个类似Celsius(t)或Fahrenheit(t)形式的显式转型操作才能将float64转为对应的类型。Celsius(t)和Fahrenheit(t)是类型转换操作，它们并不是函数调用。类型转换不会改变值本身，但是会使它们的语义发生变化。另一方面，CToF和FToC两个函数则是对不同温度单位下的温度进行换算，它们会返回不同的值。</p>\n<h3 id=\"包和文件\">包和文件</h3>\n<p>Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径；<a href=\"http://xn--gopl-zu6f77pg6m.io/ch1/helloworld%E5%AF%B9%E5%BA%94%E7%9A%84%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%E6%98%AF$GOPATH/src/gopl.io/ch1/helloworld%E3%80%82\">例如包gopl.io/ch1/helloworld对应的目录路径是$GOPATH/src/gopl.io/ch1/helloworld。</a></p>\n<p>每个包都对应一个独立的名字空间。例如，在image包中的Decode函数和在unicode/utf16包中的 Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问。</p>\n<p>包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。</p>\n<p>为了演示包基本的用法，先假设我们的温度转换软件已经很流行，我们希望到Go语言社区也能使用这个包。我们该如何做呢？</p>\n<p><a href=\"http://xn--gopl-k84fui2d97du1om8e8o0be0h784l.io/ch2/tempconv%E7%9A%84%E5%8C%85%EF%BC%8C%E8%BF%99%E6%98%AF%E5%89%8D%E9%9D%A2%E4%BE%8B%E5%AD%90%E7%9A%84%E4%B8%80%E4%B8%AA%E6%94%B9%E8%BF%9B%E7%89%88%E6%9C%AC%E3%80%82%EF%BC%88%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E6%B2%A1%E6%9C%89%E6%8C%89%E7%85%A7%E6%83%AF%E4%BE%8B%E6%8C%89%E9%A1%BA%E5%BA%8F%E5%AF%B9%E4%BE%8B%E5%AD%90%E8%BF%9B%E8%A1%8C%E7%BC%96%E5%8F%B7%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%8C%85%E8%B7%AF%E5%BE%84%E7%9C%8B%E8%B5%B7%E6%9D%A5%E6%9B%B4%E5%83%8F%E4%B8%80%E4%B8%AA%E7%9C%9F%E5%AE%9E%E7%9A%84%E5%8C%85%EF%BC%89%E5%8C%85%E4%BB%A3%E7%A0%81%E5%AD%98%E5%82%A8%E5%9C%A8%E4%B8%A4%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E7%94%A8%E6%9D%A5%E6%BC%94%E7%A4%BA%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6%E5%A3%B0%E6%98%8E%E7%84%B6%E5%90%8E%E5%9C%A8%E5%85%B6%E4%BB%96%E7%9A%84%E6%BA%90%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%EF%BC%9B%E8%99%BD%E7%84%B6%E5%9C%A8%E7%8E%B0%E5%AE%9E%E4%B8%AD%EF%BC%8C%E8%BF%99%E6%A0%B7%E5%B0%8F%E7%9A%84%E5%8C%85%E4%B8%80%E8%88%AC%E5%8F%AA%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E3%80%82\">让我们创建一个名为gopl.io/ch2/tempconv的包，这是前面例子的一个改进版本。（这里我们没有按照惯例按顺序对例子进行编号，因此包路径看起来更像一个真实的包）包代码存储在两个源文件中，用来演示如何在一个源文件声明然后在其他的源文件访问；虽然在现实中，这样小的包一般只需要一个文件。</a></p>\n<p>我们把变量的声明、对应的常量，还有方法都放到tempconv.go源文件中：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> tempconv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Celsius <span class=\"keyword\">float64</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Fahrenheit <span class=\"keyword\">float64</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    AbsoluteZeroC Celsius = <span class=\"number\">-273.15</span></span><br><span class=\"line\">    FreezingC     Celsius = <span class=\"number\">0</span></span><br><span class=\"line\">    BoilingC      Celsius = <span class=\"number\">100</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c Celsius)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span>    &#123; <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;%g°C&quot;</span>, c) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f Fahrenheit)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123; <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;%g°F&quot;</span>, f) &#125;</span><br></pre></td></tr></table></figure>\n<p>转换函数则放在另一个conv.go源文件中：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> tempconv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// CToF converts a Celsius temperature to Fahrenheit.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CToF</span><span class=\"params\">(c Celsius)</span> <span class=\"title\">Fahrenheit</span></span> &#123; <span class=\"keyword\">return</span> Fahrenheit(c*<span class=\"number\">9</span>/<span class=\"number\">5</span> + <span class=\"number\">32</span>) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// FToC converts a Fahrenheit temperature to Celsius.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FToC</span><span class=\"params\">(f Fahrenheit)</span> <span class=\"title\">Celsius</span></span> &#123; <span class=\"keyword\">return</span> Celsius((f - <span class=\"number\">32</span>) * <span class=\"number\">5</span> / <span class=\"number\">9</span>) &#125;</span><br></pre></td></tr></table></figure>\n<p>每个源文件都是以包的声明语句开始，用来指明包的名字。当包被导入的时候，包内的成员将通过类似tempconv.CToF的形式访问。而包级别的名字，例如在一个文件声明的类型和常量，在同一个包的其他源文件也是可以直接访问的，就好像所有代码都在一个文件一样。要注意的是tempconv.go源文件导入了fmt包，但是conv.go源文件并没有，因为这个源文件中的代码并没有用到fmt包。</p>\n<h4 id=\"导入包\">导入包</h4>\n<p>在Go语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似&quot;<a href=\"http://gopl.io/ch2/tempconv\">gopl.io/ch2/tempconv</a>&quot;的字符串对应包的导入路径。Go语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件。</p>\n<p>除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。按照惯例，一个包的名字和包的导入路径的最后一个字段相同，<a href=\"http://xn--gopl-zu6fx14c.io/ch2/tempconv%E5%8C%85%E7%9A%84%E5%90%8D%E5%AD%97%E4%B8%80%E8%88%AC%E6%98%AFtempconv%E3%80%82\">例如gopl.io/ch2/tempconv包的名字一般是tempconv。</a></p>\n<h2 id=\"基础数据类型\">基础数据类型</h2>\n<h3 id=\"整型\">整型</h3>\n<p>Go语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。</p>\n<p>Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。</p>\n<p>不管它们的具体大小，int、uint和uintptr是不同类型的兄弟类型。其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然。</p>\n<p>Go语言还提供了以下的bit位操作运算符，前面4个操作运算符并不区分是有符号还是无符号数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;      位运算 AND</span><br><span class=\"line\">|      位运算 OR</span><br><span class=\"line\">^      位运算 XOR</span><br><span class=\"line\">&amp;^     位清空（AND NOT）</span><br><span class=\"line\">&lt;&lt;     左移</span><br><span class=\"line\">&gt;&gt;     右移</span><br></pre></td></tr></table></figure>\n<p>位操作运算符^作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反；也就是说，它返回一个每个bit位都取反的数。位操作运算符&amp;^用于按位置零（AND NOT）：如果对应y中bit位为1的话，表达式z = x &amp;^ y结果z的对应的bit位为0，否则z对应的bit位等于x相应的bit位的值。</p>\n<h3 id=\"浮点型\">浮点型</h3>\n<p>Go语言提供了两种精度的浮点数，float32和float64。它们的算术规范由IEEE754浮点数国际标准定义，该浮点数规范被所有现代的CPU支持。</p>\n<p>用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。所有的这三个打印形式都可以指定打印的宽度和控制打印精度。</p>\n<p>math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；还有NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1)。</p>\n<p>接下来的程序演示了通过浮点计算生成的图形。它是带有两个参数的z = f(x, y)函数的三维形式，使用了可缩放矢量图形（SVG）格式输出，SVG是一个用于矢量线绘制的XML标准。图3.1显示了sin®/r函数的输出图形，其中r是<code>sqrt(x*x+y*y)</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;math&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    width, height = <span class=\"number\">600</span>, <span class=\"number\">320</span>            <span class=\"comment\">// canvas size in pixels</span></span><br><span class=\"line\">    cells         = <span class=\"number\">100</span>                 <span class=\"comment\">// number of grid cells</span></span><br><span class=\"line\">    xyrange       = <span class=\"number\">30.0</span>                <span class=\"comment\">// axis ranges (-xyrange..+xyrange)</span></span><br><span class=\"line\">    xyscale       = width / <span class=\"number\">2</span> / xyrange <span class=\"comment\">// pixels per x or y unit</span></span><br><span class=\"line\">    zscale        = height * <span class=\"number\">0.4</span>        <span class=\"comment\">// pixels per z unit</span></span><br><span class=\"line\">    angle         = math.Pi / <span class=\"number\">6</span>         <span class=\"comment\">// angle of x, y axes (=30°)</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> sin30, cos30 = math.Sin(angle), math.Cos(angle) <span class=\"comment\">// sin(30°), cos(30°)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; &quot;</span>+</span><br><span class=\"line\">        <span class=\"string\">&quot;style=&#x27;stroke: grey; fill: white; stroke-width: 0.7&#x27; &quot;</span>+</span><br><span class=\"line\">        <span class=\"string\">&quot;width=&#x27;%d&#x27; height=&#x27;%d&#x27;&gt;&quot;</span>, width, height)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; cells; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j := <span class=\"number\">0</span>; j &lt; cells; j++ &#123;</span><br><span class=\"line\">            ax, ay := corner(i+<span class=\"number\">1</span>, j)</span><br><span class=\"line\">            bx, by := corner(i, j)</span><br><span class=\"line\">            cx, cy := corner(i, j+<span class=\"number\">1</span>)</span><br><span class=\"line\">            dx, dy := corner(i+<span class=\"number\">1</span>, j+<span class=\"number\">1</span>)</span><br><span class=\"line\">            fmt.Printf(<span class=\"string\">&quot;&lt;polygon points=&#x27;%g,%g %g,%g %g,%g %g,%g&#x27;/&gt;\\n&quot;</span>,</span><br><span class=\"line\">                ax, ay, bx, by, cx, cy, dx, dy)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;&lt;/svg&gt;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">corner</span><span class=\"params\">(i, j <span class=\"keyword\">int</span>)</span> <span class=\"params\">(<span class=\"keyword\">float64</span>, <span class=\"keyword\">float64</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Find point (x,y) at corner of cell (i,j).</span></span><br><span class=\"line\">    x := xyrange * (<span class=\"keyword\">float64</span>(i)/cells - <span class=\"number\">0.5</span>)</span><br><span class=\"line\">    y := xyrange * (<span class=\"keyword\">float64</span>(j)/cells - <span class=\"number\">0.5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Compute surface height z.</span></span><br><span class=\"line\">    z := f(x, y)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Project (x,y,z) isometrically onto 2-D SVG canvas (sx,sy).</span></span><br><span class=\"line\">    sx := width/<span class=\"number\">2</span> + (x-y)*cos30*xyscale</span><br><span class=\"line\">    sy := height/<span class=\"number\">2</span> + (x+y)*sin30*xyscale - z*zscale</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sx, sy</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">f</span><span class=\"params\">(x, y <span class=\"keyword\">float64</span>)</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">    r := math.Hypot(x, y) <span class=\"comment\">// distance from (0,0)</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> math.Sin(r) / r</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"复数\">复数</h3>\n<p>Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"keyword\">complex128</span> = <span class=\"built_in\">complex</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 1+2i</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> y <span class=\"keyword\">complex128</span> = <span class=\"built_in\">complex</span>(<span class=\"number\">3</span>, <span class=\"number\">4</span>) <span class=\"comment\">// 3+4i</span></span><br><span class=\"line\">fmt.Println(x*y)                 <span class=\"comment\">// &quot;(-5+10i)&quot;</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">real</span>(x*y))           <span class=\"comment\">// &quot;-5&quot;</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">imag</span>(x*y))           <span class=\"comment\">// &quot;10&quot;</span></span><br></pre></td></tr></table></figure>\n<p>如果一个浮点数面值或一个十进制整数面值后面跟着一个i，例如3.141592i或2i，它将构成一个复数的虚部，复数的实部是0：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">fmt.Println(<span class=\"number\">1i</span> * <span class=\"number\">1i</span>) <span class=\"comment\">// &quot;(-1+0i)&quot;, i^2 = -1</span></span><br></pre></td></tr></table></figure>\n<p>在常量算术规则下，一个复数常量可以加到另一个普通数值常量（整数或浮点数、实部或虚部），我们可以用自然的方式书写复数，就像1+2i或与之等价的写法2i+1。上面x和y的声明语句还可以简化：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">x := <span class=\"number\">1</span> + <span class=\"number\">2i</span></span><br><span class=\"line\">y := <span class=\"number\">3</span> + <span class=\"number\">4i</span></span><br></pre></td></tr></table></figure>\n<p>复数也可以用==和!=进行相等比较。只有两个复数的实部和虚部都相等的时候它们才是相等的（译注：浮点数的相等比较是危险的，需要特别小心处理精度问题）。</p>\n<p>math/cmplx包提供了复数处理的许多函数，例如求复数的平方根函数和求幂函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">fmt.Println(cmplx.Sqrt(<span class=\"number\">-1</span>)) <span class=\"comment\">// &quot;(0+1i)&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串\">字符串</h3>\n<p>一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。</p>\n<p>第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字节。我们先简单说下字符的工作方式。</p>\n<p>子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串。生成的新字符串将包含j-i个字节。</p>\n<p>因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">s[<span class=\"number\">0</span>] = <span class=\"string\">&#x27;L&#x27;</span> <span class=\"comment\">// compile error: cannot assign to s[0]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串字面值\">字符串字面值</h4>\n<p>在一个双引号包含的字符串面值中，可以用以反斜杠\\开头的转义序列插入任意的数据。下面的换行、回车和制表符等是常见的ASCII控制代码的转义方式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">\\a      响铃</span><br><span class=\"line\">\\b      退格</span><br><span class=\"line\">\\f      换页</span><br><span class=\"line\">\\n      换行</span><br><span class=\"line\">\\r      回车</span><br><span class=\"line\">\\t      制表符</span><br><span class=\"line\">\\v      垂直制表符</span><br><span class=\"line\">\\&#x27;      单引号（只用在 &#x27;\\&#x27;&#x27; 形式的rune符号面值中）</span><br><span class=\"line\">\\&quot;      双引号（只用在 &quot;...&quot; 形式的字符串面值中）</span><br><span class=\"line\">\\\\      反斜杠</span><br></pre></td></tr></table></figure>\n<p>一个原生的字符串面值形式是<code>...</code>，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行（译注：在原生字符串面值内部是无法直接写`字符的，可以用八进制或十六进制转义或+&quot;`&quot;连接字符串常量完成）。唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些把回车也放入文本文件的系统（译注：Windows系统会把回车和换行一起放入文本文件中）。</p>\n<p>原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> GoUsage = <span class=\"string\">`Go is a tool for managing Go source code.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">Usage:</span></span><br><span class=\"line\"><span class=\"string\">    go command [arguments]</span></span><br><span class=\"line\"><span class=\"string\">...`</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"Unicode\">Unicode</h4>\n<p>下面例子中，字符串总共包含13个字节，但是只对应9个unicode字符</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;unicode/utf8&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">s := <span class=\"string\">&quot;Hello, 世界&quot;</span></span><br><span class=\"line\">fmt.Println(<span class=\"built_in\">len</span>(s))                    <span class=\"comment\">// &quot;13&quot;</span></span><br><span class=\"line\">fmt.Println(utf8.RuneCountInString(s)) <span class=\"comment\">// &quot;9&quot;</span></span><br></pre></td></tr></table></figure>\n<p>为了处理这些真实的字符，我们需要一个UTF8解码器。unicode/utf8包提供了该功能，我们可以这样使用：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(s); &#123;</span><br><span class=\"line\">    r, size := utf8.DecodeRuneInString(s[i:])</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%d\\t%c\\n&quot;</span>, i, r)</span><br><span class=\"line\">    i += size</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每一次调用DecodeRuneInString函数都返回一个r和长度，r对应字符本身，长度对应r采用UTF8编码后的编码字节数目。长度可以用于更新第i个字符在字符串中的字节索引位置。但是这种编码方式是笨拙的，我们需要更简洁的语法。幸运的是，Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串。下面的循环运行如图所示；需要注意的是对于非ASCII，索引更新的步长将超过1个字节。</p>\n<p><img src=\"https://i.imgur.com/hN2UTLB.png\" alt=\"picture 1\"></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i, r := <span class=\"keyword\">range</span> <span class=\"string\">&quot;Hello, 世界&quot;</span> &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%d\\t%q\\t%d\\n&quot;</span>, i, r, r)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串和byte切片\">字符串和byte切片</h4>\n<p>标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。</p>\n<p>bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效。</p>\n<p>strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</p>\n<p>unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。</p>\n<p>bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零值也是有效的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">intsToString</span><span class=\"params\">(values []<span class=\"keyword\">int</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> buf bytes.Buffer</span><br><span class=\"line\">    buf.WriteByte(<span class=\"string\">&#x27;[&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i, v := <span class=\"keyword\">range</span> values &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            buf.WriteString(<span class=\"string\">&quot;, &quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Fprintf(&amp;buf, <span class=\"string\">&quot;%d&quot;</span>, v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buf.WriteByte(<span class=\"string\">&#x27;]&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> buf.String()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(intsToString([]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;)) <span class=\"comment\">// &quot;[1, 2, 3]&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"常量\">常量</h3>\n<p>常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。</p>\n<p>下面是来自time包的例子，它首先定义了一个Weekday命名类型，然后为一周的每天定义了一个常量，从周日0开始。在其它编程语言中，这种类型一般被称为枚举类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Weekday <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    Sunday Weekday = <span class=\"literal\">iota</span></span><br><span class=\"line\">    Monday</span><br><span class=\"line\">    Tuesday</span><br><span class=\"line\">    Wednesday</span><br><span class=\"line\">    Thursday</span><br><span class=\"line\">    Friday</span><br><span class=\"line\">    Saturday</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>周日将对应0，周一为1，如此等等。</p>\n<p>我们也可以在复杂的常量表达式中使用iota，下面是来自net包的例子，用于给一个无符号整数的最低5bit的每个bit指定一个名字：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Flags <span class=\"keyword\">uint</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    FlagUp Flags = <span class=\"number\">1</span> &lt;&lt; <span class=\"literal\">iota</span> <span class=\"comment\">// is up</span></span><br><span class=\"line\">    FlagBroadcast            <span class=\"comment\">// supports broadcast access capability</span></span><br><span class=\"line\">    FlagLoopback             <span class=\"comment\">// is a loopback interface</span></span><br><span class=\"line\">    FlagPointToPoint         <span class=\"comment\">// belongs to a point-to-point link</span></span><br><span class=\"line\">    FlagMulticast            <span class=\"comment\">// supports multicast access capability</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h4 id=\"无类型常量\">无类型常量</h4>\n<p>Go语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如int或float64，或者是类似time.Duration这样命名的基础类型，但是许多常量并没有一个明确的基础类型。编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</p>\n<p>通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。例如，例子中的ZiB和YiB的值已经超出任何Go语言中整数类型能表达的范围，但是它们依然是合法的常量，而且像下面的常量表达式依然有效（译注：YiB/ZiB是在编译期计算出来的，并且结果常量是1024，是Go语言int变量能有效表示的）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    _ = <span class=\"number\">1</span> &lt;&lt; (<span class=\"number\">10</span> * <span class=\"literal\">iota</span>)</span><br><span class=\"line\">    KiB <span class=\"comment\">// 1024</span></span><br><span class=\"line\">    MiB <span class=\"comment\">// 1048576</span></span><br><span class=\"line\">    GiB <span class=\"comment\">// 1073741824</span></span><br><span class=\"line\">    TiB <span class=\"comment\">// 1099511627776             (exceeds 1 &lt;&lt; 32)</span></span><br><span class=\"line\">    PiB <span class=\"comment\">// 1125899906842624</span></span><br><span class=\"line\">    EiB <span class=\"comment\">// 1152921504606846976</span></span><br><span class=\"line\">    ZiB <span class=\"comment\">// 1180591620717411303424    (exceeds 1 &lt;&lt; 64)</span></span><br><span class=\"line\">    YiB <span class=\"comment\">// 1208925819614629174706176</span></span><br><span class=\"line\">)</span><br><span class=\"line\">fmt.Println(YiB/ZiB) <span class=\"comment\">// &quot;1024&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"复合数据类型\">复合数据类型</h2>\n<h3 id=\"数组\">数组</h3>\n<p>数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">r := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">99</span>: <span class=\"number\">-1</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。</p>\n<p>如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候我们可以直接通过==比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。不相等比较运算符!=遵循同样的规则。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">a := [<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">b := [...]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">c := [<span class=\"number\">2</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">fmt.Println(a == b, a == c, b == c) <span class=\"comment\">// &quot;true false false&quot;</span></span><br><span class=\"line\">d := [<span class=\"number\">3</span>]<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">fmt.Println(a == d) <span class=\"comment\">// compile error: cannot compare [2]int == [3]int</span></span><br></pre></td></tr></table></figure>\n<p>作为一个真实的例子，crypto/sha256包的Sum256函数对一个任意的字节slice类型的数据生成一个对应的消息摘要。消息摘要有256bit大小，因此对应[32]byte数组类型。如果两个消息摘要是相同的，那么可以认为两个消息本身也是相同（译注：理论上有HASH码碰撞的情况，但是实际应用可以基本忽略）；如果消息摘要不同，那么消息本身必然也是不同的。下面的例子用SHA256算法分别生成“x”和“X”两个信息的摘要：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;crypto/sha256&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    c1 := sha256.Sum256([]<span class=\"keyword\">byte</span>(<span class=\"string\">&quot;x&quot;</span>))</span><br><span class=\"line\">    c2 := sha256.Sum256([]<span class=\"keyword\">byte</span>(<span class=\"string\">&quot;X&quot;</span>))</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%x\\n%x\\n%t\\n%T\\n&quot;</span>, c1, c2, c1 == c2, c1)</span><br><span class=\"line\">    <span class=\"comment\">// Output:</span></span><br><span class=\"line\">    <span class=\"comment\">// 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881</span></span><br><span class=\"line\">    <span class=\"comment\">// 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015</span></span><br><span class=\"line\">    <span class=\"comment\">// false</span></span><br><span class=\"line\">    <span class=\"comment\">// [32]uint8</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Slice\">Slice</h3>\n<p>数组和slice之间有着紧密的联系。一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。</p>\n<p>多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。图4.1显示了表示一年中每个月份名字的字符串数组，还有重叠引用了该数组的两个slice。数组这样定义</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">months := [...]<span class=\"keyword\">string</span>&#123;<span class=\"number\">1</span>: <span class=\"string\">&quot;January&quot;</span>, <span class=\"comment\">/* ... */</span>, <span class=\"number\">12</span>: <span class=\"string\">&quot;December&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大。</p>\n<p>因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名。</p>\n<p>要注意的是slice类型的变量s和数组类型的变量a的初始化语法的差异。slice和数组的字面值语法很类似，它们都是用花括弧包含一系列的初始化元素，但是对于slice并没有指明序列的长度。<strong>这会隐式地创建一个合适大小的数</strong>组，然后slice的指针指向底层的数组。就像数组字面值一样，slice的字面值也可以按顺序指定初始化值序列，或者是通过索引和元素值指定，或者用两种风格的混合语法初始化。</p>\n<p>和数组不同的是，slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">equal</span><span class=\"params\">(x, y []<span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(x) != <span class=\"built_in\">len</span>(y) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> x &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x[i] != y[i] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>slice唯一合法的比较操作是和nil比较，例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> summer == <span class=\"literal\">nil</span> &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>一个零值的slice等于nil。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的，例如<code>[]int&#123;&#125;</code>或<code>make([]int, 3)[3:]</code>。与任意类型的nil值一样，我们可以用[]int(nil)类型转换表达式来生成一个对应类型slice的nil值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s []<span class=\"keyword\">int</span>    <span class=\"comment\">// len(s) == 0, s == nil</span></span><br><span class=\"line\">s = <span class=\"literal\">nil</span>        <span class=\"comment\">// len(s) == 0, s == nil</span></span><br><span class=\"line\">s = []<span class=\"keyword\">int</span>(<span class=\"literal\">nil</span>) <span class=\"comment\">// len(s) == 0, s == nil</span></span><br><span class=\"line\">s = []<span class=\"keyword\">int</span>&#123;&#125;    <span class=\"comment\">// len(s) == 0, s != nil</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Map\">Map</h3>\n<p>在Go语言中，一个map就是一个哈希表的引用，map类型可以写为<code>map[K]V</code>，其中K和V分别对应key和value。map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在。虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做key类型则是一个坏的想法，正如第三章提到的，最坏的情况是可能出现的NaN和任何浮点数都不相等。对于V对应的value数据类型则没有任何的限制。</p>\n<p>内置的make函数可以创建一个map：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ages := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>) <span class=\"comment\">// mapping from strings to ints</span></span><br></pre></td></tr></table></figure>\n<p>使用内置的delete函数可以删除元素：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">delete</span>(ages, <span class=\"string\">&quot;alice&quot;</span>) <span class=\"comment\">// remove element ages[&quot;alice&quot;]</span></span><br></pre></td></tr></table></figure>\n<p>所有这些操作是安全的，即使这些元素不在map中也没有关系；如果一个查找失败将返回value类型对应的零值，例如，即使map中不存在“bob”下面的代码也可以正常工作，因为ages[“bob”]失败时将返回0。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ages[<span class=\"string\">&quot;bob&quot;</span>] = ages[<span class=\"string\">&quot;bob&quot;</span>] + <span class=\"number\">1</span> <span class=\"comment\">// happy birthday!</span></span><br></pre></td></tr></table></figure>\n<p>而且<code>x += y</code>和<code>x++</code>等简短赋值语法也可以用在map上，所以上面的代码可以改写成</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">ages[<span class=\"string\">&quot;bob&quot;</span>] += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>但是map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">_ = &amp;ages[<span class=\"string\">&quot;bob&quot;</span>] <span class=\"comment\">// compile error: cannot take address of map element</span></span><br></pre></td></tr></table></figure>\n<p>禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</p>\n<p>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key/value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序。下面是常见的处理方式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;sort&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> names []<span class=\"keyword\">string</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> name := <span class=\"keyword\">range</span> ages &#123;</span><br><span class=\"line\">    names = <span class=\"built_in\">append</span>(names, name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sort.Strings(names)</span><br><span class=\"line\"><span class=\"keyword\">for</span> _, name := <span class=\"keyword\">range</span> names &#123;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%s\\t%d\\n&quot;</span>, name, ages[name])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>map上的大部分操作，包括查找、删除、len和range循环都可以安全工作在nil值的map上，它们的行为和一个空的map类似。但是向一个nil值的map存入元素将导致一个panic异常。</p>\n<p>通过key作为索引下标来访问map将产生一个value。如果key在map中是存在的，那么将得到与key对应的value；如果key不存在，那么将得到value对应类型的零值，正如我们前面看到的ages[“bob”]那样。这个规则很实用，但是有时候可能需要知道对应的元素是否真的是在map之中。例如，如果元素类型是一个数字，你可能需要区分一个已经存在的0，和不存在而返回零值的0，可以像下面这样测试：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">age, ok := ages[<span class=\"string\">&quot;bob&quot;</span>]</span><br><span class=\"line\"><span class=\"keyword\">if</span> !ok &#123; <span class=\"comment\">/* &quot;bob&quot; is not a key in this map; age == 0. */</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>你会经常看到将这两个结合起来使用，像这样：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> age, ok := ages[<span class=\"string\">&quot;bob&quot;</span>]; !ok &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>\n<p>在这种场景下，map的下标语法将产生两个值；第二个是一个布尔值，用于报告元素是否真的存在。布尔变量一般命名为ok，特别适合马上用于if条件判断部分。</p>\n<p>有时候我们需要一个map或set的key是slice类型，但是map的key必须是可比较的类型，但是slice并不满足这个条件。不过，我们可以通过两个步骤绕过这个限制。第一步，定义一个辅助函数k，将slice转为map对应的string类型的key，确保只有x和y相等时k(x) == k(y)才成立。然后创建一个key为string类型的map，在每次对map操作时先用k辅助函数将slice转化为string类型。</p>\n<p>下面的例子演示了如何使用map来记录提交相同的字符串列表的次数。它使用了fmt.Sprintf函数将字符串列表转换为一个字符串以用于map的key，通过%q参数忠实地记录每个字符串元素的信息：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">k</span><span class=\"params\">(list []<span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123; <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;%q&quot;</span>, list) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Add</span><span class=\"params\">(list []<span class=\"keyword\">string</span>)</span></span>       &#123; m[k(list)]++ &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Count</span><span class=\"params\">(list []<span class=\"keyword\">string</span>)</span> <span class=\"title\">int</span></span> &#123; <span class=\"keyword\">return</span> m[k(list)] &#125;</span><br></pre></td></tr></table></figure>\n<p>使用同样的技术可以处理任何不可比较的key类型，而不仅仅是slice类型。这种技术对于想使用自定义key比较函数的时候也很有用，例如在比较字符串的时候忽略大小写。同时，辅助函数k(x)也不一定是字符串类型，它可以返回任何可比较的类型，例如整数、数组或结构体等。</p>\n<h3 id=\"结构体\">结构体</h3>\n<p>下面两个语句声明了一个叫Employee的命名的结构体类型，并且声明了一个Employee类型的变量dilbert：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Employee <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ID        <span class=\"keyword\">int</span></span><br><span class=\"line\">    Name      <span class=\"keyword\">string</span></span><br><span class=\"line\">    Address   <span class=\"keyword\">string</span></span><br><span class=\"line\">    DoB       time.Time</span><br><span class=\"line\">    Position  <span class=\"keyword\">string</span></span><br><span class=\"line\">    Salary    <span class=\"keyword\">int</span></span><br><span class=\"line\">    ManagerID <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dilbert Employee</span><br></pre></td></tr></table></figure>\n<p>下面的EmployeeByID函数将根据给定的员工ID返回对应的员工信息结构体的指针。我们可以使用点操作符来访问它里面的成员：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">EmployeeByID</span><span class=\"params\">(id <span class=\"keyword\">int</span>)</span> *<span class=\"title\">Employee</span></span> &#123; <span class=\"comment\">/* ... */</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(EmployeeByID(dilbert.ManagerID).Position) <span class=\"comment\">// &quot;Pointy-haired boss&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">id := dilbert.ID</span><br><span class=\"line\">EmployeeByID(id).Salary = <span class=\"number\">0</span> <span class=\"comment\">// fired for... no real reason</span></span><br></pre></td></tr></table></figure>\n<p>后面的语句通过EmployeeByID返回的结构体指针更新了Employee结构体的成员。如果将EmployeeByID函数的返回值从*Employee指针类型改为Employee值类型，那么更新语句将不能编译通过，因为在赋值语句的左边并不确定是一个变量（译注：调用函数返回的是值，并不是一个可取地址的变量）。</p>\n<p>通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话可以被合并到一行，就像下面的Name和Address成员那样：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Employee <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ID            <span class=\"keyword\">int</span></span><br><span class=\"line\">    Name, Address <span class=\"keyword\">string</span></span><br><span class=\"line\">    DoB           time.Time</span><br><span class=\"line\">    Position      <span class=\"keyword\">string</span></span><br><span class=\"line\">    Salary        <span class=\"keyword\">int</span></span><br><span class=\"line\">    ManagerID     <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结构体成员的输入顺序也有重要的意义。我们也可以将Position成员合并（因为也是字符串类型），或者是交换Name和Address出现的先后顺序，那样的话就是定义了不同的结构体类型。通常，我们只是将相关的成员写到一起。</p>\n<p>如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。</p>\n<p>一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适用于数组。）但是S类型的结构体可以包含*S指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。在下面的代码中，我们使用一个二叉树来实现一个插入排序：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> tree <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    value       <span class=\"keyword\">int</span></span><br><span class=\"line\">    left, right *tree</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Sort sorts values in place.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Sort</span><span class=\"params\">(values []<span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> root *tree</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> values &#123;</span><br><span class=\"line\">        root = add(root, v)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    appendValues(values[:<span class=\"number\">0</span>], root)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// appendValues appends the elements of t to values in order</span></span><br><span class=\"line\"><span class=\"comment\">// and returns the resulting slice.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">appendValues</span><span class=\"params\">(values []<span class=\"keyword\">int</span>, t *tree)</span> []<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        values = appendValues(values, t.left)</span><br><span class=\"line\">        values = <span class=\"built_in\">append</span>(values, t.value)</span><br><span class=\"line\">        values = appendValues(values, t.right)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> values</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">add</span><span class=\"params\">(t *tree, value <span class=\"keyword\">int</span>)</span> *<span class=\"title\">tree</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> t == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Equivalent to return &amp;tree&#123;value: value&#125;.</span></span><br><span class=\"line\">        t = <span class=\"built_in\">new</span>(tree)</span><br><span class=\"line\">        t.value = value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> value &lt; t.value &#123;</span><br><span class=\"line\">        t.left = add(t.left, value)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        t.right = add(t.right, value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"结构体字面值\">结构体字面值</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span>&#123; X, Y <span class=\"keyword\">int</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有两种形式的结构体字面值语法，上面的是第一种写法，要求以结构体成员定义的顺序为每个结构体成员指定一个字面值。它要求写代码和读代码的人要记住结构体的每个成员的类型和顺序，不过结构体成员有细微的调整就可能导致上述代码不能编译。因此，上述的语法一般只在定义结构体的包内部使用，或者是在较小的结构体中使用，这些结构体的成员排列比较规则，比如image.Point{x, y}或color.RGBA{red, green, blue, alpha}。</p>\n<p>其实更常用的是第二种写法，以成员名字和相应的值来初始化，可以包含部分或全部的成员，如1.4节的Lissajous程序的写法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">anim := gif.GIF&#123;LoopCount: nframes&#125;</span><br></pre></td></tr></table></figure>\n<p>两种不同形式的写法不能混合使用。而且，你不能企图在外部包中用第一种顺序赋值的技巧来偷偷地初始化结构体中未导出的成员。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> p</span><br><span class=\"line\"><span class=\"keyword\">type</span> T <span class=\"keyword\">struct</span>&#123; a, b <span class=\"keyword\">int</span> &#125; <span class=\"comment\">// a and b are not exported</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> q</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;p&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> _ = p.T&#123;a: <span class=\"number\">1</span>, b: <span class=\"number\">2</span>&#125; <span class=\"comment\">// compile error: can&#x27;t reference a, b</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> _ = p.T&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;       <span class=\"comment\">// compile error: can&#x27;t reference a, b</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"结构体比较\">结构体比较</h4>\n<p>如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用==或!=运算符进行比较。相等比较运算符==将比较两个结构体的每个成员，因此下面两个比较的表达式是等价的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span>&#123; X, Y <span class=\"keyword\">int</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">p := Point&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">q := Point&#123;<span class=\"number\">2</span>, <span class=\"number\">1</span>&#125;</span><br><span class=\"line\">fmt.Println(p.X == q.X &amp;&amp; p.Y == q.Y) <span class=\"comment\">// &quot;false&quot;</span></span><br><span class=\"line\">fmt.Println(p == q)                   <span class=\"comment\">// &quot;false&quot;</span></span><br></pre></td></tr></table></figure>\n<p>可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> address <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    hostname <span class=\"keyword\">string</span></span><br><span class=\"line\">    port     <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hits := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[address]<span class=\"keyword\">int</span>)</span><br><span class=\"line\">hits[address&#123;<span class=\"string\">&quot;golang.org&quot;</span>, <span class=\"number\">443</span>&#125;]++</span><br></pre></td></tr></table></figure>\n<h4 id=\"结构体嵌入和匿名成员\">结构体嵌入和匿名成员</h4>\n<p>在本节中，我们将看到如何使用Go语言提供的不同寻常的结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，这样就可以通过简单的点运算符x.f来访问匿名成员链中嵌套的x.d.e.f成员。</p>\n<p>考虑一个二维的绘图程序，提供了一个各种图形的库，例如矩形、椭圆形、星形和轮形等几何形状。这里是其中两个的定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    X, Y, Radius <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Wheel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    X, Y, Radius, Spokes <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个Circle代表的圆形类型包含了标准圆心的X和Y坐标信息，和一个Radius表示的半径信息。一个Wheel轮形除了包含Circle类型所有的全部成员外，还增加了Spokes表示径向辐条的数量。我们可以这样创建一个wheel变量：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> w Wheel</span><br><span class=\"line\">w.X = <span class=\"number\">8</span></span><br><span class=\"line\">w.Y = <span class=\"number\">8</span></span><br><span class=\"line\">w.Radius = <span class=\"number\">5</span></span><br><span class=\"line\">w.Spokes = <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<p>随着库中几何形状数量的增多，我们一定会注意到它们之间的相似和重复之处，所以我们可能为了便于维护而将相同的属性独立出来：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Point <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    X, Y <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Center Point</span><br><span class=\"line\">    Radius <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Wheel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Circle Circle</span><br><span class=\"line\">    Spokes <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样改动之后结构体类型变的清晰了，但是这种修改同时也导致了访问每个成员变得繁琐：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> w Wheel</span><br><span class=\"line\">w.Circle.Center.X = <span class=\"number\">8</span></span><br><span class=\"line\">w.Circle.Center.Y = <span class=\"number\">8</span></span><br><span class=\"line\">w.Circle.Radius = <span class=\"number\">5</span></span><br><span class=\"line\">w.Spokes = <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<p>Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。下面的代码中，Circle和Wheel各自都有一个匿名成员。我们可以说Point类型被嵌入到了Circle结构体，同时Circle类型被嵌入到了Wheel结构体。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Circle <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Point</span><br><span class=\"line\">    Radius <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Wheel <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Circle</span><br><span class=\"line\">    Spokes <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>得益于匿名嵌入的特性，我们可以直接访问叶子属性而不需要给出完整的路径：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> w Wheel</span><br><span class=\"line\">w.X = <span class=\"number\">8</span>            <span class=\"comment\">// equivalent to w.Circle.Point.X = 8</span></span><br><span class=\"line\">w.Y = <span class=\"number\">8</span>            <span class=\"comment\">// equivalent to w.Circle.Point.Y = 8</span></span><br><span class=\"line\">w.Radius = <span class=\"number\">5</span>       <span class=\"comment\">// equivalent to w.Circle.Radius = 5</span></span><br><span class=\"line\">w.Spokes = <span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<p>在右边的注释中给出的显式形式访问这些叶子成员的语法依然有效，因此匿名成员并不是真的无法访问了。其中匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。我们在访问子成员的时候可以忽略任何匿名成员部分。</p>\n<p>不幸的是，结构体字面值并没有简短表示匿名成员的语法， 因此下面的语句都不能编译通过：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">w = Wheel&#123;<span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">5</span>, <span class=\"number\">20</span>&#125;                       <span class=\"comment\">// compile error: unknown fields</span></span><br><span class=\"line\">w = Wheel&#123;X: <span class=\"number\">8</span>, Y: <span class=\"number\">8</span>, Radius: <span class=\"number\">5</span>, Spokes: <span class=\"number\">20</span>&#125; <span class=\"comment\">// compile error: unknown fields</span></span><br></pre></td></tr></table></figure>\n<p>结构体字面值必须遵循形状类型声明时的结构，所以我们只能用下面的两种语法，它们彼此是等价的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">w = Wheel&#123;Circle&#123;Point&#123;<span class=\"number\">8</span>, <span class=\"number\">8</span>&#125;, <span class=\"number\">5</span>&#125;, <span class=\"number\">20</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">w = Wheel&#123;</span><br><span class=\"line\">    Circle: Circle&#123;</span><br><span class=\"line\">        Point:  Point&#123;X: <span class=\"number\">8</span>, Y: <span class=\"number\">8</span>&#125;,</span><br><span class=\"line\">        Radius: <span class=\"number\">5</span>,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Spokes: <span class=\"number\">20</span>, <span class=\"comment\">// <span class=\"doctag\">NOTE:</span> trailing comma necessary here (and at Radius)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%#v\\n&quot;</span>, w)</span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">w.X = <span class=\"number\">42</span></span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%#v\\n&quot;</span>, w)</span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// Wheel&#123;Circle:Circle&#123;Point:Point&#123;X:42, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span></span><br></pre></td></tr></table></figure>\n<p>需要注意的是Printf函数中%v参数包含的#副词，它表示用和Go语言类似的语法打印值。对于结构体类型来说，将包含每个成员的名字。</p>\n<p>因为匿名成员也有一个隐式的名字，因此不能同时包含两个类型相同的匿名成员，这会导致名字冲突。同时，因为成员的名字是由其类型隐式地决定的，所以匿名成员也有可见性的规则约束。在上面的例子中，Point和Circle匿名成员都是导出的。即使它们不导出（比如改成小写字母开头的point和circle），我们依然可以用简短形式访问匿名成员嵌套的成员</p>\n<p>到目前为止，我们看到匿名成员特性只是对访问嵌套成员的点运算符提供了简短的语法糖。稍后，我们将会看到匿名成员并不要求是结构体类型；其实任何命名的类型都可以作为结构体的匿名成员。但是为什么要嵌入一个没有任何子成员类型的匿名成员类型呢？</p>\n<p>答案是匿名类型的方法集。简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访问它们的方法。实际上，外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。这个机制可以用于将一些有简单行为的对象组合成有复杂行为的对象。组合是Go语言中面向对象编程的核心，我们将在6.3节中专门讨论。</p>\n<h3 id=\"JSON\">JSON</h3>\n<p>JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。在类似的协议中，JSON并不是唯一的一个标准协议。 XML（§7.14）、ASN.1和Google的Protocol Buffers都是类似的协议，并且有各自的特色，但是由于简洁性、可读性和流行程度等原因，JSON是应用最广泛的一个。</p>\n<p>基本的JSON类型有数字（十进制或科学记数法）、布尔值（true或false）、字符串，其中字符串是以双引号包含的Unicode字符序列，支持和Go语言类似的反斜杠转义特性，不过JSON使用的是<code>\\Uhhhh</code>转义数字来表示一个UTF-16编码（译注：UTF-16和UTF-8一样是一种变长的编码，有些Unicode码点较大的字符需要用4个字节表示；而且UTF-16还有大端和小端的问题），而不是Go语言的rune类型。</p>\n<p>这些基础类型可以通过JSON的数组和对象类型进行递归组合。一个JSON数组是一个有序的值序列，写在一个方括号中并以逗号分隔；一个JSON数组可以用于编码Go语言的数组和slice。一个JSON对象是一个字符串到值的映射，写成一系列的name:value对形式，用花括号包含并以逗号分隔；JSON的对象类型可以用于编码Go语言的map类型（key类型是字符串）和结构体。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">boolean         <span class=\"literal\">true</span></span><br><span class=\"line\">number          <span class=\"number\">-273.15</span></span><br><span class=\"line\"><span class=\"keyword\">string</span>          <span class=\"string\">&quot;She said \\&quot;Hello, BF\\&quot;&quot;</span></span><br><span class=\"line\">array           [<span class=\"string\">&quot;gold&quot;</span>, <span class=\"string\">&quot;silver&quot;</span>, <span class=\"string\">&quot;bronze&quot;</span>]</span><br><span class=\"line\">object          &#123;<span class=\"string\">&quot;year&quot;</span>: <span class=\"number\">1980</span>,</span><br><span class=\"line\">                 <span class=\"string\">&quot;event&quot;</span>: <span class=\"string\">&quot;archery&quot;</span>,</span><br><span class=\"line\">                 <span class=\"string\">&quot;medals&quot;</span>: [<span class=\"string\">&quot;gold&quot;</span>, <span class=\"string\">&quot;silver&quot;</span>, <span class=\"string\">&quot;bronze&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>\n<p>考虑一个应用程序，该程序负责收集各种电影评论并提供反馈功能。它的Movie数据类型和一个典型的表示电影的值列表如下所示。（在结构体声明中，Year和Color成员后面的字符串面值是结构体成员Tag；我们稍后会解释它的作用。）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Movie <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Title  <span class=\"keyword\">string</span></span><br><span class=\"line\">    Year   <span class=\"keyword\">int</span>  <span class=\"string\">`json:&quot;released&quot;`</span></span><br><span class=\"line\">    Color  <span class=\"keyword\">bool</span> <span class=\"string\">`json:&quot;color,omitempty&quot;`</span></span><br><span class=\"line\">    Actors []<span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> movies = []Movie&#123;</span><br><span class=\"line\">    &#123;Title: <span class=\"string\">&quot;Casablanca&quot;</span>, Year: <span class=\"number\">1942</span>, Color: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        Actors: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;Humphrey Bogart&quot;</span>, <span class=\"string\">&quot;Ingrid Bergman&quot;</span>&#125;&#125;,</span><br><span class=\"line\">    &#123;Title: <span class=\"string\">&quot;Cool Hand Luke&quot;</span>, Year: <span class=\"number\">1967</span>, Color: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        Actors: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;Paul Newman&quot;</span>&#125;&#125;,</span><br><span class=\"line\">    &#123;Title: <span class=\"string\">&quot;Bullitt&quot;</span>, Year: <span class=\"number\">1968</span>, Color: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        Actors: []<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;Steve McQueen&quot;</span>, <span class=\"string\">&quot;Jacqueline Bisset&quot;</span>&#125;&#125;,</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的数据结构特别适合JSON格式，并且在两者之间相互转换也很容易。将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）。编组通过调用json.Marshal函数完成：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">data, err := json.Marshal(movies)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">&quot;JSON marshaling failed: %s&quot;</span>, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%s\\n&quot;</span>, data)</span><br></pre></td></tr></table></figure>\n<p>Marshal函数返回一个编码后的字节slice，包含很长的字符串，并且没有空白缩进；我们将它折行以便于显示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">[&#123;<span class=\"string\">&quot;Title&quot;</span>:<span class=\"string\">&quot;Casablanca&quot;</span>,<span class=\"string\">&quot;released&quot;</span>:<span class=\"number\">1942</span>,<span class=\"string\">&quot;Actors&quot;</span>:[<span class=\"string\">&quot;Humphrey Bogart&quot;</span>,<span class=\"string\">&quot;Ingr</span></span><br><span class=\"line\"><span class=\"string\">id Bergman&quot;</span>]&#125;,&#123;<span class=\"string\">&quot;Title&quot;</span>:<span class=\"string\">&quot;Cool Hand Luke&quot;</span>,<span class=\"string\">&quot;released&quot;</span>:<span class=\"number\">1967</span>,<span class=\"string\">&quot;color&quot;</span>:<span class=\"literal\">true</span>,<span class=\"string\">&quot;Ac</span></span><br><span class=\"line\"><span class=\"string\">tors&quot;</span>:[<span class=\"string\">&quot;Paul Newman&quot;</span>]&#125;,&#123;<span class=\"string\">&quot;Title&quot;</span>:<span class=\"string\">&quot;Bullitt&quot;</span>,<span class=\"string\">&quot;released&quot;</span>:<span class=\"number\">1968</span>,<span class=\"string\">&quot;color&quot;</span>:<span class=\"literal\">true</span>,<span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">Actors&quot;</span>:[<span class=\"string\">&quot;Steve McQueen&quot;</span>,<span class=\"string\">&quot;Jacqueline Bisset&quot;</span>]&#125;]</span><br></pre></td></tr></table></figure>\n<p>这种紧凑的表示形式虽然包含了全部的信息，但是很难阅读。为了生成便于阅读的格式，另一个json.MarshalIndent函数将产生整齐缩进的输出。该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">data, err := json.MarshalIndent(movies, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;    &quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">&quot;JSON marshaling failed: %s&quot;</span>, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Printf(<span class=\"string\">&quot;%s\\n&quot;</span>, data)</span><br></pre></td></tr></table></figure>\n<p>上面的代码将产生这样的输出（译注：在最后一个成员或元素后面并没有逗号分隔符）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;Title&quot;</span>: <span class=\"string\">&quot;Casablanca&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;released&quot;</span>: <span class=\"number\">1942</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Actors&quot;</span>: [</span><br><span class=\"line\">            <span class=\"string\">&quot;Humphrey Bogart&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;Ingrid Bergman&quot;</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;Title&quot;</span>: <span class=\"string\">&quot;Cool Hand Luke&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;released&quot;</span>: <span class=\"number\">1967</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;color&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Actors&quot;</span>: [</span><br><span class=\"line\">            <span class=\"string\">&quot;Paul Newman&quot;</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;Title&quot;</span>: <span class=\"string\">&quot;Bullitt&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;released&quot;</span>: <span class=\"number\">1968</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;color&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Actors&quot;</span>: [</span><br><span class=\"line\">            <span class=\"string\">&quot;Steve McQueen&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;Jacqueline Bisset&quot;</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术，我们将在12.6节讨论）。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。</p>\n<p>细心的读者可能已经注意到，其中Year名字的成员在编码后变成了released，还有Color成员编码后变成了小写字母开头的color。这是因为结构体成员Tag所导致的。一个结构体成员Tag是和在编译阶段关联到该成员的元信息字符串：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">Year  <span class=\"keyword\">int</span>  <span class=\"string\">`json:&quot;released&quot;`</span></span><br><span class=\"line\">Color <span class=\"keyword\">bool</span> <span class=\"string\">`json:&quot;color,omitempty&quot;`</span></span><br></pre></td></tr></table></figure>\n<p>结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:&quot;value&quot;键值对序列；因为值中含有双引号字符，因此成员Tag一般用原生字符串面值的形式书写。json开头键名对应的值用于控制encoding/json包的编码和解码的行为，并且encoding/…下面其它的包也遵循这个约定。成员Tag中json对应值的第一部分用于指定JSON对象的名字，比如将Go语言中的TotalCount成员对应到JSON中的total_count对象。Color成员的Tag还带了一个额外的omitempty选项，表示当Go语言结构体成员为空或零值时不生成该JSON对象（这里false为零值）。果然，Casablanca是一个黑白电影，并没有输出Color成员。</p>\n<p>编码的逆操作是解码，对应将JSON数据解码为Go语言的数据结构，Go语言中一般叫unmarshaling，通过json.Unmarshal函数完成。下面的代码将JSON格式的电影数据解码为一个结构体slice，结构体中只有Title成员。通过定义合适的Go语言数据结构，我们可以选择性地解码JSON中感兴趣的成员。当Unmarshal函数调用返回，slice将被只含有Title信息的值填充，其它JSON成员将被忽略。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> titles []<span class=\"keyword\">struct</span>&#123; Title <span class=\"keyword\">string</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> err := json.Unmarshal(data, &amp;titles); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    log.Fatalf(<span class=\"string\">&quot;JSON unmarshaling failed: %s&quot;</span>, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fmt.Println(titles) <span class=\"comment\">// &quot;[&#123;Casablanca&#125; &#123;Cool Hand Luke&#125; &#123;Bullitt&#125;]&quot;</span></span><br></pre></td></tr></table></figure>\n<p>许多web服务都提供JSON接口，通过HTTP接口发送JSON格式请求并返回JSON格式的信息。为了说明这一点，我们通过Github的issue查询服务来演示类似的用法。首先，我们要定义合适的类型和常量：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Package github provides a Go API for the GitHub issue tracker.</span></span><br><span class=\"line\"><span class=\"comment\">// See https://developer.github.com/v3/search/#search-issues.</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> github</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;time&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> IssuesURL = <span class=\"string\">&quot;https://api.github.com/search/issues&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> IssuesSearchResult <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    TotalCount <span class=\"keyword\">int</span> <span class=\"string\">`json:&quot;total_count&quot;`</span></span><br><span class=\"line\">    Items          []*Issue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Issue <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Number    <span class=\"keyword\">int</span></span><br><span class=\"line\">    HTMLURL   <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;html_url&quot;`</span></span><br><span class=\"line\">    Title     <span class=\"keyword\">string</span></span><br><span class=\"line\">    State     <span class=\"keyword\">string</span></span><br><span class=\"line\">    User      *User</span><br><span class=\"line\">    CreatedAt time.Time <span class=\"string\">`json:&quot;created_at&quot;`</span></span><br><span class=\"line\">    Body      <span class=\"keyword\">string</span>    <span class=\"comment\">// in Markdown format</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> User <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Login   <span class=\"keyword\">string</span></span><br><span class=\"line\">    HTMLURL <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;html_url&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和前面一样，即使对应的JSON对象名是小写字母，每个结构体的成员名也是声明为大写字母开头的。因为有些JSON成员名字和Go结构体成员名字并不相同，因此需要Go语言结构体成员Tag来指定对应的JSON名字。同样，在解码的时候也需要做同样的处理，GitHub服务返回的信息比我们定义的要多很多。</p>\n<p>SearchIssues函数发出一个HTTP请求，然后解码返回的JSON格式的结果。因为用户提供的查询条件可能包含类似?和&amp;之类的特殊字符，为了避免对URL造成冲突，我们用url.QueryEscape来对查询中的特殊字符进行转义操作。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> github</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/url&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// SearchIssues queries the GitHub issue tracker.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">SearchIssues</span><span class=\"params\">(terms []<span class=\"keyword\">string</span>)</span> <span class=\"params\">(*IssuesSearchResult, error)</span></span> &#123;</span><br><span class=\"line\">    q := url.QueryEscape(strings.Join(terms, <span class=\"string\">&quot; &quot;</span>))</span><br><span class=\"line\">    resp, err := http.Get(IssuesURL + <span class=\"string\">&quot;?q=&quot;</span> + q)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// We must close resp.Body on all execution paths.</span></span><br><span class=\"line\">    <span class=\"comment\">// (Chapter 5 presents &#x27;defer&#x27;, which makes this simpler.)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> resp.StatusCode != http.StatusOK &#123;</span><br><span class=\"line\">        resp.Body.Close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;search query failed: %s&quot;</span>, resp.Status)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> result IssuesSearchResult</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;result); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        resp.Body.Close()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    resp.Body.Close()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;result, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在早些的例子中，我们使用了json.Unmarshal函数来将JSON格式的字符串解码为字节slice。但是这个例子中，我们使用了基于流式的解码器json.Decoder，它可以从一个输入流解码JSON数据，尽管这不是必须的。如您所料，还有一个针对输出流的json.Encoder编码对象。</p>\n<p>我们调用Decode方法来填充变量。这里有多种方法可以格式化结构。下面是最简单的一种，以一个固定宽度打印每个issue，但是在下一节我们将看到如何利用模板来输出复杂的格式。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Issues prints a table of GitHub issues matching the search terms.</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;gopl.io/ch4/github&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    result, err := github.SearchIssues(os.Args[<span class=\"number\">1</span>:])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;%d issues:\\n&quot;</span>, result.TotalCount)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, item := <span class=\"keyword\">range</span> result.Items &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;#%-5d %9.9s %.55s\\n&quot;</span>,</span><br><span class=\"line\">            item.Number, item.User.Login, item.Title)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过命令行参数指定检索条件。下面的命令是查询Go语言项目中和JSON解码相关的问题，还有查询返回的结果：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">go</span> build gopl.io/ch4/issues</span><br><span class=\"line\">$ ./issues repo:golang/<span class=\"keyword\">go</span> is:open json decoder</span><br><span class=\"line\"><span class=\"number\">13</span> issues:</span><br><span class=\"line\">#<span class=\"number\">5680</span>    eaigner encoding/json: set key converter on en/decoder</span><br><span class=\"line\">#<span class=\"number\">6050</span>  gopherbot encoding/json: provide tokenizer</span><br><span class=\"line\">#<span class=\"number\">8658</span>  gopherbot encoding/json: use bufio</span><br><span class=\"line\">#<span class=\"number\">8462</span>  kortschak encoding/json: UnmarshalText confuses json.Unmarshal</span><br><span class=\"line\">#<span class=\"number\">5901</span>        rsc encoding/json: allow override <span class=\"keyword\">type</span> marshaling</span><br><span class=\"line\">#<span class=\"number\">9812</span>  klauspost encoding/json: <span class=\"keyword\">string</span> tag not symmetric</span><br><span class=\"line\">#<span class=\"number\">7872</span>  extempora encoding/json: Encoder internally buffers full output</span><br><span class=\"line\">#<span class=\"number\">9650</span>    cespare encoding/json: Decoding gives errPhase when unmarshalin</span><br><span class=\"line\">#<span class=\"number\">6716</span>  gopherbot encoding/json: include field name in unmarshal error me</span><br><span class=\"line\">#<span class=\"number\">6901</span>  lukescott encoding/json, encoding/xml: option to treat unknown fi</span><br><span class=\"line\">#<span class=\"number\">6384</span>    joeshaw encoding/json: encode precise floating point integers u</span><br><span class=\"line\">#<span class=\"number\">6647</span>    btracey x/tools/cmd/godoc: display <span class=\"keyword\">type</span> kind of each named <span class=\"keyword\">type</span></span><br><span class=\"line\">#<span class=\"number\">4237</span>  gjemiller encoding/base64: URLEncoding padding is optional</span><br></pre></td></tr></table></figure>","categories":["go"]},{"title":"kaggle数据集上传到colab","url":"/2022/01/20/kaggle%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%8A%E4%BC%A0%E5%88%B0colab/","content":"<p>在colab上依次运行下面的命令</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">!pip install kaggle</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\">token=&#123;<span class=\"string\">&quot;username&quot;</span>:<span class=\"string\">&quot;xxxxx&quot;</span>,<span class=\"string\">&quot;key&quot;</span>:<span class=\"string\">&quot;xxxxx&quot;</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;./content/kaggle.json&#x27;</span>,<span class=\"string\">&#x27;w&#x27;</span>) <span class=\"keyword\">as</span> file:</span><br><span class=\"line\">    json.dump(token,file)</span><br></pre></td></tr></table></figure>\n<p>token中的键值对对应的是自己的账号内容，具体操作：</p>\n<ol>\n<li>进入kaggle，点击头像，点击myaccount</li>\n<li>往下拖，点击API栏中的Creat New API token，会自动生成一个json文件</li>\n<li>将json文件中的username和key对应填写到上面代码中</li>\n</ol>\n<p>接下来，依次运行下面的代码</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">-mkdir -p ~/.kaggle</span><br><span class=\"line\">!cp /content/kaggle.json ~/.kaggle</span><br><span class=\"line\">!chmod <span class=\"number\">600</span> ~/.kaggle/kaggle.json</span><br><span class=\"line\">!kaggle config <span class=\"built_in\">set</span> -n path -v /content</span><br></pre></td></tr></table></figure>\n<p>找到我们需要的kaggle数据集的API后，复制执行</p>\n","categories":["DeepLearning"],"tags":["colab,kaggle"]},{"title":"从零实现一个go web框架：Gee","url":"/2022/03/27/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAgo-web%E6%A1%86%E6%9E%B6%EF%BC%9AGee/","content":"<h2 id=\"http-Handler\">http.Handler</h2>\n<h3 id=\"实现http-Handler接口\">实现http.Handler接口</h3>\n<p>首先我们看<code>net/http</code>源码中对Handler的定义，发现只要实现了ServeHTTP方法就Handler</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> http</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    ServeHTTP(w ResponseWriter, r *Request)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">(address <span class=\"keyword\">string</span>, h Handler)</span> <span class=\"title\">error</span></span></span><br></pre></td></tr></table></figure>\n<p>那接下来我们用自己的方法实现</p>\n<span id=\"more\"></span>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Engine is the uni handler for all requests</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Engine <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> req.URL.Path &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">        fmt.Fprintf(w, <span class=\"string\">&quot;URL.Path = %q\\n&quot;</span>, req.URL.Path)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;/hello&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> req.Header &#123;</span><br><span class=\"line\">            fmt.Fprintf(w, <span class=\"string\">&quot;Header[%q] = %q\\n&quot;</span>, k, v)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        fmt.Fprintf(w, <span class=\"string\">&quot;404 NOT FOUND: %s\\n&quot;</span>, req.URL)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    engine := <span class=\"built_in\">new</span>(Engine)</span><br><span class=\"line\">    log.Fatal(http.ListenAndServe(<span class=\"string\">&quot;:9999&quot;</span>, engine))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>我们定义的一个空结构体<code>Engine</code>实现了<code>ServeHTTP</code>方法</li>\n<li>在main中，我们将自己创建的engine实例传入ListenAndServe函数中。这将所有的http请求都转接到了我们自己的处理逻辑上了。在之前，我们只能针对具体路由写处理逻辑。但是现在使用Engine，我们可以拦截所有http请求并且可以自由定义路由规则的映射</li>\n</ul>\n<h3 id=\"Gee框架的雏形\">Gee框架的雏形</h3>\n<p>接下来重新组织代码，搭建整个框架的雏形，最终代码目录结构如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">gee/</span><br><span class=\"line\">  |--gee.go</span><br><span class=\"line\">  |--go.mod</span><br><span class=\"line\">main.go</span><br><span class=\"line\">go.mod</span><br></pre></td></tr></table></figure>\n<p>然后需要修改go.mod文件，使用replace将gee指向<code>./gee</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">module example</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"number\">1.13</span></span><br><span class=\"line\"></span><br><span class=\"line\">require gee v0<span class=\"number\">.0</span><span class=\"number\">.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">replace gee =&gt; ./gee</span><br></pre></td></tr></table></figure>\n<h3 id=\"gee-go\">gee.go</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> gee</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义我们框架中需要使用的handler函数类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> HandlerFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Engine 实现ServeHTTP接口</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Engine <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\trouter <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]HandlerFunc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// New 用于新建一个gee.Engine</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span> *<span class=\"title\">Engine</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Engine&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]HandlerFunc),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">\tkey := req.Method + <span class=\"string\">&quot;-&quot;</span> + req.URL.Path</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> handler, ok := engine.router[key]; ok &#123;</span><br><span class=\"line\">\t\thandler(w, req)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tfmt.Fprintf(w, <span class=\"string\">&quot;404 NOT FOUND:%s\\n&quot;</span>, req.URL)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// addRoute 将路径和handler添加到engine中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">addRoute</span><span class=\"params\">(method <span class=\"keyword\">string</span>, pattern <span class=\"keyword\">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tkey := method + <span class=\"string\">&quot;-&quot;</span> + pattern</span><br><span class=\"line\">\tengine.router[key] = handler</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">GET</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tengine.addRoute(<span class=\"string\">&quot;GET&quot;</span>, pattern, handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">POST</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tengine.addRoute(<span class=\"string\">&quot;POST&quot;</span>, pattern, handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">Run</span><span class=\"params\">(addr <span class=\"keyword\">string</span>)</span> <span class=\"params\">(err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> http.ListenAndServe(<span class=\"string\">&quot;addr&quot;</span>, engine)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码是整章的重点：</p>\n<ul>\n<li>首先定义了<code>HandlerFunc</code>类型，提供给框架用户，用来定义路由映射的处理方法。我们在<code>Engine</code>中定义了一张路由映射表<code>router</code>，key由请求方法和静态路由地址构成，这样如果请求方法不同那么能够映射到不同的处理方法上，value是用户映射的处理方法。</li>\n<li>当用户调用<code>(*Engine).GET()</code>方法的时候会将处理方法和路由映射到router中</li>\n<li>Engine实现的ServeHTTP方法的作用就是解析请求的路径，查找路由映射表，有就执行，没有报404</li>\n</ul>\n<h3 id=\"main-go\">main.go</h3>\n<p>然后是写main函数测试我们这个框架到目前为止是否是有用的，基本和Gin框架是一样的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;base3/gee&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tr := gee.New()</span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t\tfmt.Fprintf(w, <span class=\"string\">&quot;URL.Path = %q\\n&quot;</span>, req.URL.Path)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/hello&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> req.Header &#123;</span><br><span class=\"line\">\t\t\tfmt.Fprintf(w, <span class=\"string\">&quot;Header[%q] = %q\\n&quot;</span>, k, v)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tr.Run(<span class=\"string\">&quot;:9999&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"上下文context\">上下文context</h2>\n<h3 id=\"设计context\">设计context</h3>\n<p>对于web服务来说，无非是根据请求构造响应，但是这两个对象提供的接口粒度太过于细致，比如我们构造一个完整的响应，需要考虑消息头和消息体，而header中包含了状态码、消息类型等几乎每次请求都需要设置的信息，因此如果不封装，会导致每次都要重复写大量的代码。我们用json数据作比较，感受下封装前后差距</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//封装前</span></span><br><span class=\"line\">obj = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;geektutu&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;password&quot;</span>: <span class=\"string\">&quot;1234&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">w.Header().Set(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/json&quot;</span>)</span><br><span class=\"line\">w.WriteHeader(http.StatusOK)</span><br><span class=\"line\">encoder := json.NewEncoder(w)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err := encoder.Encode(obj); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    http.Error(w, err.Error(), <span class=\"number\">500</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//封装后</span></span><br><span class=\"line\">c.JSON(http.StatusOK, gee.H&#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;username&quot;</span>: c.PostForm(<span class=\"string\">&quot;username&quot;</span>),</span><br><span class=\"line\">    <span class=\"string\">&quot;password&quot;</span>: c.PostForm(<span class=\"string\">&quot;password&quot;</span>),</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>针对使用场景，封装*http.Request和http.ResponseWriter的方法，简化相关接口的调用，只是设计 Context 的原因之一。对于框架来说，还需要支撑额外的功能。例如，将来解析动态路由/hello/:name，参数:name的值放在哪呢？再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？Context 随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由 Context 承载。因此，设计 Context 结构，扩展性和复杂性留在了内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件，参数都统一使用 Context 实例， Context 就像一次会话的百宝箱，可以找到任何东西。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> gee</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;encoding/json&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// H 是字符串-空接口映射的别名</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> H <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Context <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 基本部件</span></span><br><span class=\"line\">\tWriter http.ResponseWriter</span><br><span class=\"line\">\tReq    *http.Request</span><br><span class=\"line\">\t<span class=\"comment\">// 请求信息</span></span><br><span class=\"line\">\tPath   <span class=\"keyword\">string</span></span><br><span class=\"line\">\tMethod <span class=\"keyword\">string</span></span><br><span class=\"line\">\t<span class=\"comment\">// 返回信息</span></span><br><span class=\"line\">\tStatusCode <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// newContext 根绝输入的w和req返回一个Context的指针</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newContext</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span> *<span class=\"title\">Context</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Context&#123;</span><br><span class=\"line\">\t\tWriter: w,</span><br><span class=\"line\">\t\tReq:    req,</span><br><span class=\"line\">\t\tPath:   req.URL.Path,</span><br><span class=\"line\">\t\tMethod: req.Method,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PostForm 解析表单中的数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">PostForm</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.Req.FormValue(key)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Query 解析URL中指定的参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">Query</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.Req.URL.Query().Get(key)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Status 将状态码添加到context中，并且写入到返回头</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">Status</span><span class=\"params\">(code <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tc.StatusCode = code</span><br><span class=\"line\">\tc.Writer.WriteHeader(code)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// SetHeader 设置返回头中的键值对</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">SetHeader</span><span class=\"params\">(key <span class=\"keyword\">string</span>, value <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\tc.Writer.Header().Set(key, value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// String 返回是string类型的数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">String</span><span class=\"params\">(code <span class=\"keyword\">int</span>, format <span class=\"keyword\">string</span>, values ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tc.SetHeader(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;text/plain&quot;</span>)</span><br><span class=\"line\">\tc.Status(code)</span><br><span class=\"line\">\tc.Writer.Write([]<span class=\"keyword\">byte</span>(fmt.Sprintf(format, values...)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// JSON 返回编码好的json数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">JSON</span><span class=\"params\">(code <span class=\"keyword\">int</span>, obj <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tc.SetHeader(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/json&quot;</span>)</span><br><span class=\"line\">\tc.Status(code)</span><br><span class=\"line\">\tencoder := json.NewEncoder(c.Writer)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := encoder.Encode(obj); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\thttp.Error(c.Writer, err.Error(), <span class=\"number\">500</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Data 直接返回数据流</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">Data</span><span class=\"params\">(code <span class=\"keyword\">int</span>, data []<span class=\"keyword\">byte</span>)</span></span> &#123;</span><br><span class=\"line\">\tc.Status(code)</span><br><span class=\"line\">\tc.Writer.Write(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HTML 返回html数据，本质上也是将html转成[]byte数据流再传回去</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">HTML</span><span class=\"params\">(code <span class=\"keyword\">int</span>, html <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\tc.Status(code)</span><br><span class=\"line\">\tc.SetHeader(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;text/html&quot;</span>)</span><br><span class=\"line\">\tc.Writer.Write([]<span class=\"keyword\">byte</span>(html))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"路由\">路由</h3>\n<p>我们将和路由相关的方法和结构提取了出来，放到了一个新的文件中router.go，方便我们下一次对 router 的功能进行增强，例如提供动态路由的支持。 router 的 handle 方法作了一个细微的调整，即 handler 的参数，变成了 Context。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> gee</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> router <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\thandlers <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]HandlerFunc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// newRouter 创建一个新的router管理器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newRouter</span><span class=\"params\">()</span> *<span class=\"title\">router</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;router&#123;</span><br><span class=\"line\">\t\thandlers: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]HandlerFunc),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// addRoute 为路径管理器中的路径映射表添加映射</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *router)</span> <span class=\"title\">addRoute</span><span class=\"params\">(method <span class=\"keyword\">string</span>, pattern <span class=\"keyword\">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">&quot;Route %4s - %s&quot;</span>, method, pattern)</span><br><span class=\"line\">\tkey := method + <span class=\"string\">&quot;-&quot;</span> + pattern</span><br><span class=\"line\">\tr.handlers[key] = handler</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// handle 调用handler函数，如果存在的话</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *router)</span> <span class=\"title\">handle</span><span class=\"params\">(c *Context)</span></span> &#123;</span><br><span class=\"line\">\tkey := c.Method + <span class=\"string\">&quot;-&quot;</span> + c.Path</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> handler, ok := r.handlers[key]; ok &#123;</span><br><span class=\"line\">\t\thandler(c)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tc.String(http.StatusNotFound, <span class=\"string\">&quot;404 NOT FOUND:%s\\n&quot;</span>, c.Path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"框架入口\">框架入口</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> HandlerFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx *Context)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Engine <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\trouter *router</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// New 初始化一个新的Engine</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span> *<span class=\"title\">Engine</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Engine&#123;</span><br><span class=\"line\">\t\trouter: newRouter(),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">addRoute</span><span class=\"params\">(method <span class=\"keyword\">string</span>,pattern <span class=\"keyword\">string</span>,handler HandlerFunc)</span></span>&#123;</span><br><span class=\"line\">\tengine.router.addRoute(method,pattern,handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">GET</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>,handler HandlerFunc)</span></span>&#123;</span><br><span class=\"line\">\tengine.addRoute(<span class=\"string\">&quot;GET&quot;</span>,pattern,handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">POST</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>,handler HandlerFunc)</span></span>&#123;</span><br><span class=\"line\">\tengine.addRoute(<span class=\"string\">&quot;POST&quot;</span>,pattern,handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">Run</span><span class=\"params\">(addr <span class=\"keyword\">string</span>)</span> <span class=\"params\">(err error)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> http.ListenAndServe(addr,engine)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter,req *http.Request)</span></span>&#123;</span><br><span class=\"line\">\tc:=newContext(w,req)</span><br><span class=\"line\">\tengine.router.handle(c)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将router相关的代码独立后，gee.go简单了不少。最重要的还是通过实现了 ServeHTTP 接口，接管了所有的 HTTP 请求。相比第一天的代码，这个方法也有细微的调整，在调用 router.handle 之前，构造了一个 Context 对象。这个对象目前还非常简单，仅仅是包装了原来的两个参数，之后我们会慢慢地给Context插上翅膀。</p>\n<p>接下来写个main来试试看这个框架目前有没有用</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;context/gee&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tr := gee.New()</span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tctx.HTML(http.StatusOK, <span class=\"string\">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/hello&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tctx.String(http.StatusOK, <span class=\"string\">&quot;hello %s,you are at %s\\n&quot;</span>, ctx.Query(<span class=\"string\">&quot;name&quot;</span>), ctx.Path)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tr.POST(<span class=\"string\">&quot;/login&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tctx.JSON(http.StatusOK, gee.H&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;username&quot;</span>: ctx.PostForm(<span class=\"string\">&quot;username&quot;</span>),</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;password&quot;</span>: ctx.PostForm(<span class=\"string\">&quot;password&quot;</span>),</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\tr.Run(<span class=\"string\">&quot;:9999&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"前缀树路由router\">前缀树路由router</h2>\n<h3 id=\"Trie树简介\">Trie树简介</h3>\n<p>之前，我们用了一个非常简单的map结构存储了路由表，使用map存储键值对，索引非常高效，但是有一个弊端，键值对的存储的方式，只能用来索引静态路由。那如果我们想支持类似于/hello/:name这样的动态路由怎么办呢？所谓动态路由，即一条路由规则可以匹配某一类型而非某一条固定的路由。例如/hello/:name，可以匹配/hello/geektutu、hello/jack等。</p>\n<p><img src=\"https://i.imgur.com/8xaRXEv.png\" alt=\"picture 4\"></p>\n<p>实现动态路由最常用的数据结构，被称为前缀树(Trie树)。看到名字你大概也能知道前缀树长啥样了：每一个节点的所有的子节点都拥有相同的前缀。这种结构非常适用于路由匹配，比如我们定义了如下路由规则：</p>\n<ul>\n<li>/:lang/doc</li>\n<li>/:lang/tutorial</li>\n<li>/:lang/intro</li>\n<li>/about</li>\n<li>/p/blog</li>\n<li>/p/related</li>\n</ul>\n<p><img src=\"https://i.imgur.com/xeFRKUb.png\" alt=\"picture 5\"></p>\n<p>接下来我们实现的动态路由具备以下两个功能。</p>\n<ul>\n<li>参数匹配:。例如 /p/:lang/doc，可以匹配 /p/c/doc 和 /p/go/doc。</li>\n<li>通配*。例如 /static/*filepath，可以匹配/static/fav.ico，也可以匹配/static/js/jQuery.js，这种模式常用于静态服务器，能够递归地匹配子路径。</li>\n</ul>\n<h3 id=\"Trie树实现\">Trie树实现</h3>\n<p>首先我们需要设计树节点上应该存储那些信息。</p>\n<p>与普通的树不同，为了实现动态路由匹配，加上了isWild这个参数。即当我们匹配 /p/go/doc/这个路由时，第一层节点，p精准匹配到了p，第二层节点，go模糊匹配到:lang，那么将会把lang这个参数赋值为go，继续下一层匹配。我们将匹配的逻辑，包装为一个辅助函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> gee</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> node <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tpattern  <span class=\"keyword\">string</span>  <span class=\"comment\">//待匹配的路由 如 /p/:lang</span></span><br><span class=\"line\">\tpart     <span class=\"keyword\">string</span>  <span class=\"comment\">//路由中的一部分，例如 :lang</span></span><br><span class=\"line\">\tchildren []*node <span class=\"comment\">//子节点</span></span><br><span class=\"line\">\tisWild   <span class=\"keyword\">bool</span>    <span class=\"comment\">//是否精确匹配，part含有:或者*时为True</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// matchChild 第一个匹配成功的节点，用于插入</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n *node)</span> <span class=\"title\">matchChild</span><span class=\"params\">(part <span class=\"keyword\">string</span>)</span> *<span class=\"title\">node</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, child := <span class=\"keyword\">range</span> n.children &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> child.part == part || child.isWild &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> child</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// matchChildren 返回所有匹配成功的节点，用于查找</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n *node)</span> <span class=\"title\">matchChildren</span><span class=\"params\">(part <span class=\"keyword\">string</span>)</span> []*<span class=\"title\">node</span></span> &#123;</span><br><span class=\"line\">\tnodes := <span class=\"built_in\">make</span>([]*node, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, child := <span class=\"keyword\">range</span> n.children &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> child.part == part || child.isWild &#123;</span><br><span class=\"line\">\t\t\tnodes = <span class=\"built_in\">append</span>(nodes, child)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> nodes</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于路由来说，最重要的当然是注册与匹配了。开发服务时，注册路由规则，映射handler；访问时，匹配路由规则，查找到对应的handler。因此，Trie 树需要支持节点的插入与查询。插入功能很简单，递归查找每一层的节点，如果没有匹配到当前part的节点，则新建一个，有一点需要注意，/p/:lang/doc只有在第三层节点，即doc节点，pattern才会设置为/p/:lang/doc。p和:lang节点的pattern属性皆为空。因此，当匹配结束时，我们可以使用n.pattern == &quot;&quot;来判断路由规则是否匹配成功。例如，/p/python虽能成功匹配到:lang，但:lang的pattern值为空，因此匹配失败。查询功能，同样也是递归查询每一层的节点，退出规则是，匹配到了*，匹配失败，或者匹配到了第len(parts)层节点。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// insert 插入一个新的路径节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n *node)</span> <span class=\"title\">insert</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, parts []<span class=\"keyword\">string</span>, height <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(parts) == height &#123;</span><br><span class=\"line\">\t\tn.pattern = pattern</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpart := parts[height]</span><br><span class=\"line\">\tchild := n.matchChild(part)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> child == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tchild = &amp;node&#123;</span><br><span class=\"line\">\t\t\tpart:   part,</span><br><span class=\"line\">\t\t\tisWild: part[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;:&#x27;</span> || part[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;*&#x27;</span>,</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tn.children = <span class=\"built_in\">append</span>(n.children, child)</span><br><span class=\"line\"></span><br><span class=\"line\">\tchild.insert(pattern, parts, height+<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// search 搜索是否存在某个路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(n *node)</span> <span class=\"title\">search</span><span class=\"params\">(parts []<span class=\"keyword\">string</span>, height <span class=\"keyword\">int</span>)</span> *<span class=\"title\">node</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(parts) == height || strings.HasPrefix(n.part, <span class=\"string\">&quot;*&quot;</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> n.pattern == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpart := parts[height]</span><br><span class=\"line\">\tchildren := n.matchChildren(part)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, child := <span class=\"keyword\">range</span> children &#123;</span><br><span class=\"line\">\t\tresult := child.search(parts, height+<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> result != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> result</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Router\">Router</h3>\n<p>我们使用 roots 来存储每种请求方式的Trie 树根节点。使用 handlers 存储每种请求方式的 HandlerFunc 。getRoute 函数中，还解析了:和*两种匹配符的参数，返回一个 map 。例如/p/go/doc匹配到/p/:lang/doc，解析结果为：{lang: “go”}，/static/css/geektutu.css匹配到/static/*filepath，解析结果为{filepath: “css/geektutu.css”}。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> gee</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> router <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\troots    <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*node</span><br><span class=\"line\">\thandlers <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]HandlerFunc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// newRouter 创建一个新的router</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newRouter</span><span class=\"params\">()</span> *<span class=\"title\">router</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;router&#123;</span><br><span class=\"line\">\t\troots:    <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*node),</span><br><span class=\"line\">\t\thandlers: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]HandlerFunc),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// parsePattern 只允许出现一次*</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parsePattern</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>)</span> []<span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tvs := strings.Split(pattern, <span class=\"string\">&quot;/&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\tparts := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, item := <span class=\"keyword\">range</span> vs &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> item != <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t\tparts = <span class=\"built_in\">append</span>(parts, item)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> item[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;*&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> parts</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// addRoute 在router管理器中增加新的节点，并且增加新的路径-方法映射</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *router)</span> <span class=\"title\">addRoute</span><span class=\"params\">(method <span class=\"keyword\">string</span>, pattern <span class=\"keyword\">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tparts := parsePattern(pattern)</span><br><span class=\"line\"></span><br><span class=\"line\">\tkey := method + <span class=\"string\">&quot;-&quot;</span> + pattern</span><br><span class=\"line\">\t_, ok := r.roots[method]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\tr.roots[method] = &amp;node&#123;&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tr.roots[method].insert(pattern, parts, <span class=\"number\">0</span>)</span><br><span class=\"line\">\tr.handlers[key] = handler</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// getRoute 获取某个路径的叶子节点和对应的参数映射表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *router)</span> <span class=\"title\">getRoute</span><span class=\"params\">(method <span class=\"keyword\">string</span>, path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*node, <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\tsearchParts := parsePattern(path)</span><br><span class=\"line\">\tparams := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>)</span><br><span class=\"line\">\troot, ok := r.roots[method]</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tn := root.search(searchParts, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tparts := parsePattern(n.pattern)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> index, part := <span class=\"keyword\">range</span> parts &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> part[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;:&#x27;</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//将对应匹配到的参数记录下来（URL参数）</span></span><br><span class=\"line\">\t\t\t\tparams[part[<span class=\"number\">1</span>:]] = searchParts[index]</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> part[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;*&#x27;</span> &amp;&amp; <span class=\"built_in\">len</span>(part) &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\t\tparams[part[<span class=\"number\">1</span>:]] = strings.Join(searchParts[index:], <span class=\"string\">&quot;/&quot;</span>)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> n,params</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>,<span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"context和handle的变化\">context和handle的变化</h3>\n<p>在 HandlerFunc 中，希望能够访问到解析的参数，因此，需要对 Context 对象增加一个属性和方法，来提供对路由参数的访问。我们将解析后的参数存储到Params中，通过c.Param(“lang”)的方式获取到对应的值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//context的改动</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Context <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// origin objects</span></span><br><span class=\"line\">\tWriter http.ResponseWriter</span><br><span class=\"line\">\tReq    *http.Request</span><br><span class=\"line\">\t<span class=\"comment\">// request info</span></span><br><span class=\"line\">\tPath   <span class=\"keyword\">string</span></span><br><span class=\"line\">\tMethod <span class=\"keyword\">string</span></span><br><span class=\"line\">\tParams <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span></span><br><span class=\"line\">\t<span class=\"comment\">// response info</span></span><br><span class=\"line\">\tStatusCode <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">Param</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\tvalue, _ := c.Params[key]</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//router的改动</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *router)</span> <span class=\"title\">handle</span><span class=\"params\">(c *Context)</span></span> &#123;</span><br><span class=\"line\">\tn, params := r.getRoute(c.Method, c.Path)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tc.Params = params</span><br><span class=\"line\">\t\tkey := c.Method + <span class=\"string\">&quot;-&quot;</span> + n.pattern</span><br><span class=\"line\">\t\tr.handlers[key](c)</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tc.String(http.StatusNotFound, <span class=\"string\">&quot;404 NOT FOUND: %s\\n&quot;</span>, c.Path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"分组控制\">分组控制</h2>\n<p>分组控制(Group Control)是 Web 框架应提供的基础功能之一。所谓分组，是指路由的分组。如果没有路由分组，我们需要针对每一个路由进行控制。但是真实的业务场景中，往往某一组路由需要相似的处理。例如：</p>\n<ul>\n<li>以/post开头的路由匿名可访问。</li>\n<li>以/admin开头的路由需要鉴权。</li>\n<li>以/api开头的路由是 RESTful 接口，可以对接第三方平台，需要三方平台鉴权。</li>\n</ul>\n<p>大部分情况下的路由分组，是以相同的前缀来区分的。因此，我们今天实现的分组控制也是以前缀来区分，并且支持分组的嵌套。例如/post是一个分组，/post/a和/post/b可以是该分组下的子分组。作用在/post分组上的中间件(middleware)，也都会作用在子分组，子分组还可以应用自己特有的中间件。</p>\n<p>一个 Group 对象需要具备哪些属性呢？首先是前缀(prefix)，比如/，或者/api；要支持分组嵌套，那么需要知道当前分组的父亲(parent)是谁；当然了，按照我们一开始的分析，中间件是应用在分组上的，那还需要存储应用在该分组上的中间件(middlewares)。还记得，我们之前调用函数(*Engine).addRoute()来映射所有的路由规则和 Handler 。如果Group对象需要直接映射路由规则的话，比如我们想在使用框架时，这么调用：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">r := gee.New()</span><br><span class=\"line\">v1 := r.Group(<span class=\"string\">&quot;/v1&quot;</span>)</span><br><span class=\"line\">v1.GET(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\tc.HTML(http.StatusOK, <span class=\"string\">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>那么Group对象，还需要有访问Router的能力，为了方便，我们可以在Group中，保存一个指针，指向Engine，整个框架的所有资源都是由Engine统一协调的，那么就可以通过Engine间接地访问各种接口了。</p>\n<p>所以，最后的 Group 的定义是这样的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> (</span><br><span class=\"line\">\tRouterGroup <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t\tprefix      <span class=\"keyword\">string</span></span><br><span class=\"line\">\t\tmiddlewares []HandlerFunc <span class=\"comment\">// support middleware</span></span><br><span class=\"line\">\t\tparent      *RouterGroup  <span class=\"comment\">// support nesting</span></span><br><span class=\"line\">\t\tengine      *Engine       <span class=\"comment\">// all groups share a Engine instance</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tEngine <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t\t*RouterGroup</span><br><span class=\"line\">\t\trouter *router</span><br><span class=\"line\">\t\tgroups []*RouterGroup <span class=\"comment\">// store all groups</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>我们还可以进一步地抽象，将Engine作为最顶层的分组，也就是说Engine拥有RouterGroup所有的能力。</p>\n<p>那我们就可以将和路由有关的函数，都交给RouterGroup实现了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// New is the constructor of gee.Engine</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">()</span> *<span class=\"title\">Engine</span></span> &#123;</span><br><span class=\"line\">\tengine := &amp;Engine&#123;router: newRouter()&#125;</span><br><span class=\"line\">\tengine.RouterGroup = &amp;RouterGroup&#123;engine: engine&#125;</span><br><span class=\"line\">\tengine.groups = []*RouterGroup&#123;engine.RouterGroup&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> engine</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Group is defined to create a new RouterGroup</span></span><br><span class=\"line\"><span class=\"comment\">// remember all groups share the same Engine instance</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(group *RouterGroup)</span> <span class=\"title\">Group</span><span class=\"params\">(prefix <span class=\"keyword\">string</span>)</span> *<span class=\"title\">RouterGroup</span></span> &#123;</span><br><span class=\"line\">\tengine := group.engine</span><br><span class=\"line\">\tnewGroup := &amp;RouterGroup&#123;</span><br><span class=\"line\">\t\tprefix: group.prefix + prefix,</span><br><span class=\"line\">\t\tparent: group,</span><br><span class=\"line\">\t\tengine: engine,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tengine.groups = <span class=\"built_in\">append</span>(engine.groups, newGroup)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> newGroup</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(group *RouterGroup)</span> <span class=\"title\">addRoute</span><span class=\"params\">(method <span class=\"keyword\">string</span>, comp <span class=\"keyword\">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tpattern := group.prefix + comp</span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">&quot;Route %4s - %s&quot;</span>, method, pattern)</span><br><span class=\"line\">\tgroup.engine.router.addRoute(method, pattern, handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GET defines the method to add GET request</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(group *RouterGroup)</span> <span class=\"title\">GET</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tgroup.addRoute(<span class=\"string\">&quot;GET&quot;</span>, pattern, handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST defines the method to add POST request</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(group *RouterGroup)</span> <span class=\"title\">POST</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tgroup.addRoute(<span class=\"string\">&quot;POST&quot;</span>, pattern, handler)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tr := gee.New()</span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/index&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tc.HTML(http.StatusOK, <span class=\"string\">&quot;&lt;h1&gt;Index Page&lt;/h1&gt;&quot;</span>)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tv1 := r.Group(<span class=\"string\">&quot;/v1&quot;</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv1.GET(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\t\tc.HTML(http.StatusOK, <span class=\"string\">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tv1.GET(<span class=\"string\">&quot;/hello&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// expect /hello?name=geektutu</span></span><br><span class=\"line\">\t\t\tc.String(http.StatusOK, <span class=\"string\">&quot;hello %s, you&#x27;re at %s\\n&quot;</span>, c.Query(<span class=\"string\">&quot;name&quot;</span>), c.Path)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tv2 := r.Group(<span class=\"string\">&quot;/v2&quot;</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tv2.GET(<span class=\"string\">&quot;/hello/:name&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// expect /hello/geektutu</span></span><br><span class=\"line\">\t\t\tc.String(http.StatusOK, <span class=\"string\">&quot;hello %s, you&#x27;re at %s\\n&quot;</span>, c.Param(<span class=\"string\">&quot;name&quot;</span>), c.Path)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t\tv2.POST(<span class=\"string\">&quot;/login&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\t\tc.JSON(http.StatusOK, gee.H&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;username&quot;</span>: c.PostForm(<span class=\"string\">&quot;username&quot;</span>),</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">&quot;password&quot;</span>: c.PostForm(<span class=\"string\">&quot;password&quot;</span>),</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tr.Run(<span class=\"string\">&quot;:9999&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"中间件\">中间件</h2>\n<h3 id=\"中间件是什么\">中间件是什么</h3>\n<p>简单来说中间件就是非业务的技术类组件。因为框架不可能去理解所有的任务，不会实现所有功能，所以需要有一个插口让用户自己定义功能。需要考虑两个关键点：</p>\n<ul>\n<li>插入点在哪？使用框架的人并不关心底层逻辑的具体实现，如果插入点太底层，中间件逻辑就会非常复杂。如果插入点离用户太近，那和用户直接定义一组函数，每次在 Handler 中手工调用没有多大的优势了。</li>\n<li>中间件的输入是什么？中间件的输入，决定了扩展能力。暴露的参数太少，用户发挥空间有限。</li>\n</ul>\n<h3 id=\"中间件的设计\">中间件的设计</h3>\n<p>Gee 的中间件的定义与路由映射的 Handler 一致，处理的输入是Context对象。插入点是框架接收到请求初始化Context对象后，允许用户使用自己定义的中间件做一些额外的处理，例如记录日志等，以及对Context进行二次加工。另外通过调用(*Context).Next()函数，中间件可等待用户自己定义的 Handler处理结束后，再做一些额外的操作，例如计算本次处理所用时间等。即 Gee 的中间件支持用户在请求被处理的前后，做一些额外的操作。举个例子，我们希望最终能够支持如下定义的中间件，c.Next()表示等待执行其他的中间件或用户的Handler：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Logger</span><span class=\"params\">()</span> <span class=\"title\">HandlerFunc</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *Context)</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Start timer</span></span><br><span class=\"line\">\t\tt := time.Now()</span><br><span class=\"line\">\t\t<span class=\"comment\">// Process request</span></span><br><span class=\"line\">\t\tc.Next()</span><br><span class=\"line\">\t\t<span class=\"comment\">// Calculate resolution time</span></span><br><span class=\"line\">\t\tlog.Printf(<span class=\"string\">&quot;[%d] %s in %v&quot;</span>, c.StatusCode, c.Req.RequestURI, time.Since(t))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外要支持设置多个中间件，依次进行调用。</p>\n<p>我们之前的框架设计是这样的，当接收到请求后，匹配路由，该请求的所有信息都保存在Context中。中间件也不例外，接收到请求后，应查找所有应作用于该路由的中间件，保存在Context中，依次进行调用。为什么依次调用后，还需要在Context中保存呢？因为在设计中，中间件不仅作用在处理流程前，也可以作用在处理流程后，即在用户定义的 Handler 处理完毕后，还可以执行剩下的操作。</p>\n<p>为此，我们给Context添加了2个参数，定义了Next方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Context <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// origin objects</span></span><br><span class=\"line\">\tWriter http.ResponseWriter</span><br><span class=\"line\">\tReq    *http.Request</span><br><span class=\"line\">\t<span class=\"comment\">// request info</span></span><br><span class=\"line\">\tPath   <span class=\"keyword\">string</span></span><br><span class=\"line\">\tMethod <span class=\"keyword\">string</span></span><br><span class=\"line\">\tParams <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span></span><br><span class=\"line\">\t<span class=\"comment\">// response info</span></span><br><span class=\"line\">\tStatusCode <span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"comment\">// middleware</span></span><br><span class=\"line\">\thandlers []HandlerFunc</span><br><span class=\"line\">\tindex    <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newContext</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span> *<span class=\"title\">Context</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Context&#123;</span><br><span class=\"line\">\t\tPath:   req.URL.Path,</span><br><span class=\"line\">\t\tMethod: req.Method,</span><br><span class=\"line\">\t\tReq:    req,</span><br><span class=\"line\">\t\tWriter: w,</span><br><span class=\"line\">\t\tindex:  <span class=\"number\">-1</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">Next</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tc.index++</span><br><span class=\"line\">\ts := <span class=\"built_in\">len</span>(c.handlers)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> ; c.index &lt; s; c.index++ &#123;</span><br><span class=\"line\">\t\tc.handlers[c.index](c)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>index是记录当前执行到第几个中间件，当在中间件中调用Next方法时，控制权交给了下一个中间件，直到调用到最后一个中间件，然后再从后往前，调用每个中间件在Next方法之后定义的部分。</p>\n<h3 id=\"代码实现\">代码实现</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Use is defined to add middleware to the group</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(group *RouterGroup)</span> <span class=\"title\">Use</span><span class=\"params\">(middlewares ...HandlerFunc)</span></span> &#123;</span><br><span class=\"line\">\tgroup.middlewares = <span class=\"built_in\">append</span>(group.middlewares, middlewares...)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> middlewares []HandlerFunc</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, group := <span class=\"keyword\">range</span> engine.groups &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> strings.HasPrefix(req.URL.Path, group.prefix) &#123;</span><br><span class=\"line\">\t\t\tmiddlewares = <span class=\"built_in\">append</span>(middlewares, group.middlewares...)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc := newContext(w, req)</span><br><span class=\"line\">\tc.handlers = middlewares</span><br><span class=\"line\">\tengine.router.handle(c)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ServeHTTP 函数也有变化，当我们接收到一个具体请求时，要判断该请求适用于哪些中间件，在这里我们简单通过 URL 的前缀来判断。得到中间件列表后，赋值给 c.handlers。</p>\n<p>handle 函数中，将从路由匹配得到的 Handler 添加到 c.handlers列表中，执行c.Next()。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(r *router)</span> <span class=\"title\">handle</span><span class=\"params\">(c *Context)</span></span> &#123;</span><br><span class=\"line\">\tn, params := r.getRoute(c.Method, c.Path)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> n != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tkey := c.Method + <span class=\"string\">&quot;-&quot;</span> + n.pattern</span><br><span class=\"line\">\t\tc.Params = params</span><br><span class=\"line\">\t\tc.handlers = <span class=\"built_in\">append</span>(c.handlers, r.handlers[key])</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tc.handlers = <span class=\"built_in\">append</span>(c.handlers, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *Context)</span></span> &#123;</span><br><span class=\"line\">\t\t\tc.String(http.StatusNotFound, <span class=\"string\">&quot;404 NOT FOUND: %s\\n&quot;</span>, c.Path)</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc.Next()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"模板\">模板</h2>\n<h3 id=\"服务端渲染\">服务端渲染</h3>\n<p>现在越来越流行前后端分离的开发模式，即 Web 后端提供 RESTful 接口，返回结构化的数据(通常为 JSON 或者 XML)。前端使用 AJAX 技术请求到所需的数据，利用 JavaScript 进行渲染。Vue/React 等前端框架持续火热，这种开发模式前后端解耦，优势非常突出。后端童鞋专心解决资源利用，并发，数据库等问题，只需要考虑数据如何生成；前端童鞋专注于界面设计实现，只需要考虑拿到数据后如何渲染即可。使用 JSP 写过网站的童鞋，应该能感受到前后端耦合的痛苦。JSP 的表现力肯定是远不如 Vue/React 等专业做前端渲染的框架的。而且前后端分离在当前还有另外一个不可忽视的优势。因为后端只关注于数据，接口返回值是结构化的，与前端解耦。同一套后端服务能够同时支撑小程序、移动APP、PC端 Web 页面，以及对外提供的接口。随着前端工程化的不断地发展，Webpack，gulp 等工具层出不穷，前端技术越来越自成体系了。</p>\n<p>但前后分离的一大问题在于，页面是在客户端渲染的，比如浏览器，这对于爬虫并不友好。Google 爬虫已经能够爬取渲染后的网页，但是短期内爬取服务端直接渲染的 HTML 页面仍是主流。</p>\n<p>今天的内容便是介绍 Web 框架如何支持服务端渲染的场景。</p>\n<h3 id=\"静态文件\">静态文件</h3>\n<p>要做到服务端渲染，第一步便是要支持 JS、CSS 等静态文件。还记得我们之前设计动态路由的时候，支持通配符* 匹配多级子路径。比如路由规则/assets/*filepath，可以匹配/assets/开头的所有的地址。例如/assets/js/geektutu.js，匹配后，参数filepath就赋值为js/geektutu.js。</p>\n<p>那如果我么将所有的静态文件放在/usr/web目录下，那么filepath的值即是该目录下文件的相对地址。映射到真实的文件后，将文件返回，静态服务器就实现了。</p>\n<p>找到文件后，如何返回这一步，net/http库已经实现了。因此，gee 框架要做的，仅仅是解析请求的地址，映射到服务器上文件的真实地址，交给http.FileServer处理就好了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// createStaticHandler 创建静态的handler</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(group *RouterGroup)</span> <span class=\"title\">createStaticHandler</span><span class=\"params\">(relativePath <span class=\"keyword\">string</span>, fs http.FileSystem)</span> <span class=\"title\">HandlerFunc</span></span> &#123;</span><br><span class=\"line\">\tabsolutePath := path.Join(group.prefix, relativePath)</span><br><span class=\"line\">\tfileServer := http.StripPrefix(absolutePath, http.FileServer(fs))</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ctx *Context)</span></span> &#123;</span><br><span class=\"line\">\t\tfile := ctx.Param(<span class=\"string\">&quot;filepath&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _, err := fs.Open(file); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tctx.Status(http.StatusNotFound)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tfileServer.ServeHTTP(ctx.Writer, ctx.Req)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Static 提供静态文件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(group *RouterGroup)</span> <span class=\"title\">Static</span><span class=\"params\">(relativePath <span class=\"keyword\">string</span>, root <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\thandler := group.createStaticHandler(relativePath, http.Dir(root))</span><br><span class=\"line\">\turlPattern := path.Join(relativePath, <span class=\"string\">&quot;/*filepath&quot;</span>)</span><br><span class=\"line\">\tgroup.GET(urlPattern, handler)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们给RouterGroup添加了2个方法，Static这个方法是暴露给用户的。用户可以将磁盘上的某个文件夹root映射到路由relativePath。例如：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">r := gee.New()</span><br><span class=\"line\">r.Static(<span class=\"string\">&quot;/assets&quot;</span>, <span class=\"string\">&quot;/usr/geektutu/blog/static&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 或相对路径 r.Static(&quot;/assets&quot;, &quot;./static&quot;)</span></span><br><span class=\"line\">r.Run(<span class=\"string\">&quot;:9999&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>用户访问localhost:9999/assets/js/geektutu.js，最终返回/usr/geektutu/blog/static/js/geektutu.js。</p>\n<h3 id=\"HTML模板渲染\">HTML模板渲染</h3>\n<p>Go语言内置了text/template和html/template2个模板标准库，其中html/template为 HTML 提供了较为完整的支持。包括普通变量渲染、列表渲染、对象渲染等。gee 框架的模板渲染直接使用了html/template提供的能力。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">Engine <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t*RouterGroup</span><br><span class=\"line\">\trouter        *router</span><br><span class=\"line\">\tgroups        []*RouterGroup     <span class=\"comment\">// store all groups</span></span><br><span class=\"line\">\thtmlTemplates *template.Template <span class=\"comment\">// for html render</span></span><br><span class=\"line\">\tfuncMap       template.FuncMap   <span class=\"comment\">// for html render</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">SetFuncMap</span><span class=\"params\">(funcMap template.FuncMap)</span></span> &#123;</span><br><span class=\"line\">\tengine.funcMap = funcMap</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">LoadHTMLGlob</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\tengine.htmlTemplates = template.Must(template.New(<span class=\"string\">&quot;&quot;</span>).Funcs(engine.funcMap).ParseGlob(pattern))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先为 Engine 示例添加了 *template.Template 和 template.FuncMap对象，前者将所有的模板加载进内存，后者是所有的自定义模板渲染函数。</p>\n<p>另外，给用户分别提供了设置自定义渲染函数funcMap和加载模板的方法。</p>\n<p>接下来，对原来的 (*Context).HTML()方法做了些小修改，使之支持根据模板文件名选择模板进行渲染。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Context <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">\t<span class=\"comment\">// engine pointer</span></span><br><span class=\"line\">\tengine *Engine</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Context)</span> <span class=\"title\">HTML</span><span class=\"params\">(code <span class=\"keyword\">int</span>, name <span class=\"keyword\">string</span>, data <span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tc.SetHeader(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;text/html&quot;</span>)</span><br><span class=\"line\">\tc.Status(code)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err := c.engine.htmlTemplates.ExecuteTemplate(c.Writer, name, data); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tc.Fail(<span class=\"number\">500</span>, err.Error())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们在 Context 中添加了成员变量 engine *Engine，这样就能够通过 Context 访问 Engine 中的 HTML 模板。实例化 Context 时，还需要给 c.engine 赋值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(engine *Engine)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\">\tc := newContext(w, req)</span><br><span class=\"line\">\tc.handlers = middlewares</span><br><span class=\"line\">\tc.engine = engine</span><br><span class=\"line\">\tengine.router.handle(c)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"错误恢复\">错误恢复</h2>\n<h3 id=\"panic\">panic</h3>\n<p>Go 语言中，比较常见的错误处理方法是返回 error，由调用者决定后续如何处理。但是如果是无法恢复的错误，可以手动触发 panic，当然如果在程序运行过程中出现了类似于数组越界的错误，panic 也会被触发。panic 会中止当前执行的程序，退出。</p>\n<p>下面是主动触发的例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;before panic&quot;</span>)</span><br><span class=\"line\">\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;crash&quot;</span>)</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;after panic&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是数组越界触发的 panic</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tarr := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">\tfmt.Println(arr[<span class=\"number\">4</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"defer\">defer</h3>\n<p>panic 会导致程序被中止，但是在退出前，会先处理完当前协程上已经defer 的任务，执行完成后再退出。效果类似于 java 语言的 try…catch。</p>\n<p>可以 defer 多个任务，在同一个函数中 defer 多个任务，会逆序执行。即先执行最后 defer 的任务。</p>\n<p>在这里，defer 的任务执行完成之后，panic 还会继续被抛出，导致程序非正常结束。</p>\n<h3 id=\"recover\">recover</h3>\n<p>Go 语言还提供了 recover 函数，可以避免因为 panic 发生而导致整个程序终止，<strong>recover 函数只在 defer 中生效</strong>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">test_recover</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;defer func&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tfmt.Println(<span class=\"string\">&quot;recover success&quot;</span>)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\tarr := []<span class=\"keyword\">int</span>&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;</span><br><span class=\"line\">\tfmt.Println(arr[<span class=\"number\">4</span>])</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;after panic&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\ttest_recover()</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;after recover&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ go run hello.go </span><br><span class=\"line\">defer func</span><br><span class=\"line\">recover success</span><br><span class=\"line\">after recover</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，recover 捕获了 panic，程序正常结束。test_recover() 中的 after panic 没有打印，这是正确的，当 panic 被触发时，控制权就被交给了 defer 。就像在 java 中，try代码块中发生了异常，控制权交给了 catch，接下来执行 catch 代码块中的代码。而在 main() 中打印了 after recover，说明程序已经恢复正常，继续往下执行直到结束。</p>\n<h3 id=\"Gee的错误处理机制\">Gee的错误处理机制</h3>\n<p>对一个 Web 框架而言，错误处理机制是非常必要的。可能是框架本身没有完备的测试，导致在某些情况下出现空指针异常等情况。也有可能用户不正确的参数，触发了某些异常，例如数组越界，空指针等。如果因为这些原因导致系统宕机，必然是不可接受的。</p>\n<p>我们在第六天实现的框架并没有加入异常处理机制，如果代码中存在会触发 panic 的 BUG，很容易宕掉。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tr := gee.New()</span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/panic&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gee.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tnames := []<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;geektutu&quot;</span>&#125;</span><br><span class=\"line\">\t\tc.String(http.StatusOK, names[<span class=\"number\">100</span>])</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tr.Run(<span class=\"string\">&quot;:9999&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，我们为 gee 注册了路由 /panic，而这个路由的处理函数内部存在数组越界 names[100]，如果访问 localhost:9999/panic，Web 服务就会宕掉。</p>\n<p>今天，我们将在 gee 中添加一个非常简单的错误处理机制，即在此类错误发生时，向用户返回 Internal Server Error，并且在日志中打印必要的错误信息，方便进行错误定位。</p>\n<p>我们之前实现了中间件机制，错误处理也可以作为一个中间件，增强 gee 框架的能力。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Recovery</span><span class=\"params\">()</span> <span class=\"title\">HandlerFunc</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *Context)</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err := <span class=\"built_in\">recover</span>(); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\tmessage := fmt.Sprintf(<span class=\"string\">&quot;%s&quot;</span>, err)</span><br><span class=\"line\">\t\t\t\tlog.Printf(<span class=\"string\">&quot;%s\\n\\n&quot;</span>, trace(message))</span><br><span class=\"line\">\t\t\t\tc.Fail(http.StatusInternalServerError, <span class=\"string\">&quot;Internal Server Error&quot;</span>)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tc.Next()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Recovery 的实现非常简单，使用 defer 挂载上错误恢复的函数，在这个函数中调用 <em>recover()</em>，捕获 panic，并且将堆栈信息打印在日志中，向用户返回 Internal Server Error。</p>\n<p>你可能注意到，这里有一个 trace() 函数，这个函数是用来获取触发 panic 的堆栈信息，完整代码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">trace</span><span class=\"params\">(message <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> pcs [<span class=\"number\">32</span>]<span class=\"keyword\">uintptr</span></span><br><span class=\"line\">\tn := runtime.Callers(<span class=\"number\">3</span>, pcs[:]) <span class=\"comment\">// skip first 3 caller</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> str strings.Builder</span><br><span class=\"line\">\tstr.WriteString(message + <span class=\"string\">&quot;\\nTraceback:&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, pc := <span class=\"keyword\">range</span> pcs[:n] &#123;</span><br><span class=\"line\">\t\tfn := runtime.FuncForPC(pc)</span><br><span class=\"line\">\t\tfile, line := fn.FileLine(pc)</span><br><span class=\"line\">\t\tstr.WriteString(fmt.Sprintf(<span class=\"string\">&quot;\\n\\t%s:%d&quot;</span>, file, line))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> str.String()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 trace() 中，调用了 runtime.Callers(3, pcs[:])，Callers 用来返回调用栈的程序计数器, 第 0 个 Caller 是 Callers 本身，第 1 个是上一层 trace，第 2 个是再上一层的 defer func。因此，为了日志简洁一点，我们跳过了前 3 个 Caller。</p>\n<p>接下来，通过 runtime.FuncForPC(pc) 获取对应的函数，在通过 fn.FileLine(pc) 获取到调用该函数的文件名和行号，打印在日志中。</p>\n<p>至此，gee 框架的错误处理机制就完成了。</p>\n","categories":["go"],"tags":["web框架"]},{"title":"github无法用命令行连接","url":"/2022/03/17/github%E6%97%A0%E6%B3%95%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%9E%E6%8E%A5/","content":"<p>如果在使用git命令的时候出现<code>ssh: connect to host github.com port 22: Connection timed out</code>,可能是host文件配置错误，我们打开host文件（win10一般在C:\\Windows\\System32\\drivers\\etc）。在最下方添加github ip。</p>\n<ul>\n<li>查看github的ip地址，进入网址：<a href=\"https://github.com.ipaddress.com\">https://github.com.ipaddress.com</a></li>\n<li>确定域名ip，进入网址：<a href=\"https://fastly.net.ipaddress.com/github.global.ssl.fastly.net\">https://fastly.net.ipaddress.com/github.global.ssl.fastly.net</a></li>\n<li>确定静态资源ip（应该是有4个），进入网址：<a href=\"https://github.com.ipaddress.com/assets-cdn.github.com\">https://github.com.ipaddress.com/assets-cdn.github.com</a></li>\n</ul>\n<p>得到上述ip后添加到记事本最后，格式如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">140.82.113.4 github.com</span><br><span class=\"line\">199.232.69.194 github.global.ssl.fastly.net</span><br><span class=\"line\">185.199.108.153 assets-cdn.github.com</span><br><span class=\"line\">185.199.109.153 assets-cdn.github.com</span><br><span class=\"line\">185.199.110.153 assets-cdn.github.com</span><br><span class=\"line\">185.199.111.153 assets-cdn.github.com</span><br></pre></td></tr></table></figure>","categories":["github"],"tags":["error"]},{"title":"使用ssh传输文件/文件夹","url":"/2022/02/16/%E4%BD%BF%E7%94%A8ssh%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9/","content":"<h2 id=\"从服务器上下载文件\">从服务器上下载文件</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">scp &lt;用户名&gt;@&lt;ssh服务器地址&gt;:&lt;文件路径&gt; &lt;本地文件名&gt;</span><br></pre></td></tr></table></figure>\n<p>比如下载文件到桌面</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">scp root@127.0.0.1:~/test.txt ~/Desktop/test.txt</span><br></pre></td></tr></table></figure>\n<h2 id=\"上传文件到服务器\">上传文件到服务器</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">scp &lt;本地文件名&gt; &lt;用户名&gt;@&lt;ssh服务器地址&gt;:&lt;上传保存路径即文件名&gt;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意：只能将文件上传到用户目录下，如果需要上传到其他地方需要之后再自行移动文件</p>\n<h2 id=\"对于文件夹的操作\">对于文件夹的操作</h2>\n<p>只需要加个-r操作就可以了</p>\n","categories":["服务器"],"tags":["ssh"]},{"title":"http.Client连接行为控制","url":"/2022/02/21/http-Client%E8%BF%9E%E6%8E%A5%E8%A1%8C%E4%B8%BA%E6%8E%A7%E5%88%B6/","content":"<h2 id=\"1-http包默认客户端\">1.http包默认客户端</h2>\n<p>使用http包实现http客户端最简单的方法如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">esp, err := http.Get(<span class=\"string\">&quot;http://example.com/&quot;</span>)</span><br><span class=\"line\">...</span><br><span class=\"line\">resp, err := http.Post(<span class=\"string\">&quot;http://example.com/upload&quot;</span>, <span class=\"string\">&quot;image/jpeg&quot;</span>, &amp;buf)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p><strong>不要忘记在后面调用 <code>defer resp.Nody.Close()</code></strong></p>\n<p>但是在底层，完成http客户端操作的是http包内置的DefaultClient。客户端在默认情况下是不会等待应答回来的，所以如果服务器暂时没有给出回答的话，客户端就会尝试建立新的连接发送新的http请求，但是环境最大允许建立的连接数是有限的，所以当发送连接次数过多的时候会发生报错<code>socket: too many open files</code>。</p>\n<span id=\"more\"></span>\n<h2 id=\"2-定义一个只在小范围内生效的client实例\">2.定义一个只在小范围内生效的client实例</h2>\n<p>遇到上述情况我们就需要控制客户端避免在资源受到限制的时候仍然继续发送请求，这可以通过设置<code>http.DefaultClient</code>的属性来实现，但是这是一个包级变量，其作用域是整个程序，其他使用默认client的包也会受到影响，所以我们可以定义一个在小范围中应用的http客户端实例。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">client := &amp;http.Client&#123;&#125; <span class=\"comment\">// 自定义一个http客户端实例</span></span><br><span class=\"line\">resp, err := client.Get(<span class=\"string\">&quot;http://example.com/&quot;</span>)</span><br><span class=\"line\">...</span><br><span class=\"line\">resp, err := client.Post(<span class=\"string\">&quot;http://example.com/upload&quot;</span>, <span class=\"string\">&quot;image/jpeg&quot;</span>, &amp;buf)</span><br><span class=\"line\">..</span><br></pre></td></tr></table></figure>\n<p>上面这段代码和1中的代码时相同的。唯一不同的地方在于这段代码的应用范围仅限于上述的范围，不会对其他调用默认http包的程序产生任何影响。</p>\n<h2 id=\"3-自定义连接某host的最大限制\">3.自定义连接某host的最大限制</h2>\n<p>http包的client结构如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//$GOROOT/src/net/http/client.go</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Client <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Transport specifies the mechanism by which individual</span></span><br><span class=\"line\">        <span class=\"comment\">// HTTP requests are made.</span></span><br><span class=\"line\">        <span class=\"comment\">// If nil, DefaultTransport is used.</span></span><br><span class=\"line\">        Transport RoundTripper</span><br><span class=\"line\"></span><br><span class=\"line\">    CheckRedirect <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(req *Request, via []*Request)</span> <span class=\"title\">error</span></span></span><br><span class=\"line\">    Jar CookieJar</span><br><span class=\"line\">    Timeout time.Duration</span><br></pre></td></tr></table></figure>\n<p>其中一共4个字段，控制Client连接行为的Transport字段，如果为nil的话就是默认设置</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $GOROOT/src/net/http/transport.go</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> DefaultTransport RoundTripper = &amp;Transport&#123;</span><br><span class=\"line\">        Proxy: ProxyFromEnvironment,</span><br><span class=\"line\">        DialContext: (&amp;net.Dialer&#123;</span><br><span class=\"line\">                Timeout:   <span class=\"number\">30</span> * time.Second,</span><br><span class=\"line\">                KeepAlive: <span class=\"number\">30</span> * time.Second,</span><br><span class=\"line\">        &#125;).DialContext,</span><br><span class=\"line\">        ForceAttemptHTTP2:     <span class=\"literal\">true</span>,</span><br><span class=\"line\">        MaxIdleConns:          <span class=\"number\">100</span>,</span><br><span class=\"line\">        IdleConnTimeout:       <span class=\"number\">90</span> * time.Second,</span><br><span class=\"line\">        TLSHandshakeTimeout:   <span class=\"number\">10</span> * time.Second,</span><br><span class=\"line\">        ExpectContinueTimeout: <span class=\"number\">1</span> * time.Second,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是上述的配置中并没有控制连接某个host的最大数的设置，因为在Transport结构体中起这个作用的字段是<code>MaxConnsPerHost</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $GOROOT/src/net/http/transport.go</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Transport <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// MaxConnsPerHost optionally limits the total number of</span></span><br><span class=\"line\">        <span class=\"comment\">// connections per host, including connections in the dialing,</span></span><br><span class=\"line\">        <span class=\"comment\">// active, and idle states. On limit violation, dials will block.</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"comment\">// Zero means no limit.</span></span><br><span class=\"line\">        MaxConnsPerHost <span class=\"keyword\">int</span></span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>http.Transport维护了到每个server host的计数器connsPerHost的请求等待队列</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $GOROOT/src/net/http/transport.go</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Transport <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">        connsPerHostMu   sync.Mutex</span><br><span class=\"line\">        connsPerHost     <span class=\"keyword\">map</span>[connectMethodKey]<span class=\"keyword\">int</span></span><br><span class=\"line\">        connsPerHostWait <span class=\"keyword\">map</span>[connectMethodKey]wantConnQueue <span class=\"comment\">// waiting getConns</span></span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> connectMethodKey <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        proxy, scheme, addr <span class=\"keyword\">string</span></span><br><span class=\"line\">        onlyH1              <span class=\"keyword\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个结构体中的<code>connectMethodKey</code>使用一个四元组(proxy,scheme,addr,onlyH1)来唯一地标识一个host。</p>\n<p>但是对于一个Client来说，通常只有addr(ip+port)是不同的，也就是说实际上是按照addr区分host的。</p>\n<p><img src=\"https://i.imgur.com/Ts3HKpV.png\" alt=\"picture 1\"></p>\n<h2 id=\"4-设定idle池的大小\">4.设定idle池的大小</h2>\n<p>但是如果一直维持这些连接的话，会有点资源浪费。比如某些Client空闲的时候其实可以适当减少连接。这可以通过Transport中的MaxIdleConnsPerHost字段实现。</p>\n<p>具体就是忙时建立的多条连接在闲时会被kill到这个设定的个数。之后再与服务器交流的话，就只会用这些没有kill掉的连接。</p>\n<p><img src=\"https://i.imgur.com/wSLiAHr.png\" alt=\"picture 2\"></p>\n<p>此外，结构体中还有一个字段MaxIdleConns，它针对的是整个Client中的所有的idle池中的连接数总和。</p>\n<h2 id=\"5-清理idle池中的连接\">5.清理idle池中的连接</h2>\n<p>如果没有其他设定的话，上面保留下来的连接会一直存在，即便没有使用。这也是一种资源浪费。对于这个问题，Transport提供了IdleConnTimeout清理超时的连接。可以通过它设置超时清理的时间。</p>\n<h2 id=\"6-其他控制项\">6.其他控制项</h2>\n<p>如果觉得超时清理也会占用资源的话，可以利用Transport的DisableKeepAlive使得每个请求都要建立一个新的连接。但是这样的方法在忙的时候效果不如前者。</p>\n<p>另外，有些服务器可能暂时没法回应，这种时候要限制client等待应答的时间，超时的话要自动返回失败。</p>\n","categories":["go"],"tags":["net/http"]},{"title":"利用GPU进行训练的方法","url":"/2022/01/26/%E5%88%A9%E7%94%A8GPU%E8%BF%9B%E8%A1%8C%E8%AE%AD%E7%BB%83%E7%9A%84%E6%96%B9%E6%B3%95/","content":"<h2 id=\"方法一\">方法一</h2>\n<p>在模型、损失函数和数据后面添加<code>.cuda()</code></p>\n<h2 id=\"方法二\">方法二</h2>\n<p>对上述数据使用<code>.to(device)</code>，device需要提前设置好，利用<code>torch.device(&quot;cuda:i&quot;)</code>其中i是你想用那一块显卡</p>\n<p><code>device=torch.device('cuda' if torch.cuda.is_available() else 'cpu')</code></p>\n","categories":["DeepLearning"],"tags":["GPU"]},{"title":"使用golang+postgres+docker进行开发","url":"/2022/01/28/%E4%BD%BF%E7%94%A8golang+postgres+docker%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/","content":"<p><a href=\"https://dev.to/techschoolguru/design-db-schema-and-generate-sql-code-with-dbdiagram-io-4ko5\">课程官方文档地址</a></p>\n<h2 id=\"docker的下载\">docker的下载</h2>\n<p><a href=\"https://docs.docker.com/engine/install/ubuntu/\">ubuntu的docker下载地址</a></p>\n<p>照着上述地址的步骤进行下载安装docker</p>\n<p>为了不用每次都要sudo权限运行docker，进行以下步骤使我们当前用户具有启用docker权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo groupadd docker //创建docker组 通常来说安装万docker就已经自动创建好了</span><br><span class=\"line\">sudo usermod -aG docker $USER //将当前用户添加到组中</span><br><span class=\"line\">newgrp docker  //刷新一下对group的更改</span><br><span class=\"line\">docker run hello-world //测试不用sudo是否可以进行使用docker</span><br></pre></td></tr></table></figure>\n<p><code>image</code>和<code>container</code>的区别在于，container是image的一个实例，通过<code>docker run</code>来启动，我们可以根据一个镜像启动多个container。</p>\n<span id=\"more\"></span>\n<h3 id=\"docker端口的映射\">docker端口的映射</h3>\n<p>docker容器是在一个虚拟网络上运行的，因此我们不能简单地连接5432端口上的postgres服务器，我们需要让docker创建一个本地和容器网路的映射。</p>\n<p>可以在容器启动的时候指定<code>-p 主机端口：容器端口</code></p>\n<h3 id=\"postgres的下载安装\">postgres的下载安装</h3>\n<p>接着去下面的地址找到postgres的镜像文件进行下载安装，推荐使用官方镜像。或者直接使用<code>docker pull postgres</code>也是可以的。</p>\n<p><a href=\"https://hub.docker.com/_/postgres\">postgres镜像地址</a></p>\n<p>通过下列命令可以创建一个postgres镜像的实例，也就是数据库</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run --name 实例名称 -p 5432:5432 -e POSTGRES_PASSWORD=密码 -d postgres:version //-p后面的是docker的端口与主机端口的映射</span><br></pre></td></tr></table></figure>\n<h3 id=\"进入容器的命令行\">进入容器的命令行</h3>\n<p>使用<code>docker exec</code>命令可以让我们在容器中执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker exec -it 容器名 psql -U 用户名</span><br></pre></td></tr></table></figure>\n<p><code>it</code>是高速docker以交互式模式启动命令行，然后指定容器名。由于我们想要运行的是postgresql的命令，所以我们使用<code>psql</code>,最后指定用户名。</p>\n<h3 id=\"查看容器的日志\">查看容器的日志</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker logs 容器名（或者id）</span><br></pre></td></tr></table></figure>\n<h2 id=\"dbdiagram的使用\">dbdiagram的使用</h2>\n<p><a href=\"https://dbdiagram.io/\">dbdiagram网址</a></p>\n<p>进去后按照自己的需要设计数据库，并且可以导出为sql文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Table accounts as A &#123;</span><br><span class=\"line\">  id bigserial [pk]</span><br><span class=\"line\">  owner varchar</span><br><span class=\"line\">  balance bigint</span><br><span class=\"line\">  currency varchar</span><br><span class=\"line\">  created_at timestamptz [default: `now()`]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中<code>bigserial</code>类型可以自增，是八个字节的，余额使用的是<code>bigint</code>这历史为了方便，实际上应该是<code>decimal</code>类型的。时间戳的格式我们不用<code>timestamp</code>而是<code>timestamptz</code>是因为后者包含了时区信息，并且我们需要给他设置默认值为当时的时间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Table entries &#123;</span><br><span class=\"line\">  id bigserial [pk]</span><br><span class=\"line\">  account_id bigint [ref: &gt; A.id]</span><br><span class=\"line\">  amount bigint</span><br><span class=\"line\">  created_at timestamptz [default: `now()`]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>entry表记录了某个账户所有的出入帐，其中账户id必须是accounts表中有的，所以需要设置一个<code>ref</code>关系来与accounts表建立联系，属于外键。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Table transfers &#123;</span><br><span class=\"line\">  id bigserial [pk]</span><br><span class=\"line\">  from_account_id bigint [ref: &gt; A.id]</span><br><span class=\"line\">  to_account_id bigint [ref: &gt; A.id]</span><br><span class=\"line\">  amount bigint</span><br><span class=\"line\">  created_at timestamptz [default: `now()`]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外我们还可以对每个字段增加一些限制，由于其他的字段并没什么好限制的，所以都只需要加上<code>not null</code>限制，此外，对于entries表，出入账可以为正负，正表示入，负表示出，但是对于transfers表，出入关系在其他字段给出了，所以数额字段只能是正。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Table accounts as A &#123;</span><br><span class=\"line\">  id bigserial [pk]</span><br><span class=\"line\">  owner varchar [not null]</span><br><span class=\"line\">  balance bigint [not null]</span><br><span class=\"line\">  currency varchar [not null]</span><br><span class=\"line\">  created_at timestamptz [not null, default: `now()`]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Table entries &#123;</span><br><span class=\"line\">  id bigserial [pk]</span><br><span class=\"line\">  account_id bigint [ref: &gt; A.id, not null]</span><br><span class=\"line\">  amount bigint [not null, note: &#x27;can be negative or positive&#x27;]</span><br><span class=\"line\">  created_at timestamptz [not null, default: `now()`]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Table transfers &#123;</span><br><span class=\"line\">  id bigserial [pk]</span><br><span class=\"line\">  from_account_id bigint [ref: &gt; A.id, not null]</span><br><span class=\"line\">  to_account_id bigint [ref: &gt; A.id, not null]</span><br><span class=\"line\">  amount bigint [not null, note: &#x27;must be positive&#x27;]</span><br><span class=\"line\">  created_at timestamptz [not null, default: `now()`]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>另外我们还可以定义自己的枚举类型，比如说对于货币的种类我们只设置两种<code>USD</code>和<code>EUR</code>,那我们就可以设置字段的类型为自己的自定义类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">enum Currency &#123;</span><br><span class=\"line\">    USD</span><br><span class=\"line\">    EUR</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Table accounts as A &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  currency Currency [not null]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>transfers表记录了每一笔账户之间的转账，我们在这里只考虑本simple bank中的账户之间的转账行为。</p>\n<p>接下来我们可以给表添加索引，在accounts表中我们想要能够通过onwer的名字来查询账户，所以我们将owner增加到indexes列表中。</p>\n<p>在entries表中，我们可能会需要列出一个账户的所有出入账，所以我们需要将<code>account_id</code>添加到索引中</p>\n<p>在transfers表中我们可能需要搜索一个账户全部的出账，或者一个账户全部的入账，甚至两个账户之间的所有交易记录，所以我们要将这两个字段和<strong>两个字段的组合</strong>添加到索引中</p>\n<p>接下来我们就可以生成sql代码了，当然也可以生成其他各种形式的如pdf、图片或者是mysql的代码。</p>\n<h2 id=\"tableplus的使用（GUI）\">tableplus的使用（GUI）</h2>\n<p><a href=\"https://tableplus.com/\">tableplus官网</a></p>\n<p>去到tableplus官网按照官网教程下载安装，之后就可以用这个的可视化界面管理数据库</p>\n<h2 id=\"数据库的迁移\">数据库的迁移</h2>\n<p>首先需要下载安装migrate库<a href=\"https://github.com/golang-migrate/migrate\">migrate的github地址</a>。进入cmd/migrate目录下按照提示操作安装migrate</p>\n<p>在需要迁移的项目下创建db目录，进入目录后输入<code>migrate create -ext sql -dir db/migration -seq init_schema</code>，然后将初始化db的query语句复制粘贴到其中的up文件中，删除操作放入到down文件中。<strong>写删除操作的时候需要注意，要先删除依赖别的表的表，否则无法删除</strong></p>\n<p>接着创建一个Makefile脚本，其基本格式可以如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">postgres:</span></span><br><span class=\"line\">  docker run --name postgres14 -p 5432:5432 -e POSTGRES_USER=root -e POSTGRES_PASSWORD=123 -d postgres</span><br><span class=\"line\"><span class=\"section\">createdb:</span></span><br><span class=\"line\">  docker exec -it postgres14 createdb --username=root --owner=root simplebank</span><br><span class=\"line\"><span class=\"section\">dropdb:</span></span><br><span class=\"line\">  docker exec -it postgres14 dropdb simplebank</span><br><span class=\"line\"><span class=\"section\">migrateup:</span></span><br><span class=\"line\">  migrate -path db -database <span class=\"string\">&quot;postgresql://root:123@localhost:5432/simplebank?sslmode=disable&quot;</span> -verbose up</span><br><span class=\"line\"><span class=\"section\">migratedown:</span></span><br><span class=\"line\">  migrate -path db -database <span class=\"string\">&quot;postgresql://root:123@localhost:5432/simplebank?sslmode=disable&quot;</span> -verbose down</span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>:postgres createdb dropdb migrateup migratedown</span></span><br></pre></td></tr></table></figure>\n<p>是为了方便整个项目在别的地方使用。</p>\n<h2 id=\"使用golang对数据库进行增删改查\">使用golang对数据库进行增删改查</h2>\n<h3 id=\"方法-2\">方法</h3>\n<ul>\n<li>使用DATABASE/SQL库\n<ul>\n<li>优点：快且直接</li>\n<li>缺点：需要手动将sql字段映射到变量，容易出错</li>\n</ul>\n</li>\n<li>GORM库\n<ul>\n<li>优点：生产代码短</li>\n<li>缺点：流量很高时运行速度较慢</li>\n</ul>\n</li>\n<li>SQLX库\n<ul>\n<li>优点：相当快并且易于使用</li>\n<li>缺点：执行时才会出现错误</li>\n</ul>\n</li>\n<li>SQLC库：\n<ul>\n<li>优点：运行快，只需要编写query就可以让golang自动生成代码，错误可以被立即发现</li>\n<li>缺点：只支持postgres</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"sqlc\">sqlc</h3>\n<p>首先去sqlc的官方文档，并且根据自己的系统安装sqlc</p>\n<p>然后进入项目目录下运行<code>sqlc init</code>,会自动生成一个yaml文件，我们将这个文件进行填充修改如下，其中参数可以自己设定</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\"><span class=\"attr\">packages:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;db&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">&quot;./db/sqlc&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">queries:</span> <span class=\"string\">&quot;./db/query/&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">schema:</span> <span class=\"string\">&quot;./db/migration/&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">engine:</span> <span class=\"string\">&quot;postgresql&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">emit_json_tags:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">emit_prepared_queries:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">emit_interface:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">emit_exact_table_names:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">emit_empty_slices:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>然后在db目录下创建一个query目录，其中存放我们对于数据库中表的CRUD操作的语句，语句开头用<code>--name:函数名:返回条目数量</code>来控制我们稍后自动生成的golang代码的函数。其形式大概是这样的</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- name: CreateAccount :one</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> accounts (</span><br><span class=\"line\">    owner,</span><br><span class=\"line\">    balance,</span><br><span class=\"line\">    currency</span><br><span class=\"line\">) <span class=\"keyword\">VALUES</span> (</span><br><span class=\"line\">$<span class=\"number\">1</span>, $<span class=\"number\">2</span>,$<span class=\"number\">3</span></span><br><span class=\"line\">)</span><br><span class=\"line\">RETURNING <span class=\"operator\">*</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- name: GetAccount :one</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> accounts</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> $<span class=\"number\">1</span> LIMIT <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- name: ListAccount :many</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> accounts</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> id</span><br><span class=\"line\">LIMIT $<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">OFFSET</span> $<span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- name: UpdateAccount :one</span></span><br><span class=\"line\">UPDATE accounts</span><br><span class=\"line\"><span class=\"keyword\">SET</span> balance <span class=\"operator\">=</span> $<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> $<span class=\"number\">1</span></span><br><span class=\"line\">RETURNING <span class=\"operator\">*</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- name: DeleteAuthor :exec</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> accounts <span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> $<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>同样在db目录下创建一个sqlc目录，存放由sqlc生成的.go文件，命令行使用<code>sql generate</code>语句就可以自动生成对应的go文件。</p>\n<p>对于这些生成的文件我们不要去对它作修改改动，因为下次生成时会覆盖掉，如果我们需要自定义功能，就自己写一个文件。</p>\n<h2 id=\"测试单元\">测试单元</h2>\n<p>对于生成的文件，我们需要测试其提供给我们的函数是否是正确有用的，首先需要在sqlc目录下创建一个main_test.go文件，其测试是否能连接到创建的数据库.其中的TestMain函数是所有测试单元的主入口。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> db</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\"><span class=\"string\">&quot;database/sql&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">_ <span class=\"string\">&quot;github.com/lib/pq&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">dbDriver = <span class=\"string\">&quot;postgres&quot;</span></span><br><span class=\"line\">dbSource = <span class=\"string\">&quot;postgresql://root:123@localhost:5432/simplebank?sslmode=disable&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> testQueries *Queries</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestMain</span><span class=\"params\">(m *testing.M)</span></span> &#123;</span><br><span class=\"line\">conn, err := sql.Open(dbDriver, dbSource)</span><br><span class=\"line\"><span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">  log.Fatal(<span class=\"string\">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">testQueries = New(conn)</span><br><span class=\"line\">os.Exit(m.Run())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后可以在其他的各种不同的单元测试中进行各种不同函数的测试，需要检查测试结果的话，推荐使用github上的<code>testify</code>包中require子包，具体用法如下</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">require.NoError(t, err)<span class=\"comment\">//判断没有产生err</span></span><br><span class=\"line\">require.NotEmpty(t, account)</span><br><span class=\"line\"></span><br><span class=\"line\">require.Equal(t, arg.Owner, account.Owner)<span class=\"comment\">//判断写入数据库的和返回的是同一份数据</span></span><br><span class=\"line\">require.Equal(t, arg.Balance, account.Balance)</span><br><span class=\"line\">require.Equal(t, arg.Currency, account.Currency)</span><br><span class=\"line\"></span><br><span class=\"line\">require.NotZero(t, account.ID)<span class=\"comment\">//判断返回的不是零值</span></span><br><span class=\"line\">require.NotZero(t, account.CreatedAt)</span><br></pre></td></tr></table></figure>\n<p>为了更好地测试db，我们可以在工程目录下创建util目录，其中存放我们需要的一些工具函数。比如数据库表中的每个条目我们可以通过随机生成并放入，这时就需要随机生成数据的函数，可以放在这个目录下面。</p>\n<h2 id=\"数据库事务\">数据库事务</h2>\n<p>之前写到的都是对数据库的增删改查操作，但是在实际操作中，一个事务往往需要结合多个数据库的CRUD操作</p>\n<p>假设我们要开始一个从account1转10元到account2上，那么这个事务包含5个CRUD操作：</p>\n<ol>\n<li>创建一个transfer=10的记录</li>\n<li>创建一个金额等于-10的记录，account1-10</li>\n<li>创建另一条entry记录account2，金额为10</li>\n<li>通过减去它来更新account1的banlance</li>\n<li>增加它来更新account2的balance</li>\n</ol>\n<h3 id=\"用go实现DB事务\">用go实现DB事务</h3>\n<h4 id=\"使用组合来扩展Queries的功能\">使用组合来扩展Queries的功能</h4>\n<p>首先在<code>db/sqlc</code>下创建一个<code>store.go</code>文件，我们在其中定义一个新的<code>Store</code>结构体，该结构体会绑定其需要的函数来独立运行数据库查询语句。</p>\n<p>之前已经由sqlc生成过对应的Quriers结构体了，但是一个query只能在一个表上执行一个特定的操作，所以Queries结构体并不支持事务。因此我们需要把它迁入到Store结构体中来扩展它的功能。将Queries迁入到Store后，Queries的函数将会对Store可用。</p>\n<p>此外，还需要在Store结构体中加入sql.DB对象，因为它需要创建一个数据库事务</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Store <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    *Queries</span><br><span class=\"line\">    db *sql.DB</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建一个新的Store对象\">创建一个新的Store对象</h4>\n<p>NewStore函数以一个<code>sql.DB</code>作为输入并且返回一个Store对象。Store.db就等于我们的输入，New()函数由sqlc生成，创建并返回一个Queries对象</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewStore</span><span class=\"params\">(db *sql.DB)</span> *<span class=\"title\">Store</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;Store&#123;</span><br><span class=\"line\">        db:      db,</span><br><span class=\"line\">        Queries: New(db),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"执行一个通用数据库事务\">执行一个通用数据库事务</h4>\n<p>思路很简单：该函数以上下文环境和回调函数作为输入，之后以一个新的数据库事务作为开始，通过该事务创建一个新的Queries对象，通过这个新的Queries调用回调函数，最终根据函数返回的error来确定提交还是回滚事务。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">execTx</span><span class=\"params\">(ctx context.Context, fn <span class=\"keyword\">func</span>(*Queries)</span> <span class=\"title\">error</span>) <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，调用<code>store.db.BeginTx()</code>来开启一个新的事务，将环境和一个可选的参数<code>sql.TxOptions</code>传入,该参数允许我们对该事务设置一个通用的隔离等级。如果我们设为nil则会用数据库默认的隔离等级，在postgres中就是读提交。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">tx, err := store.db.BeginTx(ctx, &amp;sql.TxOptions&#123;&#125;)</span><br></pre></td></tr></table></figure>\n<p><code>BeginTx</code>函数会返回一个事务对象或一个错误，如果存在错误则直接返回，否则的话通过新构建的事务tx调用<code>New()</code>得到一个新的返回的Queries对象。这里的<code>New()</code>函数和上面的<code>NewStore()</code>中的是一样的。唯一的差别在于，我们传入一个<code>sql.Tx</code>而非<code>sql.DB</code>。因为<code>New()</code>函数接受的是一个DBTX接口。</p>\n<p>现在有了能够在事务内部运行的queries，我们可以调用传入的函数并且获取返回的错误。如果存在错误的话，就调用<code>tx.Rollback()</code>回滚。同时会返回一个rollback错误。如果存在rollback错误，我们就需要报告两个错误。因此我们应该把他们合二为一，在返回之前使用<code>fmt.Errorf()</code>即可。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">execTx</span><span class=\"params\">(ctx context.Context, fn <span class=\"keyword\">func</span>(*Queries)</span> <span class=\"title\">error</span>) <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    tx, err := store.db.BeginTx(ctx, &amp;sql.TxOptions)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    q := New(tx)</span><br><span class=\"line\">    err = fn(q)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> rbErr := tx.Rollback(); rbErr != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;tx err: %v, rb err: %v&quot;</span>, err, rbErr)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> tx.Commit()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果回滚成功的话我们只需要返回最初的事务错误。如果所有的操作都是成功的，我们只需要提交事务<code>tx.Commit()</code>就可以了，并且返回它的错误。</p>\n<p>到此我们就已经完成<code>execTx()</code>函数了。需要注意的是这个函数是不导出的，我们不希望在包外部可以直接调用它，作为代替，我们对每个具体的事务提供一个导出的函数。</p>\n<h3 id=\"实现转账事务\">实现转账事务</h3>\n<p>先回忆一下，这个事务需要创造一个新的转账记录，两条新的entry信息并且更新两个账户的余额。函数的输入应当是一个上下文变量和一个对应的<code>TransferTxParam</code>类型的参数。该函数需要返回一个<code>TransferTxResult</code>对象或者一个错误。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">func (store *Store) TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>TransferTxParams</code>结构体包含所有必要的在账户间转账的参数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TransferTxParams <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    FromAccountID <span class=\"keyword\">int64</span> <span class=\"string\">`json:&quot;from_account_id&quot;`</span></span><br><span class=\"line\">    ToAccountID   <span class=\"keyword\">int64</span> <span class=\"string\">`json:&quot;to_account_id&quot;`</span></span><br><span class=\"line\">    Amount        <span class=\"keyword\">int64</span> <span class=\"string\">`json:&quot;amount&quot;`</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><code>TransferTxResult</code>包含转账事务的结果</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TransferTxResult <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Transfer    Transfer <span class=\"string\">`json:&quot;transfer&quot;`</span></span><br><span class=\"line\">    FromAccount Account  <span class=\"string\">`json:&quot;from_account&quot;`</span></span><br><span class=\"line\">    ToAccount   Account  <span class=\"string\">`json:&quot;to_account&quot;`</span></span><br><span class=\"line\">    FromEntry   Entry    <span class=\"string\">`json:&quot;from_entry&quot;`</span></span><br><span class=\"line\">    ToEntry     Entry    <span class=\"string\">`json:&quot;to_entry&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在开始实现转账事务。首先创建一个空的结果，然后调用<code>store.execTX()</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">TransferTx</span><span class=\"params\">(ctx context.Context, arg TransferTxParams)</span> <span class=\"params\">(TransferTxResult, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result TransferTxResult</span><br><span class=\"line\"></span><br><span class=\"line\">    err := store.execTx(ctx, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(q *Queries)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一般来说，我们可以使用Queries对象q调用任何单独的CRUD操作。要记住这个q是在一个单独的数据库事务中创建的，所以它提供的所有方法都只在这个事务中运行。</p>\n<p>接下来通过调用<code>q.CreateTransfer()</code>来创造我们的result中需要的transfer记录，该函数需要传入上下文变量和对应的<code>CreateTransferParams</code>变量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">TransferTx</span><span class=\"params\">(ctx context.Context, arg TransferTxParams)</span> <span class=\"params\">(TransferTxResult, error)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    err := store.execTx(ctx, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(q *Queries)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> err error</span><br><span class=\"line\"></span><br><span class=\"line\">        result.Transfer, err = q.CreateTransfer(ctx, CreateTransferParams&#123;</span><br><span class=\"line\">            FromAccountID: arg.FromAccountID,</span><br><span class=\"line\">            ToAccountID:   arg.ToAccountID,</span><br><span class=\"line\">            Amount:        arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们在回调函数中就能够接触到result和前面传入的arg变量，这使得回调函数形成一个闭包。go语言中由于缺乏泛型的概念，所以通常是使用这个方法来从回调函数中获取返回。</p>\n<p>接着对result中剩下4个条目的方法的操作是一样的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">TransferTx</span><span class=\"params\">(ctx context.Context, arg TransferTxParams)</span> <span class=\"params\">(TransferTxResult, error)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    err := store.execTx(ctx, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(q *Queries)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> err error</span><br><span class=\"line\"></span><br><span class=\"line\">        result.Transfer, err = q.CreateTransfer(ctx, CreateTransferParams&#123;</span><br><span class=\"line\">            FromAccountID: arg.FromAccountID,</span><br><span class=\"line\">            ToAccountID:   arg.ToAccountID,</span><br><span class=\"line\">            Amount:        arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result.FromEntry, err = q.CreateEntry(ctx, CreateEntryParams&#123;</span><br><span class=\"line\">            AccountID: arg.FromAccountID,</span><br><span class=\"line\">            Amount:    -arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        result.ToEntry, err = q.CreateEntry(ctx, CreateEntryParams&#123;</span><br><span class=\"line\">            AccountID: arg.ToAccountID,</span><br><span class=\"line\">            Amount:    arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们现在完成了3个条目，剩下来的两个修改两个账户余额的操作比较复杂，涉及到死锁的问题，这一问题会在后面进行补充。</p>\n<h3 id=\"测试转账事务\">测试转账事务</h3>\n<p>首先创建一个store_test.go文件和store.go处在同一个目录下，然后对<code>TransferTx()</code>定义一个单元测试。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是我们需要先有一个Store对象，而<code>NewStore()</code>又需要有一个<code>sql.DB</code>对象，之前其实已经在<code>main_test.go</code>中创建了一个<code>sql.DB</code>对象，所以为了能够复用我们声明两个全局变量<code>testDB</code>和<code>testQueries</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> testQueries *Queries</span><br><span class=\"line\"><span class=\"keyword\">var</span> testDB *sql.DB</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestMain</span><span class=\"params\">(m *testing.M)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> err error</span><br><span class=\"line\">    testDB, err = sql.Open(dbDriver, dbSource)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    testQueries = New(testDB)</span><br><span class=\"line\"></span><br><span class=\"line\">    os.Exit(m.Run())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们就可以回到我们的单元测试中，并且通过将这个全局变量传给<code>NewStore()</code>来创建一个新的store。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    store := NewStore(testDB)</span><br><span class=\"line\"></span><br><span class=\"line\">    account1 := createRandomAccount(t)</span><br><span class=\"line\">    account2 := createRandomAccount(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着创建两个随机账户，会在这两个账户之间进行转账。为了保证该事务能够很好的运行，我们测试时需要并行多个进程。我们可以并行5个进程来将账户1的钱转10元到账户2，可以用一个for循环来实现。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    store := NewStore(testDB)</span><br><span class=\"line\"></span><br><span class=\"line\">    account1 := createRandomAccount(t)</span><br><span class=\"line\">    account2 := createRandomAccount(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    n := <span class=\"number\">5</span></span><br><span class=\"line\">    amount := <span class=\"keyword\">int64</span>(<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// run n concurrent transfer transaction</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            result, err := store.TransferTx(context.Background(), TransferTxParams&#123;</span><br><span class=\"line\">                FromAccountID: account1.ID,</span><br><span class=\"line\">                ToAccountID:   account2.ID,</span><br><span class=\"line\">                Amount:        amount,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在循环中我们不能立即使用<code>require</code>包来检查，因为这个函数运行在一个和我们的测试函数正在运行的进程所不相同的进程上，因此不能保证在某个条件不满足的情况下它会停止整个测试。</p>\n<p>正确的做法是将result和err送到测试单元所在的主进程上。为了做到这一点，我们使用channel，在此处我们需要两个channel来分别传输result和err。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// run n concurrent transfer transaction</span></span><br><span class=\"line\">    errs := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> error)</span><br><span class=\"line\">    results := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> TransferTxResult)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            result, err := store.TransferTx(context.Background(), TransferTxParams&#123;</span><br><span class=\"line\">                FromAccountID: account1.ID,</span><br><span class=\"line\">                ToAccountID:   account2.ID,</span><br><span class=\"line\">                Amount:        amount,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">            errs &lt;- err</span><br><span class=\"line\">            results &lt;- result</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样用一个for循环来获取channel中的值，并且对他们做检测</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// run n concurrent transfer transaction</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check results</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        err := &lt;-errs</span><br><span class=\"line\">        require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">        result := &lt;-results</span><br><span class=\"line\">        require.NotEmpty(t, result)</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于result中包含了太多的参数，所以我们一个一个来验证他们</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check results</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        err := &lt;-errs</span><br><span class=\"line\">        require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">        result := &lt;-results</span><br><span class=\"line\">        require.NotEmpty(t, result)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// check transfer</span></span><br><span class=\"line\">        transfer := result.Transfer</span><br><span class=\"line\">        require.NotEmpty(t, transfer)</span><br><span class=\"line\">        require.Equal(t, account1.ID, transfer.FromAccountID)</span><br><span class=\"line\">        require.Equal(t, account2.ID, transfer.ToAccountID)</span><br><span class=\"line\">        require.Equal(t, amount, transfer.Amount)</span><br><span class=\"line\">        require.NotZero(t, transfer.ID)</span><br><span class=\"line\">        require.NotZero(t, transfer.CreatedAt)</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着为了确保transfer记录真的在数据库中创建了，我们应该调用<code>store.GetTransfer()</code>来找到一个相同ID的记录。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check results</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        <span class=\"comment\">// check transfer</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        _, err = store.GetTransfer(context.Background(), transfer.ID)</span><br><span class=\"line\">        require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>接着对于两个entry的检测也是同样的步骤，这里就不多赘述。</p>\n<h2 id=\"事务锁以及如何解决死锁\">事务锁以及如何解决死锁</h2>\n<h3 id=\"测试驱动的开发\">测试驱动的开发</h3>\n<p>前面已经测试了三个部分了，剩下的余额部分还没有进行测试和开发，我们先写好测试程序，通过测试报错，不断完善开发程序直到测试程序能够通过。</p>\n<p>首先判断两个账户不为空以及result中两个账户的ID和对应的账户ID是相同的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check results</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// check accounts</span></span><br><span class=\"line\">        fromAccount := result.FromAccount</span><br><span class=\"line\">        require.NotEmpty(t, fromAccount)</span><br><span class=\"line\">        require.Equal(t, account1.ID, fromAccount.ID)</span><br><span class=\"line\"></span><br><span class=\"line\">        toAccount := result.ToAccount</span><br><span class=\"line\">        require.NotEmpty(t, toAccount)</span><br><span class=\"line\">        require.Equal(t, account2.ID, toAccount.ID)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> check accounts&#x27; balance</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们需要检查账户余额，将账户进行转账事务前的余额和进行事务后的余额做差，两个账户得到的差值应该是相同的，并且差值应该能够整除每一次的转账金额，因为转账次数为5次。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check results</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// check accounts&#x27; balance</span></span><br><span class=\"line\">        diff1 := account1.Balance - fromAccount.Balance</span><br><span class=\"line\">        diff2 := toAccount.Balance - account2.Balance</span><br><span class=\"line\">        require.Equal(t, diff1, diff2)</span><br><span class=\"line\">        require.True(t, diff1 &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        require.True(t, diff1%amount == <span class=\"number\">0</span>) <span class=\"comment\">// 1 * amount, 2 * amount, 3 * amount, ..., n * amount</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因此，若我们计算出差值除以转账金额，就能够得到转账次数k，而且这个次数对于每次交易是唯一的，第一次就是1，第二次就是2。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check results</span></span><br><span class=\"line\">    existed := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">bool</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// check accounts&#x27; balance</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        k := <span class=\"keyword\">int</span>(diff1 / amount)</span><br><span class=\"line\">        require.True(t, k &gt;= <span class=\"number\">1</span> &amp;&amp; k &lt;= n)</span><br><span class=\"line\"></span><br><span class=\"line\">        require.NotContains(t, existed, k)</span><br><span class=\"line\">        existed[k] = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后我们还需要确定所有转账完成后是否真的对数据库中的数据进行了改动，我们用<code>store.GetAccount()</code>从数据库中获取对应的账户，并且将它的余额与应当变成的余额做相等比较，此处应该是相等的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check results</span></span><br><span class=\"line\">    existed := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">bool</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check the final updated balance</span></span><br><span class=\"line\">    updatedAccount1, err := store.GetAccount(context.Background(), account1.ID)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    updatedAccount2, err := store.GetAccount(context.Background(), account2.ID)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    require.Equal(t, account1.Balance-<span class=\"keyword\">int64</span>(n)*amount, updatedAccount1.Balance)</span><br><span class=\"line\">    require.Equal(t, account2.Balance+<span class=\"keyword\">int64</span>(n)*amount, updatedAccount2.Balance)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着就可以运行这个测试，当然测试失败了，因为我们的转账事务中的修改两方余额的部分还没有写呢！</p>\n<h3 id=\"更新账户余额\">更新账户余额</h3>\n<p>通常我们一个直觉的想法就是通过<code>q.GetAccount()</code>获取账户然后通过<code>q.updateAccount()</code>来更新账户的余额，但是这样的做法是错误的，它没有考虑到锁的问题。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- name: GetAccount :one</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> accounts</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> $<span class=\"number\">1</span> LIMIT <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>从getAccount的数据库定义中我们可以发现它仅仅使用了一个SELECT语句，并没由阻止其他的事务来读取相同的账户记录，因此两个并行的记录可能会得到账户1的相同的值，并对这个值进行修改后提交。</p>\n<p>这种情况可以在语句后面加上<code>FOR UPDATE</code>来创造一个锁，这样只有在前一个占用该数据的事务commit之后，后一个事务才能获取该条数据并且进行修改。</p>\n<p>因此，我们可以在<code>account.sql</code>文件中增加一组操作：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- name: GetAccountForUpdate :one</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> accounts</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> $<span class=\"number\">1</span> LIMIT <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>\n<p>然后通过<code>make sqlc</code>来生成<code>account.sql.go</code>文件，这样我们需要的带锁的<code>GetAccountForUpdate()</code>函数就生成了。接着我们在事务中使用这个函数代替原本的<code>GetAccount()</code>函数，然而这一次又报错了，这次报的错是<strong>检查到死锁</strong>。</p>\n<p>为了能够debug出错误出在那里，我们为每个事务都加上一个名字，使用<code>fmt.Sprintf()</code>来创造不同的事务名称</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTx</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// run n concurrent transfer transaction</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        txName := fmt.Sprintf(<span class=\"string\">&quot;tx %d&quot;</span>, i+<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            ctx := context.WithValue(context.Background(), txKey, txName)</span><br><span class=\"line\"></span><br><span class=\"line\">            result, err := store.TransferTx(ctx, TransferTxParams&#123;</span><br><span class=\"line\">                FromAccountID: account1.ID,</span><br><span class=\"line\">                ToAccountID:   account2.ID,</span><br><span class=\"line\">                Amount:        amount,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">            errs &lt;- err</span><br><span class=\"line\">            results &lt;- result</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check results</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了能够将事务额的名称加到环境中，我们调用<code>context.WithValue()</code>传入一个background上下文和一对键值对，其中值就是对应的事务名称。文档中有说明上下文环境的key不应当是string类型或者任何其他内置的类型，这是为了避免键冲突。通常来说我们应当定义一个struct类型的变量来作为key。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> txKey = <span class=\"keyword\">struct</span>&#123;&#125;&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">TransferTx</span><span class=\"params\">(ctx context.Context, arg TransferTxParams)</span> <span class=\"params\">(TransferTxResult, error)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着在<code>TransferTx()</code>中,上下文环境会拥有事务名称，我们可以通过调用<code>ctx.Value()</code>来获取<code>txKey</code>的值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">TransferTx</span><span class=\"params\">(ctx context.Context, arg TransferTxParams)</span> <span class=\"params\">(TransferTxResult, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result TransferTxResult</span><br><span class=\"line\"></span><br><span class=\"line\">    err := store.execTx(ctx, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(q *Queries)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> err error</span><br><span class=\"line\"></span><br><span class=\"line\">        txName := ctx.Value(txKey)</span><br><span class=\"line\"></span><br><span class=\"line\">        fmt.Println(txName, <span class=\"string\">&quot;create transfer&quot;</span>)</span><br><span class=\"line\">        result.Transfer, err = q.CreateTransfer(ctx, CreateTransferParams&#123;</span><br><span class=\"line\">            FromAccountID: arg.FromAccountID,</span><br><span class=\"line\">            ToAccountID:   arg.ToAccountID,</span><br><span class=\"line\">            Amount:        arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        fmt.Println(txName, <span class=\"string\">&quot;create entry 1&quot;</span>)</span><br><span class=\"line\">        result.FromEntry, err = q.CreateEntry(ctx, CreateEntryParams&#123;</span><br><span class=\"line\">            AccountID: arg.FromAccountID,</span><br><span class=\"line\">            Amount:    -arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        fmt.Println(txName, <span class=\"string\">&quot;create entry 2&quot;</span>)</span><br><span class=\"line\">        result.ToEntry, err = q.CreateEntry(ctx, CreateEntryParams&#123;</span><br><span class=\"line\">            AccountID: arg.ToAccountID,</span><br><span class=\"line\">            Amount:    arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// move money out of account1</span></span><br><span class=\"line\">        fmt.Println(txName, <span class=\"string\">&quot;get account 1&quot;</span>)</span><br><span class=\"line\">        account1, err := q.GetAccountForUpdate(ctx, arg.FromAccountID)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        fmt.Println(txName, <span class=\"string\">&quot;update account 1&quot;</span>)</span><br><span class=\"line\">        result.FromAccount, err = q.UpdateAccount(ctx, UpdateAccountParams&#123;</span><br><span class=\"line\">            ID:      arg.FromAccountID,</span><br><span class=\"line\">            Balance: account1.Balance - arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// move money into account2</span></span><br><span class=\"line\">        fmt.Println(txName, <span class=\"string\">&quot;get account 2&quot;</span>)</span><br><span class=\"line\">        account2, err := q.GetAccountForUpdate(ctx, arg.ToAccountID)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        fmt.Println(txName, <span class=\"string\">&quot;update account 2&quot;</span>)</span><br><span class=\"line\">        result.ToAccount, err = q.UpdateAccount(ctx, UpdateAccountParams&#123;</span><br><span class=\"line\">            ID:      arg.ToAccountID,</span><br><span class=\"line\">            Balance: account2.Balance + arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们已经把输出log功能添加到程序中了，接下来我们只并行运行两个进程来进行debug。最终遭到出现死锁的原因是更新操作需要对账户进行上锁，而Select操作的表中有来自账户表中的外键，这时事务2等待事务1，事务1等待事务2，形成了死锁。</p>\n<p>此时我们已经知道，出现死锁的原因在于数据库担心事务1会对<code>accountID</code>进行更新从而影响到<code>transfer</code>表的外键约束，但是实际上我们并不会改动id，因此在数据库文件中我们要描述的更加具体:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- name: GetAccountForUpdate :one</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> accounts</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> $<span class=\"number\">1</span> LIMIT <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">FOR</span> <span class=\"keyword\">NO</span> KEY UPDATE;</span><br></pre></td></tr></table></figure>\n<p>接着<code>make sqlc</code>生成文件，并且运行测试发现能够通过了！</p>\n<p>但是我们还有更好的方法来完成转账事务，之前我们是使用两条qeuries语句来完成对账户的更新，而我们现在可以只用一条query语句来实现这个功能，我们直接在账户的余额上进行增加或者减少。因此我们需要添加一条新sql语句到<code>account.sql</code>中</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- name: AddAccountBalance :one</span></span><br><span class=\"line\">UPDATE accounts</span><br><span class=\"line\"><span class=\"keyword\">SET</span> balance <span class=\"operator\">=</span> balance <span class=\"operator\">+</span> $<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> $<span class=\"number\">2</span></span><br><span class=\"line\">RETURNING <span class=\"operator\">*</span>;</span><br></pre></td></tr></table></figure>\n<p>但是这样生成的参数中增加的金额的参数名为balance而按照我们的思维，应当是amount，所以我们对该sql语句进行修改</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- name: AddAccountBalance :one</span></span><br><span class=\"line\">UPDATE accounts</span><br><span class=\"line\"><span class=\"keyword\">SET</span> balance <span class=\"operator\">=</span> balance <span class=\"operator\">+</span> sqlc.arg(amount)</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> sqlc.arg(id)</span><br><span class=\"line\">RETURNING <span class=\"operator\">*</span>;</span><br></pre></td></tr></table></figure>\n<p>这样自动生成的语句中就能够自动将参数名改称amount了。然后回到<code>TransferTx()</code>中将<code>GetAccountForUpdate()</code>去掉，并且将<code>UpdateAccount()</code>替换为<code>AddAccountBalance()</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">TransferTx</span><span class=\"params\">(ctx context.Context, arg TransferTxParams)</span> <span class=\"params\">(TransferTxResult, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result TransferTxResult</span><br><span class=\"line\"></span><br><span class=\"line\">    err := store.execTx(ctx, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(q *Queries)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// move money out of account1</span></span><br><span class=\"line\">        result.FromAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class=\"line\">            ID:     arg.FromAccountID,</span><br><span class=\"line\">            Amount: -arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// move money into account2</span></span><br><span class=\"line\">        result.ToAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class=\"line\">            ID:     arg.ToAccountID,</span><br><span class=\"line\">            Amount: arg.Amount,</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何避免死锁\">如何避免死锁</h2>\n<p>前面我们已经解决了死锁的问题，但是如果我们呢仔细看的话我们能发现它仍然存在潜在的死锁问题。在事务中我们更新两个账户的余额，这两个操作都需要排他锁，因此如果存在两个事务同时对这两个账户进行操作就会存在一个潜在的死锁可能性。</p>\n<p>虽然我们已经确定了并行5个从账户1向账户2转账的并行事务是不会再产生死锁了，但是如果再并行5个从账户2向账户1转账的事务呢。结果我们会发现仍然会发生死锁的现象。</p>\n<p>原因是事务1可能完成了对1账户的更改，在申请对账户2的更改，而事务2完成了对账户2的更改，在申请对账户1的更改，但是两个事务都没有完成没法commit，所以就死锁了。</p>\n<p>我们可以做一个测试程序专门测试死锁</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTxDeadlock</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    store := NewStore(testDB)</span><br><span class=\"line\"></span><br><span class=\"line\">    account1 := createRandomAccount(t)</span><br><span class=\"line\">    account2 := createRandomAccount(t)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;&gt;&gt; before:&quot;</span>, account1.Balance, account2.Balance)</span><br><span class=\"line\"></span><br><span class=\"line\">    n := <span class=\"number\">10</span></span><br><span class=\"line\">    amount := <span class=\"keyword\">int64</span>(<span class=\"number\">10</span>)</span><br><span class=\"line\">    errs := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> error)</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再根据当前的循环次数的不同对<code>fromAccount</code>和<code>toAccount</code>进行不同的赋值</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTxDeadlock</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        fromAccountID := account1.ID</span><br><span class=\"line\">        toAccountID := account2.ID</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> i%<span class=\"number\">2</span> == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">            fromAccountID = account2.ID</span><br><span class=\"line\">            toAccountID = account1.ID</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">            _, err := store.TransferTx(context.Background(), TransferTxParams&#123;</span><br><span class=\"line\">                FromAccountID: fromAccountID,</span><br><span class=\"line\">                ToAccountID:   toAccountID,</span><br><span class=\"line\">                Amount:        amount,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">            errs &lt;- err</span><br><span class=\"line\">        &#125;()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后对错误和结果进行检查，这里因为我们只要检查结果，对于过程中的对错我们就不检查了，只要能有结果出来就说明不存在死锁了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestTransferTxDeadlock</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; n; i++ &#123;</span><br><span class=\"line\">        err := &lt;-errs</span><br><span class=\"line\">        require.NoError(t, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *Store)</span> <span class=\"title\">TransferTx</span><span class=\"params\">(ctx context.Context, arg TransferTxParams)</span> <span class=\"params\">(TransferTxResult, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result TransferTxResult</span><br><span class=\"line\"></span><br><span class=\"line\">    err := store.execTx(ctx, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(q *Queries)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> arg.FromAccountID &lt; arg.ToAccountID &#123;</span><br><span class=\"line\">            result.FromAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class=\"line\">                ID:     arg.FromAccountID,</span><br><span class=\"line\">                Amount: -arg.Amount,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> err</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            result.ToAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class=\"line\">                ID:     arg.ToAccountID,</span><br><span class=\"line\">                Amount: arg.Amount,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> err</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result.ToAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class=\"line\">                ID:     arg.ToAccountID,</span><br><span class=\"line\">                Amount: arg.Amount,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> err</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            result.FromAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class=\"line\">                ID:     arg.FromAccountID,</span><br><span class=\"line\">                Amount: -arg.Amount,</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> err</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result, err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用Gin框架在go语言中实现HTTP-API\">使用Gin框架在go语言中实现HTTP API</h2>\n<p>首先我们安装gin框架</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>\n<h3 id=\"定义服务器结构体\">定义服务器结构体</h3>\n<p>创建一个新的目录<code>api</code>并且在其中创建一个新的文件<code>server.go</code>，这里是我们实现HTTP API服务器的地方。</p>\n<p>首先我们定义一个Server结构体，它会提供所有的HTTP请求，它有两个字段：</p>\n<ul>\n<li><code>db.Store</code>，它使得我们处理来自客户端的请求的时候能够和数据库互动</li>\n<li><code>gin.Engine</code>，它是一个router，帮我们将每一个API请求送到正确的handler上</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    store  *db.Store</span><br><span class=\"line\">    router *gin.Engine</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着增加一个函数<code>NewServer</code>，它以<code>db.Store</code>为输入，返回一个<code>Server</code>。这个函数创造一个Server实例，并且为我们的服务在服务器上创建所有的HTTP API route。</p>\n<p>首先创建一个Server对象，然后创建一个router，我们会将routes添加到这个router中，在这之后我们将这个router分配给server并且返回server。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store *db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    server := &amp;Server&#123;store: store&#125;</span><br><span class=\"line\">    router := gin.Default()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> add routes to router</span></span><br><span class=\"line\"></span><br><span class=\"line\">    server.router = router</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们可以将第一个用于创建新账户的API以POST方式挂到该router上了，需要传入router的路径以及一个handler函数，如果传入多个函数的话，最后一个函数是真正的handler，其他的函数都应当是中间件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store *db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    server := &amp;Server&#123;store: store&#125;</span><br><span class=\"line\">    router := gin.Default()</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class=\"line\"></span><br><span class=\"line\">    server.router = router</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现创建账户API\">实现创建账户API</h3>\n<p>在当前<code>api</code>目录下创建一个新的<code>account.go</code>文件来实现跟account相关的api。其中我们声明一个<code>creatAccount()</code>函数，<strong>它必须只以一个<code>gin.Context</code>对象为输入</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createAccount</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着需要定义一个结构体去存储创建账户请求，它的字段和<code>createAccountParams</code>相近，但是不需要设置balance，因为创建账户时余额应当为0不能让客户端自己指定。<br>\n由于我们需要从HTTP请求主体中获取参数，所以字段的json标签仍然是需要的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> createAccountRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Owner    <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;owner&quot;`</span></span><br><span class=\"line\">    Currency <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;currency&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createAccount</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，无论何时我们获取到客户端传过来的输入数据时都要进行验证，因为可能会有非法的数据传过来。Gin在内部使用了一个验证包来自动执行验证。我们对两个字段增加binding的<code>required</code>标签，同时我们的银行只支持两种货币<code>USD</code>和<code>EUR</code>则我们在binding标签中还需要增加一个oneof参数用于指定值一定是在哪个范围</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> createAccountRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Owner    <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;owner&quot; binding:&quot;required&quot;`</span></span><br><span class=\"line\">    Currency <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;currency&quot; binding:&quot;required,oneof=USD EUR&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在<code>createAccount()</code>函数主体中我们生命一个该类型的实例<code>req</code>并且通过<code>ctx.shouldBindJSON()</code>来解析传过来的请求并且赋值给该<code>req</code>。这个函数会返回一个错误，如果存在错误的话就说明传过来的数据有问题我们返回一个badRequest错误，用<code>ctx.JSON()</code>实现。其中的第一个参数是HTTP状态码<code>http.StatusBadRequest</code>，第二个参数是我们希望返回给客户端的JSON对象。由于我们想返回的是个错误，所以我们需要将错误转变为一个键值对，这样Gin框架能够将他转成JSON并且返回给客户端。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createAccount</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> req createAccountRequest</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := ctx.ShouldBindJSON(&amp;req); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的<code>errorResponse()</code>是我们自定义的函数，由于我们后面会经常用到它，所以我们将它在<code>server.go</code>里面实现，我们使用<code>gin.H()</code>将错误转换为一个键值对，该函数本质上就是一个<code>map[string]interface&#123;&#125;</code>的别称。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">errorResponse</span><span class=\"params\">(err error)</span> <span class=\"title\">gin</span>.<span class=\"title\">H</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gin.H&#123;<span class=\"string\">&quot;error&quot;</span>: err.Error()&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们准备好对数据库进行CreatAccount的参数，然后调用该操作就可以了</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createAccount</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> req createAccountRequest</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := ctx.ShouldBindJSON(&amp;req); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    arg := db.CreateAccountParams&#123;</span><br><span class=\"line\">        Owner:    req.Owner,</span><br><span class=\"line\">        Currency: req.Currency,</span><br><span class=\"line\">        Balance:  <span class=\"number\">0</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    account, err := server.store.CreateAccount(ctx, arg)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.JSON(http.StatusOK, account)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"开启HTTP服务\">开启HTTP服务</h3>\n<p>我们对Server创建一个<code>Start</code>函数，它以一个地址作为输入，作用是在这个地址上运行我们的HTTP服务以监听传过来的API请求。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">Start</span><span class=\"params\">(address <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server.router.Run(address)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们创建server的入口，<code>main.go</code>在项目根目录下面，其具体内容和<code>main_test.go</code>相近，我们通过调用<code>db.NewStore()</code>创建一个<code>store</code>，再调用<code>api.NewServer()</code>来创建一个新的server。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    dbDriver      = <span class=\"string\">&quot;postgres&quot;</span></span><br><span class=\"line\">    dbSource      = <span class=\"string\">&quot;postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    conn, err := sql.Open(dbDriver, dbSource)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    store := db.NewStore(conn)</span><br><span class=\"line\">    server := api.NewServer(store)</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外我们还需要设置服务器监听的地址以及导入一个间接引用的包否则我们无法和数据库进行对话</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;database/sql&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    _ <span class=\"string\">&quot;github.com/lib/pq&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/techschool/simplebank/api&quot;</span></span><br><span class=\"line\">    db <span class=\"string\">&quot;github.com/techschool/simplebank/db/sqlc&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    dbDriver      = <span class=\"string\">&quot;postgres&quot;</span></span><br><span class=\"line\">    dbSource      = <span class=\"string\">&quot;postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable&quot;</span></span><br><span class=\"line\">    serverAddress = <span class=\"string\">&quot;0.0.0.0:8080&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    conn, err := sql.Open(dbDriver, dbSource)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    store := db.NewStore(conn)</span><br><span class=\"line\">    server := api.NewServer(store)</span><br><span class=\"line\"></span><br><span class=\"line\">    err = server.Start(serverAddress)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot start server:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在主函数入口完成了，我们可以去<code>Makefile</code>中再加入一个server指令，内容为<code>go run main.go</code></p>\n<h3 id=\"测试API接口\">测试API接口</h3>\n<p>这里我们可以用postman来模拟对接口的访问，注意下载postman的时候不要科学上网，不然会很慢。</p>\n<h3 id=\"实现get-account-API接口\">实现get account API接口</h3>\n<p>与上面不同的是，这里用GET请求显示地给出要查询的account的id。我们在<code>NewServer()</code>函数中使用GET方法向路径中添加一个功能。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store *db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts/:id&quot;</span>, server.getAccount)</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们需要实现<code>getAccount</code>handler。我们去到<code>account.go</code>中进行实现，我们首先需要一个结构体来作为请求的参数，这里由于ID是通过URI参数的方式获取到的，我们就不能用json标签了而是应该使用uri标签。同样的，在实现的过程中还需要将<code>shouldBindJSON</code>改为<code>shouldBindUri</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">getAccount</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> req getAccountRequest</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := ctx.ShouldBindUri(&amp;req); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    account, err := server.store.GetAccount(ctx, req.ID)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err == sql.ErrNoRows &#123;</span><br><span class=\"line\">            ctx.JSON(http.StatusNotFound, errorResponse(err))</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.JSON(http.StatusOK, account)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于list account的方法也是大同小异，其主要在于它的两个参数应该用<code>shouldBindQuery</code>来获取，它是通过query string传递参数的</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> listAccountRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    PageID   <span class=\"keyword\">int32</span> <span class=\"string\">`form:&quot;page_id&quot; binding:&quot;required,min=1&quot;`</span></span><br><span class=\"line\">    PageSize <span class=\"keyword\">int32</span> <span class=\"string\">`form:&quot;page_size&quot; binding:&quot;required,min=5,max=10&quot;`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">listAccount</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> req listAccountRequest</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := ctx.ShouldBindQuery(&amp;req); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    arg := db.ListAccountsParams&#123;</span><br><span class=\"line\">        Limit:  req.PageSize,</span><br><span class=\"line\">        Offset: (req.PageID - <span class=\"number\">1</span>) * req.PageSize,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    accounts, err := server.store.ListAccounts(ctx, arg)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.JSON(http.StatusOK, accounts)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用Viper从文件中加载配置和环境变量\">使用Viper从文件中加载配置和环境变量</h2>\n<p>开发和部署后端的时候我们需要对不同的环境使用不同的配置。</p>\n<p>在我们目前的代码中，我们有一些以constant形式的变量配置在<code>main_test.go</code>中，接下来我们就要用viper来从文件和环境变量中读取这些配置信息。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    dbDriver      = <span class=\"string\">&quot;postgres&quot;</span></span><br><span class=\"line\">    dbSource      = <span class=\"string\">&quot;postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable&quot;</span></span><br><span class=\"line\">    serverAddress = <span class=\"string\">&quot;0.0.0.0:8080&quot;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>首先是安装Viper，进入<a href=\"https://github.com/spf13/viper\">Viper的github主页</a>下载安装viper。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get github.com/spf13/viper</span><br></pre></td></tr></table></figure>\n<h3 id=\"创建配置文件\">创建配置文件</h3>\n<p>我们需要创建一个新的文件<code>app.env</code>来保存我们的配置信息，接着我们将上面的变量复制到这里，但是由于我们使用的是.env格式的文件，所以我们需要更改一下格式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DB_DRIVER=postgres</span><br><span class=\"line\">DB_SOURCE=postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable</span><br><span class=\"line\">SERVER_ADDRESS=0.0.0.0:8080</span><br></pre></td></tr></table></figure>\n<h3 id=\"加载配置文件\">加载配置文件</h3>\n<p>我们在util目录下创建一个config包，然后我们声明一个新的<code>Config</code>结构体变量，这个结构体中将会包含所有的配置变量信息，目前，我们有3个变量</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Config <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    DBDriver      <span class=\"keyword\">string</span> <span class=\"string\">`mapstructure:&quot;DB_DRIVER&quot;`</span></span><br><span class=\"line\">    DBSource      <span class=\"keyword\">string</span> <span class=\"string\">`mapstructure:&quot;DB_SOURCE&quot;`</span></span><br><span class=\"line\">    ServerAddress <span class=\"keyword\">string</span> <span class=\"string\">`mapstructure:&quot;SERVER_ADDRESS&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了能够获取到变量的值并且将他们保存到结构体中，我们需要用到Vpier的unmarshaling特征，viper使用<a href=\"https://github.com/mitchellh/mapstructure\">mapstructure</a>包在底层解析数据，因此我们需要使用mapstructure标签来制定每一个配置字段的名称</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Config <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    DBDriver      <span class=\"keyword\">string</span> <span class=\"string\">`mapstructure:&quot;DB_DRIVER&quot;`</span></span><br><span class=\"line\">    DBSource      <span class=\"keyword\">string</span> <span class=\"string\">`mapstructure:&quot;DB_SOURCE&quot;`</span></span><br><span class=\"line\">    ServerAddress <span class=\"keyword\">string</span> <span class=\"string\">`mapstructure:&quot;SERVER_ADDRESS&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来我们需要定义一个新的函数<code>LoadConfig()</code>，它以一个路径为输入，并且返回一个Config对象或者一个错误。这个函数会从路径中存在的配置文件中读取配置信息，或者重写这些配置的值</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LoadConfig</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(config Config, err error)</span></span> &#123;</span><br><span class=\"line\">    viper.AddConfigPath(path)</span><br><span class=\"line\">    viper.SetConfigName(<span class=\"string\">&quot;app&quot;</span>)</span><br><span class=\"line\">    viper.SetConfigType(<span class=\"string\">&quot;env&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了从文件中读取配置，我们还希望viper能够从环境变量中读取值，所以我们调用<code>viper.AutomaticEnv()</code>来让viper自动覆盖它已经从配置文件中读取到的相关的环境变量的值。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LoadConfig reads configuration from file or environment variables.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">LoadConfig</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(config Config, err error)</span></span> &#123;</span><br><span class=\"line\">    viper.AddConfigPath(path)</span><br><span class=\"line\">    viper.SetConfigName(<span class=\"string\">&quot;app&quot;</span>)</span><br><span class=\"line\">    viper.SetConfigType(<span class=\"string\">&quot;env&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    viper.AutomaticEnv()</span><br><span class=\"line\"></span><br><span class=\"line\">    err = viper.ReadInConfig()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = viper.Unmarshal(&amp;config)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后我们调用<code>viper.ReadInConfig()</code>来开始读取配置值。</p>\n<p>最后我们调用<code>viper.Unmarshal()</code>来将值解析到<code>config</code>变量中，最后返回。</p>\n<h3 id=\"在主函数中使用LoadConfig\">在主函数中使用LoadConfig</h3>\n<p>我们将之前手动配置的值全部删除，然后在主函数中我们调用刚才写的<code>util.LoadConfig()</code>并且传入<code>.</code>，意思是用当前的目录作为路径，因为我们的配置文件<code>app.env</code>是在<code>main.go</code>的统一目录下的。</p>\n<p>如果存在错误的话我么写一个fatal log来记录无法加载配置文件。否则，就成功，我们的原先的配置值就成为了结构体中的字段值，调用就可以了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    config, err := util.LoadConfig(<span class=\"string\">&quot;.&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot load config:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    conn, err := sql.Open(config.DBDriver, config.DBSource)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    store := db.NewStore(conn)</span><br><span class=\"line\">    server := api.NewServer(store)</span><br><span class=\"line\"></span><br><span class=\"line\">    err = server.Start(config.ServerAddress)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot start server:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样，在测试函数的主函数中我们也可以使用同样的方法加载这些配置信息。</p>\n<h2 id=\"为测试HTTP-API模拟一个数据库\">为测试HTTP API模拟一个数据库</h2>\n<p>如果我们无法隔离单元测试的数据来避免冲突，可以尝试模拟数据库。我们使用<a href=\"https://github.com/golang/mock\">Gomock</a>来为数据库结构生成存根。</p>\n<h3 id=\"模拟数据库的两种方式\">模拟数据库的两种方式</h3>\n<p>第一种方式是生成一个虚拟数据库，它将信息保存在内存之中。比如我们有一个Store接口定义了一系列的对于真实数据库的操作，那么我们就可以定义一个虚拟数据库的<code>MemStore</code>结构体来实现<code>Store</code>接口的所有功能，但只用一个映射去读取和写入数据。这个方法简单且易于实现，但是它需要我们去写更多只能用于测试的代码，这非常耗时。</p>\n<p>所以接下来我们将会用一个更好的方法来模拟数据库，<strong>使用存根来替代虚假的数据库</strong>。基本思路是使用<code>gomock</code>包来生成和构建存根，它会返回我们想要测试的场景的硬编码。</p>\n<p>在我们这个例子中，gomock会生成一个<code>MockStore</code>，我们需要做的是调用它的<code>EXPECT()</code>函数来生成一个存根，它会告诉gomock：<code>GetAccount()</code>函数通过输入的<code>AccountID</code>只能被调用一次，并且返回账户对象作为输出。这之后，我们只需要使用这个虚拟的store就可以测试API了。</p>\n<h3 id=\"安装gomock\">安装gomock</h3>\n<p>首先我们去gomock的github主页按照其中的命令安装gomock</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get github.com/golang/mock/mockgen@v1.4.4</span><br></pre></td></tr></table></figure>\n<p>接着可以发现，一个<code>mockgen</code>的二进制文件出现在go/bin的文件夹下。</p>\n<p>我们会使用这个工具来生成模拟数据库，所以我们要确认该命令能够在任何地方执行。我们可以通过以下命令检查</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">❯ which mockgen</span><br><span class=\"line\">mockgen not found</span><br></pre></td></tr></table></figure>\n<p>如果出现如上的情况所名go/bin目录没有被添加到环境变量中，我们可以将它添加到环境变量中。</p>\n<h3 id=\"定义Store接口\">定义Store接口</h3>\n<p>为了能够使用mockgen来生成虚拟数据库，我们需要先稍微修改一下我们的代码。</p>\n<p>目前，在<code>api/server.go</code>文件中，<code>NewServer()</code>函数接收一个<code>db.Store</code>对象</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    store  *db.Store</span><br><span class=\"line\">    router *gin.Engine</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store *db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>db.Store</code>是在<code>db/sqlc/store.go</code>中定义的，这是我们连接真实数据库的结构体</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Store <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    db *sql.DB</span><br><span class=\"line\">    *Queries</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了能在API测试中使用虚拟数据库，我们需要用一个接口替代store对象。我们会赋值<code>Store</code>结构体的定义并且将它的类型改成接口。然后将原本的定义重命名为<code>SQLStore</code>，这是<code>Store</code>接口的真实实现，能够与SQL数据库交互。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Store <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> add functions to this interface</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> SQLStore <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    db *sql.DB</span><br><span class=\"line\">    *Queries</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>接着，<code>NewStore()</code>函数不应该再返回一个指针，而是直接返回一个接口，并且在内部它应当返回真实的数据库接口实现</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewStore</span><span class=\"params\">(db *sql.DB)</span> <span class=\"title\">Store</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;SQLStore&#123;</span><br><span class=\"line\">        db:      db,</span><br><span class=\"line\">        Queries: New(db),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们同样需要改变<code>execTx()</code>和<code>TransferTx()</code>函数的<code>store</code>接收器类型改为<code>*SQLStore</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *SQLStore)</span> <span class=\"title\">execTx</span><span class=\"params\">(ctx context.Context, fn <span class=\"keyword\">func</span>(*Queries)</span> <span class=\"title\">error</span>) <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *SQLStore)</span> <span class=\"title\">TransferTx</span><span class=\"params\">(ctx context.Context, arg TransferTxParams)</span> <span class=\"params\">(TransferTxResult, error)</span></span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们需要定义一系列<code>Store</code>接口能够执行的操作。首先，它应该拥有所有的<code>Queries</code>结构体的函数，并且还多处一个执行转账交易的函数。所以我们首先将<code>TransferTx()</code>的定义复制到<code>Store</code>接口中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Store <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于<code>Queries</code>结构体的函数，我们可以同样赋值粘贴，但是这样太耗时了。所幸，sqlc包中有一个选项是发散包含<code>Queries</code>结构体包含的所有函数的接口。我们所要做的就是将它的值这是为true</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\"><span class=\"attr\">packages:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">&quot;db&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">path:</span> <span class=\"string\">&quot;./db/sqlc&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">queries:</span> <span class=\"string\">&quot;./db/query/&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">schema:</span> <span class=\"string\">&quot;./db/migration/&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">engine:</span> <span class=\"string\">&quot;postgresql&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">emit_json_tags:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">emit_prepared_queries:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">emit_interface:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"attr\">emit_exact_table_names:</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"attr\">emit_empty_slices:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>然后再执行一次make sqlc</p>\n<p>之后在<code>db/sqlc</code>中我们可以看到一个新的文件<code>querier.go</code>，它包含了生成的<code>Querier</code>接口其中包含所有的对数据库进行交互操作的函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Querier <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    AddAccountBalance(ctx context.Context, arg AddAccountBalanceParams) (Account, error)</span><br><span class=\"line\">    CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error)</span><br><span class=\"line\">    CreateEntry(ctx context.Context, arg CreateEntryParams) (Entry, error)</span><br><span class=\"line\">    CreateTransfer(ctx context.Context, arg CreateTransferParams) (Transfer, error)</span><br><span class=\"line\">    DeleteAccount(ctx context.Context, id <span class=\"keyword\">int64</span>) error</span><br><span class=\"line\">    GetAccount(ctx context.Context, id <span class=\"keyword\">int64</span>) (Account, error)</span><br><span class=\"line\">    GetAccountForUpdate(ctx context.Context, id <span class=\"keyword\">int64</span>) (Account, error)</span><br><span class=\"line\">    GetEntry(ctx context.Context, id <span class=\"keyword\">int64</span>) (Entry, error)</span><br><span class=\"line\">    GetTransfer(ctx context.Context, id <span class=\"keyword\">int64</span>) (Transfer, error)</span><br><span class=\"line\">    ListAccounts(ctx context.Context, arg ListAccountsParams) ([]Account, error)</span><br><span class=\"line\">    ListEntries(ctx context.Context, arg ListEntriesParams) ([]Entry, error)</span><br><span class=\"line\">    ListTransfers(ctx context.Context, arg ListTransfersParams) ([]Transfer, error)</span><br><span class=\"line\">    UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> _ Querier = (*Queries)(<span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<p>接着我们只需要将这个接口的定义迁入到<code>Store</code>接口中就可以了</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Store <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Querier</span><br><span class=\"line\">    TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们回到<code>api/server.go</code>文件中将<code>*db.Store</code>类型因为它不再是一个结构体指针了而是一个接口</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并且由于我们更改了<code>db.NewStore</code>的返回值所以我们在<code>main.go</code>中不需要对函数主体进行任何的修改</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    config, err := util.LoadConfig(<span class=\"string\">&quot;.&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot load config:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    conn, err := sql.Open(config.DBDriver, config.DBSource)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    store := db.NewStore(conn)</span><br><span class=\"line\">    server := api.NewServer(store)</span><br><span class=\"line\"></span><br><span class=\"line\">    err = server.Start(config.ServerAddress)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot start server:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成模拟数据库\">生成模拟数据库</h3>\n<p>目前我们已经有了<code>db.Store</code>接口，我们能够使用gomock去生成一个虚拟实现。</p>\n<p>首先我们创造一个新的<code>mock</code>目录在<code>db</code>目录下，然后我们打开终端运行<code>mockgen -help</code>。mockgen给我们两种方式去生成模拟，<code>source mode</code>会从单个源文件生成模拟接口，这在该文件导入了别的包的情况下会比较复杂。</p>\n<p>在本例子中，我们最好使用<code>reflect mode</code>，我们只需要提供包的名字和接口，mockgen就会利用反射去自动决定怎么做</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">mockgen github.com/techschool/simplebank/db/sqlc Store</span><br></pre></td></tr></table></figure>\n<p>第一个参数是导入的<code>Store</code>的路径即该接口定义的路径，第二个参数是接口的名称。我们还应该制定生成文件的路径。否则，mockgen会默认生成代码到标准输出上。所以我们用<code>-destination</code>来指定代码生成的位置。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">mockgen -destination db/mock/store.go github.com/techschool/simplebank/db/sqlc Store</span><br></pre></td></tr></table></figure>\n<p>在生成文件中有两个重要的结构体<code>MockStore</code>和<code>MockStoreRecorder</code></p>\n<p><code>MockStore</code>是执行所有<code>Store</code>接口的必要函数的结构体，<code>MockStoreRecorder</code>同样有这些相同名字的函数，只不过他们的参数是普通的接口类型。</p>\n<p>此外，由mockgen生成的代码的包的名字是<code>mock_sqlc</code>这不太好，我们可以在刚才的命令中加入一个参数来指定包名。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">mockgen -package mockdb -destination db/mock/store.go github.com/techschool/simplebank/db/sqlc Store</span><br></pre></td></tr></table></figure>\n<p>接下来我们先在MakeFile中将mock命令添加进区，之后就可以测试API了</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">mock:</span></span><br><span class=\"line\">    mockgen -package mockdb -destination db/mock/store.go github.com/techschool/simplebank/db/sqlc Store</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: postgres createdb dropdb migrateup migratedown sqlc test </span></span><br></pre></td></tr></table></figure>\n<h3 id=\"对API进行单元测试\">对API进行单元测试</h3>\n<p>在api目录下创建一个新的文件<code>account_test.go</code>。在其中我们定义一个新的函数<code>TestGetAccountAPI(t *testing.T)</code>。为了能够测试，我们需要账户，所以我们先写一个函数来生成随机的账户</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomAccount</span><span class=\"params\">()</span> <span class=\"title\">db</span>.<span class=\"title\">Account</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> db.Account&#123;</span><br><span class=\"line\">        ID:       util.RandomInt(<span class=\"number\">1</span>, <span class=\"number\">1000</span>),</span><br><span class=\"line\">        Owner:    util.RandomOwner(),</span><br><span class=\"line\">        Balance:  util.RandomMoney(),</span><br><span class=\"line\">        Currency: util.RandomCurrency(),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们返回测试，在函数中调用上面这个函数来创建一个新的用户</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    account := randomAccount()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们需要用<code>mockdb.NewMockStore()</code>创建一个新的mock store，它以一个gomock.Controller对象为输入，所以我们需要调用一个<code>gomock.NewController</code>来创建一个controller。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    account := randomAccount()</span><br><span class=\"line\"></span><br><span class=\"line\">    ctrl := gomock.NewController(t)</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> ctrl.Finish()</span><br><span class=\"line\"></span><br><span class=\"line\">    store := mockdb.NewMockStore(ctrl)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>defer调用finish非常重要，因为它会检查是否所有我们希望调用的函数都被调用到了。</p>\n<p>接下来是为虚拟store创建存根，在这个案例中我们值关心<code>GetAccount()</code>方法，因为它是唯一一个需要被GetAccount API调用的方法。所以接下来我们调用<code>store.EXPECT().GetAccount()</code>方法来创建存根。而<code>GetAccount()</code>方法需要两个参数作为输入，因此我们需要给出这两个参数。</p>\n<p>对于第一个参数，是上下文环境参数，它可以是任意值，所以我们使用<code>gomock.Any()</code>来匹配它，第二个参数应该等于我们创造的随机账户的ID，所以我们使用<code>gomock.Eq()</code>来匹配<code>account.ID</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    account := randomAccount()</span><br><span class=\"line\"></span><br><span class=\"line\">    ctrl := gomock.NewController(t)</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> ctrl.Finish()</span><br><span class=\"line\"></span><br><span class=\"line\">    store := mockdb.NewMockStore(ctrl)</span><br><span class=\"line\">    store.EXPECT().</span><br><span class=\"line\">        GetAccount(gomock.Any(), gomock.Eq(account.ID)).</span><br><span class=\"line\">        Times(<span class=\"number\">1</span>).</span><br><span class=\"line\">        Return(account, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样这个存根的意思就可以翻译为我希望GetAccount()函数被调用并且其参数是一个随意的上下文和指定的账户ID</p>\n<p>我们同样还可以指定函数应当被调用的次数，<code>Time(1)</code>表示我们希望这个函数被调用一次。此外我们还可以用<code>Return()</code>函数来告诉gomock返回指定的值。比如，在这个例子中，我们希望他能够返回账户对象和nil错误。需要注意的是，这里的Return函数的返回应当和GetAccount函数的返回值是相同的。</p>\n<p>现在存根已经设置完毕了，我们开始创建一个服务器</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    server := NewServer(store)</span><br><span class=\"line\">    recorder := httptest.NewRecorder()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了测试API我们不需要真的开启一个服务器，我们只需要使用httptest包的recording特征来记录API请求的返回值。所以我们调用<code>httptest.Recorder()</code>来创建一个新的<code>ResponseRecorder</code>。</p>\n<p>接着我们声明我们希望调用的API的url路径，在这里就是<code>/accounts/&#123;ID of the account we want to get&#125;</code>。然后我们用GET方法创建一个新的HTTP请求，因为用的是GET，我们可以对request body使用nil。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    server := NewServer(store)</span><br><span class=\"line\">    recorder := httptest.NewRecorder()</span><br><span class=\"line\"></span><br><span class=\"line\">    url := fmt.Sprintf(<span class=\"string\">&quot;/accounts/%d&quot;</span>, tc.accountID)</span><br><span class=\"line\">    request, err := http.NewRequest(http.MethodGet, url, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们用创建的recorder和request对象调用<code>server.router.ServeHTTP()</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    account := randomAccount()</span><br><span class=\"line\"></span><br><span class=\"line\">    ctrl := gomock.NewController(t)</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> ctrl.Finish()</span><br><span class=\"line\"></span><br><span class=\"line\">    store := mockdb.NewMockStore(ctrl)</span><br><span class=\"line\">    store.EXPECT().</span><br><span class=\"line\">        GetAccount(gomock.Any(), gomock.Eq(account.ID)).</span><br><span class=\"line\">        Times(<span class=\"number\">1</span>).</span><br><span class=\"line\">        Return(account, <span class=\"literal\">nil</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    server := NewServer(store)</span><br><span class=\"line\">    recorder := httptest.NewRecorder()</span><br><span class=\"line\"></span><br><span class=\"line\">    url := fmt.Sprintf(<span class=\"string\">&quot;/accounts/%d&quot;</span>, tc.accountID)</span><br><span class=\"line\">    request, err := http.NewRequest(http.MethodGet, url, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    server.router.ServeHTTP(recorder, request)</span><br><span class=\"line\">    require.Equal(t, http.StatusOK, recorder.Code)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面我们只是简单地检查了返回的http状态码是否正确，这是一种比较简陋的方法。</p>\n<p>那如果我们想要检查返回的主体呢，我们可以调用<code>requireBodyMatchAccount()</code>，它有三个参数：<code>testing.T</code>,<code>byte.Buffer</code>指针类型的返回主体和去比较的账户对象。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">requireBodyMatchAccount</span><span class=\"params\">(t *testing.T, body *bytes.Buffer, account db.Account)</span></span> &#123;</span><br><span class=\"line\">    data, err := ioutil.ReadAll(body)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> gotAccount db.Account</span><br><span class=\"line\">    err = json.Unmarshal(data, &amp;gotAccount)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.Equal(t, account, gotAccount)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取100-的覆盖率\">获取100%的覆盖率</h3>\n<p>首先我们需要定义一组测试用例，每一个测试用例会有一个独特的名字与其他用例区别开，并且会有一个accountID字段用来指定用于测试的id，此外由于每个测试所用到的存根时不一样的，所以要用一个对应的字段作为存根的设置，检查返回字段也是一样的道理。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    account := randomAccount()</span><br><span class=\"line\"></span><br><span class=\"line\">    testCases := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        name          <span class=\"keyword\">string</span></span><br><span class=\"line\">        accountID     <span class=\"keyword\">int64</span></span><br><span class=\"line\">        buildStubs    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span></span><br><span class=\"line\">        checkResponse <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T, recoder *httptest.ResponseRecorder)</span></span></span><br><span class=\"line\">    &#125;&#123;</span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> add test data</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们可以增加一些不同的场景到我们的测试用例里面了</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    account := randomAccount()</span><br><span class=\"line\"></span><br><span class=\"line\">    testCases := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        name          <span class=\"keyword\">string</span></span><br><span class=\"line\">        accountID     <span class=\"keyword\">int64</span></span><br><span class=\"line\">        buildStubs    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span></span><br><span class=\"line\">        checkResponse <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T, recoder *httptest.ResponseRecorder)</span></span></span><br><span class=\"line\">    &#125;&#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name:      <span class=\"string\">&quot;OK&quot;</span>,</span><br><span class=\"line\">            accountID: account.ID,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    GetAccount(gomock.Any(), gomock.Eq(account.ID)).</span><br><span class=\"line\">                    Times(<span class=\"number\">1</span>).</span><br><span class=\"line\">                    Return(account, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T, recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusOK, recorder.Code)</span><br><span class=\"line\">                requireBodyMatchAccount(t, recorder.Body, account)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后我们会在里面添加一些不同的案例场景，所以在测试函数中我们使用一个for loop来进行测试，我们将每个测试用例作为一个独立的测试，所以在for loop中我们呢使用<code>t.Run()</code>，传入用例名称和一个函数，然后将之前写的测试函数内部的操作都放到这个函数里面去。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGetAccountAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> testCases &#123;</span><br><span class=\"line\">        tc := testCases[i]</span><br><span class=\"line\"></span><br><span class=\"line\">        t.Run(tc.name, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">            ctrl := gomock.NewController(t)</span><br><span class=\"line\">            <span class=\"keyword\">defer</span> ctrl.Finish()</span><br><span class=\"line\"></span><br><span class=\"line\">            store := mockdb.NewMockStore(ctrl)</span><br><span class=\"line\">            tc.buildStubs(store)</span><br><span class=\"line\"></span><br><span class=\"line\">            server := NewServer(store)</span><br><span class=\"line\">            recorder := httptest.NewRecorder()</span><br><span class=\"line\"></span><br><span class=\"line\">            url := fmt.Sprintf(<span class=\"string\">&quot;/accounts/%d&quot;</span>, tc.accountID)</span><br><span class=\"line\">            request, err := http.NewRequest(http.MethodGet, url, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">            server.router.ServeHTTP(recorder, request)</span><br><span class=\"line\">            tc.checkResponse(t, recorder)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后可以按照我们自己的想法向其中添加不同的测试用例，但是之后运行测试的时候会发现控制台中的输出太多了，干扰到我们观察我们需要观察的数据，这是因为Gin默认是在Debug模式下运行的。我们可以在api目录下创建一个<code>main_test.go</code>函数来将Gin的模式设置为Test模式。这个文件的内容和db包下的<code>main_test.go</code>文件是类似的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestMain</span><span class=\"params\">(m *testing.M)</span></span> &#123;</span><br><span class=\"line\">    gin.SetMode(gin.TestMode)</span><br><span class=\"line\">    os.Exit(m.Run())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用自定义参数验证器实现转账\">使用自定义参数验证器实现转账</h2>\n<p>这一节将会实现对于银行来说最重要的API：转账。并且还会实现一个自定义验证器来验证传给API的输入参数。</p>\n<h3 id=\"实现转账API的handler\">实现转账API的handler</h3>\n<p>我们首先在api包中创建一个transfer.go文件，转账api的实现和创建账户api的实现是相似的。</p>\n<p>我们用<code>transferRequest</code>结构体来保存api的输入参数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> transferRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    FromAccountID <span class=\"keyword\">int64</span>  <span class=\"string\">`json:&quot;from_account_id&quot; binding:&quot;required,min=1&quot;`</span></span><br><span class=\"line\">    ToAccountID   <span class=\"keyword\">int64</span>  <span class=\"string\">`json:&quot;to_account_id&quot; binding:&quot;required,min=1&quot;`</span></span><br><span class=\"line\">    Amount        <span class=\"keyword\">int64</span>  <span class=\"string\">`json:&quot;amount&quot; binding:&quot;required,gt=0&quot;`</span></span><br><span class=\"line\">    Currency      <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;currency&quot; binding:&quot;required,oneof=USD EUR CAD&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着在hadler函数<code>creatTransfer()</code>中将参数和请求进行绑定，并且如果出现错误的话就返回<code>http.StatusBadRequest</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createTransfer</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> req transferRequest</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := ctx.ShouldBindJSON(&amp;req); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    arg := db.TransferTxParams&#123;</span><br><span class=\"line\">        FromAccountID: req.FromAccountID,</span><br><span class=\"line\">        ToAccountID:   req.ToAccountID,</span><br><span class=\"line\">        Amount:        req.Amount,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    result, err := server.store.TransferTx(ctx, arg)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.JSON(http.StatusOK, result)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的函数中我们已经创建好了一个handler函数了，但是我们req参数中的<code>request.Currency</code>其实是没有用到的，我们需要做的是比较转出账户和转入账户中这个参数是否是相同的。因此我们需要为<code>Server</code>结构体定义一个新的函数<code>validAccount()</code>。</p>\n<p>这个函数会检查带有指定ID的账户是否真实存在并且它的货币是否跟输入的货币相匹配。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">validAccount</span><span class=\"params\">(ctx *gin.Context, accountID <span class=\"keyword\">int64</span>, currency <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    account, err := server.store.GetAccount(ctx, accountID)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err == sql.ErrNoRows &#123;</span><br><span class=\"line\">            ctx.JSON(http.StatusNotFound, errorResponse(err))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> account.Currency != currency &#123;</span><br><span class=\"line\">        err := fmt.Errorf(<span class=\"string\">&quot;account [%d] currency mismatch: %s vs %s&quot;</span>, account.ID, account.Currency, currency)</span><br><span class=\"line\">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们要回到刚才的handler函数中，将这个valid模块插入进去。</p>\n<h3 id=\"登记转账API的路径\">登记转账API的路径</h3>\n<p>我们打开<code>api/server.go</code>文件，在其中添加一个路径，同样使用post方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    server := &amp;Server&#123;store: store&#125;</span><br><span class=\"line\">    router := gin.Default()</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts/:id&quot;</span>, server.getAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts&quot;</span>, server.listAccounts)</span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/transfers&quot;</span>, server.createTransfer)</span><br><span class=\"line\"></span><br><span class=\"line\">    server.router = router</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着在终端中输入并且执行</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">make server</span><br></pre></td></tr></table></figure>\n<p>然后就可以验证我们的api了，同样使用postman进行测试验证，这里就不多做赘述了。需要注意的是，这里我们并没有使用虚拟数据库进行验证，而是使用了真实的数据库交互。</p>\n<h3 id=\"实现自定义货币验证模块\">实现自定义货币验证模块</h3>\n<p>在我们之前的定义中我们只硬编码了三种货币，加入之后我们需要增加货币种类，使它能够支持更多的货币类型呢？那我们如果仍然使用oneof的方式一个一个放入的话就很容易出错。而且对以货币的定义出现在很多的结构体中，一个一个修改他们并不现实。</p>\n<p>我们可以在api包下创建一个新的文件<code>validator.go</code>，然后声明一个新的<code>validator.Func</code>类型的变量<code>validCurrency</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> api</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/go-playground/validator/v10&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/techschool/simplebank/util&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> validCurrency validator.Func = <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(fieldLevel validator.FieldLevel)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> currency, ok := fieldLevel.Field().Interface().(<span class=\"keyword\">string</span>); ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> util.IsSupportedCurrency(currency)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>总体上来说，<code>validator.Func</code>是一个函数，它以<code>validator.FieldLevel</code>接口作为输入并且返回true如果验证成功的话。这个接口包含了所有的信息来帮助函数进行字段的验证。</p>\n<p>我们需要做的就是通过<code>fieldLevel.Field()</code>获取到字段的值，需要注意的是这是一个反射值，所以我们需要调用<code>.interface()</code>来将值转为<code>interface&#123;&#125;</code>。然后我们将这个值转为string类型。该函数会返回一个货币字符串和一个bool类型的值，在我们这个案例中我们还需要对货币进行检查，看是否是我们支持的货币类型，因此我们需要在util中再创建一个工具函数来实现这个功能。</p>\n<p>我们首先用常量的形式将支持的货币写下，然后再用函数判断货币是否在这些常量中，如果在的话就能够支持，否则的话不能够支持。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> util</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Constants for all supported currencies</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">    USD = <span class=\"string\">&quot;USD&quot;</span></span><br><span class=\"line\">    EUR = <span class=\"string\">&quot;EUR&quot;</span></span><br><span class=\"line\">CAD = <span class=\"string\">&quot;CAD&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IsSupportedCurrency returns true if the currency is supported</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">IsSupportedCurrency</span><span class=\"params\">(currency <span class=\"keyword\">string</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> currency &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> USD, EUR, CAD:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"登记自定义的货币验证器\">登记自定义的货币验证器</h3>\n<p>我们先打开<code>server.go</code>文件，在我们创建了Gin <code>router</code>之后我们需要调用<code>binding.Validator.Engine()</code>来得到目前Gin框架正在使用的验证器引擎。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> api</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/gin-gonic/gin/binding&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/go-playground/validator/v10&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    server := &amp;Server&#123;store: store&#125;</span><br><span class=\"line\">    router := gin.Default()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class=\"line\">        v.RegisterValidation(<span class=\"string\">&quot;currency&quot;</span>, validCurrency)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts/:id&quot;</span>, server.getAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts&quot;</span>, server.listAccounts)</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/transfers&quot;</span>, server.createTransfer)</span><br><span class=\"line\"></span><br><span class=\"line\">    server.router = router</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于这个函数返回的是一个<code>validator</code>对象，因此我们需要将他转换为<code>validator.Validate</code>对象指针，如果一切成功的话我们就可以调用<code>v.RegisterValidation()</code>来登记我们的自定义的验证函数。其中第一个参数是我们的验证标签，第二个参数是我们之前实现的<code>validCurrency()</code>函数。</p>\n<h3 id=\"使用自定义验证模块\">使用自定义验证模块</h3>\n<p>接下来在request参数结构体中有货币字段的，将货币字段的binding部分的oneof去掉改成currency</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> createAccountRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Owner    <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;owner&quot; binding:&quot;required&quot;`</span></span><br><span class=\"line\">    Currency <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;currency&quot; binding:&quot;required,currency&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> transferRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    FromAccountID <span class=\"keyword\">int64</span>  <span class=\"string\">`json:&quot;from_account_id&quot; binding:&quot;required,min=1&quot;`</span></span><br><span class=\"line\">    ToAccountID   <span class=\"keyword\">int64</span>  <span class=\"string\">`json:&quot;to_account_id&quot; binding:&quot;required,min=1&quot;`</span></span><br><span class=\"line\">    Amount        <span class=\"keyword\">int64</span>  <span class=\"string\">`json:&quot;amount&quot; binding:&quot;required,gt=0&quot;`</span></span><br><span class=\"line\">    Currency      <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;currency&quot; binding:&quot;required,currency&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着，我们运行<code>make server</code>并且进行测试。</p>\n<h2 id=\"通过特殊的外键限制在pgSQL中添加用户表\">通过特殊的外键限制在pgSQL中添加用户表</h2>\n<p>我们的银行系统到目前为止还缺少一个关键的表：用户认证和授权。接下来我们九江通过连接到已经存在的account表来创建一个user表。</p>\n<h3 id=\"增加user表\">增加user表</h3>\n<p>我们去到<code>diagram.io</code>添加我们的user表。</p>\n<p>表中第一个字段是用户名，它应当是一个varchar类型的变量，每一个用户名都应当是不同的，所以它应当是个主键[pk]</p>\n<p>第二个字段是<code>hashed_password</code>字段来存储用户的密码值，它的类型同样是<code>varchar</code>并且不应当为NULL。为什么是hashed呢？因为我们基本上不会在数据库存储一个未经任何修饰的密码，因为如果我们这样做了那么任何能够访问数据库的人都会看到所有人的密码，这是一个非常重要的安全问题。</p>\n<p>接下来的字段是用户的全名，它也是varchar，并且不能为null，然后是有向，每个用户的邮箱应该不同。</p>\n<p>然后我们有一个创建时间字段，记录创建该用户的时间并且默认值为当前时间。</p>\n<p>最后，为了安全考虑，通常会定期提醒用户去修改密码，所以我们设置一个<code>password_changed_at</code>来获取用户上一次修改密码是什么时候。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Table</span> users <span class=\"keyword\">as</span> U &#123;</span><br><span class=\"line\">  username <span class=\"type\">varchar</span> [pk]</span><br><span class=\"line\">  hashed_password <span class=\"type\">varchar</span> [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  full_name <span class=\"type\">varchar</span> [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  email <span class=\"type\">varchar</span> [<span class=\"keyword\">unique</span>, <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  password_changed_at timestamptz [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>, <span class=\"keyword\">default</span>: <span class=\"string\">&#x27;0001-01-01 00:00:00Z&#x27;</span>]</span><br><span class=\"line\">  created_at timestamptz [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>, <span class=\"keyword\">default</span>: `now()`]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们设置每个字段都不为null的目的非常简单，因为我们在程序中不希望单独处理为null的情况。如果密码一直没有改变过的话，我们会用默认的一个过去时间作为它的值。在go语言中，就是<code>0001-01-01 00:00:00Z</code>，Z的意思是0时区。</p>\n<h3 id=\"增加外键约束\">增加外键约束</h3>\n<p>现在，我们需要让一个用户能够有多个不同货币的账号，所以我们需要将<code>accounts</code>表的<code>owner</code>字段连接到<code>users</code>表的<code>username</code>字段，这会使得<code>owner</code>字段成为一个外键。</p>\n<p>我们会在定义<code>owner</code>的地方增加一个索引标签到username上。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Table</span> accounts <span class=\"keyword\">as</span> A &#123;</span><br><span class=\"line\">  id bigserial [pk]</span><br><span class=\"line\">  owner <span class=\"type\">varchar</span> [<span class=\"keyword\">ref</span>: <span class=\"operator\">&gt;</span> U.username, <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  balance <span class=\"type\">bigint</span> [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  currency <span class=\"type\">varchar</span> [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  created_at timestamptz [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>, <span class=\"keyword\">default</span>: `now()`]</span><br><span class=\"line\"></span><br><span class=\"line\">  Indexes &#123;</span><br><span class=\"line\">    owner</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"增加特殊约束\">增加特殊约束</h3>\n<p>还有一件事我们需要注意，一个用户可以有多个账户，但是那些账户应当有不同的货币类型。一个将这个限制在数据库级别实现的方法是增加一个<code>composite unique index</code>到account表中。这个索引由两个字段构成：owner和currency。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Table</span> accounts <span class=\"keyword\">as</span> A &#123;</span><br><span class=\"line\">  id bigserial [pk]</span><br><span class=\"line\">  owner <span class=\"type\">varchar</span> [<span class=\"keyword\">ref</span>: <span class=\"operator\">&gt;</span> U.username, <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  balance <span class=\"type\">bigint</span> [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  currency <span class=\"type\">varchar</span> [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>]</span><br><span class=\"line\">  created_at timestamptz [<span class=\"keyword\">not</span> <span class=\"keyword\">null</span>, <span class=\"keyword\">default</span>: `now()`]</span><br><span class=\"line\"></span><br><span class=\"line\">  Indexes &#123;</span><br><span class=\"line\">    owner</span><br><span class=\"line\">    (owner, currency) [<span class=\"keyword\">unique</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后就可以将文件导出为SQL文件了。</p>\n<h3 id=\"将新的schema添加到项目中\">将新的schema添加到项目中</h3>\n<p>为了能够将变化更改到项目中去，一个方法是将<code>init_schema_migration</code>的全部内容都换成新的，然后重置数据库并且再次执行<code>migrate up</code>。但是，这么干在实际项目中显然是不可能的。因为需求一直在改，可能我们需要增加新表的时候，数据库已经投入到产品中了，不可能删库的。</p>\n<p>所以正确的合并变化的方式是创建一个新的migration版本</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">migrate create -ext sql -dir db/migration -seq add_users</span><br></pre></td></tr></table></figure>\n<p>我们用一些参数来告诉migrate输出的file要以sql作为文件扩展名，并且输出到<code>db/migration</code>，并且用一个序列数字作为文件的前缀，生成的文件名是<code>add_user</code></p>\n<h3 id=\"实现up-migration\">实现up migration</h3>\n<p>首先我们需要创建user表，所以我们将之前生成的SQL查询语句复制到新生成的up文件中，接着我们复制一个添加外键限制的查询语句到<code>account</code>表的<code>owner</code>字段中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE <span class=\"string\">&quot;users&quot;</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;username&quot;</span> varchar PRIMARY KEY,</span><br><span class=\"line\">  <span class=\"string\">&quot;hashed_password&quot;</span> varchar NOT NULL,</span><br><span class=\"line\">  <span class=\"string\">&quot;full_name&quot;</span> varchar NOT NULL,</span><br><span class=\"line\">  <span class=\"string\">&quot;email&quot;</span> varchar UNIQUE NOT NULL,</span><br><span class=\"line\">  <span class=\"string\">&quot;password_changed_at&quot;</span> timestamptz NOT NULL DEFAULT(<span class=\"string\">&#x27;0001-01-01 00:00:00Z&#x27;</span>),  </span><br><span class=\"line\">  <span class=\"string\">&quot;created_at&quot;</span> timestamptz NOT NULL DEFAULT (now())</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">ALTER TABLE <span class=\"string\">&quot;accounts&quot;</span> ADD FOREIGN KEY (<span class=\"string\">&quot;owner&quot;</span>) REFERENCES <span class=\"string\">&quot;users&quot;</span> (<span class=\"string\">&quot;username&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">CREATE UNIQUE INDEX ON <span class=\"string\">&quot;accounts&quot;</span> (<span class=\"string\">&quot;owner&quot;</span>, <span class=\"string\">&quot;currency&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>这样看起来已经很好了，但是我们还能有另一种方法，让每一个用户对每一种货币最多能有一个账户。我们不是使用一个unique索引，而是添加一个unique限制对每一个<code>owner</code>和<code>currency</code>对。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- CREATE UNIQUE INDEX ON &quot;accounts&quot; (&quot;owner&quot;, &quot;currency&quot;);</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> &quot;accounts&quot; <span class=\"keyword\">ADD</span> <span class=\"keyword\">CONSTRAINT</span> &quot;owner_currency_key&quot; <span class=\"keyword\">UNIQUE</span> (&quot;owner&quot;, &quot;currency&quot;);</span><br></pre></td></tr></table></figure>\n<p>这两种方法其实在底层是差不多的，都可以使用。</p>\n<h3 id=\"执行miagrate-up\">执行miagrate up</h3>\n<p>我们使用make migrateup命令来更新我们的改动，但是报错了。这是因为我们在account表中已经存在数据了但是在user表中没有，导致两表之间没有建立连接。所以在这个例子中，我们不得不清除掉所有的已经存在的数据，在执行刚才的命令之前。这是可行的，因为我们目前的系统还没有准备好部署呢。</p>\n<p>但是需要注意的是，由于刚才的操作失败了，它会将当前的schema改成版本2但是是以一个dirty状态。所以如果我们这时候运行down的话，我们会得到一个错误因为现在的版本是dirty的。我们可以手动去修改这个dirty标志为false，然后再运行<code>make migratedown</code>使它数据清空。然后我们再运行<code>make migrateup</code>来生成我们的数据库。</p>\n<h3 id=\"实现migration-down\">实现migration down</h3>\n<p>刚才我们为我们新创建的up文件进行了实现，接下来我们要实现我们刚刚创建的down文件。首先我们要丢弃<code>owner</code>和<code>currency</code>的特殊约束。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> &quot;accounts&quot; <span class=\"keyword\">DROP</span> <span class=\"keyword\">CONSTRAINT</span> IF <span class=\"keyword\">EXISTS</span> &quot;owner_currency_key&quot;;</span><br></pre></td></tr></table></figure>\n<p>接着我们用相同的方法丢弃掉owner的外键约束，但是我们这个时候怎么能知道这个外键约束的名称呢？我们可以点击tableplus窗口下方的info按钮获取到当前表的定义，其中会给出外键约束的名称。在这里我们的名称是<code>accounts_owner_fkey</code>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> &quot;accounts&quot; <span class=\"keyword\">DROP</span> <span class=\"keyword\">CONSTRAINT</span> IF <span class=\"keyword\">EXISTS</span> &quot;accounts_owner_fkey&quot;;</span><br></pre></td></tr></table></figure>\n<p>最后一步我们要把user表删掉就可以了。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> &quot;users&quot;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试up和down的migration\">测试up和down的migration</h3>\n<p>由于目前我们makefile中已经有一个make migratedown所以为了能够执行这个第二版本的down我们新增一个down1，其内容和之前是一样的，只是最后需要增加一个参数1，它的意思是只rollback到最后一个migration。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">migratedown1:</span></span><br><span class=\"line\">  migrate -path db/migration -database <span class=\"string\">&quot;postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable&quot;</span> -verbose down 1</span><br></pre></td></tr></table></figure>\n<p>对于up我们也是相同的做法，只向下up一层</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">migrateup1:</span></span><br><span class=\"line\">  migrate -path db/migration -database <span class=\"string\">&quot;postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable&quot;</span> -verbose up 1</span><br></pre></td></tr></table></figure>\n<p>然后把这两个添加到phony列表中。</p>\n<h2 id=\"如何正确处理DB错误\">如何正确处理DB错误</h2>\n<p>上一节中我们已经添加了一个新的user表到我们的数据库中，接下来我们就需要更改我们的代码来使它能够在这个表上工作，而且还要处理pg返回的一些特殊错误。</p>\n<h3 id=\"生成代码来创建和获取user\">生成代码来创建和获取user</h3>\n<p>首先我们需要创建一个新的<code>user.sql</code>文件，在这个文件中我们需要写两个SQL语句来创建和获取users。他们在结构上和我们之前对account的创建和获取应该是相似的。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- name: CreateUser :one</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> users (</span><br><span class=\"line\">  username,</span><br><span class=\"line\">  hashed_password,</span><br><span class=\"line\">  full_name,</span><br><span class=\"line\">  email</span><br><span class=\"line\">) <span class=\"keyword\">VALUES</span> (</span><br><span class=\"line\">  $<span class=\"number\">1</span>, $<span class=\"number\">2</span>, $<span class=\"number\">3</span>, $<span class=\"number\">4</span></span><br><span class=\"line\">) RETURNING <span class=\"operator\">*</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- name: GetUser :one</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> username <span class=\"operator\">=</span> $<span class=\"number\">1</span> LIMIT <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>然后用sqlc自动生成对应的代码。我们现在可以去<code>db/sqlc/models.go</code>中观察到一个新的结构体User已经出现了。</p>\n<h3 id=\"接下来需要给生成的代码编写测试\">接下来需要给生成的代码编写测试</h3>\n<p>我们可以使用之前对account做测试的文件中的一部分进行测试，其在本质上是差不多的。编写完成后发现对于单独的user的两个函数可以通过，但是要运行整个包通过就不可以了，因为我们的owner的外键约束还不存在呢！</p>\n<h3 id=\"修复失败了的测试\">修复失败了的测试</h3>\n<p>我们能够注意到，account_test中其创建的随机账户的owner并没有关联到我们的user表中，为了解决这个问题我们需要在数据库中创建一个用户。然后，我们不再是随机创建一个owner而是用已经创建好的account owner。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createRandomAccount</span><span class=\"params\">(t *testing.T)</span> <span class=\"title\">Account</span></span> &#123;</span><br><span class=\"line\">    user := createRandomUser(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    arg := CreateAccountParams&#123;</span><br><span class=\"line\">        Owner:    user.Username,</span><br><span class=\"line\">        Balance:  util.RandomMoney(),</span><br><span class=\"line\">        Currency: util.RandomCurrency(),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们再运行整个包，发现全部通过。但是需要注意，这只是运行了所有db包中的测试，我们还没有运行api包中的测试呢。再命令行输入 make test来运行所有的测试。</p>\n<p>我们会发现报错了，因为我们的mockstore没有实现db.Store接口。它缺失了一些函数的实现。这是因为我们运行sqlc生成代码的时候多出来两个函数<code>CreateUser</code>和<code>GetUser</code>被添加到了<code>Queries</code>接口中了，而<code>Queries</code>接口是<code>db.Store</code>接口的一部分。</p>\n<p>为了解决这个问题，我们需要将mock代码再次生成一次 <code>make mock</code>,之后再进行测试就会发现没问题了。</p>\n<h3 id=\"处理不同类型的DB错误\">处理不同类型的DB错误</h3>\n<p>接下来我们运行make server，然后打开postman来测试目前已经存在的api。</p>\n<p>首先我们尝试为一个不存在数据库中的user创建一个账户。显而易见它会报错，但是它报的是内部服务器错误，这个状态码明显不是我们要的，因为这是客户端的错误，它不应该给一个不存在的用户创建账户。这里返回的最好应该是<code>403 forbidden</code>。</p>\n<p>我们在<code>api/account.go</code>下面找到<code>creatAccount</code>函数，如果返回了一个错误的话，我们将会尝试将他转成<code>pg.Error</code>类型并且赋给一个<code>pgErr</code>变量</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createAccount</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    account, err := server.store.CreateAccount(ctx, arg)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pqErr, ok := err.(*pq.Error); ok &#123;</span><br><span class=\"line\">            log.Println(pqErr.Code.Name())</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.JSON(http.StatusOK, account)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们重启服务器，发现这一次报的错误是我们想要的了。我们一会可以利用它对错误进行分类。</p>\n<p>现在我们想要对一个已经存在的用户创建一个账户，这一次能够成功，但是要是我们再进行一次重复操作呢？即对这个用户再创建一个相同的账户。就会报一个owner_currency的键的错误了。这一次我们同样希望它报的错误是403而不是500，然后我们看log中的错误，发现是<code>unique_violation</code>，这样我们就可以回到代码中进行更新</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createAccount</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    account, err := server.store.CreateAccount(ctx, arg)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pqErr, ok := err.(*pq.Error); ok &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> pqErr.Code.Name() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;foreign_key_violation&quot;</span>, <span class=\"string\">&quot;unique_violation&quot;</span>:</span><br><span class=\"line\">                ctx.JSON(http.StatusForbidden, errorResponse(err))</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.JSON(http.StatusOK, account)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何安全地存储密码\">如何安全地存储密码</h2>\n<p>之前已经提到我们不可以直接存储密码到数据库中，所以我们可以先对他做hash变换然后只存储hash值。基本上使用<code>bcrypt</code>hashing函数来实现的。除了原本的密码，这个函数还需要一个<code>cost</code>参数，它将会决定算法的密钥扩展轮次或者迭代次数。</p>\n<p><code>bcrypt</code>同样生成一个随机的<code>salt</code>用于这些迭代中，将会有助于抵抗<a href=\"https://en.wikipedia.org/wiki/Rainbow_table\">rainbow table attack</a>。因为存在随机的<code>salt</code>，所以算法每次都会给出一个完全不同的输出hash值，即便输入的密码是相同的。</p>\n<p><img src=\"https://i.imgur.com/Ai2hmEK.png\" alt=\"picture 1\"></p>\n<p><code>cost</code>和<code>salt</code>参数会被添加到hash中来生成最终的hash字符串。这个hash字符串包含4个部分：</p>\n<ul>\n<li>第一个部分是算法id，<code>2A</code>的意思是<code>bcrypt</code>算法</li>\n<li>第二个部分是cost，在本例子中cost是10，意思是<code>2^10</code>次密钥扩展</li>\n<li>第三个部分是长度为16byte的<code>salt</code>，它是使用<code>base64</code>格式化编码的，将会生成一个22个字符的字符串</li>\n<li>最后是24个字节的hash值，被编码为31个字符</li>\n</ul>\n<p>所有这些部分会连接到一个单独的hash字符串中，并且这个字符串就是我们需要存储到数据库中的字符串。</p>\n<p>那么当用户登陆的时候我们怎么验证这个密码呢？首先我们找到这个账户对应的密码，然后我们用密码中的<code>cost</code>和<code>salt</code>作为hash函数的参数，然后对用户输入的密码进行hash处理，如果结果和数据库中的密码结果是一样的，那么验证成功。</p>\n<h3 id=\"实现hash和比较密码\">实现hash和比较密码</h3>\n<p>对于实现hash密码函数，我们先在<code>util</code>包下面创建一个<code>password.go</code>文件，其中我们定义一个新的函数<code>HashPassword()</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HashPassword returns the bcrypt hash of the password</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HashPassword</span><span class=\"params\">(password <span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">    hashedPassword, err := bcrypt.GenerateFromPassword([]<span class=\"keyword\">byte</span>(password), bcrypt.DefaultCost)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, fmt.Errorf(<span class=\"string\">&quot;failed to hash password: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">string</span>(hashedPassword), <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个函数中我们直接调用<code>bcrypt</code>包来生成我们的hash密码。</p>\n<p>接下来我们需要进行密码的比较，由于我们已经在上面定义了hash转换。所以我们可以对用户输入的密码做转换然后和数据库中的密码进行比较</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CheckPassword checks if the provided password is correct or not</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">CheckPassword</span><span class=\"params\">(password <span class=\"keyword\">string</span>, hashedPassword <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bcrypt.CompareHashAndPassword([]<span class=\"keyword\">byte</span>(hashedPassword), []<span class=\"keyword\">byte</span>(password))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"为这两个函数写单元测试\">为这两个函数写单元测试</h3>\n<p>我们在<code>util</code>包下面创建一个新的文件<code>password_test.go</code>来对刚才的两个函数进行测试。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestPassword</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    password := RandomString(<span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    hashedPassword, err := HashPassword(password)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.NotEmpty(t, hashedPassword)</span><br><span class=\"line\"></span><br><span class=\"line\">    err = CheckPassword(password, hashedPassword1)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们就测试了密码正确时的情景，下面我们用一个错误密码进行测试</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestPassword</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    password := RandomString(<span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    hashedPassword, err := HashPassword(password)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.NotEmpty(t, hashedPassword)</span><br><span class=\"line\"></span><br><span class=\"line\">    wrongPassword := RandomString(<span class=\"number\">6</span>)</span><br><span class=\"line\">    err = CheckPassword(wrongPassword, hashedPassword)</span><br><span class=\"line\">    require.EqualError(t, err, bcrypt.ErrMismatchedHashAndPassword.Error())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"更新现有的代码\">更新现有的代码</h3>\n<p>目前我们已经能够对密码进行hash，因此我们需要返回<code>user_test.go</code>中的<code>creatRandomUser()</code>函数，使用<code>hashedPassword</code>来替换原本的随机密码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createRandomUser</span><span class=\"params\">(t *testing.T)</span> <span class=\"title\">User</span></span> &#123;</span><br><span class=\"line\">    hashedPassword, err := util.HashPassword(util.RandomString(<span class=\"number\">6</span>))</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    arg := CreateUserParams&#123;</span><br><span class=\"line\">        Username:       util.RandomOwner(),</span><br><span class=\"line\">        HashedPassword: hashedPassword,</span><br><span class=\"line\">        FullName:       util.RandomOwner(),</span><br><span class=\"line\">        Email:          util.RandomEmail(),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们就可以对整个包进行测试，发现全部测试成功！并且我们能够在数据库中发现密码已经变成我们生成的hash值了。</p>\n<h3 id=\"确保所有的hashedpassword都是不同的\">确保所有的hashedpassword都是不同的</h3>\n<p>我们需要保证即便输入两次相同的密码我们生成的hash密码应该是不一样的。所以我们回到<code>password_test.go</code>文件中，对其进行一定的修改然后进行测试。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestPassword</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    password := RandomString(<span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    hashedPassword1, err := HashPassword(password)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.NotEmpty(t, hashedPassword1)</span><br><span class=\"line\"></span><br><span class=\"line\">    err = CheckPassword(password, hashedPassword1)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    wrongPassword := RandomString(<span class=\"number\">6</span>)</span><br><span class=\"line\">    err = CheckPassword(wrongPassword, hashedPassword1)</span><br><span class=\"line\">    require.EqualError(t, err, bcrypt.ErrMismatchedHashAndPassword.Error())</span><br><span class=\"line\"></span><br><span class=\"line\">    hashedPassword2, err := HashPassword(password)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.NotEmpty(t, hashedPassword2)</span><br><span class=\"line\">    require.NotEqual(t, hashedPassword1, hashedPassword2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行测试之后发现能够成功！</p>\n<h3 id=\"实现创建user的API\">实现创建user的API</h3>\n<p>下一步我们需要使用<code>HashPassword()</code>函数来实现创建用户的API。我们先在api包下创建一个<code>user.go</code>的新文件。之前我们作为创建账户的api，创建用户的api和这个是非常相像的，所以我们可以直接赋值过来。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> createUserRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Username <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;username&quot; binding:&quot;required,alphanum&quot;`</span></span><br><span class=\"line\">    Password <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;password&quot; binding:&quot;required,min=6&quot;`</span></span><br><span class=\"line\">    FullName <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;full_name&quot; binding:&quot;required&quot;`</span></span><br><span class=\"line\">    Email    <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;email&quot; binding:&quot;required,email&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中比较重要的是最后一个email，因为我们需要确保email正确能够沟通，所以我们增加一个<code>email</code> tag来确保这个邮箱是正确的。其实在validator包中有很多好用的tag，我们可以在<a href=\"https://pkg.go.dev/github.com/go-playground/validator/v10\">官方文档</a>中查看他们。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createUser</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> req createUserRequest</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := ctx.ShouldBindJSON(&amp;req); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    hashedPassword, err := util.HashPassword(req.Password)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    arg := db.CreateUserParams&#123;</span><br><span class=\"line\">        Username:       req.Username,</span><br><span class=\"line\">        HashedPassword: hashedPassword,</span><br><span class=\"line\">        FullName:       req.FullName,</span><br><span class=\"line\">        Email:          req.Email,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    user, err := server.store.CreateUser(ctx, arg)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pqErr, ok := err.(*pq.Error); ok &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> pqErr.Code.Name() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;unique_violation&quot;</span>:</span><br><span class=\"line\">                ctx.JSON(http.StatusForbidden, errorResponse(err))</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.JSON(http.StatusOK, user)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意，对于传过来的密码我们要通过哈希加密之后才能传入数据库。</p>\n<p>正如在创建账户API中的一样，如果存在错误的话我们可能会有多个场景，需要记住，在用户表中我们有两个unique约束</p>\n<ul>\n<li>一个是用户名</li>\n<li>一个是邮箱</li>\n</ul>\n<p>在这个表中我们没有外键，所以我们只需要保留<code>unique_violation</code>来返回403错误就可以了</p>\n<p>接着我们需要在<code>NewServer()</code>函数中增加一个新的路径，我们使用POST方法，路径应当是<code>/users</code>，并且它的handler应当为<code>server.createUser</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NewServer creates a new HTTP server and set up routing.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    server := &amp;Server&#123;store: store&#125;</span><br><span class=\"line\">    router := gin.Default()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class=\"line\">        v.RegisterValidation(<span class=\"string\">&quot;currency&quot;</span>, validCurrency)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/users&quot;</span>, server.createUser)</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts/:id&quot;</span>, server.getAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts&quot;</span>, server.listAccounts)</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/transfers&quot;</span>, server.createTransfer)</span><br><span class=\"line\"></span><br><span class=\"line\">    server.router = router</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们就可以在postman中测试我们创建的这个api是否成功拉！</p>\n<h3 id=\"API不能暴露hash映射后的密码\">API不能暴露hash映射后的密码</h3>\n<p>在我们彻底完成之前，我们需要注意我们测试时服务器给我们返回的信息中包含了我们的密码哈希值，但是这显然是没必要的，因为客户端永远不会用到这个哈希值。并且这也会造成一些安全性的问题，我们最好从response中删除这一条信息。</p>\n<p>因此我们创建一个结构体作为返回对象，其中不需要password这一字段，另外在最后的return之前我们将user的内容转移到这个结构体的实例上面就可以了</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> createUserResponse <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Username          <span class=\"keyword\">string</span>    <span class=\"string\">`json:&quot;username&quot;`</span></span><br><span class=\"line\">    FullName          <span class=\"keyword\">string</span>    <span class=\"string\">`json:&quot;full_name&quot;`</span></span><br><span class=\"line\">    Email             <span class=\"keyword\">string</span>    <span class=\"string\">`json:&quot;email&quot;`</span></span><br><span class=\"line\">    PasswordChangedAt time.Time <span class=\"string\">`json:&quot;password_changed_at&quot;`</span></span><br><span class=\"line\">    CreatedAt         time.Time <span class=\"string\">`json:&quot;created_at&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createUser</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    user, err := server.store.CreateUser(ctx, arg)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pqErr, ok := err.(*pq.Error); ok &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> pqErr.Code.Name() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;unique_violation&quot;</span>:</span><br><span class=\"line\">                ctx.JSON(http.StatusForbidden, errorResponse(err))</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    rsp := createUserResponse&#123;</span><br><span class=\"line\">        Username:          user.Username,</span><br><span class=\"line\">        FullName:          user.FullName,</span><br><span class=\"line\">        Email:             user.Email,</span><br><span class=\"line\">        PasswordChangedAt: user.PasswordChangedAt,</span><br><span class=\"line\">        CreatedAt:         user.CreatedAt,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ctx.JSON(http.StatusOK, rsp)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"用自定义的go-mock匹配器写高效的单元测试\">用自定义的go-mock匹配器写高效的单元测试</h3>\n<p>通过go-mock我们可以很轻松的对我们刚才实现的API做单元测试，但是如果我们自己来写单元测试的话，我们会发现这会有点小插曲在里面。因为输入的密码参数在存入数据库之前经过了hash变换。</p>\n<p>为了更好地理解威慑呢蜜，我们先看下面这个版本的测试</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCreateUserAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    user, password := randomUser(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    testCases := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        name          <span class=\"keyword\">string</span></span><br><span class=\"line\">        body          gin.H</span><br><span class=\"line\">        buildStubs    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span></span><br><span class=\"line\">        checkResponse <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recoder *httptest.ResponseRecorder)</span></span></span><br><span class=\"line\">    &#125;&#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&quot;OK&quot;</span>,</span><br><span class=\"line\">            body: gin.H&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;username&quot;</span>:  user.Username,</span><br><span class=\"line\">                <span class=\"string\">&quot;password&quot;</span>:  password,</span><br><span class=\"line\">                <span class=\"string\">&quot;full_name&quot;</span>: user.FullName,</span><br><span class=\"line\">                <span class=\"string\">&quot;email&quot;</span>:     user.Email,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class=\"line\">                    Times(<span class=\"number\">1</span>).</span><br><span class=\"line\">                    Return(user, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusOK, recorder.Code)</span><br><span class=\"line\">                requireBodyMatchUser(t, recorder.Body, user)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&quot;InternalError&quot;</span>,</span><br><span class=\"line\">            body: gin.H&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;username&quot;</span>:  user.Username,</span><br><span class=\"line\">                <span class=\"string\">&quot;password&quot;</span>:  password,</span><br><span class=\"line\">                <span class=\"string\">&quot;full_name&quot;</span>: user.FullName,</span><br><span class=\"line\">                <span class=\"string\">&quot;email&quot;</span>:     user.Email,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class=\"line\">                    Times(<span class=\"number\">1</span>).</span><br><span class=\"line\">                    Return(db.User&#123;&#125;, sql.ErrConnDone)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusInternalServerError, recorder.Code)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&quot;DuplicateUsername&quot;</span>,</span><br><span class=\"line\">            body: gin.H&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;username&quot;</span>:  user.Username,</span><br><span class=\"line\">                <span class=\"string\">&quot;password&quot;</span>:  password,</span><br><span class=\"line\">                <span class=\"string\">&quot;full_name&quot;</span>: user.FullName,</span><br><span class=\"line\">                <span class=\"string\">&quot;email&quot;</span>:     user.Email,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class=\"line\">                    Times(<span class=\"number\">1</span>).</span><br><span class=\"line\">                    Return(db.User&#123;&#125;, &amp;pq.Error&#123;Code: <span class=\"string\">&quot;23505&quot;</span>&#125;)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusForbidden, recorder.Code)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&quot;InvalidUsername&quot;</span>,</span><br><span class=\"line\">            body: gin.H&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;username&quot;</span>:  <span class=\"string\">&quot;invalid-user#1&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;password&quot;</span>:  password,</span><br><span class=\"line\">                <span class=\"string\">&quot;full_name&quot;</span>: user.FullName,</span><br><span class=\"line\">                <span class=\"string\">&quot;email&quot;</span>:     user.Email,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class=\"line\">                    Times(<span class=\"number\">0</span>)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusBadRequest, recorder.Code)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&quot;InvalidEmail&quot;</span>,</span><br><span class=\"line\">            body: gin.H&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;username&quot;</span>:  user.Username,</span><br><span class=\"line\">                <span class=\"string\">&quot;password&quot;</span>:  password,</span><br><span class=\"line\">                <span class=\"string\">&quot;full_name&quot;</span>: user.FullName,</span><br><span class=\"line\">                <span class=\"string\">&quot;email&quot;</span>:     <span class=\"string\">&quot;invalid-email&quot;</span>,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class=\"line\">                    Times(<span class=\"number\">0</span>)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusBadRequest, recorder.Code)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&quot;TooShortPassword&quot;</span>,</span><br><span class=\"line\">            body: gin.H&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;username&quot;</span>:  user.Username,</span><br><span class=\"line\">                <span class=\"string\">&quot;password&quot;</span>:  <span class=\"string\">&quot;123&quot;</span>,</span><br><span class=\"line\">                <span class=\"string\">&quot;full_name&quot;</span>: user.FullName,</span><br><span class=\"line\">                <span class=\"string\">&quot;email&quot;</span>:     user.Email,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class=\"line\">                    Times(<span class=\"number\">0</span>)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusBadRequest, recorder.Code)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和之前一样，我们可以创建一个随机的用户，然后我们声明一组测试用例，其中我们能够定义输入的请求主体，以及两个函数分别用于创建store存根和检查API的返回值。</p>\n<p>我们可以测试一些不同的案例，比如：</p>\n<ul>\n<li>成功的案例</li>\n<li>内部服务器错误案例</li>\n<li>重复用户名</li>\n<li>非法用户名、邮箱或者密码</li>\n</ul>\n<p>我们迭代所有这些例子并且为他们运行独立的子测试。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCreateUserAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> testCases &#123;</span><br><span class=\"line\">        tc := testCases[i]</span><br><span class=\"line\"></span><br><span class=\"line\">        t.Run(tc.name, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">            ctrl := gomock.NewController(t)</span><br><span class=\"line\">            <span class=\"keyword\">defer</span> ctrl.Finish()</span><br><span class=\"line\"></span><br><span class=\"line\">            store := mockdb.NewMockStore(ctrl)</span><br><span class=\"line\">            tc.buildStubs(store)</span><br><span class=\"line\"></span><br><span class=\"line\">            server := NewServer(store)</span><br><span class=\"line\">            recorder := httptest.NewRecorder()</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// Marshal body data to JSON</span></span><br><span class=\"line\">            data, err := json.Marshal(tc.body)</span><br><span class=\"line\">            require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">            url := <span class=\"string\">&quot;/users&quot;</span></span><br><span class=\"line\">            request, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(data))</span><br><span class=\"line\">            require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">            server.router.ServeHTTP(recorder, request)</span><br><span class=\"line\">            tc.checkResponse(recorder)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在每一个子测试中，我们创建一个新的gomock控制器，并且用它来创建一个新的DB store。然后我们调用<code>buildStubs()</code>来为store创建存根。之后，我们使用mock store创建一个新的服务器，并且创建一个新的HTTP返回<code>recorder</code>来记录API的返回值。接着我们解析输入的请求主体并且向API终端发送请求。我们调用<code>server.router.ServeHTTP()</code>，最后调用<code>tc.checkResponse()</code>来检查结果。</p>\n<p>这相当简单，就和我们之前做的一样。而现在，对于这一章节我们只需要注重于成功的例子</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCreateUserAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    user, password := randomUser(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    testCases := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        name          <span class=\"keyword\">string</span></span><br><span class=\"line\">        body          gin.H</span><br><span class=\"line\">        buildStubs    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span></span><br><span class=\"line\">        checkResponse <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recoder *httptest.ResponseRecorder)</span></span></span><br><span class=\"line\">    &#125;&#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&quot;OK&quot;</span>,</span><br><span class=\"line\">            body: gin.H&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;username&quot;</span>:  user.Username,</span><br><span class=\"line\">                <span class=\"string\">&quot;password&quot;</span>:  password,</span><br><span class=\"line\">                <span class=\"string\">&quot;full_name&quot;</span>: user.FullName,</span><br><span class=\"line\">                <span class=\"string\">&quot;email&quot;</span>:     user.Email,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class=\"line\">                    Times(<span class=\"number\">1</span>).</span><br><span class=\"line\">                    Return(user, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusOK, recorder.Code)</span><br><span class=\"line\">                requireBodyMatchUser(t, recorder.Body, user)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里的<code>buildstubs</code>函数中，我们用两个<code>gomock.Any()</code>函数来匹配<code>CreateUser()</code>函数的两个参数，这对于第一个参数上下文环境是合理的，但是对于第二个参数我们就无法判断是否输入的是合理的参数了。但是我们先这样用。</p>\n<p>我们输入一个成功案例并且进行测试，发现是可以的，但是如果我们将输入的参数设置为空，再运行测试发现还是可行的。这样的话就非常糟糕，因为我们的处理是错误的，但是测试竟然通过了！</p>\n<p>此外我们加入忽视用户生成的密码，而改用一个常量<code>weirdo</code>作为密码并且做hash转换，发现仍然不会报错。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createUser</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    hashedPassword, err := util.HashPassword(<span class=\"string\">&quot;xyz&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    arg := db.CreateUserParams&#123;</span><br><span class=\"line\">        Username:       req.Username,</span><br><span class=\"line\">        HashedPassword: hashedPassword,</span><br><span class=\"line\">        FullName:       req.FullName,</span><br><span class=\"line\">        Email:          req.Email,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    user, err := server.store.CreateUser(ctx, arg)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> pqErr, ok := err.(*pq.Error); ok &#123;</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> pqErr.Code.Name() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;unique_violation&quot;</span>:</span><br><span class=\"line\">                ctx.JSON(http.StatusForbidden, errorResponse(err))</span><br><span class=\"line\">                <span class=\"keyword\">return</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"尝试使用gomock-Eq\">尝试使用<code>gomock.Eq</code></h3>\n<p>我们可以想到如果不使用<code>gomock.Any()</code>来作为替代呢，我们用别的，比如<code>gomock.Eq()</code>.</p>\n<p>首先我们声明一个新的arg变量是<code>db.CreateUserParams</code>，其中username是<code>user.Username</code>。对于<code>hashed_password</code>这一字段，我们需要映射输入的密码。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCreateUserAPI</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    user, password := randomUser(t)</span><br><span class=\"line\"></span><br><span class=\"line\">    hashedPassword, err := util.HashPassword(password)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    testCases := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">        name          <span class=\"keyword\">string</span></span><br><span class=\"line\">        body          gin.H</span><br><span class=\"line\">        buildStubs    <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span></span><br><span class=\"line\">        checkResponse <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recoder *httptest.ResponseRecorder)</span></span></span><br><span class=\"line\">    &#125;&#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            name: <span class=\"string\">&quot;OK&quot;</span>,</span><br><span class=\"line\">            body: gin.H&#123;</span><br><span class=\"line\">                <span class=\"string\">&quot;username&quot;</span>:  user.Username,</span><br><span class=\"line\">                <span class=\"string\">&quot;password&quot;</span>:  password,</span><br><span class=\"line\">                <span class=\"string\">&quot;full_name&quot;</span>: user.FullName,</span><br><span class=\"line\">                <span class=\"string\">&quot;email&quot;</span>:     user.Email,</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            buildStubs: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class=\"line\">                arg := db.CreateUserParams&#123;</span><br><span class=\"line\">                    Username: user.Username,</span><br><span class=\"line\">                    HashedPassword: hashedPassword,</span><br><span class=\"line\">                    FullName: user.FullName,</span><br><span class=\"line\">                    Email: user.Email,</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                store.EXPECT().</span><br><span class=\"line\">                    CreateUser(gomock.Any(), gomock.Eq(arg)).</span><br><span class=\"line\">                    Times(<span class=\"number\">1</span>).</span><br><span class=\"line\">                    Return(user, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            checkResponse: <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class=\"line\">                require.Equal(t, http.StatusOK, recorder.Code)</span><br><span class=\"line\">                requireBodyMatchUser(t, recorder.Body, user)</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们用<code>gomock.Eq(arg)</code>来代替<code>gomock.Any()</code>。接下来我们测试如果传入的是空的值是否可以通过测试，发现确实不能通过了！这就对了，但是如果我们把这个传入的值设置为正确的值，结果发现不能通过。</p>\n<p>这是因为传入的值和gomock期待的值是不一样的，我们在log中可以看到，只有hashedpassword字段没有通过。我们还记得上一节说提到过，同样的密码经过hash得到的值也会是不一样的，因此我们的匹配不会成功。</p>\n<p>唯一能解决这个问题的办法似乎只能是我们自定义一个匹配器了。</p>\n<h3 id=\"实现自定义gomock匹配器\">实现自定义gomock匹配器</h3>\n<p>首先我们移除掉<code>hashedPassword</code>因为这部是我们在自定义匹配器中所需要的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Eq</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">Matcher</span></span> &#123; <span class=\"keyword\">return</span> eqMatcher&#123;x&#125; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Matcher <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Matches returns whether x is a match.</span></span><br><span class=\"line\">    Matches(x <span class=\"keyword\">interface</span>&#123;&#125;) <span class=\"keyword\">bool</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// String describes what the matcher matches.</span></span><br><span class=\"line\">    String() <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于我们自定义的匹配器而言，我们将写一个类似的实现，它只有两个方法：</p>\n<ul>\n<li><code>Matches()</code>，它应当返回输入<code>x</code>是否是一个匹配</li>\n<li><code>String()</code>，它描述匹配器匹配了哪些内容，用于日志的记录</li>\n</ul>\n<p>这是我们正在使用的相等匹配器的代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> eqMatcher <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    x <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e eqMatcher)</span> <span class=\"title\">Matches</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reflect.DeepEqual(e.x, x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e eqMatcher)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;is equal to %v&quot;</span>, e.x)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们自定义的匹配器应该和它非常相像所以我把它复制到<code>user_test.go</code>文件的最上方，然后对他进行修改.</p>\n<p>首先我们把结构体的名字改成<code>eqCreateUserParamsMatcher</code>，并且为了正确比较输入的参数，我们需要两个字段</p>\n<ul>\n<li>首先是<code>arg</code>字段，它是<code>db.CreateUserParams</code>类型的</li>\n<li>第二个是password字段，存储最原始的密码值</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> eqCreateUserParamsMatcher <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    arg      db.CreateUserParams</span><br><span class=\"line\">    password <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在让我们实现<code>Matches()</code>函数，因为输入<code>x</code>是一个接口，我们应当把它转换为<code>db.CreateUserParams</code>对象。</p>\n<p>如果转换不成功我们返回错误，如果转换成功，我们检测输入的密码是否和hash转换后的密码相同</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e eqCreateUserParamsMatcher)</span> <span class=\"title\">Matches</span><span class=\"params\">(x <span class=\"keyword\">interface</span>&#123;&#125;)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    arg, ok := x.(db.CreateUserParams)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err := util.CheckPassword(e.password, arg.HashedPassword)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    e.arg.HashedPassword = arg.HashedPassword</span><br><span class=\"line\">    <span class=\"keyword\">return</span> reflect.DeepEqual(e.arg, arg)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们再修改其他的函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(e eqCreateUserParamsMatcher)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fmt.Sprintf(<span class=\"string\">&quot;matches arg %v and password %v&quot;</span>, e.arg, e.password)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">EqCreateUserParams</span><span class=\"params\">(arg db.CreateUserParams, password <span class=\"keyword\">string</span>)</span> <span class=\"title\">gomock</span>.<span class=\"title\">Matcher</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> eqCreateUserParamsMatcher&#123;arg, password&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"在基于令牌的验证上为什么PASETO比JWT好\">在基于令牌的验证上为什么PASETO比JWT好</h2>\n<h3 id=\"基于令牌的验证\">基于令牌的验证</h3>\n<p>我们先了解一下基于令牌的验证。大体来说，在验证机制中，客户端会发起第一个请求来登陆账户，它会向客户端提供用户名和密码。然后服务器会检查用户名是否是正确的，如果是的话服务器会创建并且登记一个token，然后返回一个<code>200 ok</code>和产生的这个token一块到客户端。</p>\n<p>之所以这个token会被称为通行token是因为稍后客户端会通过它来获取服务器上面的资源。比如说客户端想要获取到当前user名下的所有银行账户，他需要发送一个<code>GET/accounts</code>请求到服务器，通行token会被嵌入在请求的头部。受到请求的时候，服务器会验证这个令牌是否是有效的，如果请求是被允许的话，就会返回<code>200 ok</code>和该user的银行账户列表。</p>\n<p>需要注意通行token通常是有生命周期的，在这个期间，客户端可以用相同的令牌向服务器发送多个请求。</p>\n<h3 id=\"JSON-Web-Tkoen-JWT\">JSON Web Tkoen(JWT)</h3>\n<p><img src=\"https://i.imgur.com/HNe1dBh.png\" alt=\"picture 1\"></p>\n<p>上图是一个JSON Web Token的例子，它基于64位字符串编码，由3个主要部分组成，中间由点分割开：</p>\n<ul>\n<li>第一部分是红色的部分，是令牌的头部，当我们解码这一部分的时候，我们将会获得一个JSON对象，其中包含令牌的类型<code>JWT</code>，和用于登记令牌的算法<code>HS256</code></li>\n<li>第二部分是紫色的部分，这一部分是我们保存当前登陆用户的信息的部分，比如用户名和该令牌的生命截止的时间戳。</li>\n</ul>\n<p>我们可以自定义这个JSON来存储一些别的信息，在这个例子中我们有一个ID字段来标识令牌。当令牌泄漏我们需要撤销令牌的权限的时候会派上用场。存储在JWT中的数据只是基于64位的编码，而不是加密，我们不需要用服务器的密钥来对它进行解密内容。这意味着我们可以很轻松地对头部和有效信息部分进行编码。那么服务器如何验证这个令牌的权限呢？</p>\n<p>这就是第三部分需要做的了</p>\n<ul>\n<li>数字签名，这个思路很简单，只有服务器拥有密钥来注册令牌，所以如果有黑客再没有正确密钥情况下尝试去创建一个虚假的令牌，服务器会很容易发现这一行为。</li>\n</ul>\n<p>JWT标准提供了许多不同种类的数字签名算法，但是总体上能够概括为两个主要类别</p>\n<h4 id=\"对称密钥算法\">对称密钥算法</h4>\n<p>在注册和验证密钥期间使用相同的密钥，因为只有一个密钥，它必须要保密。所以这个算法只适合本地用户，换句话说就是内部服务器。这个算法在大部分应用的情况下都是有效并且合适的。</p>\n<p>但是我们不能在存在第三方服务需要验证令牌的时候使用它，因为这意味着我们必须把密钥交给第三方。</p>\n<h4 id=\"非对称密钥算法\">非对称密钥算法</h4>\n<p>私有密钥用于注册令牌，公共密钥用于验证。</p>\n<h4 id=\"JWT存在的问题\">JWT存在的问题</h4>\n<ul>\n<li>算法太弱：JWT提供的算法中有很多已知比较脆弱的算法，对于开发新手来说，很难知道哪一个算法是最合适的。</li>\n<li>简单的令牌伪造：如果选了一个不恰当的库，我们的系统会成为极易攻破的目标。JWT将注册算法放在了令牌的头部，因此攻击者可以向令牌中这个位置设置none来绕过签名验证过程。虽然这个问题在大部分库中被解决了，但是我们在选择的时候仍然需要小心。</li>\n</ul>\n<h3 id=\"PASETO-Platform-Agnostic-Security-Token\">PASETO-Platform Agnostic Security Token</h3>\n<h4 id=\"强力算法\">强力算法</h4>\n<p>它解决了所有JSON Web Token中存在的问题，并且开发者不再需要选择算法，而是只需要选择PASETO的版本。同一时刻只有两个PASETO版本是可用的。</p>\n<p>版本1比较老旧并且只能用于不能使用现代密码学的遗留系统。</p>\n<p>和JWT类似，PASETO对于两种主要情况同样有两个算法总类，对于本地和内部服务器而言，可以使用对称密钥算法。但是和JWT不同的是，PASETO会在令牌中进行加密和验证所有的信息。对于公共服务器的情况，我们还是使用非对称密钥算法，可JWT一样不对令牌信息进行编码。</p>\n<p>PASETO版本2的令牌字段主要分为4个部分，用点分割开</p>\n<ul>\n<li>第一部分是PASETO的版本</li>\n<li>第二部分是令牌的目的，是用于本地还是公共场景</li>\n<li>第三个部分是令牌承载的有效信息的主要内容，注意这是加密的，我们需要用密钥对它进行解密，这之后我们得到三个小部分\n<ul>\n<li>有效信息主体</li>\n<li>用于加密和验证的随机数</li>\n<li>信息验证标签，用于验证加密信息和与之相关的未加密信息</li>\n</ul>\n</li>\n<li>最后一部分可以存储任何公共信息，因为它不会被加密，这一部分是可以选择的</li>\n</ul>\n<h2 id=\"如何用go创建和验证JWT和PASETO\">如何用go创建和验证JWT和PASETO</h2>\n<h3 id=\"声明制作令牌的接口\">声明制作令牌的接口</h3>\n<p>我们创建一个新的包<code>token</code>，然后在其中创建一个新的文件<code>make.go</code>。思路是声明一个总的<code>token.Maker</code>接口来管理令牌的创建和验证。然后我们会写一个<code>JWTMaker</code>和<code>PasetoMaker</code>结构体来实现这个接口。通过这样做，我们能够很轻松地在不同种类的令牌制造。</p>\n<p>这个接口应当有两个方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Maker <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    CreateToken(username <span class=\"keyword\">string</span>, duration time.Duration) (<span class=\"keyword\">string</span>, error)</span><br><span class=\"line\">    VerifyToken(token <span class=\"keyword\">string</span>) (*Payload, error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>CreateToken()</code>方法以<code>username</code>和<code>duration</code>作为输入，返回一个token和一个错误类型</p>\n<p><code>VerifyToken()</code>方法接收一个token然后返回<code>Payload</code>对象和一个错误类型，这个payload对象存储token的主体。</p>\n<h3 id=\"声明token的Payload结构体\">声明token的Payload结构体</h3>\n<p>我们需要创建一个<code>payload.go</code>文件，然后定义<code>Payload</code>结构体。其中最重要的是<code>Username</code>字段，用于识别token的拥有者。当使用基于验证的token的时候，一定要记住每一个token都有一个较短的验证时间，所以我们需要<code>ExpiredAt</code>字段来指明这个token什么时候会过期。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Payload <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ID        uuid.UUID <span class=\"string\">`json:&quot;id&quot;`</span></span><br><span class=\"line\">    Username  <span class=\"keyword\">string</span>    <span class=\"string\">`json:&quot;username&quot;`</span></span><br><span class=\"line\">    IssuedAt  time.Time <span class=\"string\">`json:&quot;issued_at&quot;`</span></span><br><span class=\"line\">    ExpiredAt time.Time <span class=\"string\">`json:&quot;expired_at&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通常来说我们只需要下面这三个字段就可以了，但是如果我们想要有一个机制来取消对某些泄漏的token的权限的话，我们需要增加一个<code>ID</code>字段来独立地标志每一个token。这里我们用到的是uuid，它在<a href=\"https://github.com/google/uuid\">uuid</a>包中定义，我们可以go get一下。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get github.com/google/uuid</span><br></pre></td></tr></table></figure>\n<p>接下来我们定义一个<code>NewPayload()</code>函数，以一个<code>username</code>和<code>duration</code>作为输入参数并且返回一个<code>Payload</code>对象和一个错误。这个函数会创建一个新的带有username和duration的token payload。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewPayload</span><span class=\"params\">(username <span class=\"keyword\">string</span>, duration time.Duration)</span> <span class=\"params\">(*Payload, error)</span></span> &#123;</span><br><span class=\"line\">    tokenID, err := uuid.NewRandom()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    payload := &amp;Payload&#123;</span><br><span class=\"line\">        ID:        tokenID,</span><br><span class=\"line\">        Username:  username,</span><br><span class=\"line\">        IssuedAt:  time.Now(),</span><br><span class=\"line\">        ExpiredAt: time.Now().Add(duration),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> payload, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们先调用<code>uuid.Random()</code>来进行随机生成tokenID，然后我们定义一个payload变量，对其中字段进行赋值。</p>\n<h3 id=\"实现JWT-Maker\">实现JWT Maker</h3>\n<p>我们需要JWT的包，包的种类很多但是我们选用最流行的<a href=\"https://github.com/dgrijalva/jwt-go\">https://github.com/dgrijalva/jwt-go</a>,我们go get一下这个包。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get github.com/dgrijalva/jwt-go</span><br></pre></td></tr></table></figure>\n<p>接着我们创建一个<code>jwt_maker.go</code>文件，然后声明一个<code>JWTMaker</code>结构体，它是一个JWT maker，用于实现token.Maker接。</p>\n<p>在我们的项目中，我们使用对称密钥算法来注册token，因此结构体中应当有一个字段来保存密钥。</p>\n<p>然后我们需要增加一个<code>NewJWTMaker()</code>函数，以<code>secretKey</code>作为输入，并且返回一个token.Maker接口和一个错误类型。通过返回这个接口，我们将会保证我们的<code>JWTMaker</code>实现了<code>token.Maker</code>接口。</p>\n<p>目前，景观我们将要使用的算法不需要获得密钥的长度，确保密钥不是太短仍然是一个不错的想法。因此我们声明一个常量<code>minSecrectKeySize</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> minSecretKeySize = <span class=\"number\">32</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewJWTMaker</span><span class=\"params\">(secretKey <span class=\"keyword\">string</span>)</span> <span class=\"params\">(Maker, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(secretKey) &lt; minSecretKeySize &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;invalid key size: must be at least %d characters&quot;</span>, minSecretKeySize)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;JWTMaker&#123;secretKey&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在函数中我们检查密钥的长度，如果不够长的话我们回报错，如果够长我们就将他的值赋给JWTMaker对应的字段。</p>\n<p>到目前这一步我们发现我们的代码中还是有错误的，因为我们创建的<code>JWTMaker</code>对象没有实现<code>token.Maker</code>所要求的方法，因此我们需要解决这个问题就要实现这两个方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *JWTMaker)</span> <span class=\"title\">CreateToken</span><span class=\"params\">(username <span class=\"keyword\">string</span>, duration time.Duration)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *JWTMaker)</span> <span class=\"title\">VerifyToken</span><span class=\"params\">(token <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Payload, error)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现JWT-CreateToken方法\">实现JWT CreateToken方法</h3>\n<p>首先我们调用<code>NewPayload()</code>方法，并且传入<code>username</code>和<code>duration</code>,然后创建一个<code>jwtToken</code>通过调用jwt-go的包里面的<code>jwt.NewWithClaims()</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *JWTMaker)</span> <span class=\"title\">CreateToken</span><span class=\"params\">(username <span class=\"keyword\">string</span>, duration time.Duration)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">    payload, err := NewPayload(username, duration)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    jwtToken := jwt.NewWithClaims(jwt.SigningMethodHS256, payload)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jwtToken.SignedString([]<span class=\"keyword\">byte</span>(maker.secretKey))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是此时我们会遇到一个错误，我们的Payload结构体并没有实现jwt.Claims接口，它缺少一个<code>Valid()</code>方法。所以我们需要为它加上这个方法。它不需要仍和的输入参数，并且仅仅返回一个错误以防token是非法的。在jwt-go包中能够很轻易地找到这个方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ErrExpiredToken = errors.New(<span class=\"string\">&quot;token has expired&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(payload *Payload)</span> <span class=\"title\">Valid</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> time.Now().After(payload.ExpiredAt) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ErrExpiredToken</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它是用于判断当前token是否已经过期的函数，当现在时间迟于token的失效时间的时候，这个token就过期了，因此需要返回一个错误，我们应当把这个错误定义为一个公共的常量<code>ErrExpiredToken</code>，这样我们就可以从外部检查这个错误类型了。</p>\n<p>接着我们回到<code>jwtmaker.go</code>文件中，我们发现刚才的红线报的错误消失了。由于我们添加了<code>jwt-go</code>包，我们需要<code>go mod tidy</code>来将他添加到<code>go.mod</code>文件中。</p>\n<h3 id=\"实现JWT-VerifyToken方法\">实现JWT VerifyToken方法</h3>\n<p>首先我们需要解析token，调用<code>jwt.ParseWithClaims</code>并且传入token，一个空的payload和一个key函数。key函数接受一个解析后的但没验证的token，我们应该验证头部以确保注册算法和我们使用的是一致的。如果匹配的话，就返回key这样jwt-go能够用它来验证token。这一步对于预防攻击很重要。</p>\n<p>下面这个就是key函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *JWTMaker)</span> <span class=\"title\">VerifyToken</span><span class=\"params\">(token <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Payload, error)</span></span> &#123;</span><br><span class=\"line\">    keyFunc := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(token *jwt.Token)</span> <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class=\"line\">        _, ok := token.Method.(*jwt.SigningMethodHMAC)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrInvalidToken</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []<span class=\"keyword\">byte</span>(maker.secretKey), <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    jwtToken, err := jwt.ParseWithClaims(token, &amp;Payload&#123;&#125;, keyFunc)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在key函数中我们能够通过<code>token.Method</code>获得它的注册算法。注意到它的类型是一个<code>SigningMethod</code>，是一个接口，所以我们需要将他转换为一个具体的实现。在我们的代码中将他转换成了<code>SigningMethodHMAC</code>，因为我们使用的是<code>HS256</code>，是属于他的实例。如果转换不成功说明他们的类型是不一致的，我们需要返回一个空key和一个<code>ErrInvalidToken</code>错误，我们一会会在<code>payload.go</code>文件中定义这个错误。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">    ErrInvalidToken = errors.New(<span class=\"string\">&quot;token is invalid&quot;</span>)</span><br><span class=\"line\">    ErrExpiredToken = errors.New(<span class=\"string\">&quot;token has expired&quot;</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>如果转换成功的话，我们将密钥转成[]byte切片并且返回。</p>\n<p>现在key函数完成了，我们可以开始调用<code>ParseWithClaims</code>函数。如果它返回一个或者没有错误，可能存在2个不同的情况：要么token非法，要么token过期。但是我们需要区分这两种情况的时候问题变得复杂了，如果我们深入jwt-go包中的话我们发现它会自动调用<code>token.Claims.Valid()</code>函数，而在我们的函数实现中我们返回的是<code>ErrExpiredToken</code>，jwt-go中隐式地将最初的错误放在了<code>ValidationError</code>对象中了。</p>\n<p>因此为了弄清真实的错误，我们需要转换<code>ParseWithClaims()</code>函数返回的错误，使它成为<code>jwt.ValidationError</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *JWTMaker)</span> <span class=\"title\">VerifyToken</span><span class=\"params\">(token <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Payload, error)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    jwtToken, err := jwt.ParseWithClaims(token, &amp;Payload&#123;&#125;, keyFunc)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        verr, ok := err.(*jwt.ValidationError)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ok &amp;&amp; errors.Is(verr.Inner, ErrExpiredToken) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrExpiredToken</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrInvalidToken</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们这里将转换后的err赋值给<code>verr</code>变量，如果转换成功，<a href=\"http://xn--errors-hz8ig3bo82im51b.Is\">我们使用errors.Is</a>()函数来检查<code>verr.Inner</code>是否是<code>ErrExpiredToken</code>。如果是的话，我们返回一个空的payload和过期错误，否则我们返回token非法错误。</p>\n<p>如果一切都是正常，并且token也成功解析和验证，我们会尝试获取它的payload信息，通过将<code>jwtToken.Claims</code>转换为一个payload对象。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *JWTMaker)</span> <span class=\"title\">VerifyToken</span><span class=\"params\">(token <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Payload, error)</span></span> &#123;</span><br><span class=\"line\">    keyFunc := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(token *jwt.Token)</span> <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class=\"line\">        _, ok := token.Method.(*jwt.SigningMethodHMAC)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrInvalidToken</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> []<span class=\"keyword\">byte</span>(maker.secretKey), <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    jwtToken, err := jwt.ParseWithClaims(token, &amp;Payload&#123;&#125;, keyFunc)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        verr, ok := err.(*jwt.ValidationError)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ok &amp;&amp; errors.Is(verr.Inner, ErrExpiredToken) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrExpiredToken</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrInvalidToken</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    payload, ok := jwtToken.Claims.(*Payload)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> !ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrInvalidToken</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> payload, <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试JWT-Maker\">测试JWT Maker</h3>\n<p>在token包下面创建一个新的文件<code>jwt_maker_test.go</code>我们对这个maker进行测试。</p>\n<p>首先我们调用<code>NewJWTMaker()</code>函数并且传入一个随机的密钥。我们require一个Noerror。接着我们用util.RandomOwner()生成一个username，并且将token的生命周期设置为1分钟。</p>\n<p>我们声明两个变量来比较最后的结果：</p>\n<ul>\n<li><code>issueAt</code>时间应当是`time.Now(0</li>\n<li>在这个基础上加上<code>duration</code>就可以得到我们的截止时间</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestJWTMaker</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    maker, err := NewJWTMaker(util.RandomString(<span class=\"number\">32</span>))</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    username := util.RandomOwner()</span><br><span class=\"line\">    duration := time.Minute</span><br><span class=\"line\"></span><br><span class=\"line\">    issuedAt := time.Now()</span><br><span class=\"line\">    expiredAt := issuedAt.Add(duration)</span><br><span class=\"line\"></span><br><span class=\"line\">    token, err := maker.CreateToken(username, duration)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.NotEmpty(t, token)</span><br><span class=\"line\"></span><br><span class=\"line\">    payload, err := maker.VerifyToken(token)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.NotEmpty(t, token)</span><br><span class=\"line\"></span><br><span class=\"line\">    require.NotZero(t, payload.ID)</span><br><span class=\"line\">    require.Equal(t, username, payload.Username)</span><br><span class=\"line\">    require.WithinDuration(t, issuedAt, payload.IssuedAt, time.Second)</span><br><span class=\"line\">    require.WithinDuration(t, expiredAt, payload.ExpiredAt, time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在测试中我们先生成token，然后调用token验证来确保token合法并且返回payload信息。最后我们再一一检查payload中的各个字段。然后我们就可以运行这个单元测试了。</p>\n<p>接下来我们需要增加一个测试用于过期token。和之前类似，我们首先创建一个新的JWTMaker，然后创建一个过期token，传入一个username和负的duration就可以了。</p>\n<p>我们最后还需要验证一下非法的token，其中算法头部是None。这在上一节中说过，是一个著名的攻击技术。首先我们创建一个新的payload，然后我们创建一个新的token。然后我们要使用<code>SignedString()</code>注册token。但是这里我们不能再使用随机密钥了，因为jwt-go包中已经完全禁止使用<code>None</code>算法去注册token。我们只能在传入指定常量的时候对他做测试：<code>jwt.UnsafeAllowNoneSignatureType</code>。</p>\n<p>如果你遵循这个值的实现，你可以看到通常不允许使用无符号方法，除非输入键是这个特殊的常量。这意味着你知道你在干什么。确保你只在测试的时候这样用！</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestInvalidJWTTokenAlgNone</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    payload, err := NewPayload(util.RandomOwner(), time.Minute)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    jwtToken := jwt.NewWithClaims(jwt.SigningMethodNone, payload)</span><br><span class=\"line\">    token, err := jwtToken.SignedString(jwt.UnsafeAllowNoneSignatureType)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    maker, err := NewJWTMaker(util.RandomString(<span class=\"number\">32</span>))</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    payload, err = maker.VerifyToken(token)</span><br><span class=\"line\">    require.Error(t, err)</span><br><span class=\"line\">    require.EqualError(t, err, ErrInvalidToken.Error())</span><br><span class=\"line\">    require.Nil(t, payload)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现PASETO-Maker\">实现PASETO Maker</h3>\n<p>接下来我们使用相同的token maker接口来实现PASETO。我们去到<a href=\"https://github.com/o1egl/paseto\">paseto golang github page</a>,使用go get获取这个包</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get github.com/o1egl/paseto</span><br></pre></td></tr></table></figure>\n<p>接着我回到项目中，创建一个<code>paseto_maker.go</code>文件在<code>token</code>包中，与我们刚才做的类似，我们声明一个<code>PasetoMaker</code>结构体，用于实现相同的<code>token.Maker</code>接口。我们在这里会使用paseto的版本2，所以该结构体中应当有一个指定版本的字段。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PasetoMaker <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    paseto       *paseto.V2</span><br><span class=\"line\">    symmetricKey []<span class=\"keyword\">byte</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为我们只是想在银行api内部使用token，我们将会使用对称加密方法对token payload进行加密，因此我们需要symmetricKey字段存储密钥。</p>\n<p>接下来我们增加一个函数，<code>NewPasetoMaker</code>创建一个新的PasetoMaker实例。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewPasetoMaker</span><span class=\"params\">(symmetricKey <span class=\"keyword\">string</span>)</span> <span class=\"params\">(Maker, error)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(symmetricKey) != chacha20poly1305.KeySize &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;invalid key size: must be exactly %d characters&quot;</span>, chacha20poly1305.KeySize)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    maker := &amp;PasetoMaker&#123;</span><br><span class=\"line\">        paseto:       paseto.NewV2(),</span><br><span class=\"line\">        symmetricKey: []<span class=\"keyword\">byte</span>(symmetricKey),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maker, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为version2使用的是<code>Chacha20 Poly1305</code>算法来加密，所以我们需要在函数中先检查对称密钥的长度。</p>\n<p>同样我们发现在返回的maker下面有红线提示错误，这是因为我们还没有实现<code>token.Maker</code>接口。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *PasetoMaker)</span> <span class=\"title\">CreateToken</span><span class=\"params\">(username <span class=\"keyword\">string</span>, duration time.Duration)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *PasetoMaker)</span> <span class=\"title\">VerifyToken</span><span class=\"params\">(token <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Payload, error)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现paseto-CreateToken方法\">实现paseto CreateToken方法</h3>\n<p>我们首先需要去创建一个新的<code>payload</code>用<code>username</code>和<code>duration</code>。然后我们返回<code>maker.paseto.Encrypt()</code>并且传入我们的密钥和payload对象。最后一个参数是可选的footer部分，我们不需要，所以设置为nil。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *PasetoMaker)</span> <span class=\"title\">CreateToken</span><span class=\"params\">(username <span class=\"keyword\">string</span>, duration time.Duration)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">    payload, err := NewPayload(username, duration)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> maker.paseto.Encrypt(maker.symmetricKey, payload, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现paseto-VerifyToken-方法\">实现paseto VerifyToken 方法</h3>\n<p>我们只需要定义一个空的payload，然后调用decrypt来解密token就可以了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(maker *PasetoMaker)</span> <span class=\"title\">VerifyToken</span><span class=\"params\">(token <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*Payload, error)</span></span> &#123;</span><br><span class=\"line\">    payload := &amp;Payload&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err := maker.paseto.Decrypt(token, maker.symmetricKey, payload, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, ErrInvalidToken</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = payload.Valid()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> payload, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个的测试和前面是相同的，因为他们是同样的接口。</p>\n<h2 id=\"实现用户登录API，返回PASETO或者JWT通行证\">实现用户登录API，返回PASETO或者JWT通行证</h2>\n<h3 id=\"将token-maker添加到服务器\">将token maker添加到服务器</h3>\n<p>我们打开<code>api.server.go</code>文件，在其中的Server结构体中增加一个<code>tokenMaker</code>字段。然后我们在<code>NewServer()</code>中对这个字段进行初始化。我们这里选用PASETO作为我们的token maker。这需要调用<code>token.NewPasetoMaker()</code>，他需要一个对称密钥字符串作为输入，所以我们需要加载环境变量。目前的话我们可以先放一个空字符串在这里占个位置。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(store db.Store)</span> <span class=\"params\">(*Server, error)</span></span> &#123;</span><br><span class=\"line\">    tokenMaker, err := token.NewPasetoMaker(<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;cannot create token maker: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server := &amp;Server&#123;</span><br><span class=\"line\">        store:      store,</span><br><span class=\"line\">        tokenMaker: tokenMaker,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> server, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来我们需要增加一个环境变量到<code>app.env</code>里面，我们把他命名为<code>TOKEN_SYMMETRIC_KEY</code>。由于我们用的paseto v2,这个密钥的长度应该为32。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">TOKEN_SYMMETRIC_KEY=12345678901234567890123456789012</span><br><span class=\"line\">ACCESS_TOKEN_DURATION=15m</span><br></pre></td></tr></table></figure>\n<p>此外我们还加入了一个控制token的生命周期的变量，我们设置它为15min。接下来我们需要更新我们的config结构体来包含我们刚刚增加的两个变量。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Config <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    TokenSymmetricKey   <span class=\"keyword\">string</span>        <span class=\"string\">`mapstructure:&quot;TOKEN_SYMMETRIC_KEY&quot;`</span></span><br><span class=\"line\">    AccessTokenDuration time.Duration <span class=\"string\">`mapstructure:&quot;ACCESS_TOKEN_DURATION&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，我们定义time.Duration类型的环境变量的时候可以用我们人类方便理解的15m作为duration。</p>\n<p>然后我们需要在<code>NewServer()</code>中增加一个参数config，用它来加载我们的环境变量。我们同样需要将这个config字段增加到Server结构体中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    config     util.Config</span><br><span class=\"line\">    store      db.Store</span><br><span class=\"line\">    tokenMaker token.Maker</span><br><span class=\"line\">    router     *gin.Engine</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(config util.Config, store db.Store)</span> <span class=\"params\">(*Server, error)</span></span> &#123;</span><br><span class=\"line\">    tokenMaker, err := token.NewPasetoMaker(config.TokenSymmetricKey)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;cannot create token maker: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server := &amp;Server&#123;</span><br><span class=\"line\">        config:     config,</span><br><span class=\"line\">        store:      store,</span><br><span class=\"line\">        tokenMaker: tokenMaker,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class=\"line\">        v.RegisterValidation(<span class=\"string\">&quot;currency&quot;</span>, validCurrency)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server.setupRouter()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里由于我们改变了这个函数的输入输出，所以我们需要对之前的单元测试中用到这个函数的地方进行修改。</p>\n<h3 id=\"修复受影响的单元测试\">修复受影响的单元测试</h3>\n<p>在<code>api/main_test.go</code>文件中，我们要定义一个函数<code>newTestServer()</code>，它会创建一个新的server用于测试。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newTestServer</span><span class=\"params\">(t *testing.T, store db.Store)</span> *<span class=\"title\">Server</span></span> &#123;</span><br><span class=\"line\">    config := util.Config&#123;</span><br><span class=\"line\">        TokenSymmetricKey:   util.RandomString(<span class=\"number\">32</span>),</span><br><span class=\"line\">        AccessTokenDuration: time.Minute,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    server, err := NewServer(config, store)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> server</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着我们去到<code>api/transfer_test.go</code>文件中，这里我们将<code>NewServer()</code>换成<code>newTestServer()</code>。其他测试文件中我们也做同样的修改。</p>\n<p>但是还有一个非常重要的地方我们要去更新，服务器的主入口<code>main.go</code></p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    config, err := util.LoadConfig(<span class=\"string\">&quot;.&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot load config:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    conn, err := sql.Open(config.DBDriver, config.DBSource)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    store := db.NewStore(conn)</span><br><span class=\"line\">    server, err := api.NewServer(config, store)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot create server:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = server.Start(config.ServerAddress)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot start server:&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现login-user的handler\">实现login user的handler</h3>\n<p>打开<code>api/user.go</code>文件，login api必须要包含用户名和密码，这和创建user的api相类似。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> loginUserRequest <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Username <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;username&quot; binding:&quot;required,alphanum&quot;`</span></span><br><span class=\"line\">    Password <span class=\"keyword\">string</span> <span class=\"string\">`json:&quot;password&quot; binding:&quot;required,min=6&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们需要定义这个api的返回结构体，其中最重要的应该是<code>AccessToken</code>字符串</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> loginUserResponse <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    AccessToken <span class=\"keyword\">string</span>       <span class=\"string\">`json:&quot;access_token&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除此之外，我们还希望能够返回一部分登陆账户的相关信息，就像我们创建用户api中返回的那样。为了能将这个结构体进行重用，我们将它的名字改为<code>userResponse</code>，它会作为我们login api返回结构体中的一个字段。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> userResponse <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Username          <span class=\"keyword\">string</span>    <span class=\"string\">`json:&quot;username&quot;`</span></span><br><span class=\"line\">    FullName          <span class=\"keyword\">string</span>    <span class=\"string\">`json:&quot;full_name&quot;`</span></span><br><span class=\"line\">    Email             <span class=\"keyword\">string</span>    <span class=\"string\">`json:&quot;email&quot;`</span></span><br><span class=\"line\">    PasswordChangedAt time.Time <span class=\"string\">`json:&quot;password_changed_at&quot;`</span></span><br><span class=\"line\">    CreatedAt         time.Time <span class=\"string\">`json:&quot;created_at&quot;`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> loginUserResponse <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    AccessToken <span class=\"keyword\">string</span>       <span class=\"string\">`json:&quot;access_token&quot;`</span></span><br><span class=\"line\">    User        userResponse <span class=\"string\">`json:&quot;user&quot;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们从<code>createUser()</code>的handler中复制出来，并且定义一个<code>newUserResponse()</code>函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newUserResponse</span><span class=\"params\">(user db.User)</span> <span class=\"title\">userResponse</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> userResponse&#123;</span><br><span class=\"line\">        Username:          user.Username,</span><br><span class=\"line\">        FullName:          user.FullName,</span><br><span class=\"line\">        Email:             user.Email,</span><br><span class=\"line\">        PasswordChangedAt: user.PasswordChangedAt,</span><br><span class=\"line\">        CreatedAt:         user.CreatedAt,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数的作用是将输入的<code>db.User</code>转换为<code>userResponse</code>。这样做的原因是在<code>db.User</code>结构体中的部分信息比较敏感的数据<code>hashed_password</code>，这是我们不希望暴露给客户端的。</p>\n<p>所以在<code>createUser()</code>的handler中，我们能够只调用<code>newUserResponse()</code>函数来创建返回对象。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">createUser</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    user, err := server.store.CreateUser(ctx, arg)</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    rsp := newUserResponse(user)</span><br><span class=\"line\">    ctx.JSON(http.StatusOK, rsp)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数同样对物品们的loginUser()的handler也有用。现在我们给服务器结构体:<code>loginUser()</code>,和其他的API handler相类似，这个函数以gin.Contest()作为输入。在里面，我们声明了一个<code>request</code>对象，并且我们调用<code>ctx.ShouldBindJSON</code>函数。这会绑定API的所有输入参数到<code>request</code>对象中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">loginUser</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> req loginUserRequest</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err := ctx.ShouldBindJSON(&amp;req); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有错误的话，我们将要在数据库中查找这个用户。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">loginUser</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    user, err := server.store.GetUser(ctx, req.Username)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err == sql.ErrNoRows &#123;</span><br><span class=\"line\">            ctx.JSON(http.StatusNotFound, errorResponse(err))</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果一切正常的话，我们就需要检查客户端提供的密码是正确的还是错误的。因此我们调用函数来检查密码。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">loginUser</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    err = util.CheckPassword(req.Password, user.HashedPassword)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusUnauthorized, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只有当密码正确的时候我们彩绘创建一个通行令牌。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">loginUser</span><span class=\"params\">(ctx *gin.Context)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    accessToken, err := server.tokenMaker.CreateToken(</span><br><span class=\"line\">        user.Username,</span><br><span class=\"line\">        server.config.AccessTokenDuration,</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    rsp := loginUserResponse&#123;</span><br><span class=\"line\">        AccessToken: accessToken,</span><br><span class=\"line\">        User:        newUserResponse(user),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ctx.JSON(http.StatusOK, rsp)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们处理login接口的handler就写好了。</p>\n<h3 id=\"将login-api的route添加到服务器上\">将login api的route添加到服务器上</h3>\n<p>我们接下来需要将一个新的终端添加到服务器上，并且以loginUser()作为handler。我将会把它放到创建用户的route旁边。所以<code>route.POST()</code>，路径应当为<code>/user/login</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewServer</span><span class=\"params\">(config util.Config, store db.Store)</span> <span class=\"params\">(*Server, error)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    router := gin.Default()</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/users&quot;</span>, server.createUser)</span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/users/login&quot;</span>, server.loginUser)</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样就可以了。但是<code>NewServer()</code>函数太常了，这使得它很难阅读，所以我们要把它的功能部分分开。把路径设置部分单独拿出来做成<code>setupRouter()</code>。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *Server)</span> <span class=\"title\">setupRouter</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    router := gin.Default()</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/users&quot;</span>, server.createUser)</span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/users/login&quot;</span>, server.loginUser)</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts/:id&quot;</span>, server.getAccount)</span><br><span class=\"line\">    router.GET(<span class=\"string\">&quot;/accounts&quot;</span>, server.listAccounts)</span><br><span class=\"line\"></span><br><span class=\"line\">    router.POST(<span class=\"string\">&quot;/transfers&quot;</span>, server.createTransfer)</span><br><span class=\"line\"></span><br><span class=\"line\">    server.router = router</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"实现验证中间件和授权规则\">实现验证中间件和授权规则</h2>\n<p>目前为止我们的API都可以让任何人调用，不需要验证身份信息，这样做显然是不安全的。</p>\n","categories":["后端"],"tags":["sql,docker"]},{"title":"图卷积神经网络概述","url":"/2022/03/19/%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/","content":"<h2 id=\"图卷积缘起\">图卷积缘起</h2>\n<p>我们要思考：为什么研究者们要设计图卷积，直接在图上不能应用传统的卷积吗？要理解这个，我们首先要理解应用传统卷积的图像（欧氏空间）和图（非欧式空间的区别）。如下图，是在两种不同结构上应用卷积的场景</p>\n<p><img src=\"https://i.imgur.com/PrBt36X.png\" alt=\"picture 6\"></p>\n<p>图卷积真正的难点在于 <strong>邻居节点数量不固定</strong>。目前有两中主流的研究方向</p>\n<ul>\n<li>将非欧式空间转换为欧式空间</li>\n<li>找出一种可以处理变长邻居节点的卷积核在图上抽取特征</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"图卷积的框架\">图卷积的框架</h2>\n<p>如下图所示，输入的是整张图，在<code>Convolution Layer 1</code>里面，对每个节点的邻居都进行一次卷积操作，并且用卷积的结果更新这个节点；然后经过激活函数传给<code>Convolution Layer 2</code>与激活函数，重复这个过程。</p>\n<p>与GNN类似，GCN也有一个局部输出函数，用于将节点的状态（包括隐藏状态和节点特征）转换成任务相关的标签，称为<code>Node-Level</code>的任务；也有些任务是对整张图进行分类的，比如化合物分类，称为<code>Graph-Level</code>的任务。卷积操作只关心每个节点的隐藏状态如何更新，而对于<code>Graph-Level</code>的任务，会在卷积层之后增加更多的操作。</p>\n<h2 id=\"卷积\">卷积</h2>\n<p>图卷积神经网络主要两中：空域和频域的。通俗点，空域就是直接在图片的像素点上进行卷积，频域是对图片进行傅里叶变换后再卷积。</p>\n<h3 id=\"空域卷积\">空域卷积</h3>\n<p>其核心在于聚合邻居节点的信息。比如最简单的无参卷积方式是：将所有直连邻居节点的隐藏状态加和，来更新当前节点的隐藏状态。</p>\n<p><img src=\"https://i.imgur.com/3Jnfovx.png\" alt=\"picture 14\"></p>\n<h3 id=\"消息传递网络（Message-Passing-Neural-Network）\">消息传递网络（Message Passing Neural Network）</h3>\n<p>严格来说，MPNN并不是一种具体的模型，而是一种空域卷积的形式化框架。将空域卷积分解为两个过程：消息传递和状态更新，分别由$M_l(·)$和$U_l(·)$函数完成。将节点v的特征$X_v$作为隐藏状态的初始状态$H_v^0$之后，空域卷积对隐藏状态的更新如下：</p>\n<p><img src=\"https://i.imgur.com/dmxgXS1.png\" alt=\"picture 15\"></p>\n<p>其中l代表卷积层的第l层。式子的物理意义是：受到来自每个邻居的消息$M_{l+1}$之后，每个节点如何更新自己的状态。</p>\n<p>MPNN的示意图如下</p>\n<p><img src=\"https://i.imgur.com/aaerMwm.png\" alt=\"picture 16\"></p>\n<h3 id=\"图采样与聚合\">图采样与聚合</h3>\n<p>MPNN很好地概括了空域卷积的过程，但这个框架下的所有模型都有一个共同的缺陷：卷积操作针对的对象是整张图，即要将所有的节点放到内存中，才能卷积。但是实际应用中，整个图上的卷积操作并不现实。GraphSage利用采样部分节点的方式进行学习。当然，即使不需要整张图同时卷积，GraphSage仍然需要聚合邻居节点的信息。这种操作类似于MPNN中的消息传递过程</p>\n<p><img src=\"https://i.imgur.com/N3phwJo.png\" alt=\"picture 17\"></p>\n<p>具体采样过程分为三步：</p>\n<ol>\n<li>在图中随机采样若干个节点，节点数就是传统任务中的<code>batch_size</code>。对于每个节点，随机选择固定数目的邻居节点（未必是一阶邻居，也可以是二阶邻居）。</li>\n<li>将邻居节点的信息通过aggregate函数聚合起来更新刚才采样的节点</li>\n<li>计算采样节点处的损失。如果是无监督任务，我们希望图上邻居节点的编码相似；如果是监督任务，可以根据具体节点的任务标签计算损失。</li>\n</ol>\n<p>最终的GraphSage的状态更新公式如下：</p>\n<p><img src=\"https://i.imgur.com/e6fe9aR.png\" alt=\"picture 43\"></p>\n<p>GraphSage的设计重点是aggrega函数的设计上，它可以是max，mean也可以是带参数的如LSTM等神经网络。</p>\n<h2 id=\"图结构序列化\">图结构序列化</h2>\n<p>这个方法将图结构转换成序列结构，然后直接利用卷积神经网络在序列化之后的序列结构上进行卷积。</p>\n<p>这种序列转换需要保持图结构的两个特点：1.同构的性质。2.邻居节点的链接关系。对于前者，意思是我们把图上节点的标号随机打乱，得到的仍然应该是一样的序列；对于后者，意味着我们需要保持邻居节点和目标节点的距离关系。</p>\n<p>PATCH-SAN通过以下三个步骤来解决这两个问题：</p>\n<ol>\n<li><strong>节点选择</strong>：通过一些人为定义的规则（比如度大的节点分数高，邻居节点度大时分数较高等）为每个节点指定一个在图中的排序。完成排序后取出前$\\omega$个节点代表整个图。</li>\n<li><strong>邻居节点构造</strong>：以第一步选择的节点为中心，得到他们的邻居节点（可以是一阶邻居也可以是二阶邻居），这样就构成了$\\omega$个团，根据第一步得到的节点排序对每个团中的邻居节点进行排序，取前k个邻居节点按照顺序排序，就组成了$\\omega$个有序的团。</li>\n<li><strong>图规范化</strong>：按照每个团中的节点顺序可以将所有的团转换成固定长度的序列（k+1），再将他们按照中心节点的顺序从前到后依次拼接就能得到长度为$\\omega \\times (k+1)$的代表整张图的序列。需要注意的是，如果取不到$\\omega$或者k个节点，需要用空节点填充。</li>\n</ol>\n<p>流程图如下所示：</p>\n<p><img src=\"https://i.imgur.com/qEhL4bU.png\" alt=\"picture 24\"></p>\n<p>下图更清晰：</p>\n<p><img src=\"https://i.imgur.com/aRKWzoN.png\" alt=\"picture 25\"></p>\n<h2 id=\"频域卷积\">频域卷积</h2>\n<p>空域卷积直观地借鉴了图像中的卷积操作，但是缺乏理论基础。而频域卷积则不同，主要利用图傅里叶变换实现卷积。</p>\n<p>简单来说就是，利用图的拉普拉斯矩阵导出其频域上的拉普拉斯算子，再类比频域上的欧氏空间中的卷积，导出卷积公式。</p>\n<h3 id=\"傅里叶变换\">傅里叶变换</h3>\n<p>傅里叶变换会将一个在空域（或者时域）上定义的函数分解成频域上的若干频率成分。即傅里叶变换可以将一个函数从空域变换到频域。先抛开傅里叶变换的数学公式，用F来表示傅里叶变换的话，有一个重要的恒等式：</p>\n<p>$$<br>\n(f * g)(t)=F^{-1} [F [f(t)] \\odot F [g(t)] ]<br>\n$$</p>\n<p>这里的$F^{-1}$ 指的是傅里叶逆变换，$\\odot$ 指的是哈达玛积。上式的直观含义是：空（时）域卷积等于频域卷积。简单来说就是如果要求f和g的卷积，可以先将他们通过傅里叶变换变换到频域中，将两个函数在频域中相乘，然后再通过傅里叶逆变换转换出来。</p>\n<p>那么傅里叶变换能够做什么呢？一个简单的应用是给图像去除规律噪点。如下图，傅里叶变换前有一些规律的条纹，直接在原图去除有点困难，但我们可以将图片通过傅里叶变换变到频谱图中，频谱中的规律条纹就是原图中的背景条纹。</p>\n<p><img src=\"https://i.imgur.com/1RCTpbS.png\" alt=\"picture 26\"></p>\n<p>只要在频谱图中去除这些点，就可以将背景条纹去掉。</p>\n<p><img src=\"https://i.imgur.com/ocm1zaI.png\" alt=\"picture 27\"></p>\n<p>除了去除噪声点，其在加速卷积运算方面还有很大的潜力，快速傅里叶变换也是由此而生。事实上现在常用的卷积神经网络完全可以搭配傅里叶变换。但是由于目前的大部分卷积核都比较小，卷积操作本身就不是很大开销，搭配傅里叶变换不一定就会减小时间开销。</p>\n<p>那么傅里叶变换的公式是什么样的呢？</p>\n<p>$$<br>\n\\hat{f}(t)=\\int f(x) \\exp ^{-2 \\pi i x t} d x<br>\n$$</p>\n<p>其中$i=\\sqrt{-1}$，t是任意实数。</p>\n<p>我们这里实际上需要关注$\\exp ^{-2 \\pi i x t}$的物理意义，它实际上是拉普拉斯算子$\\delta$的广义特征函数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">拉普拉斯算子(Laplacian operator) 的物理意义是空间二阶导，准确定义是：标量梯度场中的散度，一般可用于描述物理量的流入流出。比如说在二维空间中的温度传播规律，一般可以用拉普拉斯算子来描述。</span><br></pre></td></tr></table></figure>\n<p>为什么是特征向量呢？稍微推导以下就可以知道，拉普拉斯算子作用在$\\exp ^{-2 \\pi i x t}$确实满足以上特征向量的定义：</p>\n<p>$$<br>\n\\Delta \\exp ^{-2 \\pi i x t}=\\frac{\\partial^{2} } {\\partial t^{2} } \\exp ^{-2 \\pi i x t}=-4 \\pi^{2} x^{2} \\exp ^{-2 \\pi i x t}<br>\n$$</p>\n<p>这里$\\partial$是求导符号，$\\partial^2$是二阶导。</p>\n<p>实际上，仔细观察傅里叶变换的例子，本质上就是将函数f(t)映射到$\\exp ^{-2\\pi ixt}$的基向量空间中。</p>\n<h3 id=\"图上的傅里叶变换\">图上的傅里叶变换</h3>\n<p>前面讲的都是为了这一部分做铺垫。问题来了：在图上，我们怎么找拉普拉斯算子$\\delta$和$\\exp ^{-2\\pi ixt}$呢？</p>\n<p>研究者们找到了图的拉普拉斯矩阵和特征向量作为替代品。拉普拉斯矩阵本质上是度矩阵（D）减去邻接矩阵（A）L=D-A，如图所示</p>\n<p><img src=\"https://i.imgur.com/xkIhW3R.png\" alt=\"picture 28\"></p>\n<p>频域卷积的前提条件就是图必须是无向图，那么L就是对称矩阵。所以可以由以下公式分解：</p>\n<p><img src=\"https://i.imgur.com/zJw8FYb.png\" alt=\"picture 29\"></p>\n<p>那么根据上面卷积和傅里叶结合的变换公式，图上频域卷积的公式就可以写成$\\hat{f}(t)=\\sum_{n=1}^{N} f(n) u_{t}(n)$，如果整个图上的N个节点一起做卷积，就能够得到整张图上的卷积如下：</p>\n<p><img src=\"https://i.imgur.com/oZNB2qd.png\" alt=\"picture 30\"></p>\n<p>回顾传统卷积和图卷积，发现他们非常相似，这里f都是特征函数，g都是卷积核</p>\n<p><img src=\"https://i.imgur.com/hxBFtSB.png\" alt=\"picture 31\"></p>\n<p>如果把$U^Tg$整体看作可以学习的卷积核，我们写作$g_\\theta$。最终的卷积公式就是：</p>\n<p><img src=\"https://i.imgur.com/6ZqiOgV.png\" alt=\"picture 32\"></p>\n<h3 id=\"频域卷积网络\">频域卷积网络</h3>\n<p>上面推导出的$g_\\theta$就是首个提出的频域卷积神经网络的卷积核。设l层的隐藏状态为$h^l\\in R^{N\\times d_t}$，频域卷积层的状态更新计算公式如下：</p>\n<p><img src=\"https://i.imgur.com/K0CkMxN.png\" alt=\"picture 33\"></p>\n<p>物理上可以如下理解</p>\n<p><img src=\"https://i.imgur.com/lldUmjS.png\" alt=\"picture 34\"></p>\n<a href=\"/2022/03/19/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/\" title=\"图神经网络概述\">图神经网络概述</a>\n<a href=\"/2022/03/19/%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/\" title=\"图卷积神经网络概述\">图卷积神经网络概述</a>\n<a href=\"/2022/03/19/%E8%8A%82%E7%82%B9%E8%A1%A8%E7%A4%BA%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%9B%BE%E8%A1%A8%E7%A4%BA/\" title=\"节点表示如何生成图表示\">节点表示如何生成图表示</a>","categories":["图神经网络"],"tags":["GCN 综述"]},{"title":"常见的报错以及解决方式","url":"/2022/01/25/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8A%A5%E9%94%99%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/","content":"<h2 id=\"Deep-Learning\">Deep Learning</h2>\n<h3 id=\"tqdm\">tqdm</h3>\n<ul>\n<li>使用tqdm对迭代对象时，如果出现<code>'module' object is not callable</code>则将<code>import tqdm</code>改为<code>tqdm</code></li>\n</ul>\n","categories":["Code"],"tags":["error"]},{"title":"图神经网络概述","url":"/2022/03/19/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/","content":"<h2 id=\"状态更新与输出\">状态更新与输出</h2>\n<p>最早的图神经网络的理论基础是不动点理论。给定一张图$G$，每个节点都有其自身特征$X_v$，每个边也有其自身特征$X_{(u,v)}$。GNN的学习目标就是获得每个结点的图感知的隐藏状态，即：对于每个节点，其隐藏状态包含来自邻居节点的信息。那如何让每个节点都能感知到图上的其他节点呢？GNN通过迭代式更新所有节点的隐藏状态来实现，在t+1时刻，节点的隐藏状态按照如下方式更新：</p>\n<p><img src=\"https://i.imgur.com/2vgW7gB.png\" alt=\"picture 8\"></p>\n<p>其中f就是隐藏状态的更新函数，$x_co[v]$是与节点v相邻的边的特征，$x_ne[v]$是节点v的邻居节点的特征，$h_n^te[v]$是邻居节点在t时刻的隐藏状态。神经网络需要做的就是拟合这个函数f。</p>\n<span id=\"more\"></span>\n<p>显然对于不同的节点，他们相邻的边或者点的个数不一定是相同的，那这个f函数的输入就是不定长的，怎么解决这个问题呢？我们可以在f的内部先将不定长的参数转变成一个固定的参数，比如说所有隐状态的和作为隐状态的代表。举个例子：</p>\n<p><img src=\"https://i.imgur.com/AdE1gjq.png\" alt=\"picture 45\"></p>\n<p>假设节点5是中心节点，隐藏状态更新的公式如图所示。公式的中心思想：不断利用当前时刻邻居节点的隐藏状态作为部分输入来生成下一时刻中心节点的隐藏状态，直到每个节点的隐藏状态变化幅度很小。</p>\n<p>但是状态更新公式仅仅描述了如何获取每个节点的隐状态，我们还需要一个函数g来描述如何适应下游任务。比如，下游任务是判断各节点是否为水军账号</p>\n<p>$$<br>\no_v=g(h_v,x_v)<br>\n$$</p>\n<p>整个流程可以使用下面这张图表达</p>\n<p><img src=\"https://i.imgur.com/JV7M8Ow.png\" alt=\"picture 46\"></p>\n<p>直到$T_n$时刻各个节点的隐藏状态收敛，每个节点后面接一个g就可以得到节点的输出。对于不同的图，节点的收敛时刻可能不同，收敛是通过两个时刻的p-范数差值和某个阈值$\\epsilon$。</p>\n<p><img src=\"https://i.imgur.com/xxyvPCL.png\" alt=\"picture 47\"></p>\n<h2 id=\"不动点理论\">不动点理论</h2>\n<p>这里的不动点理论专指巴纳赫不动点理论(Banach’s Fixed Point Theorem)。首先我们用F表示若干个f堆叠得到的一个函数，那么图上所有节点的状态更新公式可以写成</p>\n<p><img src=\"https://i.imgur.com/IF5e2Zf.png\" alt=\"picture 48\"></p>\n<p>不动点定理指的就是，不论$H^0$是什么，只要F是个压缩映射，$H^0$经过不断迭代都会收敛到某一个固定的点，称之为不动点。</p>\n<h3 id=\"压缩映射\">压缩映射</h3>\n<p><img src=\"https://i.imgur.com/ryRG4FY.png\" alt=\"picture 3\"></p>\n<p>上图的实线就是映射F，任意两个点x，y经过映射后变成F(x),F(y)。经过F变换后的空间一定比原空间小，这样经过不断的迭代压缩，最终原空间上的所有点都会被映射到同一个点上。</p>\n<p>那既然f是由神经网络实现的，如何实现才能保证他是个压缩映射呢？</p>\n<h2 id=\"具体实现\">具体实现</h2>\n<p>具体实现中，f可以是意见简单前馈神经网络实现，比如只是简单地将f的几个参数凭借在一起然后做个加和。</p>\n<p><img src=\"https://i.imgur.com/bYmBx17.png\" alt=\"picture 10\"></p>\n<p>但如何保证f是个压缩映射呢？只需要限制f对H的偏导数矩阵的大小就可以了，本质上是通过对雅可比矩阵的惩罚项来实现的。代数中有个定理：f为压缩映射的等价条件是f的梯度（也就是对H的导数）要小于1。</p>\n<p>我们使用$\\left|x\\right|$表示x在这个空间上的范数。范数是一个标量是向量的长度或者模。这里我们将x简化为1维的，左边间的差值可以看作向量在空间中的距离，可以推导出：</p>\n<p><img src=\"https://i.imgur.com/JGORo9H.png\" alt=\"picture 11\"></p>\n<p>推广一下，即得到雅可比矩阵的罚项需要满足其范数小于等于c等价于压缩映射的条件。根据拉格朗日乘子法，将有约束问题变成带罚项的无约束优化问题，训练的目标可表示成如下形式：</p>\n<p>$$<br>\nJ=\\operatorname{Loss}+\\lambda \\cdot \\max \\left(\\frac{|\\partial F N N|}{|\\partial \\mathbf{h}|}-c, 0\\right), c \\in(0,1)<br>\n$$</p>\n<h2 id=\"模型学习\">模型学习</h2>\n<p>虽然每个节点都会有隐藏状态和输出，但并不是每个节点都有监督信号。比如，社交网络中只有部分用户被明确标记为水军，这就构成了典型的节点二分类问题。</p>\n<p>模型的损失就可以由这些有监督的信号的节点得到。假设监督节点由p个，模型损失可以形式化为：</p>\n<p><img src=\"https://i.imgur.com/6LVIkvo.png\" alt=\"picture 12\"></p>\n<p>反向传播计算梯度的过程：</p>\n<ol>\n<li>调用f若干次，比如$T_n$次，直到$h_v^{T_n}$收敛。</li>\n<li>此时每个结点的隐藏状态接近不动点的解。</li>\n<li>对于有监督信号的结点，将其隐藏状态通过 g 得到输出，进而算出模型的损失</li>\n</ol>\n<h2 id=\"GNN与RNN\">GNN与RNN</h2>\n<p>大家可以发现，GNN与RNN的不论是前向还是反向传播的算法，都是非常相似的。实际上确实如此，我们用下图来解释两者设计上的不同：</p>\n<p><img src=\"https://i.imgur.com/fOPCggK.png\" alt=\"picture 49\"></p>\n<p>假设在GNN上存在三个节点x1,x2,x3,同样RNN中存在一个序列（x1,x2,x3），他们的区别主要在于：</p>\n<ol>\n<li>GNN的基础理论是不动点，所以其沿时间展开的长度是动态的，根据收敛条件决定，RNN沿时间展开的长度就等于序列本身的长度。</li>\n<li>GNN每次时间步的输入都是所有节点v的特征，而RNN每次是对应时刻的对应输入。同时，时间步之间的信息流也不同，前者由边决定，后者由序列的顺序决定。</li>\n<li>GNN采用AP算法反向传播优化，RNN使用BPTT优化。前者对收敛性有要求，后者没有。</li>\n<li>GNN循环调用f是为了得到每个节点稳定的隐状态，因此只有在隐状态收敛之后才能输出；RNN在每个时间步上都可以输出，比如语言模型。</li>\n</ol>\n<h2 id=\"GNN的局限性\">GNN的局限性</h2>\n<ul>\n<li>GNN只将边作为了一种传播手段，并未区分不同边的功能。虽然我们可以在特征构造阶段$(X_{(u,v)})$为不同类型的边赋予不同的特征，但相比于其他输入，边对节点隐藏状态的影响实在有限。GNN没有为边设置独立的可学习参数，就意味着无法通过模型学习到边的某些特性。</li>\n<li>如果把GNN应用在图表示的场景中，使用不动点理论并不合适。主要因为基于不动点的收敛会导致节点之间的隐藏状态之间存在较多的信息共享，导致节点状态太过于光滑，属于节点自身的特征信息匮乏。</li>\n</ul>\n<p>下面这张来自维基百科的图可以形象地解释什么是 Over Smooth，其中我们把整个布局视作一张图，每个像素点与其上下左右以及斜上下左右8个像素点相邻，这决定了信息在图上的流动路径。初始时，蓝色表示没有信息量，如果用向量的概念表达即为空向量；绿色，黄色与红色各自有一部分信息量，表达为非空的特征向量。在图上，信息主要从三块有明显特征的区域向其邻接的像素点流动。一开始不同像素点的区分非常明显，但在向不动点过渡的过程中，所有像素点都取向一致，最终整个系统形成均匀分布。这样，虽然每个像素点都感知到了全局的信息，但我们无法根据它们最终的隐藏状态区分它们。比如说，根据最终的状态，我们是无法得知哪些像素点最开始时在绿色区域。</p>\n<p><img src=\"https://images.cnblogs.com/cnblogs_com/SivilTaram/1510485/o_image-9-over-smooth.gif\" alt=\"picture 5\"></p>\n<h2 id=\"门控图神经网络\">门控图神经网络</h2>\n<p>既然RNN和GNN存在如此多的相似点，是否可以用类似RNN的方法定义GNN呢？于是，门控图神经网络（GGNN）出现了。虽然类似，但实际上差别很大，最核心点在于门控神经网络不以不动点理论为基础。意味着：f不再需要是一个压缩映射；迭代不需要达到收敛才可以输出，可以固定迭代步长；优化算法也从AP算法转向BPTT。</p>\n<h3 id=\"状态更新\">状态更新</h3>\n<p>与图神经网络定义的范式一致，GGNN也有两个过程：状态更新与输出。相比GNN而言，它主要的区别来源于状态更新阶段。GGNN参考了GRU的设计，把邻居节点的信息视为输入，节点本身状态视为隐藏状态，状态更新函数如下：</p>\n<p><img src=\"https://i.imgur.com/OxrJiqQ.png\" alt=\"picture 13\"></p>\n<p>观察上式，除了GRU式的设计之外，GGNN还针对不同类型的边引入了可学习的参数W。每种edge对应一个$W_{edge}$，这样就可以处理异构图。</p>\n<p>但是，GNN中需要作为输入的节点特征$X_v$没有出现在GGNN公式中，但是这个特征对于预测非常重要！</p>\n<p>为了解决这个问题，GGNN将节点特征作为隐藏状态初始化的一部分。重新回顾GGNN的流程：</p>\n<ol>\n<li>用节点特征初始化各个节点的（部分）隐藏状态</li>\n<li>对整张图按照上述状态更新公式固定迭代若干步</li>\n<li>对部分有监督信号的节点求得模型损失，利用BPTT算法反向传播求得$W_edge$和GRU参数梯度</li>\n</ol>\n<h3 id=\"实例1：到达判断\">实例1：到达判断</h3>\n<p>比如说给定一张图G，开始结点 S，对于任意一个结点 E，模型判断开始结点是否可以通过图游走至该结点。同样地，这也可以转换成一个对结点的二分类问题，即可以到达和不能到达。下图即描述了这样的过程：</p>\n<p><img src=\"https://i.imgur.com/9v9XVfd.png\" alt=\"picture 50\"></p>\n<p>图中的黄色结点即开始结点S，绿色结点是我们希望判断的结点E，我们这里称其为结束结点。那么相比于其他结点，这两个结点具有一定特殊性。那我们就可以使用第1维为1来表示开始结点，第2维为1来表示结束结点。最后在对结束结点分类时，如果其隐藏状态的第1维被赋予得到了一个非0的实数值，那意味着它可以到达。</p>\n<p>从初始化的流程我们也可以看出GNN与GGNN的区别：GNN依赖于不动点理论，所以每个结点的隐藏状态即使使用随机初始化都会收敛到不动点；GGNN则不同，不同的初始化对GGNN最终的结果影响很大。</p>\n<p>下一篇博客中会继续介绍图卷积神经网络，摆脱了基于循环的方法，开始走向多层神经网络。</p>\n<a href=\"/2022/03/19/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/\" title=\"图神经网络概述\">图神经网络概述</a>\n<a href=\"/2022/03/19/%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/\" title=\"图卷积神经网络概述\">图卷积神经网络概述</a>\n<a href=\"/2022/03/19/%E8%8A%82%E7%82%B9%E8%A1%A8%E7%A4%BA%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%9B%BE%E8%A1%A8%E7%A4%BA/\" title=\"节点表示如何生成图表示\">节点表示如何生成图表示</a>","categories":["图神经网络"],"tags":["GNN 综述"]},{"title":"桃子你好","url":"/2022/01/10/%E6%A1%83%E5%AD%90%E4%BD%A0%E5%A5%BD/","content":""},{"title":"概念漂移入门","url":"/2022/03/26/%E6%A6%82%E5%BF%B5%E6%BC%82%E7%A7%BB%E5%85%A5%E9%97%A8/","content":"<p>数据可能会随着时间的变化而变化，这会使得预测模型中预测变差并且降级，这种改变数据中潜在关系的问题在机器学习领域中被称为概念漂移。</p>\n<p>本文主要注重于三点：</p>\n<ul>\n<li>数据随时间的变化问题</li>\n<li>什么是概念漂移及其定义方式</li>\n<li>如何在自己的预测建模问题中处理概念偏差</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"随时间变化的数据\">随时间变化的数据</h2>\n<p>预测建模是从历史中学习模型并且使用模型对我们不知道答案的新数据进行预测的问题。</p>\n<p>本质上就是一个映射函数<code>y=f(x)</code>。</p>\n<p>通常来说，这种映射被认为是静态的，即从历史数据中学习的映射对将来的新数据同样适用，其间关系不会改变。</p>\n<p>但是在一些情况下，这种输入输出的关系会随时间变化发生改变。而这些改变可能是非常重要的，会导致我们的模型失灵。反过来，我们可以检测这些变化，如果检测到了的话，就适时更新学习的模型来反映这些变化。</p>\n<h2 id=\"什么是概念漂移\">什么是概念漂移</h2>\n<p>机器学习和数据挖掘中的概念漂移指的是随着时间的推移，潜在问题中输入和输出数据之间关系的变化。在其他邻域这种变化可能被称作“协变量移位”，“数据集移位”或者“非平稳性”。</p>\n<p>例如，天气数据中的一个概念可能是未在温度数据中明确指定的季节，但可能影响温度数据。另一个例子可能是随着时间的推移客户购买行为可能受到经济实力的影响，其中经济实力没有在数据中明确规定。这些元素也称为“隐藏上下文”。</p>\n<p>对数据的更改可以采取任何形式。从概念上讲，更容易考虑这样一种情况，即变化存在一定的时间一致性，使得在特定时间段内收集的数据显示出相同的关系，并且这种关系随时间平滑变化。</p>\n<p>每种情况可能需要不同的概念漂移检测和处理方案。通常，经常性变化和长期趋势被认为是系统性的，可以明确地识别和处理。</p>\n<p>概念漂移可能出现在监督学习问题上，其中进行预测并且随时间收集数据。这些传统上称为在线学习问题，考虑到数据随时间的变化。</p>\n<p>存在按时间排序预测的域，例如时间序列预测和流数据的预测，其中概念漂移的问题更可能并且应该明确地测试和解决。</p>\n<h2 id=\"如何解决概念漂移\">如何解决概念漂移</h2>\n<h3 id=\"1-什么都不做\">1. 什么都不做</h3>\n<p>开发一次得到最佳模型，应用于将来的所有数据。这应该是与其他方法比较的起点和基线，如果数据集可能出现概念漂移，可以通过两种方式使用静态模型：</p>\n<ol>\n<li><strong>概念漂移检测</strong>：检测静态模型随时间的性能，如果性能下降，说明可能出现概念漂移现象</li>\n<li><strong>基线表现</strong>：使用静态模型的性能作为基准，比较干预后的性能</li>\n</ol>\n<h3 id=\"2-定期重新适应\">2. 定期重新适应</h3>\n<p>使用更新的历史数据定期更新静态模型，比如可以使用前一时期收集的数据每月或者每年更新模型。还可以涉及对模型进行反向测试，以便在重新拟合静态模型时选择合适数量的历史数据。</p>\n<h3 id=\"3-定期更新\">3. 定期更新</h3>\n<p>一些机器学习模型可以定期更新。这是比先前方法（周期性重新拟合）效率更高，其中并不完全丢弃静态模型，而是将现有状态用作适合过程的七点，使用最新的数据样本来更新模型拟合。该方法适用于使用权重或者系数的大多数机器学习算法，比如回归算法和神经网络。</p>\n<h3 id=\"4-重量数据\">4. 重量数据</h3>\n<p>某些算放允许权衡输入数据的重要性。这种情况下可以使用与数据年龄成反比的加权，以便更多地关注最新数据（较高权重），并且较少的关注最近数据（较小权重）。</p>\n<h3 id=\"5-了解变化\">5. 了解变化</h3>\n<p>可以在静态模型保持不变的情况下使用集合方法，但是新模型学习基于更新近的数据中的关系来校正来自静态模型的预测。</p>\n<p>这可以被认为是增强型集合（仅在精神上），其中后续模型校正来自先前模型的预测。这里的关键区别在于后续模型适用于不同的和更新的数据，而不是相同数据集的加权形式，如AdaBoost和梯度增强的情况。</p>\n<h3 id=\"6-检测并选择模型\">6. 检测并选择模型</h3>\n<p>对于某些问题域，可以设计系统来检测变化并选择特定的和不同的模型来进行预测。</p>\n<p>这可能适用于预期过去可能发生突然变化并且可以在将来检查的域。它还假设可以开发熟练的模型来处理每个可检测的数据更改。</p>\n<p>例如，突然变化可以是范围内的特定观察或观察，或者一个或多个输入变量的分布的变化。</p>\n<h3 id=\"7-数据准备\">7. 数据准备</h3>\n<p>在某些领域，例如时间序列问题，数据可能会随着时间的推移而发生变化。</p>\n<p>在这些类型的问题中，通常以这样的方式准备数据，即通过差分去除随时间的数据的系统变化，例如趋势和季节性。</p>\n<p>这很常见，它被内置到ARIMA模型等经典线性方法中。</p>\n<p>通常，我们不会将数据的系统变化视为概念漂移的问题，因为它可以直接处理。相反，这些示例可能是一种思考问题的有用方法，可以帮助您使用标准化，缩放，预测等方式以特定方式预测变更和准备数据，从而减轻或至少减少变更对输入变量的影响。</p>\n","categories":["概念漂移"],"tags":["综述"]},{"title":"从零开始实现一个分布式缓存","url":"/2022/04/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/","content":"<h2 id=\"前言\">前言</h2>\n<h3 id=\"分布式缓存\">分布式缓存</h3>\n<p>第一次请求时将一些耗时操作的结果暂存，以后遇到相同请求就直接返回暂存的数据。这是大部分人对于缓存的理解。比如我们访问一个网页，网页和引用的JS/CSS等静态文件，根据不同的策略会缓存在本地或者CDN服务器，下次访问就会觉得很快了</p>\n<span id=\"more\"></span>\n<p>缓存中最简单的莫过于存储在内存中的键值对缓存了。说到键值对，很容易想到的是字典(dict)类型，Go 语言中称之为 map。那直接创建一个 map，每次有新数据就往 map 中插入不就好了，这不就是键值对缓存么？这样做有什么问题呢？</p>\n<p>1）内存不够了怎么办？</p>\n<p>那就随机删掉几条数据好了。随机删掉好呢？还是按照时间顺序好呢？或者是有没有其他更好的淘汰策略呢？不同数据的访问频率是不一样的，优先删除访问频率低的数据是不是更好呢？数据的访问频率可能随着时间变化，那优先删除最近最少访问的数据可能是一个更好的选择。我们需要实现一个合理的淘汰策略。</p>\n<p>2）并发写入冲突了怎么办？</p>\n<p>对缓存的访问，一般不可能是串行的。map 是没有并发保护的，应对并发的场景，修改操作(包括新增，更新和删除)需要加锁。</p>\n<p>3）单机性能不够怎么办？</p>\n<p>单台计算机的资源是有限的，计算、存储等都是有限的。随着业务量和访问量的增加，单台机器很容易遇到瓶颈。如果利用多台计算机的资源，并行处理提高性能就要缓存应用能够支持分布式，这称为水平扩展(scale horizontally)。与水平扩展相对应的是垂直扩展(scale vertically)，即通过增加单个节点的计算、存储、带宽等，来提高系统的性能，硬件的成本和性能并非呈线性关系，大部分情况下，分布式系统是一个更优的选择。</p>\n<p>4）…</p>\n<h3 id=\"关于GeeCache\">关于GeeCache</h3>\n<p>设计一个分布式缓存系统，需要考虑资源控制、淘汰策略、并发、分布式节点通信等各个方面的问题。而且，针对不同的应用场景，还需要在不同的特性之间权衡，例如，是否需要支持缓存更新？还是假定缓存在淘汰之前是不允许改变的。不同的权衡对应着不同的实现。</p>\n<p>groupcache 是 Go 语言版的 memcached，目的是在某些特定场合替代 memcached。groupcache 的作者也是 memcached 的作者。无论是了解单机缓存还是分布式缓存，深入学习这个库的实现都是非常有意义的。</p>\n<p>GeeCache 基本上模仿了 groupcache 的实现，为了将代码量限制在 500 行左右（groupcache 约 3000 行），裁剪了部分功能。但总体实现上，还是与 groupcache 非常接近的。</p>\n<h2 id=\"LRU缓存淘汰策略\">LRU缓存淘汰策略</h2>\n<h3 id=\"LRU算法实现\">LRU算法实现</h3>\n<h4 id=\"核心数据结构\">核心数据结构</h4>\n<p><img src=\"https://i.imgur.com/zHzjrlO.png\" alt=\"picture 2\"></p>\n<p>这张图很好地表示了 LRU 算法最核心的 2 个数据结构</p>\n<ul>\n<li>绿色的是字典(map)，存储键和值的映射关系。这样根据某个键(key)查找对应的值(value)的复杂是O(1)，在字典中插入一条记录的复杂度也是O(1)。</li>\n<li>红色的是双向链表(double linked list)实现的队列。将所有的值放到双向链表中，这样，当访问到某个值时，将其移动到队尾的复杂度是O(1)，在队尾新增一条记录以及删除一条记录的复杂度均为O(1)。</li>\n</ul>\n<p>接下来我们创建一个包含字典和双向链表的结构体类型 Cache，方便实现后续的增删查改操作。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> lru</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;container/list&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Cache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tmaxBytes <span class=\"keyword\">int64</span></span><br><span class=\"line\">\tnbytes   <span class=\"keyword\">int64</span></span><br><span class=\"line\">\tll       *list.List</span><br><span class=\"line\">\tcache    <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*list.Element</span><br><span class=\"line\">\t<span class=\"comment\">// 可选的，当一个entry被清除的时候会执行</span></span><br><span class=\"line\">\tonEvicted <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key <span class=\"keyword\">string</span>, value Value)</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 双向列表节点的数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> entry <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tkey <span class=\"keyword\">string</span></span><br><span class=\"line\">\tvalue Value</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Value 接口类型，用Len来计算它携带了多少byte的数据</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Value <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tLen() <span class=\"keyword\">int</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>在这里我们直接使用 Go 语言标准库实现的双向链表list.List。</li>\n<li>字典的定义是 map[string]*list.Element，键是字符串，值是双向链表中对应节点的指针。</li>\n<li>maxBytes 是允许使用的最大内存，nbytes 是当前已使用的内存，OnEvicted 是某条记录被移除时的回调函数，可以为 nil。</li>\n<li>键值对 entry 是双向链表节点的数据类型，在链表中仍保存每个值对应的 key 的好处在于，淘汰队首节点时，需要用 key 从字典中删除对应的映射。</li>\n<li>为了通用性，我们允许值是实现了 Value 接口的任意类型，该接口只包含了一个方法 Len() int，用于返回值所占用的内存大小。</li>\n</ul>\n<p>为了方便实例化Cache，实现New函数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// New 构建一个Cache实例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(maxBytes <span class=\"keyword\">int64</span>, onEvicted <span class=\"keyword\">func</span>(<span class=\"keyword\">string</span>, Value)</span>) *<span class=\"title\">Cache</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;Cache&#123;</span><br><span class=\"line\">\t\tmaxBytes:  maxBytes,</span><br><span class=\"line\">\t\tll:        list.New(),</span><br><span class=\"line\">\t\tcache:     <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*list.Element),</span><br><span class=\"line\">\t\tonEvicted: onEvicted,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"查找功能\">查找功能</h4>\n<p>查找主要有 2 个步骤，第一步是从字典中找到对应的双向链表的节点，第二步，将该节点移动到队尾。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Get 查找某个键对应的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Cache)</span> <span class=\"title\">Get</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(value Value, ok <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ele, ok := c.cache[key]; ok &#123;</span><br><span class=\"line\">\t\tc.ll.MoveToFront(ele)</span><br><span class=\"line\">\t\tkv := ele.Value.(*entry)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kv.value, <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果键对应的链表节点存在，则将对应节点移动到队尾，并返回查找到的值。</li>\n<li>c.ll.MoveToFront(ele)，即将链表中的节点 ele 移动到队尾（双向链表作为队列，队首队尾是相对的，在这里约定 front 为队尾）</li>\n</ul>\n<h4 id=\"删除-2\">删除</h4>\n<p>这里的删除，实际上是缓存淘汰。即移除最近最少访问的节点（队首）</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// RemoveOldest 删除掉队尾的节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Cache)</span> <span class=\"title\">RemoveOldest</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">//获取应该移除的节点（即队尾节点）</span></span><br><span class=\"line\">\tele := c.ll.Back()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ele != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//首先从队列中移除节点</span></span><br><span class=\"line\">\t\tc.ll.Remove(ele)</span><br><span class=\"line\">\t\t<span class=\"comment\">//然后从获取该节点对应的entry</span></span><br><span class=\"line\">\t\tkv := ele.Value.(*entry)</span><br><span class=\"line\">\t\t<span class=\"comment\">//从cache中删除掉这个节点</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">delete</span>(c.cache, kv.key)</span><br><span class=\"line\">\t\tc.nbytes -= <span class=\"keyword\">int64</span>(<span class=\"built_in\">len</span>(kv.key)) + <span class=\"keyword\">int64</span>(kv.value.Len())</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> c.onEvicted != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\tc.onEvicted(kv.key, kv.value)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>c.ll.Back() 取到队首节点，从链表中删除。</li>\n<li>delete(c.cache, kv.key)，从字典中 c.cache 删除该节点的映射关系。</li>\n<li>更新当前所用的内存 c.nbytes。</li>\n<li>如果回调函数 OnEvicted 不为 nil，则调用回调函数。</li>\n</ul>\n<h4 id=\"增加-修改\">增加/修改</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Add 增加键值对映射</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Cache)</span> <span class=\"title\">Add</span><span class=\"params\">(key <span class=\"keyword\">string</span>, value Value)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果已经存在该键</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ele, ok := c.cache[key]; ok &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将键移到队首</span></span><br><span class=\"line\">\t\tc.ll.MoveToFront(ele)</span><br><span class=\"line\">\t\tkv := ele.Value.(*entry)</span><br><span class=\"line\">\t\t<span class=\"comment\">// 更新键对应的值</span></span><br><span class=\"line\">\t\tc.nbytes += <span class=\"keyword\">int64</span>(value.Len()) - <span class=\"keyword\">int64</span>(kv.value.Len())</span><br><span class=\"line\">\t\tkv.value=value</span><br><span class=\"line\">\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果该键不存在，需要在list和cache中都增加一个新的键值对</span></span><br><span class=\"line\">\t\tele:=c.ll.PushFront(&amp;entry&#123;key: key,value: value&#125;)</span><br><span class=\"line\">\t\tc.cache[key]=ele</span><br><span class=\"line\">\t\tc.nbytes+=<span class=\"keyword\">int64</span>(<span class=\"built_in\">len</span>(key))+<span class=\"keyword\">int64</span>(value.Len())</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> c.maxBytes!=<span class=\"number\">0</span> &amp;&amp; c.maxBytes&lt;c.nbytes&#123;</span><br><span class=\"line\">\t\tc.RemoveOldest()</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，为了方便测试，我们实现 Len() 用来获取添加了多少条数据。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Len the number of cache entries</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *Cache)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.ll.Len()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试\">测试</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> lru</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;reflect&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> String <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(d String)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(d)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCache_Get</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tlru := New(<span class=\"keyword\">int64</span>(<span class=\"number\">0</span>), <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\tlru.Add(<span class=\"string\">&quot;weirdo&quot;</span>, String(<span class=\"string\">&quot;1234&quot;</span>))</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v, ok := lru.Get(<span class=\"string\">&quot;weirdo&quot;</span>); !ok || <span class=\"keyword\">string</span>(v.(String)) != <span class=\"string\">&quot;1234&quot;</span> &#123;</span><br><span class=\"line\">\t\tt.Fatalf(<span class=\"string\">&quot;cache hit weirdo=1234 failed&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, ok := lru.Get(<span class=\"string\">&quot;peach&quot;</span>); ok &#123;</span><br><span class=\"line\">\t\tt.Fatalf(<span class=\"string\">&quot;cache miss key2 failed&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestCache_RemoveOldest</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tk1, k2, k3 := <span class=\"string\">&quot;weirdo&quot;</span>, <span class=\"string\">&quot;peach&quot;</span>, <span class=\"string\">&quot;bye&quot;</span></span><br><span class=\"line\">\tv1, v2, v3 := <span class=\"string\">&quot;23&quot;</span>, <span class=\"string\">&quot;22&quot;</span>, <span class=\"string\">&quot;0&quot;</span></span><br><span class=\"line\">\t<span class=\"built_in\">cap</span> := <span class=\"built_in\">len</span>(k1 + k2 + v1 + v2)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlru := New(<span class=\"keyword\">int64</span>(<span class=\"built_in\">cap</span>), <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\tlru.Add(k1, String(v1))</span><br><span class=\"line\">\tlru.Add(k2, String(v2))</span><br><span class=\"line\">\tlru.Add(k3, String(v3))</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, ok := lru.Get(<span class=\"string\">&quot;weirdo&quot;</span>); ok || lru.Len() != <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\tt.Fatalf(<span class=\"string\">&quot;Removeoldest weirdo failed&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestOnEvicted</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tkeys := <span class=\"built_in\">make</span>([]<span class=\"keyword\">string</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">\tcallback := <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key <span class=\"keyword\">string</span>, value Value)</span></span> &#123;</span><br><span class=\"line\">\t\tkeys = <span class=\"built_in\">append</span>(keys, key)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlru := New(<span class=\"keyword\">int64</span>(<span class=\"number\">10</span>), callback)</span><br><span class=\"line\">\tlru.Add(<span class=\"string\">&quot;key1&quot;</span>, String(<span class=\"string\">&quot;123456&quot;</span>))</span><br><span class=\"line\">\tlru.Add(<span class=\"string\">&quot;k2&quot;</span>, String(<span class=\"string\">&quot;k2&quot;</span>))</span><br><span class=\"line\">\tlru.Add(<span class=\"string\">&quot;k3&quot;</span>, String(<span class=\"string\">&quot;k3&quot;</span>))</span><br><span class=\"line\">\tlru.Add(<span class=\"string\">&quot;k4&quot;</span>, String(<span class=\"string\">&quot;k4&quot;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">\texpect := []<span class=\"keyword\">string</span>&#123;<span class=\"string\">&quot;key1&quot;</span>, <span class=\"string\">&quot;k2&quot;</span>&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !reflect.DeepEqual(expect, keys) &#123;</span><br><span class=\"line\">\t\tt.Fatalf(<span class=\"string\">&quot;call onEnvicted failed,expect keys equals to %s&quot;</span>, expect)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"单机并发缓存\">单机并发缓存</h2>\n<h3 id=\"sync-Mutex\">sync.Mutex</h3>\n<p>多个协程(goroutine)同时读写同一个变量，在并发度较高的情况下，会发生冲突。确保一次只有一个协程(goroutine)可以访问该变量以避免冲突，这称之为互斥，互斥锁可以解决这个问题。</p>\n<p>sync.Mutex 是 Go 语言标准库提供的一个互斥锁，当一个协程(goroutine)获得了这个锁的拥有权后，其它请求锁的协程(goroutine) 就会阻塞在 Lock() 方法的调用上，直到调用 Unlock() 锁被释放。</p>\n<p>接下来举一个简单的例子，假设有10个并发的协程打印了同一个数字100，为了避免重复打印，实现了printOnce(num int) 函数，使用集合 set 记录已打印过的数字，如果数字已打印过，则不再打印。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">bool</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printOnce</span><span class=\"params\">(num <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, exist := set[num]; !exist &#123;</span><br><span class=\"line\">\t\tfmt.Println(num)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tset[num] = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> printOnce(<span class=\"number\">100</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们运行 go run . 会发生什么情况呢？</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">go</span> run .</span><br><span class=\"line\"><span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n<p>有时候打印 2 次，有时候打印 4 次，有时候还会触发 panic，因为对同一个数据结构set的访问冲突了。接下来用互斥锁的Lock()和Unlock() 方法将冲突的部分包裹起来：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> m sync.Mutex</span><br><span class=\"line\"><span class=\"keyword\">var</span> set = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">bool</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printOnce</span><span class=\"params\">(num <span class=\"keyword\">int</span>)</span></span> &#123;</span><br><span class=\"line\">\tm.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> _, exist := set[num]; !exist &#123;</span><br><span class=\"line\">\t\tfmt.Println(num)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tset[num] = <span class=\"literal\">true</span></span><br><span class=\"line\">\tm.Unlock()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> printOnce(<span class=\"number\">100</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttime.Sleep(time.Second)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"支持并发读写\">支持并发读写</h3>\n<p>上一篇节 GeeCache 第一天 实现了 LRU 缓存淘汰策略。接下来我们使用 sync.Mutex 封装 LRU 的几个方法，使之支持并发的读写。在这之前，我们抽象了一个只读数据结构 ByteView 用来表示缓存值，是 GeeCache 主要的数据结构之一。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> geecache</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// A ByteView holds an immutable view of bytes.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ByteView <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tb []<span class=\"keyword\">byte</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Len returns the view&#x27;s length</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v ByteView)</span> <span class=\"title\">Len</span><span class=\"params\">()</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">len</span>(v.b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ByteSlice returns a copy of the data as a byte slice.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v ByteView)</span> <span class=\"title\">ByteSlice</span><span class=\"params\">()</span> []<span class=\"title\">byte</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> cloneBytes(v.b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// String returns the data as a string, making a copy if necessary.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(v ByteView)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">string</span>(v.b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">cloneBytes</span><span class=\"params\">(b []<span class=\"keyword\">byte</span>)</span> []<span class=\"title\">byte</span></span> &#123;</span><br><span class=\"line\">\tc := <span class=\"built_in\">make</span>([]<span class=\"keyword\">byte</span>, <span class=\"built_in\">len</span>(b))</span><br><span class=\"line\">\t<span class=\"built_in\">copy</span>(c, b)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ByteView 只有一个数据成员，b []byte，b 将会存储真实的缓存值。选择 byte 类型是为了能够支持任意的数据类型的存储，例如字符串、图片等。</li>\n<li>实现 Len() int 方法，我们在 lru.Cache 的实现中，要求被缓存对象必须实现 Value 接口，即 Len() int 方法，返回其所占的内存大小。</li>\n<li>b 是只读的，使用 ByteSlice() 方法返回一个拷贝，防止缓存值被外部程序修改。</li>\n</ul>\n<p>接下来就可以为 lru.Cache 添加并发特性了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> geecache</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;GeeCache/geecache/lru&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> cache <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tmu         sync.Mutex</span><br><span class=\"line\">\tlru        *lru.Cache</span><br><span class=\"line\">\tcacheBytes <span class=\"keyword\">int64</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *cache)</span> <span class=\"title\">add</span><span class=\"params\">(key <span class=\"keyword\">string</span>, value ByteView)</span></span> &#123;</span><br><span class=\"line\">\tc.mu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> c.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.lru == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tc.lru = lru.New(c.cacheBytes, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc.lru.Add(key, value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *cache)</span> <span class=\"title\">get</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(value ByteView, ok <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\tc.mu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> c.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c.lru == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v, ok := c.lru.Get(key); ok &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v.(ByteView), ok</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>cache.go 的实现非常简单，实例化 lru，封装 get 和 add 方法，并添加互斥锁 mu。</li>\n<li>在 add 方法中，判断了 c.lru 是否为 nil，如果等于 nil 再创建实例。这种方法称之为延迟初始化(Lazy Initialization)，一个对象的延迟初始化意味着该对象的创建将会延迟至第一次使用该对象时。主要用于提高性能，并减少程序内存要求。</li>\n</ul>\n<h3 id=\"主体结构Group\">主体结构Group</h3>\n<p>Group 是 GeeCache 最核心的数据结构，负责与用户的交互，并且控制缓存值存储和获取的流程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">   是</span><br><span class=\"line\">接收 key --&gt; 检查是否被缓存 -----&gt; 返回缓存值 ⑴</span><br><span class=\"line\">                |  否                         是</span><br><span class=\"line\">                |-----&gt; 是否应当从远程节点获取 -----&gt; 与远程节点交互 --&gt; 返回缓存值 ⑵</span><br><span class=\"line\">                            |  否</span><br><span class=\"line\">                            |-----&gt; 调用`回调函数`，获取值并添加到缓存 --&gt; 返回缓存值 ⑶</span><br></pre></td></tr></table></figure>\n<p>接下来我们将实现流程 ⑴ 和 ⑶，远程交互的部分后续再实现。</p>\n<h4 id=\"回调Getter\">回调Getter</h4>\n<p>我们思考一下，如果缓存不存在，应从数据源（文件，数据库等）获取数据并添加到缓存中。GeeCache 是否应该支持多种数据源的配置呢？不应该，一是数据源的种类太多，没办法一一实现；二是扩展性不好。如何从源头获取数据，应该是用户决定的事情，我们就把这件事交给用户好了。因此，我们设计了一个回调函数(callback)，在缓存不存在时，调用这个函数，得到源数据。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> geecache</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Getter <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tGet(key <span class=\"keyword\">string</span>) ([]<span class=\"keyword\">byte</span>, error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GetterFunc 用一个函数实现Getter</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> GetterFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f GetterFunc)</span> <span class=\"title\">Get</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> f(key)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义接口 Getter 和 回调函数 Get(key string)([]byte, error)，参数是 key，返回值是 []byte。<br>\n定义函数类型 GetterFunc，并实现 Getter 接口的 Get 方法。<br>\n函数类型实现某一个接口，称之为接口型函数，方便使用者在调用时既能够传入函数作为参数，也能够传入实现了该接口的结构体作为参数。</p>\n<h4 id=\"Group的定义\">Group的定义</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A Group is a cache namespace and associated data loaded spread over</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Group <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tname      <span class=\"keyword\">string</span></span><br><span class=\"line\">\tgetter    Getter</span><br><span class=\"line\">\tmainCache cache</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> (</span><br><span class=\"line\">\tmu     sync.RWMutex</span><br><span class=\"line\">\tgroups = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*Group)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewGroup create a new instance of Group</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewGroup</span><span class=\"params\">(name <span class=\"keyword\">string</span>, cacheBytes <span class=\"keyword\">int64</span>, getter Getter)</span> *<span class=\"title\">Group</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> getter == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;nil Getter&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tmu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> mu.Unlock()</span><br><span class=\"line\">\tg := &amp;Group&#123;</span><br><span class=\"line\">\t\tname:      name,</span><br><span class=\"line\">\t\tgetter:    getter,</span><br><span class=\"line\">\t\tmainCache: cache&#123;cacheBytes: cacheBytes&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tgroups[name] = g</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// GetGroup returns the named group previously created with NewGroup, or</span></span><br><span class=\"line\"><span class=\"comment\">// nil if there&#x27;s no such group.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">GetGroup</span><span class=\"params\">(name <span class=\"keyword\">string</span>)</span> *<span class=\"title\">Group</span></span> &#123;</span><br><span class=\"line\">\tmu.RLock()</span><br><span class=\"line\">\tg := groups[name]</span><br><span class=\"line\">\tmu.RUnlock()</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>一个 Group 可以认为是一个缓存的命名空间，每个 Group 拥有一个唯一的名称 name。比如可以创建三个 Group，缓存学生的成绩命名为 scores，缓存学生信息的命名为 info，缓存学生课程的命名为 courses。</li>\n<li>第二个属性是 getter Getter，即缓存未命中时获取源数据的回调(callback)。</li>\n<li>第三个属性是 mainCache cache，即一开始实现的并发缓存。</li>\n<li>构建函数 NewGroup 用来实例化 Group，并且将 group 存储在全局变量 groups 中。</li>\n<li>GetGroup 用来特定名称的 Group，这里使用了只读锁 RLock()，因为不涉及任何冲突变量的写操作。</li>\n</ul>\n<h4 id=\"Group的Get方法\">Group的Get方法</h4>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Get value for a key from cache</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">Get</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(ByteView, error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> key == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ByteView&#123;&#125;, fmt.Errorf(<span class=\"string\">&quot;key is required&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> v, ok := g.mainCache.get(key); ok &#123;</span><br><span class=\"line\">\t\tlog.Println(<span class=\"string\">&quot;[GeeCache] hit&quot;</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> v, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g.load(key)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">load</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(value ByteView, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g.getLocally(key)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">getLocally</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(ByteView, error)</span></span> &#123;</span><br><span class=\"line\">\tbytes, err := g.getter.Get(key)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ByteView&#123;&#125;, err</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvalue := ByteView&#123;b: cloneBytes(bytes)&#125;</span><br><span class=\"line\">\tg.populateCache(key, value)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> value, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">populateCache</span><span class=\"params\">(key <span class=\"keyword\">string</span>, value ByteView)</span></span> &#123;</span><br><span class=\"line\">\tg.mainCache.add(key, value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Get 方法实现了上述所说的流程 ⑴ 和 ⑶。</li>\n<li>流程 ⑴ ：从 mainCache 中查找缓存，如果存在则返回缓存值。</li>\n<li>流程 ⑶ ：缓存不存在，则调用 load 方法，load 调用 getLocally（分布式场景下会调用 getFromPeer 从其他节点获取），getLocally 调用用户回调函数 g.getter.Get() 获取源数据，并且将源数据添加到缓存 mainCache 中（通过 populateCache 方法）</li>\n</ul>\n<h3 id=\"测试-2\">测试</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> db = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>&#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;weirdo&quot;</span>: <span class=\"string\">&quot;23&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;peach&quot;</span>:  <span class=\"string\">&quot;22&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;love&quot;</span>:   <span class=\"string\">&quot;21&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestGroup_Get</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tloadCounts := <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">int</span>, <span class=\"built_in\">len</span>(db))</span><br><span class=\"line\">\tgee := NewGroup(<span class=\"string\">&quot;source&quot;</span>, <span class=\"number\">2</span>&lt;&lt;<span class=\"number\">10</span>, GetterFunc(</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(<span class=\"string\">&quot;[SlowDB] search key&quot;</span>, key)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> v, ok := db[key]; ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> _, ok := loadCounts[key]; !ok &#123;</span><br><span class=\"line\">\t\t\t\t\tloadCounts[key] = <span class=\"number\">0</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tloadCounts[key] += <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> []<span class=\"keyword\">byte</span>(v), <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;%s not exist&quot;</span>, key)</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t))</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> db &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果取出来的值和db中的值不同</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> view, err := gee.Get(k); err != <span class=\"literal\">nil</span> || view.String() != v &#123;</span><br><span class=\"line\">\t\t\tt.Fatalf(<span class=\"string\">&quot;failed to get value of %s&quot;</span>, k)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//如果取到值的过程调用了多次回调函数，说明根本就没存在缓存里</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> _, err := gee.Get(k); err != <span class=\"literal\">nil</span> || loadCounts[k] &gt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">\t\t\tt.Fatalf(<span class=\"string\">&quot;cache %s miss&quot;</span>, k)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> view, err := gee.Get(<span class=\"string\">&quot;unknown&quot;</span>); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tt.Fatalf(<span class=\"string\">&quot;the value of unknow should be empty, but %s got&quot;</span>, view)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个测试用例中，我们主要测试了 2 种情况</p>\n<ul>\n<li>1）在缓存为空的情况下，能够通过回调函数获取到源数据。</li>\n<li>2）在缓存已经存在的情况下，是否直接从缓存中获取，为了实现这一点，使用 loadCounts 统计某个键调用回调函数的次数，如果次数大于1，则表示调用了多次回调函数，没有缓存。</li>\n</ul>\n<h2 id=\"HTTP服务端\">HTTP服务端</h2>\n<h3 id=\"GeeCache-HTTP服务端\">GeeCache HTTP服务端</h3>\n<p>分布式缓存需要实现节点间通信，建立基于 HTTP 的通信机制是比较常见和简单的做法。如果一个节点启动了 HTTP 服务，那么这个节点就可以被其他节点访问。今天我们就为单机节点搭建 HTTP Server。</p>\n<p>首先我们创建一个结构体 HTTPPool，作为承载节点间 HTTP 通信的核心数据结构（包括服务端和客户端，今天只实现服务端）。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> geecache</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> defaultBasePath = <span class=\"string\">&quot;/_geecache/&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> HTTPPool <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tself     <span class=\"keyword\">string</span> <span class=\"comment\">// 该节点的URL，比如&quot;https://example.net:8000&quot;</span></span><br><span class=\"line\">\tbasePath <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewHTTPPool</span><span class=\"params\">(self <span class=\"keyword\">string</span>)</span> *<span class=\"title\">HTTPPool</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;HTTPPool&#123;</span><br><span class=\"line\">\t\tself:     self,</span><br><span class=\"line\">\t\tbasePath: defaultBasePath,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>HTTPPool 只有 2 个参数，一个是 self，用来记录自己的地址，包括主机名/IP 和端口。</li>\n<li>另一个是 basePath，作为节点间通讯地址的前缀，默认是 /_geecache/，那么 <a href=\"http://example.com/_geecache/\">http://example.com/_geecache/</a> 开头的请求，就用于节点间的访问。因为一个主机上还可能承载其他的服务，加一段 Path 是一个好习惯。比如，大部分网站的 API 接口，一般以 /api 作为前缀。</li>\n</ul>\n<p>接下来，实现最为核心的 ServeHTTP 方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *HTTPPool)</span> <span class=\"title\">Log</span><span class=\"params\">(format <span class=\"keyword\">string</span>, v ...<span class=\"keyword\">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">&quot;[Server %s] %s&quot;</span>, p.self, fmt.Sprintf(format, v...))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *HTTPPool)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> !strings.HasPrefix(r.URL.Path, p.basePath) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;HTTPPool serving unexpected path:&quot;</span> + r.URL.Path)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tp.Log(<span class=\"string\">&quot;%s %s&quot;</span>, r.Method, r.URL.Path)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 服务器上的路径是/basepath/groupname/key</span></span><br><span class=\"line\">\tparts := strings.SplitN(r.URL.Path[<span class=\"built_in\">len</span>(p.basePath):], <span class=\"string\">&quot;/&quot;</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(parts) != <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">\t\thttp.Error(w, <span class=\"string\">&quot;bad request&quot;</span>, http.StatusBadRequest)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgroupName := parts[<span class=\"number\">0</span>]</span><br><span class=\"line\">\tkey := parts[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">\tgroup := GetGroup(groupName)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> group == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\thttp.Error(w, <span class=\"string\">&quot;no such group:&quot;</span>+groupName, http.StatusNotFound)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tview,err:=group.Get(key)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err!=<span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\thttp.Error(w,err.Error(),http.StatusInternalServerError)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tw.Header().Set(<span class=\"string\">&quot;Content-Type&quot;</span>,<span class=\"string\">&quot;application/octet-stream&quot;</span>)</span><br><span class=\"line\">\tw.Write(view.ByteSlice())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ServeHTTP 的实现逻辑是比较简单的，首先判断访问路径的前缀是否是 basePath，不是返回错误。</li>\n<li>我们约定访问路径格式为 /<basepath>/<groupname>/<key>，通过 groupname 得到 group 实例，再使用 group.Get(key) 获取缓存数据。</li>\n<li>最终使用 w.Write() 将缓存值作为 httpResponse 的 body 返回。</li>\n</ul>\n<h3 id=\"测试-3\">测试</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;geecache&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>&#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;Tom&quot;</span>:  <span class=\"string\">&quot;630&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;Jack&quot;</span>: <span class=\"string\">&quot;589&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;Sam&quot;</span>:  <span class=\"string\">&quot;567&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tgeecache.NewGroup(<span class=\"string\">&quot;scores&quot;</span>, <span class=\"number\">2</span>&lt;&lt;<span class=\"number\">10</span>, geecache.GetterFunc(</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(<span class=\"string\">&quot;[SlowDB] search key&quot;</span>, key)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> v, ok := db[key]; ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> []<span class=\"keyword\">byte</span>(v), <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;%s not exist&quot;</span>, key)</span><br><span class=\"line\">\t\t&#125;))</span><br><span class=\"line\"></span><br><span class=\"line\">\taddr := <span class=\"string\">&quot;localhost:9999&quot;</span></span><br><span class=\"line\">\tpeers := geecache.NewHTTPPool(addr)</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;geecache is running at&quot;</span>, addr)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(addr, peers))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>同样地，我们使用 map 模拟了数据源 db。</li>\n<li>创建一个名为 scores 的 Group，若缓存为空，回调函数会从 db 中获取数据并返回。</li>\n<li>使用 http.ListenAndServe 在 9999 端口启动了 HTTP 服务。</li>\n</ul>\n<h2 id=\"一致性哈希\">一致性哈希</h2>\n<h3 id=\"为什么使用一致性哈希\">为什么使用一致性哈希</h3>\n<h4 id=\"我该访问谁\">我该访问谁</h4>\n<p>对于分布式缓存来说，当一个节点接收到请求，如果该节点并没有存储缓存值，那么它面临的难题是，从谁那获取数据？自己，还是节点1, 2, 3, 4… 。假设包括自己在内一共有 10 个节点，当一个节点接收到请求时，随机选择一个节点，由该节点从数据源获取数据。</p>\n<p>假设第一次随机选取了节点 1 ，节点 1 从数据源获取到数据的同时缓存该数据；那第二次，只有 1/10 的可能性再次选择节点 1, 有 9/10 的概率选择了其他节点，如果选择了其他节点，就意味着需要再一次从数据源获取数据，一般来说，这个操作是很耗时的。这样做，一是缓存效率低，二是各个节点上存储着相同的数据，浪费了大量的存储空间。</p>\n<p>那有什么办法，对于给定的 key，每一次都选择同一个节点呢？使用 hash 算法也能够做到这一点。那把 key 的每一个字符的 ASCII 码加起来，再除以 10 取余数可以吗？当然可以，这可以认为是自定义的 hash 算法。</p>\n<h4 id=\"节点数量变化了怎么办\">节点数量变化了怎么办</h4>\n<p>简单求取 Hash 值解决了缓存性能的问题，但是没有考虑节点数量变化的场景。假设，移除了其中一台节点，只剩下 9 个，那么之前 hash(key) % 10 变成了 hash(key) % 9，也就意味着几乎缓存值对应的节点都发生了改变。即几乎所有的缓存值都失效了。节点在接收到对应的请求时，均需要重新去数据源获取数据，容易引起 缓存雪崩。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">缓存雪崩：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。常因为缓存服务器宕机，或缓存设置了相同的过期时间引起。</span><br></pre></td></tr></table></figure>\n<p>那如何解决这个问题呢？一致性哈希算法可以。</p>\n<h3 id=\"算法原理\">算法原理</h3>\n<h4 id=\"步骤\">步骤</h4>\n<p>一致性哈希算法将 key 映射到 2^32 的空间中，将这个数字首尾相连，形成一个环。</p>\n<ul>\n<li>计算节点/机器(通常使用节点的名称、编号和 IP 地址)的哈希值，放置在环上。</li>\n<li>计算 key 的哈希值，放置在环上，顺时针寻找到的第一个节点，就是应选取的节点/机器。</li>\n</ul>\n<p><img src=\"https://i.imgur.com/bwtzmdF.png\" alt=\"picture 1\"></p>\n<p>环上有 peer2，peer4，peer6 三个节点，key11，key2，key27 均映射到 peer2，key23 映射到 peer4。此时，如果新增节点/机器 peer8，假设它新增位置如图所示，那么只有 key27 从 peer2 调整到 peer8，其余的映射均没有发生改变。</p>\n<p>也就是说，一致性哈希算法，在新增/删除节点时，只需要重新定位该节点附近的一小部分数据，而不需要重新定位所有的节点，这就解决了上述的问题。</p>\n<h4 id=\"数据倾斜问题\">数据倾斜问题</h4>\n<p>如果服务器的节点过少，容易引起 key 的倾斜。例如上面例子中的 peer2，peer4，peer6 分布在环的上半部分，下半部分是空的。那么映射到环下半部分的 key 都会被分配给 peer2，key 过度向 peer2 倾斜，缓存节点间负载不均。</p>\n<p>为了解决这个问题，引入了虚拟节点的概念，一个真实节点对应多个虚拟节点。</p>\n<p>假设 1 个真实节点对应 3 个虚拟节点，那么 peer1 对应的虚拟节点是 peer1-1、 peer1-2、 peer1-3（通常以添加编号的方式实现），其余节点也以相同的方式操作。</p>\n<ul>\n<li>第一步，计算虚拟节点的 Hash 值，放置在环上。</li>\n<li>第二步，计算 key 的 Hash 值，在环上顺时针寻找到应选取的虚拟节点，例如是 peer2-1，那么就对应真实节点 peer2。</li>\n</ul>\n<p>虚拟节点扩充了节点的数量，解决了节点较少的情况下数据容易倾斜的问题。而且代价非常小，只需要增加一个字典(map)维护真实节点与虚拟节点的映射关系即可。</p>\n<h3 id=\"go语言实现\">go语言实现</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> consistenthash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;hash/crc32&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Hash <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(data []<span class=\"keyword\">byte</span>)</span> <span class=\"title\">uint32</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Map <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\thash     Hash</span><br><span class=\"line\">\t<span class=\"comment\">//虚拟节点的倍数</span></span><br><span class=\"line\">\treplicas <span class=\"keyword\">int</span></span><br><span class=\"line\">\tkeys     []<span class=\"keyword\">int</span></span><br><span class=\"line\">\thashMap  <span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">New</span><span class=\"params\">(replicas <span class=\"keyword\">int</span>,fn Hash)</span>*<span class=\"title\">Map</span></span>&#123;</span><br><span class=\"line\">\tm:=&amp;Map&#123;</span><br><span class=\"line\">\t\treplicas: replicas,</span><br><span class=\"line\">\t\thash: fn,</span><br><span class=\"line\">\t\thashMap: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">string</span>),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> m.hash==<span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\tm.hash=crc32.ChecksumIEEE</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> m</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>定义了函数类型 Hash，采取依赖注入的方式，允许用于替换成自定义的 Hash 函数，也方便测试时替换，默认为 crc32.ChecksumIEEE 算法。</li>\n<li>Map 是一致性哈希算法的主数据结构，包含 4 个成员变量：Hash 函数 hash；虚拟节点倍数 replicas；哈希环 keys；虚拟节点与真实节点的映射表 hashMap，键是虚拟节点的哈希值，值是真实节点的名称。</li>\n<li>构造函数 New() 允许自定义虚拟节点倍数和 Hash 函数。</li>\n</ul>\n<p>接下来，实现添加真实节点/机器的 Add() 方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Add 向hash表中添加几个key</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Map)</span> <span class=\"title\">Add</span><span class=\"params\">(keys ...<span class=\"keyword\">string</span>)</span></span>  &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _,key :=<span class=\"keyword\">range</span> keys&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i:=<span class=\"number\">0</span>;i&lt;m.replicas;i++&#123;</span><br><span class=\"line\">\t\t\tkeyHashed:=<span class=\"keyword\">int</span>(m.hash([]<span class=\"keyword\">byte</span>(strconv.Itoa(i)+key)))</span><br><span class=\"line\">\t\t\tm.keys=<span class=\"built_in\">append</span>(m.keys,keyHashed)</span><br><span class=\"line\">\t\t\tm.hashMap[keyHashed]=key</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tsort.Ints(m.keys)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Add 函数允许传入 0 或 多个真实节点的名称。</li>\n<li>对每一个真实节点 key，对应创建 m.replicas 个虚拟节点，虚拟节点的名称是：strconv.Itoa(i) + key，即通过添加编号的方式区分不同虚拟节点。</li>\n<li>使用 m.hash() 计算虚拟节点的哈希值，使用 append(m.keys, hash) 添加到环上。</li>\n<li>在 hashMap 中增加虚拟节点和真实节点的映射关系。</li>\n<li>最后一步，环上的哈希值排序。</li>\n</ul>\n<p>最后一步，实现选择节点的 Get() 方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(m *Map)</span> <span class=\"title\">Get</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(m.keys)==<span class=\"number\">0</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tkeyHashed:=<span class=\"keyword\">int</span>(m.hash([]<span class=\"keyword\">byte</span>(key)))</span><br><span class=\"line\">\t<span class=\"comment\">//采用二分搜索</span></span><br><span class=\"line\">\tidx:=sort.Search(<span class=\"built_in\">len</span>(m.keys), <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(i <span class=\"keyword\">int</span>)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> m.keys[i]&gt;=keyHashed</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> m.hashMap[m.keys[idx%<span class=\"built_in\">len</span>(m.keys)]]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>选择节点就非常简单了，第一步，计算 key 的哈希值。</li>\n<li>第二步，顺时针找到第一个匹配的虚拟节点的下标 idx，从 m.keys 中获取到对应的哈希值。如果 idx == len(m.keys)，说明应选择 m.keys[0]，因为 m.keys 是一个环状结构，所以用取余数的方式来处理这种情况。</li>\n<li>第三步，通过 hashMap 映射得到真实的节点。<br>\n至此，整个一致性哈希算法就实现完成了。</li>\n</ul>\n<h3 id=\"测试-4\">测试</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> consistenthash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;strconv&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestHashing</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\thash := New(<span class=\"number\">3</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key []<span class=\"keyword\">byte</span>)</span> <span class=\"title\">uint32</span></span> &#123;</span><br><span class=\"line\">\t\ti, _ := strconv.Atoi(<span class=\"keyword\">string</span>(key))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">uint32</span>(i)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//根据上面的hash的定义，下面增加的节点会产生如下的键：1，3，6，11，13，16，21，23，26</span></span><br><span class=\"line\">\thash.Add(<span class=\"string\">&quot;6&quot;</span>, <span class=\"string\">&quot;3&quot;</span>, <span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\ttestCases := <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;1&quot;</span>:  <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;21&quot;</span>: <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;23&quot;</span>: <span class=\"string\">&quot;3&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;27&quot;</span>: <span class=\"string\">&quot;1&quot;</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> testCases &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> hash.Get(k) != v &#123;</span><br><span class=\"line\">\t\t\tt.Errorf(<span class=\"string\">&quot;Asking for %s,should have yield %s&quot;</span>, k, v)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\thash.Add(<span class=\"string\">&quot;8&quot;</span>)</span><br><span class=\"line\">\t<span class=\"comment\">//27应该要映射到8了</span></span><br><span class=\"line\">\ttestCases[<span class=\"string\">&quot;27&quot;</span>] = <span class=\"string\">&quot;8&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k, v := <span class=\"keyword\">range</span> testCases &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> hash.Get(k) != v &#123;</span><br><span class=\"line\">\t\t\tt.Errorf(<span class=\"string\">&quot;Asking for %s, should have yielded %s&quot;</span>, k, v)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要进行测试，那么我们需要明确地知道每一个传入的 key 的哈希值，那使用默认的 crc32.ChecksumIEEE 算法显然达不到目的。所以在这里使用了自定义的 Hash 算法。自定义的 Hash 算法只处理数字，传入字符串表示的数字，返回对应的数字即可。</p>\n<ul>\n<li>一开始，有 2/4/6 三个真实节点，对应的虚拟节点的哈希值是 02/12/22、04/14/24、06/16/26。</li>\n<li>那么用例 2/11/23/27 选择的虚拟节点分别是 02/12/24/02，也就是真实节点 2/2/4/2。</li>\n<li>添加一个真实节点 8，对应虚拟节点的哈希值是 08/18/28，此时，用例 27 对应的虚拟节点从 02 变更为 28，即真实节点 8。</li>\n</ul>\n<h2 id=\"分布式节点\">分布式节点</h2>\n<h3 id=\"流程回顾\">流程回顾</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  是</span><br><span class=\"line\">接收 key --&gt; 检查是否被缓存 -----&gt; 返回缓存值 ⑴</span><br><span class=\"line\">                |  否                         是</span><br><span class=\"line\">                |-----&gt; 是否应当从远程节点获取 -----&gt; 与远程节点交互 --&gt; 返回缓存值 ⑵</span><br><span class=\"line\">                            |  否</span><br><span class=\"line\">                            |-----&gt; 调用`回调函数`，获取值并添加到缓存 --&gt; 返回缓存值 ⑶</span><br></pre></td></tr></table></figure>\n<p>我们在之前描述了 geecache 的流程。在这之前已经实现了流程 ⑴ 和 ⑶，今天实现流程 ⑵，从远程节点获取缓存值。</p>\n<p>我们进一步细化流程 ⑵：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">使用一致性哈希选择节点        是                                    是</span><br><span class=\"line\">    |-----&gt; 是否是远程节点 -----&gt; HTTP 客户端访问远程节点 --&gt; 成功？-----&gt; 服务端返回返回值</span><br><span class=\"line\">                    |  否                                    ↓  否</span><br><span class=\"line\">                    |----------------------------&gt; 回退到本地节点处理。</span><br></pre></td></tr></table></figure>\n<h3 id=\"抽象PeerPicker\">抽象PeerPicker</h3>\n<p>在这里，抽象出 2 个接口，PeerPicker 的 PickPeer() 方法用于根据传入的 key 选择相应节点 PeerGetter。<br>\n接口 PeerGetter 的 Get() 方法用于从对应 group 查找缓存值。PeerGetter 就对应于上述流程中的 HTTP 客户端。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> geecache</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PeerPicker is the interface that must be implemented to locate</span></span><br><span class=\"line\"><span class=\"comment\">// the peer that owns a specific key.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PeerPicker <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tPickPeer(key <span class=\"keyword\">string</span>) (peer PeerGetter, ok <span class=\"keyword\">bool</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PeerGetter is the interface that must be implemented by a peer.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> PeerGetter <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tGet(group <span class=\"keyword\">string</span>, key <span class=\"keyword\">string</span>) ([]<span class=\"keyword\">byte</span>, error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"节点选择和HTTP客户端\">节点选择和HTTP客户端</h3>\n<p>首先创建具体的 HTTP 客户端类 httpGetter，实现 PeerGetter 接口。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> httpGetter <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tbaseURL <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h *httpGetter)</span> <span class=\"title\">Get</span><span class=\"params\">(group <span class=\"keyword\">string</span>, key <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tu := fmt.Sprintf(</span><br><span class=\"line\">\t\t<span class=\"string\">&quot;%v%v/%v&quot;</span>,</span><br><span class=\"line\">\t\th.baseURL,</span><br><span class=\"line\">\t\turl.QueryEscape(group),</span><br><span class=\"line\">\t\turl.QueryEscape(key),</span><br><span class=\"line\">\t)</span><br><span class=\"line\">\tres, err := http.Get(u)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> res.Body.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> res.StatusCode != http.StatusOK &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;server returned: %v&quot;</span>, res.Status)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbytes, err := ioutil.ReadAll(res.Body)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;reading response body: %v&quot;</span>, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> bytes, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> _ PeerGetter = (*httpGetter)(<span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>baseURL 表示将要访问的远程节点的地址，例如 <a href=\"http://example.com/_geecache/%E3%80%82\">http://example.com/_geecache/。</a></li>\n<li>使用 http.Get() 方式获取返回值，并转换为 []bytes 类型。</li>\n</ul>\n<p>第二步，为 HTTPPool 添加节点选择的功能。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> (</span><br><span class=\"line\">\tdefaultBasePath = <span class=\"string\">&quot;/_geecache/&quot;</span></span><br><span class=\"line\">\tdefaultReplicas = <span class=\"number\">50</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// HTTPPool implements PeerPicker for a pool of HTTP peers.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> HTTPPool <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// this peer&#x27;s base URL, e.g. &quot;https://example.net:8000&quot;</span></span><br><span class=\"line\">\tself        <span class=\"keyword\">string</span></span><br><span class=\"line\">\tbasePath    <span class=\"keyword\">string</span></span><br><span class=\"line\">\tmu          sync.Mutex <span class=\"comment\">// guards peers and httpGetters</span></span><br><span class=\"line\">\tpeers       *consistenthash.Map</span><br><span class=\"line\">\thttpGetters <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*httpGetter <span class=\"comment\">// keyed by e.g. &quot;http://10.0.0.2:8008&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>新增成员变量 peers，类型是一致性哈希算法的 Map，用来根据具体的 key 选择节点。</li>\n<li>新增成员变量 httpGetters，映射远程节点与对应的 httpGetter。每一个远程节点对应一个 httpGetter，因为 httpGetter 与远程节点的地址 baseURL 有关。</li>\n</ul>\n<p>第三步，实现 PeerPicker 接口。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Set 更新pool的peers列表信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *HTTPPool)</span> <span class=\"title\">Set</span><span class=\"params\">(peers ...<span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">\tp.mu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> p.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\tp.peers = consistenthash.New(defaultReplicas, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">\tp.peers.Add(peers...)</span><br><span class=\"line\">\tp.httpGetters = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*httpGetter, <span class=\"built_in\">len</span>(peers))</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, peer := <span class=\"keyword\">range</span> peers &#123;</span><br><span class=\"line\">\t\tp.httpGetters[peer] = &amp;httpGetter&#123;baseURL: peer + p.basePath&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PickPeer 找到对应的存储的节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(p *HTTPPool)</span> <span class=\"title\">PickPeer</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(PeerGetter, <span class=\"keyword\">bool</span>)</span></span> &#123;</span><br><span class=\"line\">\tp.mu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> p.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> peer := p.peers.Get(key); peer != <span class=\"string\">&quot;&quot;</span> &amp;&amp; peer != p.self &#123;</span><br><span class=\"line\">\t\tp.Log(<span class=\"string\">&quot;Pick peer %s&quot;</span>, peer)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p.httpGetters[peer], <span class=\"literal\">true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>,<span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Set() 方法实例化了一致性哈希算法，并且添加了传入的节点。</li>\n<li>并为每一个节点创建了一个 HTTP 客户端 httpGetter。</li>\n<li>PickerPeer() 包装了一致性哈希算法的 Get() 方法，根据具体的 key，选择节点，返回节点对应的 HTTP 客户端。<br>\n至此，HTTPPool 既具备了提供 HTTP 服务的能力，也具备了根据具体的 key，创建 HTTP 客户端从远程节点获取缓存值的能力。</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A Group is a cache namespace and associated data loaded spread over</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Group <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tname      <span class=\"keyword\">string</span></span><br><span class=\"line\">\tgetter    Getter</span><br><span class=\"line\">\tmainCache cache</span><br><span class=\"line\">\tpeers     PeerPicker</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RegisterPeers registers a PeerPicker for choosing remote peer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">RegisterPeers</span><span class=\"params\">(peers PeerPicker)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> g.peers != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">panic</span>(<span class=\"string\">&quot;RegisterPeerPicker called more than once&quot;</span>)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tg.peers = peers</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">load</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(value ByteView, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> g.peers != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> peer, ok := g.peers.PickPeer(key); ok &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> value, err = g.getFromPeer(peer, key); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> value, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tlog.Println(<span class=\"string\">&quot;[GeeCache] Failed to get from peer&quot;</span>, err)</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g.getLocally(key)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">getFromPeer</span><span class=\"params\">(peer PeerGetter, key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(ByteView, error)</span></span> &#123;</span><br><span class=\"line\">\tbytes, err := peer.Get(g.name, key)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ByteView&#123;&#125;, err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ByteView&#123;b: bytes&#125;, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>新增 RegisterPeers() 方法，将 实现了 PeerPicker 接口的 HTTPPool 注入到 Group 中。</li>\n<li>新增 getFromPeer() 方法，使用实现了 PeerGetter 接口的 httpGetter 从访问远程节点，获取缓存值。</li>\n<li>修改 load 方法，使用 PickPeer() 方法选择节点，若非本机节点，则调用 getFromPeer() 从远程获取。若是本机节点或失败，则回退到 getLocally()。</li>\n</ul>\n<h3 id=\"main函数测试\">main函数测试</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> db = <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">string</span>&#123;</span><br><span class=\"line\">\t<span class=\"string\">&quot;Tom&quot;</span>:  <span class=\"string\">&quot;630&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;Jack&quot;</span>: <span class=\"string\">&quot;589&quot;</span>,</span><br><span class=\"line\">\t<span class=\"string\">&quot;Sam&quot;</span>:  <span class=\"string\">&quot;567&quot;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createGroup</span><span class=\"params\">()</span> *<span class=\"title\">geecache</span>.<span class=\"title\">Group</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> geecache.NewGroup(<span class=\"string\">&quot;scores&quot;</span>, <span class=\"number\">2</span>&lt;&lt;<span class=\"number\">10</span>, geecache.GetterFunc(</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\t\t\tlog.Println(<span class=\"string\">&quot;[SlowDB] search key&quot;</span>, key)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> v, ok := db[key]; ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> []<span class=\"keyword\">byte</span>(v), <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;%s not exist&quot;</span>, key)</span><br><span class=\"line\">\t\t&#125;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startCacheServer</span><span class=\"params\">(addr <span class=\"keyword\">string</span>, addrs []<span class=\"keyword\">string</span>, gee *geecache.Group)</span></span> &#123;</span><br><span class=\"line\">\tpeers := geecache.NewHTTPPool(addr)</span><br><span class=\"line\">\tpeers.Set(addrs...)</span><br><span class=\"line\">\tgee.RegisterPeers(peers)</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;geecache is running at&quot;</span>, addr)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(addr[<span class=\"number\">7</span>:], peers))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startAPIServer</span><span class=\"params\">(apiAddr <span class=\"keyword\">string</span>, gee *geecache.Group)</span></span> &#123;</span><br><span class=\"line\">\thttp.Handle(<span class=\"string\">&quot;/api&quot;</span>, http.HandlerFunc(</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t\t\tkey := r.URL.Query().Get(<span class=\"string\">&quot;key&quot;</span>)</span><br><span class=\"line\">\t\t\tview, err := gee.Get(key)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tw.Header().Set(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/octet-stream&quot;</span>)</span><br><span class=\"line\">\t\t\tw.Write(view.ByteSlice())</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;))</span><br><span class=\"line\">\tlog.Println(<span class=\"string\">&quot;fontend server is running at&quot;</span>, apiAddr)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(apiAddr[<span class=\"number\">7</span>:], <span class=\"literal\">nil</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> port <span class=\"keyword\">int</span></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> api <span class=\"keyword\">bool</span></span><br><span class=\"line\">\tflag.IntVar(&amp;port, <span class=\"string\">&quot;port&quot;</span>, <span class=\"number\">8001</span>, <span class=\"string\">&quot;Geecache server port&quot;</span>)</span><br><span class=\"line\">\tflag.BoolVar(&amp;api, <span class=\"string\">&quot;api&quot;</span>, <span class=\"literal\">false</span>, <span class=\"string\">&quot;Start a api server?&quot;</span>)</span><br><span class=\"line\">\tflag.Parse()</span><br><span class=\"line\"></span><br><span class=\"line\">\tapiAddr := <span class=\"string\">&quot;http://localhost:9999&quot;</span></span><br><span class=\"line\">\taddrMap := <span class=\"keyword\">map</span>[<span class=\"keyword\">int</span>]<span class=\"keyword\">string</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"number\">8001</span>: <span class=\"string\">&quot;http://localhost:8001&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">8002</span>: <span class=\"string\">&quot;http://localhost:8002&quot;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">8003</span>: <span class=\"string\">&quot;http://localhost:8003&quot;</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">var</span> addrs []<span class=\"keyword\">string</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> _, v := <span class=\"keyword\">range</span> addrMap &#123;</span><br><span class=\"line\">\t\taddrs = <span class=\"built_in\">append</span>(addrs, v)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tgee := createGroup()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> api &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">go</span> startAPIServer(apiAddr, gee)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstartCacheServer(addrMap[port], []<span class=\"keyword\">string</span>(addrs), gee)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>main 函数的代码比较多，但是逻辑是非常简单的。</p>\n<ul>\n<li>startCacheServer() 用来启动缓存服务器：创建 HTTPPool，添加节点信息，注册到 gee 中，启动 HTTP 服务（共3个端口，8001/8002/8003），用户不感知。</li>\n<li>startAPIServer() 用来启动一个 API 服务（端口 9999），与用户进行交互，用户感知。</li>\n<li>main() 函数需要命令行传入 port 和 api 2 个参数，用来在指定端口启动 HTTP 服务。</li>\n</ul>\n<h2 id=\"防止缓存击穿\">防止缓存击穿</h2>\n<h3 id=\"缓存雪崩、缓存击穿和缓存穿透\">缓存雪崩、缓存击穿和缓存穿透</h3>\n<ul>\n<li>缓存雪崩：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。缓存雪崩通常因为缓存服务器宕机、缓存的 key 设置了相同的过期时间等引起。</li>\n<li>缓存击穿：一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到 DB ，造成瞬时DB请求量大、压力骤增。</li>\n<li>缓存穿透：查询一个不存在的数据，因为不存在则不会写到缓存中，所以每次都会去请求 DB，如果瞬间流量过大，穿透到 DB，导致宕机。</li>\n</ul>\n<h3 id=\"singleflight的实现\">singleflight的实现</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">之前的测试结果</span><br><span class=\"line\">2020/02/16 21:17:45 [Server http://localhost:8003] Pick peer http://localhost:8001</span><br><span class=\"line\">2020/02/16 21:17:45 [Server http://localhost:8003] Pick peer http://localhost:8001</span><br><span class=\"line\">2020/02/16 21:17:45 [Server http://localhost:8003] Pick peer http://localhost:8001</span><br></pre></td></tr></table></figure>\n<p>我们并发了 N 个请求 ?key=Tom，8003 节点向 8001 同时发起了 N 次请求。假设对数据库的访问没有做任何限制的，很可能向数据库也发起 N 次请求，容易导致缓存击穿和穿透。即使对数据库做了防护，HTTP 请求是非常耗费资源的操作，针对相同的 key，8003 节点向 8001 发起三次请求也是没有必要的。那这种情况下，我们如何做到只向远端节点发起一次请求呢？</p>\n<p>geecache 实现了一个名为 singleflight 的 package 来解决这个问题。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> singleflight</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> call <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\twg  sync.WaitGroup</span><br><span class=\"line\">\tval <span class=\"keyword\">interface</span>&#123;&#125;</span><br><span class=\"line\">\terr error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Group <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tmu sync.Mutex       <span class=\"comment\">// protects m</span></span><br><span class=\"line\">\tm  <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*call</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>call 代表正在进行中，或已经结束的请求。使用 sync.WaitGroup 锁避免重入。</li>\n<li>Group 是 singleflight 的主数据结构，管理不同 key 的请求(call)。</li>\n</ul>\n<p>实现Do方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">Do</span><span class=\"params\">(key <span class=\"keyword\">string</span>, fn <span class=\"keyword\">func</span>()</span> <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span>) <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class=\"line\">\tg.mu.Lock()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> g.m == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tg.m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*call)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class=\"line\">\t\tg.mu.Unlock()</span><br><span class=\"line\">\t\tc.wg.Wait()</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> c.val, c.err</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tc := <span class=\"built_in\">new</span>(call)</span><br><span class=\"line\">\tc.wg.Add(<span class=\"number\">1</span>)</span><br><span class=\"line\">\tg.m[key] = c</span><br><span class=\"line\">\tg.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\tc.val, c.err = fn()</span><br><span class=\"line\">\tc.wg.Done()</span><br><span class=\"line\"></span><br><span class=\"line\">\tg.mu.Lock()</span><br><span class=\"line\">\t<span class=\"built_in\">delete</span>(g.m, key)</span><br><span class=\"line\">\tg.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c.val, c.err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Do 方法，接收 2 个参数，第一个参数是 key，第二个参数是一个函数 fn。Do 的作用就是，针对相同的 key，无论 Do 被调用多少次，函数 fn 都只会被调用一次，等待 fn 调用结束了，返回返回值或错误。</p>\n<h3 id=\"singleflight的使用、\">singleflight的使用、</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Group <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tname      <span class=\"keyword\">string</span></span><br><span class=\"line\">\tgetter    Getter</span><br><span class=\"line\">\tmainCache cache</span><br><span class=\"line\">\tpeers     PeerPicker</span><br><span class=\"line\">\t<span class=\"comment\">// use singleflight.Group to make sure that</span></span><br><span class=\"line\">\t<span class=\"comment\">// each key is only fetched once</span></span><br><span class=\"line\">\tloader *singleflight.Group</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewGroup</span><span class=\"params\">(name <span class=\"keyword\">string</span>, cacheBytes <span class=\"keyword\">int64</span>, getter Getter)</span> *<span class=\"title\">Group</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">\tg := &amp;Group&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\tloader:    &amp;singleflight.Group&#123;&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> g</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(g *Group)</span> <span class=\"title\">load</span><span class=\"params\">(key <span class=\"keyword\">string</span>)</span> <span class=\"params\">(value ByteView, err error)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// each key is only fetched once (either locally or remotely)</span></span><br><span class=\"line\">\t<span class=\"comment\">// regardless of the number of concurrent callers.</span></span><br><span class=\"line\">\tviewi, err := g.loader.Do(key, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> g.peers != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> peer, ok := g.peers.PickPeer(key); ok &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> value, err = g.getFromPeer(peer, key); err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> value, <span class=\"literal\">nil</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tlog.Println(<span class=\"string\">&quot;[GeeCache] Failed to get from peer&quot;</span>, err)</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> g.getLocally(key)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> viewi.(ByteView), <span class=\"literal\">nil</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>修改 geecache.go 中的 Group，添加成员变量 loader，并更新构建函数 NewGroup。</li>\n<li>修改 load 函数，将原来的 load 的逻辑，使用 <a href=\"http://g.loader.Do\">g.loader.Do</a> 包裹起来即可，这样确保了并发场景下针对相同的 key，load 过程只会调用一次。</li>\n</ul>\n<h2 id=\"使用protobuf通信\">使用protobuf通信</h2>\n<h3 id=\"为什么使用protobuf\">为什么使用protobuf</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">protobuf 即 Protocol Buffers，Google 开发的一种数据描述语言，是一种轻便高效的结构化数据存储格式，与语言、平台无关，可扩展可序列化。protobuf 以二进制方式存储，占用空间小。</span><br></pre></td></tr></table></figure>\n<p>使用 protobuf 的目的非常简单，为了获得更高的性能。传输前使用 protobuf 编码，接收方再进行解码，可以显著地降低二进制传输的大小。另外一方面，protobuf 可非常适合传输结构化数据，便于通信字段的扩展。<a href=\"https://geektutu.com/post/quick-go-protobuf.html\">go protobuf简明教程</a></p>\n<p>使用 protobuf 一般分为以下 2 步：</p>\n<ul>\n<li>按照 protobuf 的语法，在 .proto 文件中定义数据结构，并使用 protoc 生成 Go 代码（.proto 文件是跨平台的，还可以生成 C、Java 等其他源码文件）。</li>\n<li>在项目代码中引用生成的 Go 代码。</li>\n</ul>\n<h3 id=\"使用protobuf通信-2\">使用protobuf通信</h3>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">&quot;proto3&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> geecachepb;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">Request</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> <span class=\"keyword\">group</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"built_in\">string</span> key = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">message</span> <span class=\"title\">Response</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">bytes</span> value = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">service</span> <span class=\"title\">GroupCache</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">rpc</span> Get(Request) <span class=\"keyword\">returns</span> (Response)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Request 包含 2 个字段， group 和 cache，这与我们之前定义的接口 /_geecache/<group>/<name> 所需的参数吻合。</li>\n<li>Response 包含 1 个字段，bytes，类型为 byte 数组，与之前吻合。</li>\n</ul>\n","categories":["go"],"tags":["分布式cache"]},{"title":"简单易懂地理解LSTM","url":"/2022/03/23/%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E5%9C%B0%E7%90%86%E8%A7%A3LSTM/","content":"<h2 id=\"lstm结构\">lstm结构</h2>\n<p><img src=\"https://i.imgur.com/YTwGUXM.png\" alt=\"picture 5\"></p>\n<p>相较于传统的RNN只有一个状态值传递，lstm传递了两个状态，其中c(cell state)变化地比较慢，而h(hidden state)则在不同节点下往往有很大的区别</p>\n<span id=\"more\"></span>\n<h2 id=\"深入lstm结构\">深入lstm结构</h2>\n<p>首先用lstm当前的输入和上层传递过来的$h^{t-1}$拼接训练得到四个状态</p>\n<p><img src=\"https://i.imgur.com/T581bEb.png\" alt=\"picture 6\"></p>\n<p>接下来介绍这四个状态在LSTM内部的使用</p>\n<p><img src=\"https://i.imgur.com/Vsx3k7N.png\" alt=\"picture 7\"></p>\n<p>lstm主要有三个阶段：</p>\n<ol>\n<li>忘记阶段。对上个节点传过来的输入做选择性忘记。即通过$z^f$作为忘记门控，来控制上一个状态的$c^{t-1}$</li>\n<li>选择记忆。将这个阶段的输入进行有选择性地记忆。选择门控信号由$z^i$控制。到这里将这两步的结果进行相加就可以得到传递给下一时间步的$c^t$</li>\n<li>输出阶段。通过$z^0$控制当前状态的输出应该是什么。</li>\n</ol>\n","categories":["DeepLearning"],"tags":["LSTM"]},{"title":"简单易懂地理解GRU","url":"/2022/03/23/%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E5%9C%B0%E7%90%86%E8%A7%A3GRU/","content":"<h2 id=\"GRU的输入输出结构\">GRU的输入输出结构</h2>\n<p>它的输入是当前时刻的输入$x^t$和上一时刻传递过来的隐状态$h^{t-1}$，通过对这两个数据的结合进行操作，会得到当前节点的输出$y^t$和传递给下一个节点的隐状态$h^t$</p>\n<span id=\"more\"></span>\n<p><img src=\"https://i.imgur.com/Lb0dS15.png\" alt=\"picture 1\"></p>\n<h2 id=\"GRU的内部结构\">GRU的内部结构</h2>\n<p>其中有两个门控状态。r控制重置门，z控制更新门，具体计算过程如下图所示</p>\n<p><img src=\"https://i.imgur.com/25vkcJn.png\" alt=\"picture 2\"></p>\n<p>得到门控信号之后，首先使用重置门的数据来得到重置后的$h^{t-1’}=h^{t-1}\\odot r$，再将$h^{t-1’}$与输入进行拼接得到下图</p>\n<p><img src=\"https://i.imgur.com/ulcM3RC.png\" alt=\"picture 3\"></p>\n<p>这里的$h’$主要包含了当前输入的$x^t$数据，相当于记忆了当前时刻的状态。</p>\n<p>最后一步是进行更新，更新表达式如下</p>\n<p><img src=\"https://i.imgur.com/U9JlMYQ.png\" alt=\"picture 4\"></p>\n","categories":["DeepLearning"],"tags":["GRU"]},{"title":"节点表示如何生成图表示","url":"/2022/03/19/%E8%8A%82%E7%82%B9%E8%A1%A8%E7%A4%BA%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%9B%BE%E8%A1%A8%E7%A4%BA/","content":"<h2 id=\"图读出操作\">图读出操作</h2>\n<p>顾名思义，图读出操作就是用来生成图表示的。它的核心要义在于：操作本身要对节点顺序不敏感。</p>\n<p>为什么是这样呢？因为在欧氏空间中如果一张图片旋转了，那么他就是新的图片了；但在非欧氏空间中，如果一个图旋转一下，比如重新编号，形成的图仍然是原图。这就是典型的图重构问题。下面两个图是等价的</p>\n<p><img src=\"https://i.imgur.com/1lrMMsW.png\" alt=\"picture 35\"></p>\n<p>为了使得同构图能够保持一致，图读出的操作就需要对节点顺序不敏感。数学上能表达这种操作的函数称为对称函数。</p>\n<p>接下来介绍两中方法实现图读出操作：<strong>基于统计的方法</strong>和<strong>基于学习的方法</strong></p>\n<span id=\"more\"></span>\n<h2 id=\"基于统计的方法\">基于统计的方法</h2>\n<p>有学者提出用类似直方图的方法对每维数据分布进行建模。假设我们有100个介于[-3,1]之间的数字，如果我们直接将他们求和，就看不出他们的分布情况；而如果我们将[-3,1]分成4个子区域，分开统计各个区域的和就能略微发现一些原始数据分布特征，如下图</p>\n<p><img src=\"https://i.imgur.com/YT5Y8pE.png\" alt=\"picture 36\"></p>\n<p>如果要实现上面这个做法，应该怎么做呢？很简单，举个例子，给定3个数据点，他们的特征向量（2D）分别是[-2,1],[-1,2]和[-1,1]。如果直接求和，全局的特征向量是[-2±1±1,1+2+1]即[-4,4]。如果采取上述直方图的方式，则可能会得到一个这样的全局特征向量<code>[-2, -1 + -1, 1 + 1, 2]</code>（第1,2维代表从原先的第1维统计的直方图,对应的区域为<code>[-2,1),[1,2)</code>,第3,4维的含义类似）。但在实践中并没有使用这种方法，而是采用高斯函数来实现名为模糊直方图的操作。</p>\n<p><img src=\"https://i.imgur.com/T5HHZvP.png\" alt=\"picture 37\"></p>\n<p>模糊直方图的原理也很简单：预先定义几个特征值区域的边界为各个高斯分布的均匀值，并且预设好方差。对于任一特征值，根据其与各个高斯分布交点的纵坐标作为其落入该区域的数值，然后将所有数值归一化。比如，图上的[1.8]与三个高斯分布交点分别在0，0.3，0.9处，归一化一下可以用一个三维向量<code>[0.0,0.25,0.75]</code>表示。</p>\n<h2 id=\"基于学习的方法\">基于学习的方法</h2>\n<p>基于统计的方法的坏处在于它没办法参数化，间接地难以表示节点到图向量的“复杂过程”。基于学习的方法就是希望用神经网络来拟合这个过程。</p>\n<h3 id=\"采样加全连接\">采样加全连接</h3>\n<p>最简单的做法，取固定数量节点，通过全连接层得到图表示。这里不论是随机采样，还是根据某些规则采样，都需要得到确定数量的节点，不够就填充。公式也很简单（$H^L指的是将采样到的节点表示拼在一起）：</p>\n<p><img src=\"https://i.imgur.com/4wwS4yv.png\" alt=\"picture 38\"></p>\n<p>这种方法很难适用于规模差距很大的图。比如训练时见过的图只有几百个节点，但测试的图可能有上千个节点，很难泛化。</p>\n<h3 id=\"全局节点\">全局节点</h3>\n<p>这种做法动机很简单，考虑到图同构问题和基于统计的方法，从节点的表示生成最终图表示主要有两个难点：</p>\n<ol>\n<li>难以找到一个合适的根节点（图的根节点一般都是根据领域知识确定的，比如前面第一篇中讲到的化合物分类）</li>\n<li>如果直接用基于统计的方法对各个节点一视同仁，无法区别对待（比如某些重要的节点信息更多，就应该表达得更多）</li>\n</ol>\n<p>那直接引入一个全局节点代表这张图的根节点，把他跟图中的每个节点通过一种特殊的边连接，最终拿这个节点的表示作为整个图的表示，岂不是很棒？</p>\n<h3 id=\"可微池化\">可微池化</h3>\n<p>上面的两中方法都比较简单，不会层次化地去获得图表示。因此又有研究者提出了一种层次化的图的表示，而这依赖于他们提出的可微池化技术。简单来说就是，他不希望各个节点一次性得到图的表示，而是希望通过一个逐渐压缩信息的过程，来得到最终图的表示。如下图所示：</p>\n<p><img src=\"https://i.imgur.com/QCFr9Db.png\" alt=\"picture 39\"></p>\n<p>相比于一般先通过GCN获取所有节点表示，再通过方法汇总得到图的最终表示的方法，DiffPool同时完成了两个任务：<strong>节点聚类</strong>和<strong>节点表示</strong>。</p>\n<p>这两个任务是由两个不共享参数的GCN模块分别完成的，下文用SC和NR分别表示这两个模块。NR模块和传统GCN一样，输入是各个节点隐藏状态，通过图上的传播，输出是传播后各个节点的i傲视。SC模块则不同，虽然输入也是各节点的隐藏表示，但输出是各节点属于不同聚类簇的概率（这里每一层聚类簇的数目是预先定义的）。上图中最左侧每个节点右上方的表格就代表这个。举个例子，假设本层子图有6个节点，将各个节点输出的簇分类概率堆叠在一起，就可以得到矩阵$S^l$，如下图所示（三个颜色代表三个聚类簇。实际中，聚类矩阵不是离散变量，而是连续变量）</p>\n<p><img src=\"https://i.imgur.com/eDLJ1Nn.png\" alt=\"picture 40\"></p>\n<p>用$A_l$表示第l层子图节点的邻接关系，$A^0$即是图的邻接矩阵，$N_l$表示第l层节点的个数，$H^l$表示第l层子图各个节点表示堆叠而成的隐状态矩阵，DiffPool通过如下公式得到新子图中各个节点的表示：</p>\n<p><img src=\"https://i.imgur.com/B53yvW6.png\" alt=\"picture 41\"></p>\n<p>除了表示各个节点的表示之外，还有一个很重要的事情是生成新子图$A^{l+1}$的邻接关系</p>\n<p><img src=\"https://i.imgur.com/dEP1ZEr.png\" alt=\"picture 42\"></p>\n<a href=\"/2022/03/19/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/\" title=\"图神经网络概述\">图神经网络概述</a>\n<a href=\"/2022/03/19/%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/\" title=\"图卷积神经网络概述\">图卷积神经网络概述</a>\n<a href=\"/2022/03/19/%E8%8A%82%E7%82%B9%E8%A1%A8%E7%A4%BA%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E5%9B%BE%E8%A1%A8%E7%A4%BA/\" title=\"节点表示如何生成图表示\">节点表示如何生成图表示</a>","categories":["图神经网络"],"tags":["GCN 综述"]},{"title":"Hellinger Distance Based Drift Detection for Nonstationary Environments","url":"/2022/04/14/Hellinger-Distance-Based-Drift-Detection-for-Nonstationary-Environments/","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>本文作者将改变决策边界的突然的数据分布变化定义为concept change，逐渐的数据分布的变化定义为概念漂移。但是如果在不需要仔细区分两者的情况下，使用概念漂移作为其统一名称，因为概念漂移更难检测一点。</p>\n<span id=\"more\"></span>\n\n<p>流式数据中有两种漂移检测方法：</p>\n<ul>\n<li>被动检测：每次获取到新数据的时候，学习器都假设漂移已经发生，然后根据现有的数据分布更新分类器，不管是否真的发生漂移。</li>\n<li>主动检测：持续显式地监视数据以检测是否发生漂移，只有发生漂移的时候，算法才会采取行动，比如用最近的数据更新分类器或者创建一个新的分类器来学习当前的数据。</li>\n</ul>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>HDDDM的总体特征：</p>\n<ul>\n<li>数据块：基于批的</li>\n<li>使用的信息：原始特征（不依赖于分类的准确率）</li>\n<li>检测漂移的模式：显式</li>\n<li>指定分类器还是不限分类器：不限分类器</li>\n</ul>\n<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><p>该检测方法的动机是检测在一系列的批数据中是否发生了漂移。选择Hellinger距离作为衡量依据是因为没有对数据的分布进行假设并且Hellinger距离使该方法能够测量两个顺序时间戳上数据分布的变化。</p>\n<p>HDDDM使用当前数据分布和参考分布（就是最新的一些数据）之间的距离Hellinger距离。该距离和KL散度相似，都是f散度的一个实例，不同点在于Hellinger散度是对称度量。此外，H散度是一个有界距离度量：对于两个概率密度函数为P和Q的分布，H散度是 $\\delta_H(P,Q)\\in[0,\\sqrt{2}]$ 。如果 $\\delta_H(P,Q)&#x3D;0$ ，说明两个概率密度函数是完全相同的；如果 $\\delta_H(P,Q)&#x3D;\\sqrt{2}$ ，说明两个概率密度函数是完全不同的。</p>\n<p>举个例子说，考虑具有类中心以圆形模式移动的高斯的两类旋转混合，其中每一个分布都表示一个不同的类（下图所示）。类均值可以通过参数化方程给出 $\\mu_1^{(t)}&#x3D;[cos\\theta_t,sin\\theta_t]^T,\\mu_2^{(t)}&#x3D;-\\mu_1^(t),\\theta_t&#x3D;\\frac{2\\pi c}{N}t$ ，固定的类协方差矩阵为 $\\epsilon_1&#x3D;\\epsilon_2&#x3D;0.5*I$ ，其中c是圆的数量，t是时间戳（从0到N-1），I是一个2x2的单位矩阵。</p>\n<p><img src=\"https://i.imgur.com/I3YriW6.png\" alt=\"picture 2\">  </p>\n<p>Hellinger距离能够展示新数据集 $D_k$ 和基准数据集 $D_1$ 之间的相似度。下图给出了类1、类2和整个数据集上的散度的Hellinger距离。我们发现Hellinger距离随着 $\\theta$ 的变化而变得不同。并且当 $\\theta_1$ 和 $\\theta_k$ 相近的时候，H距离就很小（t&#x3D;0，200，400，600）。</p>\n<p><img src=\"https://i.imgur.com/TzQxK4a.png\" alt=\"picture 3\">  </p>\n<p>另外，如果控制不同时间的数据分布是相同的话，不同时间的数据H距离就会是一个很小的常数，但是不是0。这是因为类均值的一些不同和采样出来的随机性导致的。</p>\n<h3 id=\"假设\"><a href=\"#假设\" class=\"headerlink\" title=\"假设\"></a>假设</h3><p>该方法做出了三个假设：</p>\n<ul>\n<li>有标签的训练数据集是以批形式送入漂移检测算法的，H距离是在两个数据分布的直方图上计算的。如果只能一条一条地获取数据的话，可以积累数据来形成直方图以供计算。</li>\n<li>数据分布具有有限的范围： 当 $x\\leq T_1$ ，$P(X\\leq x)&#x3D;0$；当 $x\\geq T_2$ ， $P(X \\geq x)$ , 其中 $T_1&lt;T_2$ 是有限实数（前面描述的就是数据的分布范围是有限的不是无限的）。我们将直方图中用于计算H距离的bin的数量固定为 $\\lfloor \\sqrt{N} \\rfloor$ ，其中N是每一个时间步上获取到的数据的数量。当然，这个值可以根据先前经验来设置，但是如果对这方面不熟悉的话，就用 $\\sqrt{N}$ 就可以了。</li>\n<li>为了服从真实的增量学习的设置，每个样本都只会被算法获取一次。</li>\n</ul>\n<h3 id=\"漂移检测算法\"><a href=\"#漂移检测算法\" class=\"headerlink\" title=\"漂移检测算法\"></a>漂移检测算法</h3><p>下图是HDDDM的伪代码</p>\n<p><img src=\"https://i.imgur.com/hEeGsF1.png\" alt=\"picture 4\">  </p>\n<p>算法初始化 $\\lambda &#x3D;1,D_\\lambda &#x3D;D_1$ 其中 $\\lambda$ 是上一次发生漂移的时间步。 $D_1$ 是D的初始化，后续的 $D_\\lambda$ 的更新如下所述。</p>\n<p>算法先根据 $D_t,D_\\lambda$ 构建直方图P和Q，他们的bin都为 $\\lfloor \\sqrt{N} \\rfloor$，N是当前batch的数据数量。两个直方图的H距离会通过下面的公式进行计算。先单独计算每一个特征的H距离，然后所有特征的距离的平均值作为最终的距离。</p>\n<p><img src=\"https://i.imgur.com/5tmN1Qh.png\" alt=\"picture 5\">  </p>\n<p>其中d是数据的维数，$P_{i,k}(Q_{i,k})$  是在直方图中关于特征k的第i个bin的数值。然后计算 $\\epsilon(t)$ ，即当前时间步的H散度和上一时间步的H散度。将这两个之间的差距和一个阈值进行比较，来决定差距是否足够大到称之为一个漂移。这里的阈值采用了一个自适应的方法，能够跟着时间步自动调整。其实就是将基准数据集的时间步开始到当前时间步的前一时间步的 $\\epsilon(t)$ 求一个平均值，然后再求其标准差。</p>\n<p>真实的阈值 $\\beta(t)$ 就是用下面的公式求。作者这里提出了两种方法来求，一种基于标准差，另一种基于置信度。</p>\n<p>第一种的计算公式如下</p>\n<p><img src=\"https://i.imgur.com/u2P1ZQM.png\" alt=\"picture 6\">  </p>\n<p>其中 $\\gamma$ 是一个正实数，表示标准差改变多少就认为足够多了。</p>\n<p>第二种的计算公式如下，</p>\n<p><img src=\"https://i.imgur.com/zF90WCy.png\" alt=\"picture 7\">  </p>\n<p>如果检测到漂移的话，我们需要对基准数据分布进行重置，重置为当前批次；如果没有检测到漂移的话，就将当前数据信息放到基准数据分布中，如下所示：</p>\n<p><img src=\"https://i.imgur.com/HlZK3EK.png\" alt=\"picture 8\">  </p>\n","categories":["异常检测"]},{"title":"Unsupervised Concept Drift Detection Using a Student–Teacher Approach","url":"/2022/04/17/Unsupervised-Concept-Drift-DetectionUsing-a-Student%E2%80%93Teacher-Approach/","content":"<h2 id=\"摘要-2\">摘要</h2>\n<p>作者提出了一个基于学生-教师的方法。本质上是构建一个辅助模型来模仿主模型的行为。运行过程中，使用老师模型来预测新的实例并且监控学生模型的模仿损失以检测概念漂移。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-2\">引言</h2>\n<p>使用教师-学生模型通过检测学生模型的模仿损失来判断漂移。模仿损失是一个学生预测和老师预测之间的差异函数。概念漂移发生时，它导致类的先验概率发生变化或预测变量的类条件概率发生变化。我们假设这些变化会破坏教师和学生模型之间的集体行为。</p>\n<h2 id=\"方法-2\">方法</h2>\n<p>该方法主要有三个步骤：</p>\n<ul>\n<li>创建主模型T</li>\n<li>创建学生模型S，模仿主模型的行为</li>\n<li>部署主模型T并且基于S的损失进行漂移检测</li>\n</ul>\n<h3 id=\"创建老师和学生模型\">创建老师和学生模型</h3>\n<p>$D_{tr}(X,y)$ 表示可以获取的训练数据，用它来训练分类器T。该模型用于预测数据流中传来的样本，我们称之为 $X_{new}$ 。我们用T来预测 $D_{tr}(X,y)$ 得到 $\\hat{y}<em>{T,tr}$ 。然后构建一个新的数据集 $D</em>{tr}(x,\\hat{y}_T)$ 用于训练学生分类器S。</p>\n<h3 id=\"漂移检测\">漂移检测</h3>\n<p>由于我们真实标签是无法获取的，所以无法计算主模型T的损失，但是我们能够衡量学生模型的，对于学生来说它的标签就是老师给的，然后再和他自己预测的结果做一个损失。</p>\n<p>实际上，这个方法的本质可以理解为检测学生模型的错误率，以此来达到类似有监督学习的效果。</p>\n<p>当漂移发生时，会导致类的先验概率 $p(y|X)$ 的改变。而这一变化会扰动学生模型的损失。因此，监视这一损失就足够获取到漂移信息了。</p>\n","categories":["异常检测"]},{"title":"Know-GNN: An Explainable Knowledge-Guided Graph Neural Network for Fraud Detection","url":"/2022/04/22/Know-GNN-An-Explainable-Knowledge-Guided-Graph-Neural-Network-for-Fraud-Detection/","content":"<h2 id=\"摘要\">摘要</h2>\n<p>欺诈检测会有两个挑战：</p>\n<ul>\n<li>现实中的欺诈检测缺少带标签的样本</li>\n<li>最新的基于机器学习的检测方法缺少可解释性</li>\n</ul>\n<p>作者提出了一个知识引导的GNN称为Know-GNN，使用专业知识去粗略地去给数据进行打标然后使用一个可解释的半监督方法训练一个欺诈检测器。采用了 <strong>图函数依赖(Graph Functional Dependency,GFD)</strong> 作为知识的统一表示来打标并且给出检测结果的解释。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言\">引言</h2>\n<p>KnowGNN的总体结构如下图。打标前，通过标记有标签数据来初始化GFD的可靠性。然后采用了一个使用噪声样本的训练方法（联合训练）来使用无标签数据和有标签数据共同训练GNN。最后在联合训练网络中增加一个attention机制来决定检测结果的可靠性向量，该向量表明每个GFD规则对欺诈检测的结果做出了多少贡献。</p>\n<p><img src=\"https://i.imgur.com/XJhBLn9.png\" alt=\"picture 1\"></p>\n<h2 id=\"方法\">方法</h2>\n<h3 id=\"结构\">结构</h3>\n<p>结构如上图。最初的节点分为两部分，一部分有标签称为 $V_{lab}$ ，一部分没有标签（金标）称为 $V_{unlab}$ 。无标签数据通过带有可靠性向量的GFD规则打标。由这些规则打标的数据被认为是噪声。</p>\n<p>每次联合训练的epoch前，通过伪随机方法对噪声数据进行采样成噪声标签 $N_{data}$ 。金标数据以同样的大小对 $V_{data}$ 采样成为金标 $G_{data}$ 。这两个数据集分别用于训练噪声网络f和黄金网络g。在每个训练周期中，通过图注意力机制聚合每个邻居信息之后，选取topk个最小损失的数据放入另一个网络中作为有用的知识来更新参数。网络自身也拿出topk-2个最小损失的数据一起来更新自己。网络选用自身数据和传来的数据的比例通过 $\\sigma_{se}$ 控制。</p>\n<p>每个训练周期结束后，噪声网络被用于对无标签数据再次打标并且更新可靠性向量。</p>\n<h3 id=\"无标签数据的打标\">无标签数据的打标</h3>\n<h4 id=\"图函数依赖-GFD\">图函数依赖(GFD)</h4>\n<p>图函数依赖表示为 $Q[\\overline{x}](X \\rightarrow Y)$ ，其中 $Q[\\overline{x}]$ 是图模式，X和Y是 $\\overline{x}$ 的两个文字集合。比如说下图中，GFD规则识别普通银行卡可以表示为 $Q[\\overline{x}](X \\rightarrow Y)$ 。其中 $Q[\\overline{x}]$ 就是整张图的模式，$X={F_a(Card)=(Workplace=‘Beijing’;Credit\\lt 100);$ $F_a(e)=(transferAmount \\gt 1000;transferType =‘loan’)},Y={F_a(SP)=(bankLevel=3;operatorID=ABC;isFraud=True)}$ 。 这个表达式说明如果交易满足图中的模式，并且GFD约束了X，那么下图中红框的服务提供端就是欺诈。</p>\n<p><img src=\"https://i.imgur.com/q9S13bb.png\" alt=\"picture 2\"></p>\n<h4 id=\"可靠性（RE）\">可靠性（RE）</h4>\n<p>RE是用来定义可以被网络f更新的数据的噪声等级的。 $v_{RE}$ 是欺诈实例的可靠性向量，其中包含所有能够识别该实例的GFD规则的RE，其他GFD规则被置为0。噪声数据的可靠性等于 $v_{RE}$ 中的最小值。黄金数据的可靠性向量与噪声数据的计算相同，因此黄金数据的可靠性 RE 设置为 1。</p>\n<p>GFD规则的RE初始化通过使用规则对黄金数据打标并且使用F1得分作为其RE。RE的下边界设置为0.8。</p>\n<h3 id=\"Know-GNN\">Know-GNN</h3>\n<p>作者使用GAT作为算法的基本方法。节点i的向量 $h_i$ 是由它的特征向量 $\\overline{h_i}$ 和他的可靠性向量 $v_{RE}$ 拼接起来的。邻接节点的聚合和图注意力网络的方法是一样的</p>\n<p><img src=\"https://i.imgur.com/4OXhhYL.png\" alt=\"picture 3\"></p>\n<p>网络的损失函数使用交叉熵求得。黄金网络g是一个经典的GAT。作者修改了具有可靠性的交叉熵损失，以适应 Noisy 网络 f 的标签不确定性。</p>\n<p><img src=\"https://i.imgur.com/B40z7l1.png\" alt=\"picture 4\"></p>\n<p>在交叉熵损失中增加了log(RE)，表名可靠性越高，惩罚就越小。此外，可靠性向量 $v_{RE}$ 和可靠性通过下式更新</p>\n<p><img src=\"https://i.imgur.com/5bax3wO.png\" alt=\"picture 5\"></p>\n<p>可靠性通过可靠性向量中的最小的非零值更新。</p>\n","categories":["图神经网络"],"tags":["欺诈检测"]},{"title":"gRPC基础学习","url":"/2022/04/26/gRPC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","content":"<h2 id=\"gRPC如何生成代码\">gRPC如何生成代码</h2>\n<p>客户端上会有一个存根，提供和服务器上相同的方法，由gRPC自动生成。当调用其中方法的时候，存根会在后台调用gRPC框架，通过网络与服务器交换信息。</p>\n<p><img src=\"https://i.imgur.com/CpGtllp.png\" alt=\"picture 1\"></p>\n<span id=\"more\"></span>\n<p>为了服务器和客户端能够生成存根，我们首先需要写一个API的契约，在一个protocol buffer中编写服务及其有效负载的描述</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax=&quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">package proto;</span><br><span class=\"line\"></span><br><span class=\"line\">service Greeter&#123;</span><br><span class=\"line\">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;;</span><br><span class=\"line\">  rpc SayList (HelloRequest) returns (stream HelloReply) &#123;&#125;;</span><br><span class=\"line\">  rpc SayRecord (stream HelloRequest) returns (HelloReply) &#123;&#125;;</span><br><span class=\"line\">  rpc SayRoute(stream HelloRequest) returns (stream HelloReply);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloRequest&#123;</span><br><span class=\"line\">  string name=1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message HelloReply&#123;</span><br><span class=\"line\">  string message=1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个proto文件中，服务器和客户端的存根通过协议缓冲区编译器（protoc）生成。根据编程语言的不同，需要告诉编译器使用正确的gRPC插件。</p>\n<h2 id=\"gRPC的秘密武器\">gRPC的秘密武器</h2>\n<h3 id=\"为什么选择HTTP-2\">为什么选择HTTP/2</h3>\n<p>gRPC 使用 HTTP/2 作为其传输协议，因此它继承了 HTTP/2 提供的一些强大功能，例如二进制帧，与其他基于文本的协议相比，它具有高性能和健壮、传输更轻、解码更安全。而且因为它是二进制的，所以它与协议缓冲区是一个很好的组合。</p>\n<p>在 HTTP/2 中可以进行多路复用，这意味着客户端和服务器可以通过单个 TCP 连接并行发送多个请求和响应。这将有助于减少延迟并提高网络利用率。</p>\n<p>HTTP/2 还使用 HPACK 压缩标头，这将降低开销成本并提高性能。</p>\n<p>最后，HTTP/2 允许服务器推送，其中来自客户端的 1 个请求，服务器可以发送回多个响应。在许多情况下，当服务器确切地知道客户端需要什么资源并在它们被请求之前发送它们时，这对于减少客户端和服务器之间的往返延迟非常有价值。</p>\n<p>可以用这个演示来看HTTP/2比1.1快多少<a href=\"http://www.http2demo.io/\">速度比较链接</a></p>\n<h3 id=\"HTTP-2工作原理\">HTTP/2工作原理</h3>\n<p>有一个 TCP 连接可以承载多个双向流。每个流都有一个唯一的标识符，并携带多个双向消息。</p>\n<p>每条消息，可以是请求或响应，都被分解成多个二进制帧。帧是承载不同类型数据的最小单位，例如 HEADERS、SETTINGS、PRIORITY、DATA 等。</p>\n<p>事实上，这些流实际上并没有单独流动，而是它们的帧在连接上交错，到达另一端时会重新组合。多亏了这个二进制成帧层，HTTP/2 中的流多路复用成为可能。</p>\n<h3 id=\"HTTP-2和HTTP-1-1\">HTTP/2和HTTP/1.1</h3>\n<ul>\n<li>2是二进制协议，1是文本协议</li>\n<li>2中会压缩标头，1中是纯文本</li>\n<li>2允许多路复用，1不允许</li>\n<li>2中可以在单个连接中发多个请求和响应，1中只能一个</li>\n<li>服务器推送可以用2，但不能用1</li>\n</ul>\n<h2 id=\"gRPC和REST，何时使用gRPC\">gRPC和REST，何时使用gRPC</h2>\n<p>gRPC 使用 Protocol Buffer 来序列化有效载荷数据，它是二进制的，更小，而 REST 使用 JSON，它是文本，更大。</p>\n<p>gRPC 中的 API 契约是严格的，需要在 proto 文件中明确定义。在 REST 中，它通常是松散的和可选的。如果需要，我们可以通过 OpenAPI 定义它，但这不是强制性的。</p>\n<p>gRPC 和 REST 通信都使用 TLS/SSL 保护。</p>\n<p>流式传输在 gRPC 中是双向的，而在 REST 中只有一种方式从客户端到服务器的请求。</p>\n<p>因此，对于我们迄今为止提到的大多数事情，gRPC 都比 REST 更好。然而，有一件事是 REST 还是更好的，</p>\n<p>那是浏览器支持。虽然所有浏览器都完全支持 REST，但对 gRPC 的支持是有限的，并且需要带有代理层的gRPC-web在 HTTP/1 和 HTTP/2 之间进行转换。</p>\n<p>微服务是 gRPC 真正闪耀的地方，因为它支持低延迟和高吞吐量的通信，以及强大的 API 合约。</p>\n<p>gRPC 也适用于多语言环境，因为它为许多编程语言提供了开箱即用的代码生成。</p>\n<p>点对点实时通信也是 gRPC 的一个好地方，因为它对双向流有很好的支持。</p>\n<p>最后，gRPC 是移动应用程序 (android/ios) 等网络受限环境的绝佳选择，因为它具有轻量级的消息格式。</p>\n<h2 id=\"定义protobuf并且生成go代码\">定义protobuf并且生成go代码</h2>\n<p>注意消息的名字应该是UpperCamelCase，字段的名字应该是lower_snake_case。</p>\n<p>我们可以使用许多内置的标量值数据类型，例如：string、bool、byte、float、double和许多其他整数类型。我们还可以使用我们自己的数据类型，例如枚举或其他消息。</p>\n<p>每个消息字段都应该分配一个唯一的标签。并且标签比字段名更重要，因为 protobuf 将使用它来序列化消息。</p>\n<p>标记只是一个任意整数，最小值为 1，最大值为 2 29 - 1，但从 19000 到 19999 的数字除外，因为它们是为内部协议缓冲区实现保留的。</p>\n<p>请注意，从 1 到 15 的标签只需要 1 个字节进行编码，而从 16 到 2047 的标签需要 2 个字节。所以你应该明智地使用它们，比如：为非常频繁出现的字段保存从 1 到 15 的标签。</p>\n<p>请记住，标签不需要是有序的（或连续的），但对于消息的同级字段，它们必须是唯一的。</p>\n<h3 id=\"定义CPU消息\">定义CPU消息</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// /proto/processor_message.proto</span><br><span class=\"line\"></span><br><span class=\"line\">syntax = &quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">option go_package=&quot;../pb&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message CPU &#123;</span><br><span class=\"line\">  string brand = 1;</span><br><span class=\"line\">  string name = 2;</span><br><span class=\"line\">  uint32 number_cores = 3;</span><br><span class=\"line\">  uint32 number_threads = 4;</span><br><span class=\"line\">  double min_ghz = 5;</span><br><span class=\"line\">  double max_ghz = 6;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先安装protoc-gen-go和gRPC库</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get -u google.golang.org/grpc</span><br><span class=\"line\">go get -u github.com/golang/protobuf/protoc-gen-go@v1.3.2</span><br></pre></td></tr></table></figure>\n<p>之后可以执行此命令,生成go代码</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">protoc --go_out=plugins=grpc:pb proto/*.proto</span><br></pre></td></tr></table></figure>\n<p>此时的项目目录为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pcbook</span><br><span class=\"line\">├── proto</span><br><span class=\"line\">│   └── processor_message.proto</span><br><span class=\"line\">├── pb</span><br><span class=\"line\">│   └── processor_message.pb.go</span><br><span class=\"line\">└── main.go</span><br></pre></td></tr></table></figure>\n<h3 id=\"编写Makefile\">编写Makefile</h3>\n<p>我们用来生成代码的命令很长，所以当我们更新proto文件并想重新生成代码时，输​​入不是很方便。因此，让我们使用一个简短的命令创建一个 Makefile 来执行此操作。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">gen:</span></span><br><span class=\"line\">    protoc --proto_path=proto proto/*.proto --go_out=plugins=grpc:pb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">    rm pb/*.go </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">run:</span></span><br><span class=\"line\">    go run main.go</span><br></pre></td></tr></table></figure>\n<h2 id=\"协议缓冲区深入研究\">协议缓冲区深入研究</h2>\n<h3 id=\"一个文件中的多条消息\">一个文件中的多条消息</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax = &quot;proto3&quot;;</span><br><span class=\"line\">import &quot;memory_message.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message CPU &#123;</span><br><span class=\"line\">  string brand = 1;</span><br><span class=\"line\">  string name = 2;</span><br><span class=\"line\">  uint32 number_cores = 3;</span><br><span class=\"line\">  uint32 number_threads = 4;</span><br><span class=\"line\">  double min_ghz = 5;</span><br><span class=\"line\">  double max_ghz = 6;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message GPU &#123;</span><br><span class=\"line\">  string brand = 1;</span><br><span class=\"line\">  string name = 2;</span><br><span class=\"line\">  double min_ghz = 3;</span><br><span class=\"line\">  double max_ghz = 4;</span><br><span class=\"line\">  Memory memory=5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义类型：消息和枚举\">自定义类型：消息和枚举</h3>\n<p>内存是一个非常流行的术语，可以在其他地方使用，例如 RAM 或存储（持久驱动器）。它有许多不同的度量单位，例如千字节、兆字节、千兆字节或太字节。所以我将它定义为自定义类型，在一个单独的memory_message.proto文件中，以便我们以后可以重用它。</p>\n<p>首先，我们需要定义测量单位。为此，我们将使用枚举。因为这个单元应该只存在于内存的上下文中，所以我们应该将它定义为内存消息中的嵌套类型。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax = &quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message Memory &#123;</span><br><span class=\"line\">  enum Unit &#123;</span><br><span class=\"line\">    UNKNOWN = 0;</span><br><span class=\"line\">    BIT = 1;</span><br><span class=\"line\">    BYTE = 2;</span><br><span class=\"line\">    KILOBYTE = 3;</span><br><span class=\"line\">    MEGABYTE = 4;</span><br><span class=\"line\">    GIGABYTE = 5;</span><br><span class=\"line\">    TERABYTE = 6;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  uint64 value = 1;</span><br><span class=\"line\">  Unit unit = 2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>惯例是，始终使用特殊值作为枚举的默认值并为其分配标签 0。然后我们添加其他单位，从 BIT 到 TERABYTE。</p>\n<p>内存消息将有 2 个字段：一个用于值，另一个用于单位。</p>\n<h3 id=\"定义存储消息\">定义存储消息</h3>\n<p>让我们继续我们的项目。我将为storage_message.proto文件中的存储创建一条新消息。</p>\n<p>存储可以是硬盘驱动器或固态驱动器。所以我们应该Driver用这两个值定义一个枚举。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax =&quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">option go_package=&quot;../pb&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;proto/memory_message.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message Storage&#123;</span><br><span class=\"line\">  enum Drive&#123;</span><br><span class=\"line\">    UNKNOWN=0;</span><br><span class=\"line\">    HDD=1;</span><br><span class=\"line\">    SSD=2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Drive driver=1;</span><br><span class=\"line\">  Memory memory=2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"定义键盘消息\">定义键盘消息</h3>\n<p>接下来，我们将定义键盘消息。它可以具有 QWERTY、QWERTZ 或 AZERTY 布局。供您参考，QWERTZ 在德国被广泛使用。在法国，AZERTY 更受欢迎。</p>\n<p>键盘可以背光或不背光，因此我们使用布尔字段。很简单，对吧？</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax=&quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">option go_package=&quot;../pb&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message Keyboard&#123;</span><br><span class=\"line\">  enum Layout&#123;</span><br><span class=\"line\">    UNKONWN=0;</span><br><span class=\"line\">    QWERTY=1;</span><br><span class=\"line\">    QWERTZ=2;</span><br><span class=\"line\">    AZERTY=3;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Layout layout=1;</span><br><span class=\"line\">  bool backlit=2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"定义屏幕消息\">定义屏幕消息</h3>\n<p>现在让我们写一个更复杂的信息：屏幕。它有一个嵌套的消息类型：Resolution. 我们这里使用嵌套类型的原因是：分辨率是一个与屏幕有着紧密联系的实体，它单独存在时没有任何意义。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax=&quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">option go_package=&quot;../pb&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message Screen&#123;</span><br><span class=\"line\">  message Resolution&#123;</span><br><span class=\"line\">    uint32 width=1;</span><br><span class=\"line\">    uint32 height=2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  enum Panel&#123;</span><br><span class=\"line\">    UNKNOWN=0;</span><br><span class=\"line\">    IPS=1;</span><br><span class=\"line\">    OLED=2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  float size_inch=1;</span><br><span class=\"line\">  Resolution resolution =2;</span><br><span class=\"line\">  Panel panel =3;</span><br><span class=\"line\">  bool multitouch=4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同样，我们有一个屏幕面板的枚举，可以是 IPS 或 OLED。然后屏幕尺寸以英寸为单位。最后是一个布尔字段来判断它是否是多点触控屏幕。</p>\n<h3 id=\"定义笔记本电脑消息\">定义笔记本电脑消息</h3>\n<p>我想基本上我们已经定义了笔记本电脑的所有必要组件。现在让我们定义笔记本电脑消息。</p>\n<p>它有一个字符串类型的唯一标识符。此 ID 将由服务器自动生成。它有一个品牌和一个名字。然后是CPU和RAM。我们需要导入其他 proto 文件来使用这些类型。</p>\n<p>一台笔记本电脑可以有多个 GPU，所以我们使用repeated关键字告诉 protoc 这是一个 GPU 列表。</p>\n<p>同样，笔记本电脑有多个存储也是正常的，所以这个字段也应该重复。</p>\n<p>笔记本的重量如何？比方说，我们允许以千克或磅为单位指定它。为了做到这一点，我们可以使用一个新的关键字：oneof.</p>\n<p>在这个块中，我们定义了 2 个字段，一个用于公斤，另一个用于磅。请记住，当您使用oneof字段组时，只有最后分配的字段才会保留其值。</p>\n<p>然后我们再添加 2 个字段：美元价格和笔记本电脑的发布年份。最后，我们需要一个时间戳字段来存储我们系统中记录的最后更新时间。</p>\n<p>Timestamp 是 Google 已经定义好的众所周知的类型之一，所以我们只需要导入包并使用它。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax=&quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">option go_package=&quot;../pb&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;proto/memory_message.proto&quot;;</span><br><span class=\"line\">import &quot;proto/processor_message.proto&quot;;</span><br><span class=\"line\">import &quot;proto/storage_message.proto&quot;;</span><br><span class=\"line\">import &quot;proto/screen_message.proto&quot;;</span><br><span class=\"line\">import &quot;proto/keyboard_message.proto&quot;;</span><br><span class=\"line\">import &quot;google/protobuf/timestamp.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message Laptop&#123;</span><br><span class=\"line\">  string id=1;</span><br><span class=\"line\">  string brand=2;</span><br><span class=\"line\">  string name=3;</span><br><span class=\"line\">  CPU cpu=4;</span><br><span class=\"line\">  Memory ram=5;</span><br><span class=\"line\">  repeated GPU gpus=6;</span><br><span class=\"line\">  repeated Storage storages=7;</span><br><span class=\"line\">  Screen screen=8;</span><br><span class=\"line\">  Keyboard keyboard=9;</span><br><span class=\"line\">  oneof weight&#123;</span><br><span class=\"line\">    double weight_kg=10;</span><br><span class=\"line\">    double weight_lb=11;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  double price_usd=12;</span><br><span class=\"line\">  uint32 release_year=13;</span><br><span class=\"line\">  google.protobuf.Timestamp updated_at=14;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之后就可以一并生成go文件了。</p>\n<h2 id=\"在GO中生成和序列化protobuf消息\">在GO中生成和序列化protobuf消息</h2>\n<p>创建一个sample包来生成一些随机的笔记本电脑数据。此时的项目目录结构如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pcbook</span><br><span class=\"line\">├── proto</span><br><span class=\"line\">├── pb</span><br><span class=\"line\">├── sample</span><br><span class=\"line\">│   ├── generator.go</span><br><span class=\"line\">│   └── random.go</span><br><span class=\"line\">├── go.mod</span><br><span class=\"line\">├── main.go</span><br><span class=\"line\">└── Makefile</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成随机键盘\">生成随机键盘</h3>\n<p>首先我们需要一个键盘，所以我定义了一个函数NewKeyboard()，它返回一个指向pb.Keyboard对象的指针。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> sample</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;gitlab.com/techschool/pcbook/pb&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewKeyboard returns a new sample keyboard</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewKeyboard</span><span class=\"params\">()</span> *<span class=\"title\">pb</span>.<span class=\"title\">Keyboard</span></span> &#123;</span><br><span class=\"line\">    keyboard := &amp;pb.Keyboard&#123;</span><br><span class=\"line\">        Layout:  randomKeyboardLayout(),</span><br><span class=\"line\">        Backlit: randomBool(),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> keyboard</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它将有一个布局，所以我将编写一个函数来生成随机键盘布局。还有一个为背光字段生成随机布尔值的函数。让我们将它们写入新文件random.go中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> sample</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;math/rand&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomBool</span><span class=\"params\">()</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rand.Intn(<span class=\"number\">2</span>) == <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomKeyboardLayout</span><span class=\"params\">()</span> <span class=\"title\">pb</span>.<span class=\"title\">Keyboard_Layout</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> rand.Intn(<span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pb.Keyboard_QWERTY</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pb.Keyboard_QWERTZ</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pb.Keyboard_AZERTY</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成随机cpu\">生成随机cpu</h3>\n<p>首先我们需要一个函数来返回一个随机的 CPU 品牌。让我们去random.go文件中定义它。一种简单的方法是从一组预定义的品牌中选择一个随机值，例如“Intel”和“AMD”。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomCPUBrand</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> randomStringFromSet(<span class=\"string\">&quot;Intel&quot;</span>, <span class=\"string\">&quot;AMD&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomStringFromSet</span><span class=\"params\">(a ...<span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    n := <span class=\"built_in\">len</span>(a)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a[rand.Intn(n)]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，我们将根据具有此功能的品牌生成一个随机的 CPU 名称。因为我们知道只有 2 个品牌，所以这里简单的 if 就足够了。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomCPUName</span><span class=\"params\">(brand <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> brand == <span class=\"string\">&quot;Intel&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> randomStringFromSet(</span><br><span class=\"line\">            <span class=\"string\">&quot;Xeon E-2286M&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;Core i9-9980HK&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;Core i7-9750H&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;Core i5-9400F&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;Core i3-1005G1&quot;</span>,</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> randomStringFromSet(</span><br><span class=\"line\">        <span class=\"string\">&quot;Ryzen 7 PRO 2700U&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Ryzen 5 PRO 3500U&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;Ryzen 3 PRO 3200GE&quot;</span>,</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们必须填写的下一个 CPU 字段是内核数。假设我们希望它介于 2 核和 8 核之间。所以我们需要一个randomInt()函数来生成 和 之间的随机min整数max。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomInt</span><span class=\"params\">(min, max <span class=\"keyword\">int</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min + rand.Int()%(max-min+<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好的，下一个字段是minGhz，这是一个float64。我希望 CPU 的最低频率介于2.0和之间3.5。所以我们需要一个函数来生成float64范围 from minto max。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomFloat64</span><span class=\"params\">(min, max <span class=\"keyword\">float64</span>)</span> <span class=\"title\">float64</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min + rand.Float64()*(max-min)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把所有东西放在一起，我们得到了这个NewCPU()函数：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NewCPU returns a new sample CPU</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewCPU</span><span class=\"params\">()</span> *<span class=\"title\">pb</span>.<span class=\"title\">CPU</span></span> &#123;</span><br><span class=\"line\">    brand := randomCPUBrand()</span><br><span class=\"line\">    name := randomCPUName(brand)</span><br><span class=\"line\"></span><br><span class=\"line\">    numberCores := randomInt(<span class=\"number\">2</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">    numberThreads := randomInt(numberCores, <span class=\"number\">12</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    minGhz := randomFloat64(<span class=\"number\">2.0</span>, <span class=\"number\">3.5</span>)</span><br><span class=\"line\">    maxGhz := randomFloat64(minGhz, <span class=\"number\">5.0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    cpu := &amp;pb.CPU&#123;</span><br><span class=\"line\">        Brand:         brand,</span><br><span class=\"line\">        Name:          name,</span><br><span class=\"line\">        NumberCores:   <span class=\"keyword\">uint32</span>(numberCores),</span><br><span class=\"line\">        NumberThreads: <span class=\"keyword\">uint32</span>(numberThreads),</span><br><span class=\"line\">        MinGhz:        minGhz,</span><br><span class=\"line\">        MaxGhz:        maxGhz,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cpu</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成随机-GPU\">生成随机 GPU</h3>\n<p>NewGPU 函数将以相同的方式实现。我们编写了一个函数来返回一个随机的 GPU 品牌，它可以是“NVIDIA”或“AMD”。然后我们根据品牌生成一个随机的 GPU 名称。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomGPUBrand</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> randomStringFromSet(<span class=\"string\">&quot;Nvidia&quot;</span>, <span class=\"string\">&quot;AMD&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomGPUName</span><span class=\"params\">(brand <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> brand == <span class=\"string\">&quot;Nvidia&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> randomStringFromSet(</span><br><span class=\"line\">            <span class=\"string\">&quot;RTX 2060&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;RTX 2070&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;GTX 1660-Ti&quot;</span>,</span><br><span class=\"line\">            <span class=\"string\">&quot;GTX 1070&quot;</span>,</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> randomStringFromSet(</span><br><span class=\"line\">        <span class=\"string\">&quot;RX 590&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;RX 580&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;RX 5700-XT&quot;</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;RX Vega-56&quot;</span>,</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在只剩下一个领域：记忆。假设我们希望它在 2 到 6 GB 之间。因此，我们将在randomInt()此处使用该函数，并将其类型转换为uint64. 对于单元，只需使用Memory_GIGABYTEprotoc 生成的枚举即可。我们已经完成了 GPU。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NewGPU returns a new sample GPU</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewGPU</span><span class=\"params\">()</span> *<span class=\"title\">pb</span>.<span class=\"title\">GPU</span></span> &#123;</span><br><span class=\"line\">    brand := randomGPUBrand()</span><br><span class=\"line\">    name := randomGPUName(brand)</span><br><span class=\"line\"></span><br><span class=\"line\">    minGhz := randomFloat64(<span class=\"number\">1.0</span>, <span class=\"number\">1.5</span>)</span><br><span class=\"line\">    maxGhz := randomFloat64(minGhz, <span class=\"number\">2.0</span>)</span><br><span class=\"line\">    memGB := randomInt(<span class=\"number\">2</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    gpu := &amp;pb.GPU&#123;</span><br><span class=\"line\">        Brand:  brand,</span><br><span class=\"line\">        Name:   name,</span><br><span class=\"line\">        MinGhz: minGhz,</span><br><span class=\"line\">        MaxGhz: maxGhz,</span><br><span class=\"line\">        Memory: &amp;pb.Memory&#123;</span><br><span class=\"line\">            Value: <span class=\"keyword\">uint64</span>(memGB),</span><br><span class=\"line\">            Unit:  pb.Memory_GIGABYTE,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> gpu</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成随机-RAM\">生成随机 RAM</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NewRAM returns a new sample RAM</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewRAM</span><span class=\"params\">()</span> *<span class=\"title\">pb</span>.<span class=\"title\">Memory</span></span> &#123;</span><br><span class=\"line\">    memGB := randomInt(<span class=\"number\">4</span>, <span class=\"number\">64</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    ram := &amp;pb.Memory&#123;</span><br><span class=\"line\">        Value: <span class=\"keyword\">uint64</span>(memGB),</span><br><span class=\"line\">        Unit:  pb.Memory_GIGABYTE,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ram</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成随机存储\">生成随机存储</h3>\n<p>然后是存储。我们将定义 2 个不同的函数：1 个用于 SSD，1 个用于 HDD。</p>\n<p>对于 SSD，我们将驱动程序设置为Storage_SSD并且内存大小将从 128 GB 到 1024 GB。</p>\n<p>对于 HDD，驱动程序必须是 Storage_HDD，内存大小在 1 到 6 TB 之间。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NewSSD returns a new sample SSD</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewSSD</span><span class=\"params\">()</span> *<span class=\"title\">pb</span>.<span class=\"title\">Storage</span></span> &#123;</span><br><span class=\"line\">    memGB := randomInt(<span class=\"number\">128</span>, <span class=\"number\">1024</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    ssd := &amp;pb.Storage&#123;</span><br><span class=\"line\">        Driver: pb.Storage_SSD,</span><br><span class=\"line\">        Memory: &amp;pb.Memory&#123;</span><br><span class=\"line\">            Value: <span class=\"keyword\">uint64</span>(memGB),</span><br><span class=\"line\">            Unit:  pb.Memory_GIGABYTE,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ssd</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewHDD returns a new sample HDD</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewHDD</span><span class=\"params\">()</span> *<span class=\"title\">pb</span>.<span class=\"title\">Storage</span></span> &#123;</span><br><span class=\"line\">    memTB := randomInt(<span class=\"number\">1</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    hdd := &amp;pb.Storage&#123;</span><br><span class=\"line\">        Driver: pb.Storage_HDD,</span><br><span class=\"line\">        Memory: &amp;pb.Memory&#123;</span><br><span class=\"line\">            Value: <span class=\"keyword\">uint64</span>(memTB),</span><br><span class=\"line\">            Unit:  pb.Memory_TERABYTE,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hdd</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成随机屏幕\">生成随机屏幕</h3>\n<p>现在我们将制作一个新屏幕。屏幕尺寸在 13 到 17 英寸之间。这是一个float32数字，所以让我们定义一个randomFloat32函数。它与randomFloat64函数相同，除了类型应该是float32.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomFloat32</span><span class=\"params\">(min, max <span class=\"keyword\">float32</span>)</span> <span class=\"title\">float32</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> min + rand.Float32()*(max-min)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其次，屏幕分辨率。我们将高度设置为 1080 到 4320 之间的随机整数。并以 16 乘 9 的比率从高度计算宽度。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomScreenResolution</span><span class=\"params\">()</span> *<span class=\"title\">pb</span>.<span class=\"title\">Screen_Resolution</span></span> &#123;</span><br><span class=\"line\">    height := randomInt(<span class=\"number\">1080</span>, <span class=\"number\">4320</span>)</span><br><span class=\"line\">    width := height * <span class=\"number\">16</span> / <span class=\"number\">9</span></span><br><span class=\"line\"></span><br><span class=\"line\">    resolution := &amp;pb.Screen_Resolution&#123;</span><br><span class=\"line\">        Width:  <span class=\"keyword\">uint32</span>(width),</span><br><span class=\"line\">        Height: <span class=\"keyword\">uint32</span>(height),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resolution</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后是屏幕面板。在我们的应用中，只有两种类型的面板：IPS 或 OLED。所以我们在这里只使用 rand.Intn(2) ，一个简单的 if 就可以完成这项工作。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomScreenPanel</span><span class=\"params\">()</span> <span class=\"title\">pb</span>.<span class=\"title\">Screen_Panel</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> rand.Intn(<span class=\"number\">2</span>) == <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pb.Screen_IPS</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pb.Screen_OLED</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们必须设置的最后一个字段是多点触控，它只是一个随机布尔值。然后我们有这个函数来生成一个新的屏幕：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NewScreen returns a new sample Screen</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewScreen</span><span class=\"params\">()</span> *<span class=\"title\">pb</span>.<span class=\"title\">Screen</span></span> &#123;</span><br><span class=\"line\">    screen := &amp;pb.Screen&#123;</span><br><span class=\"line\">        SizeInch:   randomFloat32(<span class=\"number\">13</span>, <span class=\"number\">17</span>),</span><br><span class=\"line\">        Resolution: randomScreenResolution(),</span><br><span class=\"line\">        Panel:      randomScreenPanel(),</span><br><span class=\"line\">        Multitouch: randomBool(),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> screen</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成随机笔记本电脑\">生成随机笔记本电脑</h3>\n<p>好了，所有组件都准备好了，现在我们可以生成一台新的笔记本电脑了。</p>\n<p>首先，它需要一个唯一的随机标识符。因此，让我们为此创建一个 randomID() 函数。我将使用Google UUID。我们可以在终端运行这个命令来安装包：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get github.com/google/uuid</span><br></pre></td></tr></table></figure>\n<p>现在我们可以调用uuid.New()来获取一个随机 ID 并将其转换为字符串。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomID</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> uuid.New().String()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，我们将生成类似于我们对 CPU 和 GPU 所做的笔记本电脑品牌和名称。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomLaptopBrand</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> randomStringFromSet(<span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Dell&quot;</span>, <span class=\"string\">&quot;Lenovo&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">randomLaptopName</span><span class=\"params\">(brand <span class=\"keyword\">string</span>)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> brand &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;Apple&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> randomStringFromSet(<span class=\"string\">&quot;Macbook Air&quot;</span>, <span class=\"string\">&quot;Macbook Pro&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;Dell&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> randomStringFromSet(<span class=\"string\">&quot;Latitude&quot;</span>, <span class=\"string\">&quot;Vostro&quot;</span>, <span class=\"string\">&quot;XPS&quot;</span>, <span class=\"string\">&quot;Alienware&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> randomStringFromSet(<span class=\"string\">&quot;Thinkpad X1&quot;</span>, <span class=\"string\">&quot;Thinkpad P1&quot;</span>, <span class=\"string\">&quot;Thinkpad P53&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在让我们使用这些函数来生成一个新的随机笔记本电脑。我们通过调用它们的生成器函数来添加 CPU 和 RAM。GPU 应该是一个值列表，所以我在这里定义了一个切片。假设我们现在只有 1 个 GPU。存储类似，但这次我将添加 2 个项目：1 个用于 SSD，另一个用于 HDD。屏幕和键盘字段非常简单。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NewLaptop returns a new sample Laptop</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewLaptop</span><span class=\"params\">()</span> *<span class=\"title\">pb</span>.<span class=\"title\">Laptop</span></span> &#123;</span><br><span class=\"line\">    brand := randomLaptopBrand()</span><br><span class=\"line\">    name := randomLaptopName(brand)</span><br><span class=\"line\"></span><br><span class=\"line\">    laptop := &amp;pb.Laptop&#123;</span><br><span class=\"line\">        Id:       randomID(),</span><br><span class=\"line\">        Brand:    brand,</span><br><span class=\"line\">        Name:     name,</span><br><span class=\"line\">        Cpu:      NewCPU(),</span><br><span class=\"line\">        Ram:      NewRAM(),</span><br><span class=\"line\">        Gpus:     []*pb.GPU&#123;NewGPU()&#125;,</span><br><span class=\"line\">        Storages: []*pb.Storage&#123;NewSSD(), NewHDD()&#125;,</span><br><span class=\"line\">        Screen:   NewScreen(),</span><br><span class=\"line\">        Keyboard: NewKeyboard(),</span><br><span class=\"line\">        Weight: &amp;pb.Laptop_WeightKg&#123;</span><br><span class=\"line\">            WeightKg: randomFloat64(<span class=\"number\">1.0</span>, <span class=\"number\">3.0</span>),</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        PriceUsd:    randomFloat64(<span class=\"number\">1500</span>, <span class=\"number\">3500</span>),</span><br><span class=\"line\">        ReleaseYear: <span class=\"keyword\">uint32</span>(randomInt(<span class=\"number\">2015</span>, <span class=\"number\">2019</span>)),</span><br><span class=\"line\">        UpdatedAt:   timestamppb.Now(),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> laptop</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"序列化-protobuf-消息\">序列化 protobuf 消息</h3>\n<p>现在我们将创建一个新serializer包并编写一些函数来将笔记本电脑对象序列化为文件。所以让我们在这里创建一个file.go文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pcbook</span><br><span class=\"line\">├── proto</span><br><span class=\"line\">├── pb</span><br><span class=\"line\">├── sample</span><br><span class=\"line\">│   ├── generator.go</span><br><span class=\"line\">│   └── random.go</span><br><span class=\"line\">├── serializer</span><br><span class=\"line\">│   └── file.go</span><br><span class=\"line\">├── go.mod</span><br><span class=\"line\">├── main.go</span><br><span class=\"line\">└── Makefile</span><br></pre></td></tr></table></figure>\n<h3 id=\"将-protobuf-消息写入二进制文件\">将 protobuf 消息写入二进制文件</h3>\n<p>第一个函数将用于将 protobuf 消息以二进制格式写入文件。在我们的例子中，消息将是笔记本电脑对象。我们可以使用该proto.Message接口使其更通用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// WriteProtobufToBinaryFile writes protocol buffer message to binary file</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WriteProtobufToBinaryFile</span><span class=\"params\">(message proto.Message, filename <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    data, err := proto.Marshal(message)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;cannot marshal proto message to binary: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = ioutil.WriteFile(filename, data, <span class=\"number\">0644</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;cannot write binary data to file: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我将向您展示如何为其编写单元测试。让我们在这里创建一个file_test.go。注意，_test文件名中有后缀是必须的，所以 Go 可以理解它是一个测试文件。</p>\n<p>我通常要求t.Parallel()几乎所有的单元测试，以便它们可以并行运行，并且可以轻松检测到任何条件。</p>\n<p>假设我们要将对象序列化为文件tmp夹中的 notebook.bin 文件。所以我们需要先创建tmp文件夹。</p>\n<p>然后使用该NewLaptop()功能制作一个新的laptop1. 并调用该WriteProtobufToBinaryFile()函数将其保存到laptop.bin文件中。由于此函数返回错误，我们必须检查此错误是否为nil，这意味着文件已成功写入。</p>\n<p>为此，我经常使用testify 包。在终端中运行此命令以获取它：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get github.com/stretchr/testify</span><br></pre></td></tr></table></figure>\n<p>然后我们可以简单地调用require.NoError(t, err).</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> serializer_test</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;testing&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;github.com/stretchr/testify/require&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;gitlab.com/techschool/pcbook/sample&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;gitlab.com/techschool/pcbook/serializer&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestFileSerializer</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    t.Parallel()</span><br><span class=\"line\"></span><br><span class=\"line\">    binaryFile := <span class=\"string\">&quot;../tmp/laptop.bin&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    laptop1 := sample.NewLaptop()</span><br><span class=\"line\">    err := serializer.WriteProtobufToBinaryFile(laptop1, binaryFile)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"从二进制文件中读取-protobuf-消息\">从二进制文件中读取 protobuf 消息</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ReadProtobufFromBinaryFile reads protocol buffer message from binary file</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ReadProtobufFromBinaryFile</span><span class=\"params\">(filename <span class=\"keyword\">string</span>, message proto.Message)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    data, err := ioutil.ReadFile(filename)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;cannot read binary data from file: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = proto.Unmarshal(data, message)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;cannot unmarshal binary to proto message: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好的，让我们测试一下。在我们的单元测试中，我将定义一个新laptop2对象，并调用ReadProtobufFromBinaryFile()以将文件数据读入该对象。我们将检查没有错误。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestFileSerializer</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    t.Parallel()</span><br><span class=\"line\"></span><br><span class=\"line\">    binaryFile := <span class=\"string\">&quot;../tmp/laptop.bin&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    laptop1 := sample.NewLaptop()</span><br><span class=\"line\">    err := serializer.WriteProtobufToBinaryFile(laptop1, binaryFile)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    laptop2 := &amp;pb.Laptop&#123;&#125;</span><br><span class=\"line\">    err = serializer.ReadProtobufFromBinaryFile(binaryFile, laptop2)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    require.True(t, proto.Equal(laptop1, laptop2))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们还想检查是否laptop2包含与 相同的数据laptop1。为此，我们可以使用包proto.Equal提供的功能golang/protobuf。这个函数必须返回true，所以我们require.True()在这里使用。</p>\n<h3 id=\"将-protobuf-消息写入-JSON-文件\">将 protobuf 消息写入 JSON 文件</h3>\n<p>现在由于数据是以二进制格式写入的，我们无法读取它。让我们编写另一个函数来将其序列化为JSON格式。</p>\n<p>在这个函数中，我们必须先将 protobuf 消息转换为JSON字符串。为此，我将创建一个名为 的新函数，并将其编码在同一个包下的ProtobufToJSON()单独json.go文件中。serializer</p>\n<p>现在要将 protobuf 消息转换为 JSON，我们可以使用jsonb.Marshaler结构体。基本上，我们只需要调用marshaler.MarshalToString()函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> serializer</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;google.golang.org/protobuf/encoding/protojson&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;google.golang.org/protobuf/proto&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;io/ioutil&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ProtobufToJSON transfer a protobuf to json string</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ProtobufToJSON</span><span class=\"params\">(message proto.Message)</span> <span class=\"params\">([]<span class=\"keyword\">byte</span>, error)</span></span> &#123;</span><br><span class=\"line\">\tmarshaler := protojson.MarshalOptions&#123;</span><br><span class=\"line\">\t\tEmitUnpopulated: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\tIndent:          <span class=\"string\">&quot;  &quot;</span>,</span><br><span class=\"line\">\t\tUseProtoNames:   <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> marshaler.Marshal(message)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以配置一些东西，例如：</p>\n<ul>\n<li>将枚举写为整数或字符串。</li>\n<li>写入具有默认值的字段或不写入。</li>\n<li>我们要使用的缩进是什么。</li>\n<li>我们是否要使用原始文件中的原始字段名称。</li>\n<li>现在让我们使用这些配置，稍后我们将尝试其他值。</li>\n</ul>\n<p>现在回到我们的函数，在调用之后ProtobufToJSON，我们得到了JSON字符串。我们需要做的就是将该字符串写入文件。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// WriteProtobufToJSONFile writes protocol buffer message to JSON file</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">WriteProtobufToJSONFile</span><span class=\"params\">(message proto.Message, filename <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    data, err := ProtobufToJSON(message)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;cannot marshal proto message to JSON: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = ioutil.WriteFile(filename, []<span class=\"keyword\">byte</span>(data), <span class=\"number\">0644</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fmt.Errorf(<span class=\"string\">&quot;cannot write JSON data to file: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好的，现在让我们在单元测试中调用这个函数。检查没有返回错误，然后运行测试。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestFileSerializer</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    t.Parallel()</span><br><span class=\"line\"></span><br><span class=\"line\">    binaryFile := <span class=\"string\">&quot;../tmp/laptop.bin&quot;</span></span><br><span class=\"line\">    jsonFile := <span class=\"string\">&quot;../tmp/laptop.json&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    laptop1 := sample.NewLaptop()</span><br><span class=\"line\"></span><br><span class=\"line\">    err := serializer.WriteProtobufToBinaryFile(laptop1, binaryFile)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    err = serializer.WriteProtobufToJSONFile(laptop1, jsonFile)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    laptop2 := &amp;pb.Laptop&#123;&#125;</span><br><span class=\"line\">    err = serializer.ReadProtobufFromBinaryFile(binaryFile, laptop2)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    require.True(t, proto.Equal(laptop1, laptop2))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"在go中生成一元gRPC-API\">在go中生成一元gRPC API</h2>\n<p>gRPC 有 4 种类型：一元、客户端流式传输、服务器流式传输和双向流式传输。</p>\n<h3 id=\"定义一个-proto-服务和一个一元-RPC\">定义一个 proto 服务和一个一元 RPC</h3>\n<p>第一步，我们将创建一个新laptop_service.proto文件。</p>\n<p>在这个文件中，我们定义了一条CreateLaptopRequest消息，它只包含一个字段：我们要创建的笔记本电脑。</p>\n<p>message CreateLaptopRequest {<br>\nLaptop laptop = 1;<br>\n}</p>\n<p>然后CreateLaptopResponse消息也只有 1 个字段：创建的笔记本电脑的 ID。</p>\n<p>message CreateLaptopResponse {<br>\nstring id = 1;<br>\n}</p>\n<p>我们用关键字定义了 LaptopService service。然后在其中，一元 RPC 定义如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">service LaptopService &#123;</span><br><span class=\"line\">  rpc CreateLaptop(CreateLaptopRequest) returns (CreateLaptopResponse&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"为一元-RPC-生成代码\">为一元 RPC 生成代码</h3>\n<p>使用<code>make gen</code>生成代码</p>\n<h3 id=\"实现服务器的一元-RPC-处理程序\">实现服务器的一元 RPC 处理程序</h3>\n<p>现在让我们实现LaptopServiceServer!</p>\n<p>我将创建一个新service文件夹，并laptop_server.go在其中创建一个文件。</p>\n<p>我将声明一个LaptopServer结构和一个NewLaptopServer()函数来返回它的一个新实例：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LaptopServer is the server that provides laptop services</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> LaptopServer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewLaptopServer returns a new LaptopServer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewLaptopServer</span><span class=\"params\">()</span> *<span class=\"title\">LaptopServer</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;LaptopServer&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们需要实现接口CreateLaptop所需的LaptopServiceServer功能。</p>\n<p>它接受一个上下文和一个CreateLaptopRequest对象作为输入，并返回一个CreateLaptopResponse或一个错误。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// CreateLaptop Create a laptop</span><br><span class=\"line\">func (server *LaptopServer) CreateLaptop(ctx context.Context, req *pb.CreateLaptopRequest) (*pb.CreateLaptopResponse, error) &#123;</span><br><span class=\"line\">\tlaptop := req.GetLaptop()</span><br><span class=\"line\">\tlog.Printf(&quot;recieve a create-laptop request with id:%s&quot;, laptop.Id)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们调用GetLaptop函数从请求中获取笔记本电脑对象。</p>\n<p>如果客户端已经生成了笔记本电脑ID，我们必须检查它是否有效UUID。</p>\n<p>为此，我们使用Google UUID包。在终端中运行这个命令来安装它：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get github.com/google/uuid</span><br></pre></td></tr></table></figure>\n<p>之后，我们可以使用uuid.Parse()函数来解析笔记本电脑的 ID。</p>\n<p>如果它返回错误则意味着提供的 ID 无效，我们应该向客户端返回 nil 响应以及错误状态代码。</p>\n<p>为此，我们使用包的status和codes子grpc包。在这种情况下，我们返回InvalidArgument代码，因为笔记本电脑 ID 是由客户端提供的。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(laptop.Id) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// check if it&#x27;s a valid UUID</span></span><br><span class=\"line\">    _, err := uuid.Parse(laptop.Id)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, status.Errorf(codes.InvalidArgument, <span class=\"string\">&quot;laptop ID is not a valid UUID: %v&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    id, err := uuid.NewRandom()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, status.Errorf(codes.Internal, <span class=\"string\">&quot;cannot generate a new laptop ID: %v&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    laptop.Id = id.String()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果客户端没有发送笔记本电脑 ID，我们将在服务器上使用uuid.NewRandom()命令生成它。</p>\n<p>如果发生错误，我们将它与 一起返回codes.Internal，这意味着内部服务器错误。否则，我们只需将 设置laptop.ID为生成的随机 UUID。</p>\n<p>接下来我们应该检查请求是否超时或被客户端取消，因为如果是，那么没有理由继续处理请求。</p>\n<p>要检查这一点，我们只需使用以下ctx.Err()函数：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ctx.Err() == context.Canceled &#123;</span><br><span class=\"line\">    log.Print(<span class=\"string\">&quot;request is canceled&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, status.Error(codes.Canceled, <span class=\"string\">&quot;request is canceled&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> ctx.Err() == context.DeadlineExceeded &#123;</span><br><span class=\"line\">    log.Print(<span class=\"string\">&quot;deadline is exceeded&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, status.Error(codes.DeadlineExceeded, <span class=\"string\">&quot;deadline is exceeded&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"将笔记本信息保存在内存中\">将笔记本信息保存在内存中</h3>\n<p>通常在此之后，我们应该将笔记本电脑保存到数据库中。然而，这是一门关于 gRPC 的课程，所以我只想专注于它。因此，为简单起见，我将只使用内存存储。它对于以后的单元测试也将非常有用。</p>\n<p>laptop_store.go让我们在service文件夹中创建一个新文件</p>\n<p>由于我们可能有不同的存储类型，我们将其定义为LaptopStore接口，具有ave()将笔记本电脑保存到商店的功能。</p>\n<p>然后我们将编写一个InMemoryLaptopStore来实现这个接口。稍后，如果我们想将笔记本电脑保存到数据库中，我们总是可以实现另一个DBLaptopStore来这样做。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LaptopStore is a interface to store laptop</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> LaptopStore <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tSave(laptop *pb.Laptop) error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// InMemoryLaptopStore store laptops in memory</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> InMemoryLaptopStore <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tmutex sync.RWMutex</span><br><span class=\"line\">\tdata  <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*pb.Laptop</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个InMemoryLaptopStore中，我们使用映射来存储数据，其中键是笔记本电脑 ID，值是笔记本电脑对象。</p>\n<p>我们需要一个读写互斥体来处理多个并发请求以保存笔记本电脑。</p>\n<p>现在让我们声明一个函数来返回一个新的 InMemoryLaptopStore，并初始化其中的数据映射：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NewInMemoryLaptopStore returns a new InMemoryLaptopStore</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewInMemoryLaptopStore</span><span class=\"params\">()</span> *<span class=\"title\">InMemoryLaptopStore</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;InMemoryLaptopStore&#123;</span><br><span class=\"line\">        data: <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*pb.Laptop),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后Save按照界面要求实现笔记本功能。</p>\n<p>首先，我们需要在添加新对象之前获取写锁。请记住推迟解锁命令。</p>\n<p>接下来，我们检查笔记本电脑 ID 是否已经存在于map中。如果是这样，只需向调用者返回一个错误。</p>\n<p>应导出ErrAlreadyExists该变量，以便可以在此服务包之外使用它。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ErrAlreadyExists is returned when a record with the same ID already exists in the store</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrAlreadyExists = errors.New(<span class=\"string\">&quot;record already exists&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Save saves the laptop to the store</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *InMemoryLaptopStore)</span> <span class=\"title\">Save</span><span class=\"params\">(laptop *pb.Laptop)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    store.mutex.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> store.mutex.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> store.data[laptop.Id] != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ErrAlreadyExists</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    other, err := deepCopy(laptop)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    store.data[other.Id] = other</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果笔记本电脑不存在，我们可以将其保存到商店。但是，为了安全起见，我们应该对膝上型电脑对象进行深拷贝。</p>\n<p>为此，我们可以使用copier包：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get github.com/jinzhu/copier</span><br></pre></td></tr></table></figure>\n<p>然后我们可以用它来实现deepCopy()功能：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deepCopy</span><span class=\"params\">(laptop *pb.Laptop)</span> <span class=\"params\">(*pb.Laptop, error)</span></span> &#123;</span><br><span class=\"line\">    other := &amp;pb.Laptop&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err := copier.Copy(other, laptop)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, fmt.Errorf(<span class=\"string\">&quot;cannot copy laptop data: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> other, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好的，让我们回到我们的笔记本电脑服务器并laptopStore在结构中添加一个新字段LaptopServer。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LaptopServer is the server that provides laptop services</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> LaptopServer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    laptopStore LaptopStore</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NewLaptopServer returns a new LaptopServer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewLaptopServer</span><span class=\"params\">(laptopStore LaptopStore)</span> *<span class=\"title\">LaptopServer</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;LaptopServer&#123;laptopStore&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在CreateLaptop()函数中，我们可以调用server.Store.Save()将输入的笔记本电脑保存到商店。</p>\n<p>如果有错误，将错误返回codes.Internal给客户端。通过检查错误是否已经存在记录，我们可以让客户更清楚地处理。</p>\n<p>为此，<a href=\"http://xn--errors-hz8iy45au65am53b4s2cpt1a.Is\">我们只需调用errors.Is</a>()函数。如果是true，我们返回AlreadyExists状态码而不是Internal。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *LaptopServer)</span> <span class=\"title\">CreateLaptop</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    ctx context.Context,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    req *pb.CreateLaptopRequest,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span> <span class=\"params\">(*pb.CreateLaptopResponse, error)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    err := server.laptopStore.Save(laptop)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        code := codes.Internal</span><br><span class=\"line\">        <span class=\"keyword\">if</span> errors.Is(err, ErrAlreadyExists) &#123;</span><br><span class=\"line\">            code = codes.AlreadyExists</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, status.Errorf(code, <span class=\"string\">&quot;cannot save laptop to the store: %v&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Printf(<span class=\"string\">&quot;saved laptop with id: %s&quot;</span>, laptop.Id)</span><br><span class=\"line\"></span><br><span class=\"line\">    res := &amp;pb.CreateLaptopResponse&#123;</span><br><span class=\"line\">        Id: laptop.Id,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res, <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试一元-RPC-处理程序\">测试一元 RPC 处理程序</h3>\n<p>现在我将向您展示如何测试它。让我们创建一个service/laptop_server_test.go文件并将包名称设置为service_test. 然后我们创建一个函数TestServerCreateLaptop()。</p>\n<p>我想测试很多不同的情况，所以让我们使用表驱动测试。一个测试用例将有一个名称、一个输入的笔记本电脑对象、一个笔记本电脑商店和一个预期的状态码。</p>\n<p>第一种情况是客户端生成的带有笔记本电脑 ID 的成功呼叫。所以笔记本电脑将是一个sample.NewLaptop()，商店只是一个新的InMemoryLaptopStore，而预期的代码是OK。</p>\n<p>第二种情况也是通话成功，但没有笔记本电脑ID。我希望服务器为我们生成一个随机 ID。所以在这里我们生成一个示例笔记本电脑，并将其 ID 设置为空字符串。</p>\n<p>第三种情况是由于 UUID 无效而导致调用失败。因此，我们生成了一个示例笔记本电脑并将其 ID 设置为invalid-uuid。对于这种情况，我们希望状态码为InvalidArgument.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestLaptopServer_CreateLaptop</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">\tt.Parallel()</span><br><span class=\"line\"></span><br><span class=\"line\">\tlaptopNoID := sample.NewLaptop()</span><br><span class=\"line\">\tlaptopNoID.Id = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">\tlaptopInvalidID := sample.NewLaptop()</span><br><span class=\"line\">\tlaptopInvalidID.Id = <span class=\"string\">&quot;invalid-uuid&quot;</span></span><br><span class=\"line\">\tlaptopDuplicateID := sample.NewLaptop()</span><br><span class=\"line\">\tstoreDuplicateID := service.NewInMemoryLaptopStore()</span><br><span class=\"line\">\terr := storeDuplicateID.Save(laptopDuplicateID)</span><br><span class=\"line\">\trequire.Nil(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">\ttestCases := []<span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\t\tname   <span class=\"keyword\">string</span></span><br><span class=\"line\">\t\tlaptop *pb.Laptop</span><br><span class=\"line\">\t\tstore  service.LaptopStore</span><br><span class=\"line\">\t\tcode   codes.Code</span><br><span class=\"line\">\t&#125;&#123;</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tname:   <span class=\"string\">&quot;success_with_id&quot;</span>,</span><br><span class=\"line\">\t\t\tlaptop: sample.NewLaptop(),</span><br><span class=\"line\">\t\t\tstore:  service.NewInMemoryLaptopStore(),</span><br><span class=\"line\">\t\t\tcode:   codes.OK,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tname:   <span class=\"string\">&quot;success_no_id&quot;</span>,</span><br><span class=\"line\">\t\t\tlaptop: laptopNoID,</span><br><span class=\"line\">\t\t\tstore:  service.NewInMemoryLaptopStore(),</span><br><span class=\"line\">\t\t\tcode:   codes.OK,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tname:   <span class=\"string\">&quot;failure_invalid_id&quot;</span>,</span><br><span class=\"line\">\t\t\tlaptop: laptopInvalidID,</span><br><span class=\"line\">\t\t\tstore:  service.NewInMemoryLaptopStore(),</span><br><span class=\"line\">\t\t\tcode:   codes.InvalidArgument,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tname:   <span class=\"string\">&quot;failure_duplicate_id&quot;</span>,</span><br><span class=\"line\">\t\t\tlaptop: laptopDuplicateID,</span><br><span class=\"line\">\t\t\tstore:  storeDuplicateID,</span><br><span class=\"line\">\t\t\tcode:   codes.AlreadyExists,</span><br><span class=\"line\">\t\t&#125;,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好了，所有的测试用例都准备好了。现在我们用一个简单的 for 循环遍历它们。</p>\n<p>我们必须将当前的测试用例保存到一个局部变量中。这对于避免并发问题非常重要，因为我们要创建多个并行子测试。</p>\n<p>要创建子测试，我们调用t.Run()并使用tc.name子测试的名称。我们呼吁t.Parallel()使其与其他测试并行运行。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i := <span class=\"keyword\">range</span> testCases &#123;</span><br><span class=\"line\">    tc := testCases[i]</span><br><span class=\"line\"></span><br><span class=\"line\">    t.Run(tc.name, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">        t.Parallel()</span><br><span class=\"line\"></span><br><span class=\"line\">        req := &amp;pb.CreateLaptopRequest&#123;</span><br><span class=\"line\">            Laptop: tc.laptop,</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        server := service.NewLaptopServer(tc.store)</span><br><span class=\"line\">        res, err := server.CreateLaptop(context.Background(), req)</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们用输入构建一个新CreateLaptopRequest对象tc.laptop。我们使用内存中的笔记本电脑商店创建一个新LaptopServer的。</p>\n<p>然后只需调用server.CreateLaptop()带有背景上下文和请求对象的函数。</p>\n<p>现在有2种情况：</p>\n<p>成功的案例，或者tc.code是什么时候OK。在这种情况下，我们应该检查没有错误。响应不应该nil。返回的 ID 不能为空。如果输入的笔记本电脑已经有 ID，那么返回的 ID 应该等于它。</p>\n<p>失败案例，when tc.codeis not OK。我们检查应该有错误并且响应应该是nil。</p>\n<p>要检查状态码，我们调用status.FromError()以获取状态对象。检查ok应该是真的并且st.Code()应该等于tc.code。然后就完成了。</p>\n<p>但是，我们编写的测试还没有使用任何类型的网络调用。它们基本上只是服务器端的直接调用。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">res, err := server.CreateLaptop(context.Background(), req)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> tc.code == codes.OK &#123;</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.NotNil(t, res)</span><br><span class=\"line\">    require.NotEmpty(t, res.Id)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(tc.laptop.Id) &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        require.Equal(t, tc.laptop.Id, res.Id)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    require.Error(t, err)</span><br><span class=\"line\">    require.Nil(t, res)</span><br><span class=\"line\">    st, ok := status.FromError(err)</span><br><span class=\"line\">    require.True(t, ok)</span><br><span class=\"line\">    require.Equal(t, tc.code, st.Code())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"用真实连接测试一元-RPC\">用真实连接测试一元 RPC</h3>\n<p>现在我将向您展示如何使用真实连接测试来自客户端的 RPC 请求。</p>\n<p>让我们创建laptop_client_test.go文件。包名仍然是service_test，但函数名是 now TestClientCreateLaptop()。</p>\n<p>首先我们需要编写一个函数来启动 gRPC 服务器。它将 atesting.T作为参数，并返回服务器的网络地址字符串。</p>\n<p>在这个函数中，我们创建了一个新的笔记本电脑服务器，其中包含一个内存笔记本电脑存储。我们通过调用grpc.NewServer()函数创建 gRPC 服务器，然后在该 gRPC 服务器上注册笔记本电脑服务服务器。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startTestLaptopServer</span><span class=\"params\">(t *testing.T, laptopStore service.LaptopStore)</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    laptopServer := service.NewLaptopServer(laptopStore)</span><br><span class=\"line\"></span><br><span class=\"line\">    grpcServer := grpc.NewServer()</span><br><span class=\"line\">    pb.RegisterLaptopServiceServer(grpcServer, laptopServer)</span><br><span class=\"line\"></span><br><span class=\"line\">    listener, err := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;:0&quot;</span>) <span class=\"comment\">// random available port</span></span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">go</span> grpcServer.Serve(listener)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> listener.Addr().String()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们创建一个新的监听器来监听 tcp 连接。这里的数字 0 表示我们希望为它分配任何随机可用端口。</p>\n<p>然后我们就调用grpcServer.Serve()开始监听请求。这是一个阻塞调用，所以我们必须在一个单独的 go-routine 中运行它，因为我们想在那之后向这个服务器发送请求。</p>\n<p>最后我们只返回监听器的地址字符串。</p>\n<p>接下来我们将创建另一个函数来返回一个新的笔记本电脑客户端。此函数将testing.T对象和服务器地址作为其参数，然后返回一个pb.LaptopServiceClient.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestClientCreateLaptop</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    t.Parallel()</span><br><span class=\"line\"></span><br><span class=\"line\">    laptopStore := service.NewInMemoryLaptopStore()</span><br><span class=\"line\">    serverAddress := startTestLaptopServer(t, laptopStore)</span><br><span class=\"line\">    laptopClient := newTestLaptopClient(t, serverAddress)</span><br><span class=\"line\"></span><br><span class=\"line\">    laptop := sample.NewLaptop()</span><br><span class=\"line\">    expectedID := laptop.Id</span><br><span class=\"line\">    req := &amp;pb.CreateLaptopRequest&#123;</span><br><span class=\"line\">        Laptop: laptop,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里，我们创建了一个新的示例笔记本电脑，将其 ID 保存到一个变量中以供以后比较。我们用笔记本电脑创建一个新的请求对象。</p>\n<p>然后我们使用laptopClient对象来调用CreateLaptop()函数。我们检查是否没有返回错误并且响应应该是 not nil。返回的 ID 也应该与我们之前保存的预期 ID 匹配。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestClientCreateLaptop</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    res, err := laptopClient.CreateLaptop(context.Background(), req)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.NotNil(t, res)</span><br><span class=\"line\">    require.Equal(t, expectedID, res.Id)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们要确保笔记本电脑确实存储在服务器上。为此，我们需要向笔记本电脑商店再添加 1 个功能。</p>\n<p>这是Find()通过 ID 搜索笔记本电脑的功能。它将stringID 作为输入，并返回带有错误的笔记本电脑对象。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> LaptopStore <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Save saves the laptop to the store</span></span><br><span class=\"line\">    Save(laptop *pb.Laptop) error</span><br><span class=\"line\">    <span class=\"comment\">// Find finds a laptop by ID</span></span><br><span class=\"line\">    Find(id <span class=\"keyword\">string</span>) (*pb.Laptop, error)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Find finds a laptop by ID</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *InMemoryLaptopStore)</span> <span class=\"title\">Find</span><span class=\"params\">(id <span class=\"keyword\">string</span>)</span> <span class=\"params\">(*pb.Laptop, error)</span></span> &#123;</span><br><span class=\"line\">    store.mutex.RLock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> store.mutex.RUnlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    laptop := store.data[id]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> laptop == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> deepCopy(laptop)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这个函数中，我们首先调用mutex.RLock()获取读锁。</p>\n<p>然后我们store.data通过它的 id 从地图中获取笔记本电脑。如果没有找到，就返回nil。否则，我们应该返回找到的笔记本电脑的深层副本。</p>\n<p>现在回到我们的客户端测试。我们调用laptopServer.Store.Find() 通过ID 查找笔记本电脑。检查没有错误，笔记本电脑不应该是零。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">TestClientCreateLaptop</span><span class=\"params\">(t *testing.T)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check that the laptop is saved to the store</span></span><br><span class=\"line\">    other, err := laptopStore.Find(res.Id)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\">    require.NotNil(t, other)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// check that the saved laptop is the same as the one we send</span></span><br><span class=\"line\">    requireSameLaptop(t, laptop, other)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，我们要检查保存的笔记本电脑是否与我们发送的笔记本电脑相同。让我们为此编写一个单独的函数。</p>\n<p>它将有 3 个输入：testing.T对象和 2 个笔记本电脑对象。</p>\n<p>现在如果我们只使用require.Equal()函数来比较这两个对象，测试将失败。</p>\n<p>这是因为在 Laptop 结构中，gRPC 内部使用一些特殊字段来序列化对象。因此，要正确比较 2 台笔记本电脑，我们必须忽略这些特殊字段。</p>\n<p>一种简单的方法是将对象序列化为 JSON，然后比较 2 个输出 JSON 字符串：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">requireSameLaptop</span><span class=\"params\">(t *testing.T, laptop1 *pb.Laptop, laptop2 *pb.Laptop)</span></span> &#123;</span><br><span class=\"line\">    json1, err := serializer.ProtobufToJSON(laptop1)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    json2, err := serializer.ProtobufToJSON(laptop2)</span><br><span class=\"line\">    require.NoError(t, err)</span><br><span class=\"line\"></span><br><span class=\"line\">    require.Equal(t, json1, json2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"编写主服务器和客户端\">编写主服务器和客户端</h3>\n<p>接下来，我们将实现main.gogRPC 服务器和客户端的入口点。</p>\n<p>让我们创建一个新cmd文件夹，然后在这个文件夹中，server为client. 每个都有自己的main.go文件。</p>\n<p>然后还更新Makefile为服务器和客户端二进制文件有 2 个运行命令：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">server:</span></span><br><span class=\"line\">    go run cmd/server/main.go -port 8080</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">client:</span></span><br><span class=\"line\">    go run cmd/client/main.go -address 0.0.0.0:8080</span><br></pre></td></tr></table></figure>\n<p>现在让我们实现server/main.go.</p>\n<p>我们需要一个服务器端口，所以我使用该flag.Int()函数从命令行参数中获取它。</p>\n<p>与我们在单元测试中编写的类似，我们创建了一个带有内存存储的新笔记本电脑服务器对象。然后我们创建一个新的 gRPC 服务器并向其注册笔记本电脑服务器。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    port := flag.Int(<span class=\"string\">&quot;port&quot;</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;the server port&quot;</span>)</span><br><span class=\"line\">    flag.Parse()</span><br><span class=\"line\">    log.Printf(<span class=\"string\">&quot;start server on port %d&quot;</span>, *port)</span><br><span class=\"line\"></span><br><span class=\"line\">    laptopStore := service.NewInMemoryLaptopStore()</span><br><span class=\"line\">    laptopServer := service.NewLaptopServer(laptopStore)</span><br><span class=\"line\">    pb.RegisterLaptopServiceServer(grpcServer, laptopServer)</span><br><span class=\"line\"></span><br><span class=\"line\">    address := fmt.Sprintf(<span class=\"string\">&quot;0.0.0.0:%d&quot;</span>, *port)</span><br><span class=\"line\">    listener, err := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, address)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot start server: &quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    err = grpcServer.Serve(listener)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot start server: &quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们使用之前获得的端口创建一个地址字符串，然后在该服务器地址上侦听 TCP 连接。</p>\n<p>最后我们调用grpcServer.Serve()启动服务器。如果发生任何错误，只需写一个致命日志并退出。这就是服务器代码。</p>\n<p>现在是客户。首先，我们从命令行参数中获取服务器地址。</p>\n<p>我们grpc.Dial()用输入地址调用函数，现在只是创建一个不安全的连接。</p>\n<p>如果发生错误，我们会写一个致命日志并退出。否则，我们使用连接创建一个新的笔记本电脑客户端对象。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    serverAddress := flag.String(<span class=\"string\">&quot;address&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;the server address&quot;</span>)</span><br><span class=\"line\">    flag.Parse()</span><br><span class=\"line\">    log.Printf(<span class=\"string\">&quot;dial server %s&quot;</span>, *serverAddress)</span><br><span class=\"line\"></span><br><span class=\"line\">    conn, err := grpc.Dial(*serverAddress, grpc.WithInsecure())</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot dial server: &quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    laptopClient := pb.NewLaptopServiceClient(conn)</span><br><span class=\"line\"></span><br><span class=\"line\">    laptop := sample.NewLaptop()</span><br><span class=\"line\">    req := &amp;pb.CreateLaptopRequest&#123;</span><br><span class=\"line\">        Laptop: laptop,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// set timeout</span></span><br><span class=\"line\">    ctx, cancel := context.WithTimeout(context.Background(), <span class=\"number\">5</span>*time.Second)</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> cancel()</span><br><span class=\"line\"></span><br><span class=\"line\">    res, err := laptopClient.CreateLaptop(ctx, req)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        st, ok := status.FromError(err)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ok &amp;&amp; st.Code() == codes.AlreadyExists &#123;</span><br><span class=\"line\">            <span class=\"comment\">// not a big deal</span></span><br><span class=\"line\">            log.Print(<span class=\"string\">&quot;laptop already exists&quot;</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.Fatal(<span class=\"string\">&quot;cannot create laptop: &quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Printf(<span class=\"string\">&quot;created laptop with id: %s&quot;</span>, res.Id)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们生成一个新的笔记本电脑，创建一个新的请求对象，然后laptopClient.Createlaptop()使用请求和上下文调用函数。这里我们context.WithTimeout()用来设置这个请求的超时时间为 5 秒。</p>\n<p>如果错误不是nil，我们将其转换为状态对象。如果状态码是AlreadyExists那么没什么大不了的，写个普通的log就行了。否则，我们会写一个致命的日志。</p>\n<p>如果一切正常，我们只需写一个日志，说明笔记本电脑是使用此 ID 创建的。对客户来说就是这样。</p>\n<h2 id=\"在-Go-中实现服务器流式-gRPC\">在 Go 中实现服务器流式 gRPC</h2>\n<h3 id=\"将服务器流式-RPC-定义添加到-Protobuf\">将服务器流式 RPC 定义添加到 Protobuf</h3>\n<p>我们的 RPC 将允许我们搜索满足某些配置要求的笔记本电脑。所以我会创建一个filter_message.proto文件。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax = &quot;proto3&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">package techschool.pcbook;</span><br><span class=\"line\"></span><br><span class=\"line\">option go_package = &quot;pb&quot;;</span><br><span class=\"line\">option java_package = &quot;com.gitlab.techschool.pcbook.pb&quot;;</span><br><span class=\"line\">option java_multiple_files = true;</span><br><span class=\"line\"></span><br><span class=\"line\">import &quot;memory_message.proto&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">message Filter &#123;</span><br><span class=\"line\">  double max_price_usd = 1;</span><br><span class=\"line\">  uint32 min_cpu_cores = 2;</span><br><span class=\"line\">  double min_cpu_ghz = 3;</span><br><span class=\"line\">  Memory min_ram = 4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此消息将定义我们要查找的笔记本电脑类型，例如：</p>\n<p>我们愿意为笔记本电脑支付的最高价格。<br>\n笔记本电脑 CPU 应具有的最小内核数。<br>\nCPU 的最低频率。<br>\n以及 RAM 的最小大小。<br>\n然后我们将在文件中定义新的服务器流式 RPC laptop_service.proto。</p>\n<p>我们定义SearchLaptopRequest仅包含 1 个Filter字段的 和SearchLaptopResponse仅包含 1 个Laptop字段的 a。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">message SearchLaptopRequest &#123; </span><br><span class=\"line\">    Filter filter = 1; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message SearchLaptopResponse &#123; </span><br><span class=\"line\">    Laptop laptop = 1; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>服务器流式 RPC 的定义方式与一元 RPC 类似。以 rpc 关键字开头，然后 RPC 名称为SearchLaptop。输入为SearchLaptopRequest，输出为SearchLaptopResponse.</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">service LaptopService &#123;</span><br><span class=\"line\">  rpc CreateLaptop(CreateLaptopRequest) returns (CreateLaptopResponse) &#123;&#125;;</span><br><span class=\"line\">  rpc SearchLaptop(SearchLaptopRequest) returns (stream SearchLaptopResponse) &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"将搜索功能添加到内存存储中\">将搜索功能添加到内存存储中</h3>\n<p>在实现服务器之前，让我们在接口中添加一个新Search()功能LaptopStore。</p>\n<p>它需要一个过滤器作为输入，以及一个回调函数，以便在找到笔记本电脑时进行报告。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> LaptopStore <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Save(laptop *pb.Laptop) error</span><br><span class=\"line\">    Find(id <span class=\"keyword\">string</span>) (*pb.Laptop, error)</span><br><span class=\"line\">    Search(ctx context.Context, filter *pb.Filter, found <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(laptop *pb.Laptop)</span> <span class=\"title\">error</span>) <span class=\"title\">error</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上下文用于控制请求的期限/超时。我们稍后会看到它是如何工作的。</p>\n<p>现在我们应该Search()为InMemoryLaptopStore.</p>\n<p>由于我们正在读取数据，我们必须获得一个读取锁，然后再解锁它。我们遍历商店中的所有笔记本电脑，并检查哪一台符合过滤条件。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Search searches for laptops with filter, returns one by one via the found function</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *InMemoryLaptopStore)</span> <span class=\"title\">Search</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    ctx context.Context,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    filter *pb.Filter,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    found <span class=\"keyword\">func</span>(laptop *pb.Laptop)</span> <span class=\"title\">error</span>,</span></span><br><span class=\"line\">) error &#123;</span><br><span class=\"line\">    store.mutex.RLock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> store.mutex.RUnlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, laptop := <span class=\"keyword\">range</span> store.data &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ctx.Err() == context.Canceled || ctx.Err() == context.DeadlineExceeded &#123;</span><br><span class=\"line\">            log.Print(<span class=\"string\">&quot;context is cancelled&quot;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> isQualified(filter, laptop) &#123;</span><br><span class=\"line\">            other, err := deepCopy(laptop)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> err</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            err = found(other)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> err</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 for 循环中，在检查笔记本电脑是否合格之前，我们会检查上下文错误是否Cancelled存在DeadlineExceeded。如果是，我们应该立即返回，因为请求要么已经超时，要么被客户端取消，所以继续搜索只是浪费时间。</p>\n<p>当笔记本电脑合格后，我们必须在通过回调函数将其发送给调用者之前对其进行深度复制found()。</p>\n<p>该isQualified()函数将过滤器和笔记本电脑作为输入，如果笔记本电脑满足过滤器，则返回 true。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">isQualified</span><span class=\"params\">(filter *pb.Filter, laptop *pb.Laptop)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> laptop.GetPriceUsd() &gt; filter.GetMaxPriceUsd() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> laptop.GetCpu().GetNumberCores() &lt; filter.GetMinCpuCores() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> laptop.GetCpu().GetMinGhz() &lt; filter.GetMinCpuGhz() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> toBit(laptop.GetRam()) &lt; toBit(filter.GetMinRam()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于存在不同类型的内存单元，为了比较 RAM，我们必须编写一个函数将其值转换为最小单位：BIT。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toBit</span><span class=\"params\">(memory *pb.Memory)</span> <span class=\"title\">uint64</span></span> &#123;</span><br><span class=\"line\">    value := memory.GetValue()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> memory.GetUnit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> pb.Memory_BIT:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value</span><br><span class=\"line\">    <span class=\"keyword\">case</span> pb.Memory_BYTE:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value &lt;&lt; <span class=\"number\">3</span> <span class=\"comment\">// 8 = 2^3</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> pb.Memory_KILOBYTE:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value &lt;&lt; <span class=\"number\">13</span> <span class=\"comment\">// 1024 * 8 = 2^10 * 2^3 = 2^13</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> pb.Memory_MEGABYTE:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value &lt;&lt; <span class=\"number\">23</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> pb.Memory_GIGABYTE:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value &lt;&lt; <span class=\"number\">33</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> pb.Memory_TERABYTE:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value &lt;&lt; <span class=\"number\">43</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"实现服务器\">实现服务器</h3>\n<p>我们将不得不实现接口的SearchLaptop()功能LaptopServiceServer。它有 2 个参数：输入请求和输出流响应。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SearchLaptop is a server-streaming RPC to search for laptops</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *LaptopServer)</span> <span class=\"title\">SearchLaptop</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    req *pb.SearchLaptopRequest,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    stream pb.LaptopService_SearchLaptopServer,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    filter := req.GetFilter()</span><br><span class=\"line\">    log.Printf(<span class=\"string\">&quot;receive a search-laptop request with filter: %v&quot;</span>, filter)</span><br><span class=\"line\"></span><br><span class=\"line\">    err := server.laptopStore.Search(</span><br><span class=\"line\">        stream.Context(),</span><br><span class=\"line\">        filter,</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(laptop *pb.Laptop)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">            res := &amp;pb.SearchLaptopResponse&#123;Laptop: laptop&#125;</span><br><span class=\"line\">            err := stream.Send(res)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> err</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            log.Printf(<span class=\"string\">&quot;sent laptop with id: %s&quot;</span>, laptop.GetId())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> status.Errorf(codes.Internal, <span class=\"string\">&quot;unexpected error: %v&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们要做的第一件事是从请求中获取过滤器。然后我们调用server.Store.Search()，传入流上下文、过滤器和回调函数。</p>\n<p>如果发生错误，我们将其与Internal状态码一起返回，否则我们返回 nil。</p>\n<p>在回调函数中，当我们找到一台笔记本电脑时，我们用该笔记本电脑创建一个新的响应对象，并通过调用stream.Send().</p>\n<p>如果发生错误，只需返回它。否则，我们会写一个简单的日志，说明我们已经用这个 ID 发送了笔记本电脑，然后返回 nil。</p>\n<p>我们已经完成了服务器。现在让我们实现客户端！</p>\n<h3 id=\"实现客户端\">实现客户端</h3>\n<p>首先，我将拆分代码以创建我们在上一课中编写的随机笔记本电脑到一个单独的函数：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createLaptop</span><span class=\"params\">(laptopClient pb.LaptopServiceClient)</span></span> &#123;</span><br><span class=\"line\">    laptop := sample.NewLaptop()</span><br><span class=\"line\">    laptop.Id = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    req := &amp;pb.CreateLaptopRequest&#123;</span><br><span class=\"line\">        Laptop: laptop,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// set timeout</span></span><br><span class=\"line\">    ctx, cancel := context.WithTimeout(context.Background(), <span class=\"number\">5</span>*time.Second)</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> cancel()</span><br><span class=\"line\"></span><br><span class=\"line\">    res, err := laptopClient.CreateLaptop(ctx, req)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        st, ok := status.FromError(err)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ok &amp;&amp; st.Code() == codes.AlreadyExists &#123;</span><br><span class=\"line\">            <span class=\"comment\">// not a big deal</span></span><br><span class=\"line\">            log.Print(<span class=\"string\">&quot;laptop already exists&quot;</span>)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.Fatal(<span class=\"string\">&quot;cannot create laptop: &quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    log.Printf(<span class=\"string\">&quot;created laptop with id: %s&quot;</span>, res.Id)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在 main 函数中，我们将使用一个 for 循环来创建 10 台随机笔记本电脑。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    serverAddress := flag.String(<span class=\"string\">&quot;address&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;the server address&quot;</span>)</span><br><span class=\"line\">    flag.Parse()</span><br><span class=\"line\">    log.Printf(<span class=\"string\">&quot;dial server %s&quot;</span>, *serverAddress)</span><br><span class=\"line\"></span><br><span class=\"line\">    conn, err := grpc.Dial(*serverAddress, grpc.WithInsecure())</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot dial server: &quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    laptopClient := pb.NewLaptopServiceClient(conn)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++ &#123;</span><br><span class=\"line\">        createLaptop(laptopClient)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    filter := &amp;pb.Filter&#123;</span><br><span class=\"line\">        MaxPriceUsd: <span class=\"number\">3000</span>,</span><br><span class=\"line\">        MinCpuCores: <span class=\"number\">4</span>,</span><br><span class=\"line\">        MinCpuGhz:   <span class=\"number\">2.5</span>,</span><br><span class=\"line\">        MinRam:      &amp;pb.Memory&#123;Value: <span class=\"number\">8</span>, Unit: pb.Memory_GIGABYTE&#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    searchLaptop(laptopClient, filter)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们创建一个新的搜索过滤器。假设我想搜索笔记本电脑：</p>\n<ul>\n<li>最高价3000</li>\n<li>至少 4 个 CPU 内核</li>\n<li>最低频率为 2.5 Ghz</li>\n<li>以及至少 8 GB 的 RAM<br>\n之后，我们searchLaptop()使用 this 过滤器调用。让我们实现这个功能！</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">searchLaptop</span><span class=\"params\">(laptopClient pb.LaptopServiceClient, filter *pb.Filter)</span></span> &#123;</span><br><span class=\"line\">    log.Print(<span class=\"string\">&quot;search filter: &quot;</span>, filter)</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx, cancel := context.WithTimeout(context.Background(), <span class=\"number\">5</span>*time.Second)</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> cancel()</span><br><span class=\"line\"></span><br><span class=\"line\">    req := &amp;pb.SearchLaptopRequest&#123;Filter: filter&#125;</span><br><span class=\"line\">    stream, err := laptopClient.SearchLaptop(ctx, req)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        log.Fatal(<span class=\"string\">&quot;cannot search laptop: &quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        res, err := stream.Recv()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            log.Fatal(<span class=\"string\">&quot;cannot receive response: &quot;</span>, err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        laptop := res.GetLaptop()</span><br><span class=\"line\">        log.Print(<span class=\"string\">&quot;- found: &quot;</span>, laptop.GetId())</span><br><span class=\"line\">        log.Print(<span class=\"string\">&quot;  + brand: &quot;</span>, laptop.GetBrand())</span><br><span class=\"line\">        log.Print(<span class=\"string\">&quot;  + name: &quot;</span>, laptop.GetName())</span><br><span class=\"line\">        log.Print(<span class=\"string\">&quot;  + cpu cores: &quot;</span>, laptop.GetCpu().GetNumberCores())</span><br><span class=\"line\">        log.Print(<span class=\"string\">&quot;  + cpu min ghz: &quot;</span>, laptop.GetCpu().GetMinGhz())</span><br><span class=\"line\">        log.Print(<span class=\"string\">&quot;  + ram: &quot;</span>, laptop.GetRam())</span><br><span class=\"line\">        log.Print(<span class=\"string\">&quot;  + price: &quot;</span>, laptop.GetPriceUsd())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们首先创建一个超时时间为 5 秒的上下文。我们SearchLaptopRequest用输入过滤器制作一个对象。然后我们调用laptopClient.SearchLaptop()获取流。</p>\n<p>如果有错误，写一个致命日志。否则，我们使用 for 循环从流中接收多个响应。</p>\n<p>如果stream.Recv()函数调用返回一个文件结束 (EOF) 错误，这意味着它是流的结尾，所以我们只是返回。否则，如果 error 不为零，我们会写一个致命日志。</p>\n<p>如果一切顺利，我们可以从流中获取笔记本电脑。这里我只打印了笔记本电脑的一些属性，以便于阅读。</p>\n<h2 id=\"使用客户端流式-gRPC-分块上传文件-Go\">使用客户端流式 gRPC 分块上传文件 - Go</h2>\n<h3 id=\"在proto文件中定义client-streaming-RPC\">在proto文件中定义client-streaming RPC</h3>\n<p>laptop_service.proto让我们在文件中定义新的 RPC 。</p>\n<p>首先，我们需要一条UploadImageRequest消息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">message UploadImageRequest &#123;</span><br><span class=\"line\">  oneof data &#123;</span><br><span class=\"line\">    ImageInfo info = 1;</span><br><span class=\"line\">    bytes chunk_data = 2;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>路是将图像文件分成多个块，在每个请求消息中一个一个地发送给服务器。我oneof在这里使用一个字段，因为第一个请求将只包含元数据，或者图像的一些基本信息。然后以下请求将包含图像数据块。</p>\n<p>该ImageInfo消息将包含 2 个字符串字段：笔记本电脑 ID 和图像类型，例如“.jpg”或“.png”。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">message ImageInfo &#123;</span><br><span class=\"line\">  string laptop_id = 1;</span><br><span class=\"line\">  string image_type = 2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我们定义一条UploadImageResponse消息，一旦服务器接收到所有图像块，该消息将返回给客户端：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">message UploadImageResponse &#123;</span><br><span class=\"line\">  string id = 1;</span><br><span class=\"line\">  uint32 size = 2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好的，现在我们定义UploadImageRPC。这是一个客户端流式 RPC，因此它需要一个流UploadImageRequest作为输入并返回 1 个 single UploadImageResponse。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">service LaptopService &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  rpc UploadImage(stream UploadImageRequest) returns (UploadImageResponse) &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好的，现在让我们运行makegen 来生成代码。</p>\n<p>成功生成代码后，我们会看到代码中有一些错误，因为笔记本服务器没有实现接口UploadImage()所需的方法LaptopServiceServer。</p>\n<h3 id=\"实现服务器-2\">实现服务器</h3>\n<p>让我们打开laptop_server.go文件并将UploadImage()函数添加到LaptopServer结构中。laptop_service.pb.go我们可以很容易地在生成的文件中找到它的签名。只需将其复制并粘贴到laptop_server.go文件中：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *LaptopServer)</span> <span class=\"title\">UploadImage</span><span class=\"params\">(stream pb.LaptopService_UploadImageServer)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>让我们暂时返回nil。我们稍后会在实现图像存储后回到这个功能。</p>\n<h4 id=\"实现图片存储\">实现图片存储</h4>\n<p>store的作用是将上传的图片文件保存在服务器或云端的某处。为了使其更通用和更容易更改为不同类型的存储，我们将其定义ImageStore为接口。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ImageStore <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    Save(laptopID <span class=\"keyword\">string</span>, imageType <span class=\"keyword\">string</span>, imageData bytes.Buffer) (<span class=\"keyword\">string</span>, error)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>它有 1 个函数来保存笔记本电脑图像，它需要 3 个输入参数：笔记本电脑 ID、图像类型和字节缓冲区给出的图像数据。它会返回已保存图像的 ID，否则会出错。</p>\n<p>接下来我们将使用 实现这个接口DiskImageStore，它将图像文件保存到磁盘，并将其信息存储在内存中。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> DiskImageStore <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    mutex       sync.RWMutex</span><br><span class=\"line\">    imageFolder <span class=\"keyword\">string</span></span><br><span class=\"line\">    images      <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*ImageInfo</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与笔记本电脑商店类似，我们需要一个互斥锁来处理并发。然后我们需要文件夹的路径来保存笔记本电脑图像。最后一张map，key是图片ID，value是图片的一些信息。</p>\n<p>ImageInfo 包含 3 个字段：笔记本电脑的 ID、图像的类型（或其文件扩展名：jpg/png）和图像文件在磁盘上的路径。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ImageInfo <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    LaptopID <span class=\"keyword\">string</span></span><br><span class=\"line\">    Type     <span class=\"keyword\">string</span></span><br><span class=\"line\">    Path     <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>让我们编写一个函数来创建一个新的DiskImageStore. 它只有 1 个输入，即图像文件夹。在里面，我们只需要初始化images地图：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewDiskImageStore</span><span class=\"params\">(imageFolder <span class=\"keyword\">string</span>)</span> *<span class=\"title\">DiskImageStore</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;DiskImageStore&#123;</span><br><span class=\"line\">        imageFolder: imageFolder,</span><br><span class=\"line\">        images:      <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*ImageInfo),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们必须实现接口Save()所需的ImageStore功能。</p>\n<p>首先，我们必须为图像生成一个新的随机 UUID。我们通过加入图像文件夹、图像 ID 和图像类型来创建存储图像的路径。</p>\n<p>然后我们调用os.Create()创建文件。我们调用imageData.WriteTo()将图像数据写入创建的文件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(store *DiskImageStore)</span> <span class=\"title\">Save</span><span class=\"params\">(laptopID <span class=\"keyword\">string</span>, imageType <span class=\"keyword\">string</span>, imageData bytes.Buffer)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span> &#123;</span><br><span class=\"line\">    imageID, err := uuid.NewRandom()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, fmt.Errorf(<span class=\"string\">&quot;cannot generate image id: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    imagePath := fmt.Sprintf(<span class=\"string\">&quot;%s/%s%s&quot;</span>, store.imageFolder, imageID, imageType)</span><br><span class=\"line\"></span><br><span class=\"line\">    file, err := os.Create(imagePath)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, fmt.Errorf(<span class=\"string\">&quot;cannot create image file: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _, err = imageData.WriteTo(file)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>, fmt.Errorf(<span class=\"string\">&quot;cannot write image to file: %w&quot;</span>, err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    store.mutex.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> store.mutex.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    store.images[imageID.String()] = &amp;ImageInfo&#123;</span><br><span class=\"line\">        LaptopID: laptopID,</span><br><span class=\"line\">        Type:     imageType,</span><br><span class=\"line\">        Path:     imagePath,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> imageID.String(), <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果文件写入成功，我们需要将其信息保存到内存映射中。所以我们要获取store的写锁。</p>\n<p>然后我们将图片信息保存到map中，key为图片的ID，value包含笔记本ID、图片类型、图片文件路径。</p>\n<p>最后，我们将图像 ID 返回给调用者。就是这样，我们完成了图像存储。现在让我们回到服务器。</p>\n<h4 id=\"实现-UploadImage-RPC\">实现 UploadImage RPC</h4>\n<p>我们需要将新的图像存储添加到LaptopServer结构中，并添加imageStore作为函数的第二个参数NewLaptopServer()：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> LaptopServer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    laptopStore LaptopStore</span><br><span class=\"line\">    imageStore  ImageStore</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewLaptopServer</span><span class=\"params\">(laptopStore LaptopStore, imageStore ImageStore)</span> *<span class=\"title\">LaptopServer</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;LaptopServer&#123;laptopStore, imageStore&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// UploadImage upload images</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server *LaptopServer)</span> <span class=\"title\">UploadImage</span><span class=\"params\">(stream pb.LaptopService_UploadImageServer)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\treq, err := stream.Recv()</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> logError(status.Errorf(codes.Unknown, <span class=\"string\">&quot;cannot receive image info&quot;</span>))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tlaptopID := req.GetInfo().GetLaptopId()</span><br><span class=\"line\">\timageType := req.GetInfo().GetImageType()</span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">&quot;receive an upload-image request for laptop %s with image type %s&quot;</span>, laptopID, imageType)</span><br><span class=\"line\"></span><br><span class=\"line\">\tlaptop, err := server.laptopStore.Find(laptopID)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> logError(status.Errorf(codes.Internal, <span class=\"string\">&quot;cannot find laptop:%v&quot;</span>, err))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> laptop == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> logError(status.Errorf(codes.InvalidArgument, <span class=\"string\">&quot;laptop id %s doesn&#x27;t exist&quot;</span>, laptopID))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\timageData := bytes.Buffer&#123;&#125;</span><br><span class=\"line\">\timageSize := <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">\t\tlog.Print(<span class=\"string\">&quot;waiting to receive more data...&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\treq, err := stream.Recv()</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">\t\t\tlog.Print(<span class=\"string\">&quot;no more data&quot;</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> logError(status.Errorf(codes.Unknown, <span class=\"string\">&quot;cannot receive chunk data:%v&quot;</span>, err))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tchunk:=req.GetChunkData()</span><br><span class=\"line\">\t\tsize:=<span class=\"built_in\">len</span>(chunk)</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tlog.Printf(<span class=\"string\">&quot;received a chunk with size:%d&quot;</span>,size)</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\timageSize+=size</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> imageSize&gt;maxImageSize&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> logError(status.Errorf(codes.InvalidArgument,<span class=\"string\">&quot;cannot write chunk data:%v&quot;</span>,err))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t_,err=imageData.Write(chunk)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> err!=<span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> logError(status.Errorf(codes.Internal,<span class=\"string\">&quot;cannot write chunk data:%v&quot;</span>,err))</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\timageID,err:=server.imageStore.Save(laptopID,imageType,imageData)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> logError(status.Errorf(codes.Internal,<span class=\"string\">&quot;cannot save image to the store:%v&quot;</span>,err))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tres:=&amp;pb.UploadImageResponse&#123;</span><br><span class=\"line\">\t\tId: imageID,</span><br><span class=\"line\">\t\tSize: <span class=\"keyword\">uint32</span>(imageSize),</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\terr=stream.SendAndClose(res)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> logError(status.Errorf(codes.Unknown,<span class=\"string\">&quot;cannot send response:%v&quot;</span>,err))</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlog.Printf(<span class=\"string\">&quot;saved image with id:%s,size:%d&quot;</span>,imageID,imageSize)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">logError</span><span class=\"params\">(err error)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tlog.Print(err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["go"],"tags":["RPC框架"]},{"title":"KERL:A Knowledge-Guided Reinforcement Learning Model for Sequential Recommendation","url":"/2022/04/29/KERL-A-Knowledge-Guided-Reinforcement-Learning-Model-for-Sequential-Recommendation/","content":"<h2 id=\"摘要-3\">摘要</h2>\n<p>对于序列推荐来说,获取并预测用户未来的偏好来生成准确的推荐是很重要的。为了增强这一能力,作者采用了强化学习。但是用户-商品的交互数据可能会比较稀疏、复杂并且随时间变化。直接使用RL来改善推荐能力没那么简单。</p>\n<p>受到知识图谱的启发,作者提出了一个KERL模型来将知识图谱的信息聚合到序列推荐的强化学习框架中。作者将序列推荐任务描述为一个马尔可夫决策过程,在框架中做出了三个主要的技术扩展,包括状态表示、奖励函数和学习算法。</p>\n<span id=\"more\"></span>\n<p>首先,作者提出在考虑开发和探索的情况下利用知识图谱信息增强状态表示。其次,作者设计了一个组合奖励函数,能够计算序列级和知识级的奖励。最后,作者提出了一个新的算法来更加高效地训练所提出的模型。</p>\n<h2 id=\"引言-3\">引言</h2>\n<p>序列推荐的一些传统的方法比如矩阵分解方法、循环神经网络等都是使用最大似然估计来一步步拟合用户的交互序列。但是这些研究对于优化目标的整体有效性没有进行很好刻画。强化学习通过考虑最大化长期表现提供了一个有前景的方法。</p>\n<p>虽然在理论上很有吸引力,但在实际应用中,如何优化序列推荐的长期奖励是一个大问题。首先用户的行为数据可能比较少,这样去学习一个更复杂的优化目标的困难就更大了。其次,RL的一个核心机制是探索过程,用一个随机的探索策略来获取用户兴趣的变化并不可靠。将RL算法应用到序列推荐中需要一个更加可控的学习过程。受到知识图谱的启发,作者采用启发式的知识图谱数据来指导基于强化学习的方法进行序列推荐。</p>\n<p>之前的研究主要是将知识图谱用于开发过程,很少考虑其在探索过程中的效果。因此,他们无法获取到用户喜好的潜在漂移。如下图所示,用户按序看了五部电影。总体的顺序可以分为两个连续的反映不同电影喜好的阶段。直观上,知识图谱数据能够在每个阶段帮助提高推荐表现,因为同阶段中的电影有相同的知识图谱特征,但是两个阶段中的电影在许多方面有着本质上的不同,现有的知识感知的顺序推荐器很可能在第一阶段被“困住”,不能有效地捕获两个阶段之间的偏好漂移。这样的问题本质上就是开发和探索之间的权衡问题。考虑到这两个因素,为了更好地利用知识信息,需要开发一种更原则性的顺序推荐方法。</p>\n<h2 id=\"前期准备\">前期准备</h2>\n<h3 id=\"符号\">符号</h3>\n<p>U表示用户的集合,I表示商品的集合。对于每一个用户$u\\in U$,用$i_{1:n}^u = i_1^u \\rightarrow i_2^u \\rightarrow \\dots \\rightarrow i_n^u$表示用户u的交互序列,同样用$i_{j:k}^u$表示其中的一个子序列。知识图谱G中的每一条记录都是一个包含了两个实体和一些关系的知识三元组。</p>\n<h3 id=\"任务定义\">任务定义</h3>\n<p>基于上述符号,序列推荐的任务旨在预测用户u在给定$i_{1:n}^u$和 G的情况下下一个会选择的商品。</p>\n<h3 id=\"马尔可夫决策过程-MDP\">马尔可夫决策过程(MDP)</h3>\n<p>MDP可以表述为一个五元组$&lt;S,A,T,R,\\pi&gt;$:</p>\n<ul>\n<li>S是状态的集合,每一个$s\\in S$都表示环境的信息状态</li>\n<li>A是行为的集合,每一个$a\\in A$都表示客户可以执行的行为</li>\n<li>T是状态转换函数,根据行为和当前状态来更新状态,比如$s_{t+1}=T(s_t,a_t)$</li>\n<li>R是奖励函数,$r=R(s,a)$<br>\n-$\\pi (a|s)$描述用户的行为,通常是通过可能行为的概率分布建模的</li>\n</ul>\n<h2 id=\"方法-3\">方法</h2>\n<h3 id=\"MDP公式\">MDP公式</h3>\n<p>在MDP中,有客户会在离散的时间步上和环境进行交互。在每一个时间步t,过程处于某个状态$s_t\\in S$。在本任务中,环境的状态可以认为是包含了所有对序列推荐有用的信息,包括交互历史信息和知识图谱。本例中,只考虑这两个主要部分</p>\n<p><img src=\"https://i.imgur.com/8eNPC92.png\" alt=\"picture 1\"></p>\n<p>初始状态设置为$s_0=[\\emptyset,G]$。我们可以使用嵌入向量$v_{s_t} \\in R^{L_s}$来对状态信息进行编码。</p>\n<p>根据状态$s_t$,客户会执行一个行为$a_t\\in A$,从商品集I中选出$i_{t+1}$作为推荐。该行为通过策略$\\pi (s_t)$建模,即一个函数以$s_t$为输入,输出一个可能的商品的概率分布。在本文中使用softmax计算概率：</p>\n<p><img src=\"https://i.imgur.com/cxVktdj.png\" alt=\"picture 2\"></p>\n<p>其中$q_j\\in R^{L_I}$表示第j个商品的嵌入向量,$W_1$是双线性映射的参数,$v_{s_t}$是状态$s_t$的嵌入向量。</p>\n<p>每个行为过后,客户会收到一个数字中间奖励,比如$r_{t+1}=R(s_t,a_t)$。奖励函数可以反映我们任务所需要的推荐表现。此外,还使用了转换函数$T(T:S\\times T \\rightarrow S)$来更新状态</p>\n<p><img src=\"https://i.imgur.com/Ls6w3TV.png\" alt=\"picture 3\"></p>\n<p>下图是整个KERL的总体架构</p>\n<p><img src=\"https://i.imgur.com/lmrP1MY.png\" alt=\"picture 4\"></p>\n<h3 id=\"学习知识增强状态表示\">学习知识增强状态表示</h3>\n<p>基于MDP的算法的一个关键点就在于建模并且学习一个好的状态表示,因为它保存了状态的必要信息特征。作者提出联合知识信息来增强状态标识,并且设置了两种状态表示,即序列级别的和知识级别的。用这种方式,能够使用启发式的知识图谱数据来引导序列级的RL学习算法。</p>\n<h4 id=\"序列级的状态表示\">序列级的状态表示</h4>\n<p>采用标准循环神经网络对历史交互序列进行编码</p>\n<p><img src=\"https://i.imgur.com/gsWakRx.png\" alt=\"picture 5\"></p>\n<p>其中$q_{i_t}$是商品的嵌入向量,$\\Phi_{gru}$是GRU网络中的所有相关参数。这个表示主要获取用户喜好的顺序特征,不使用知识信息来做衍生。</p>\n<h4 id=\"知识级的状态表示\">知识级的状态表示</h4>\n<p>遗忘的研究主要利用知识图谱数据拟合用户的短期行为,并没有用于探索过程去优化长期目标。为了在开发和探索之间权衡,作者想到对两种基于知识的喜好进行建模即当前喜好和未来喜好。</p>\n<p><strong>学习当前喜好</strong>。基于历史数据获取当前的知识特征非常简单。每一个商品i和知识图G中的实体$e_i$相关联。作者使用TransE作为嵌入方法来获取商品$i_t$的嵌入向量,表示为$v_{e_{i_t}} \\in R^{L_E}$。此外,使用一个简单的平均池化方法来聚合所有的用户选择的历史商品的知识图嵌入：</p>\n<p><img src=\"https://i.imgur.com/uDI88Ru.png\" alt=\"picture 1\"></p>\n<p>我们在上面并没有考虑到时序信息或者注意力机制,因为经过实验发现那些方法并没有比上面这个式子有改进。</p>\n<p><strong>预测未来喜好</strong>。直观上,知道未来的喜好对于序列推荐是有帮助的。基于当前的喜好,我们的想法是建立一个感应网络来直接预测未来喜好。这里作者使用的是多层感知机,在时间步t,以当前的喜好表示$c_t$作为输入预测一个k步未来喜好表示：</p>\n<p><img src=\"https://i.imgur.com/mMkbAKP.png\" alt=\"picture 2\"></p>\n<p>其中$f_{t:t+k}$表示t时刻的未来k步喜好,$\\Phi_{mlp}$表示网络中的所有参数。作者假设在连续的时间步上基于知识的喜好是不会有太大改变的。</p>\n<h4 id=\"获取最终的状态表示\">获取最终的状态表示</h4>\n<p>对于状态$s_t$,它的表示$v_{s_t}$是三个表示向量的结合：</p>\n<p><img src=\"https://i.imgur.com/TkGQNzH.png\" alt=\"picture 3\"></p>\n<p>其中$\\oplus$是向量的拼接操作,$h_t$是序列等级的状态向量(公式4),$c_t$是当前基于知识的喜好(公式5),$f_{t:t+k}$是未来基于知识的喜好(公式6)。通过结合这三者,本方法自然地将知识图谱数据用到了MDP框架的状态表示种,在开发和探索间做了一个不错的权衡。</p>\n<h3 id=\"利用知识信息设置奖励\">利用知识信息设置奖励</h3>\n<p>定义一个合适的奖励函数对于强化学习算法至关重要。在序列推荐中,最终的表现通常是基于商品id的准确匹配衡量的。但是,交互序列是由用户根据其对商品属性或简介的喜好生成的。因此,除了商品层面的表现,衡量推断出的知识层面的质量也很重要。</p>\n<h4 id=\"奖励分解\">奖励分解</h4>\n<p>在时间步t,通过整合两个不同的奖励函数定义k步奖励函数：</p>\n<p><img src=\"https://i.imgur.com/06HqE4H.png\" alt=\"picture 4\"></p>\n<p>其中$R_{seq}$和$R_{kg}$分别衡量序列级和知识级的奖励,以真实子序列$i_{t:t+k}$和推荐子序列$\\hat{i}_{t:t+k}$的信息为输入。</p>\n<h4 id=\"序列级奖励\">序列级奖励</h4>\n<p>序列推荐中一个好的奖励函数不应该只考虑独立时间步的表现,也要衡量总体的表现。受到机器翻译评估的启发,作者使用了BLEU的衡量方法。给定真实的交互子序列$i_{t:t+k}$和推荐子序列$\\hat{i}_{t:t+k}$,定义了一个奖励函数：</p>\n<p><img src=\"https://i.imgur.com/p6QSNSa.png\" alt=\"picture 5\"></p>\n<p>其中$prec_m$是改进后的精度,通过下式计算：</p>\n<p><img src=\"https://i.imgur.com/MLkzZVu.png\" alt=\"picture 6\"></p>\n<p>其中$p_m$是$i_{t:t+k}$的一个m-gram子序列,$# (p_m,i_{t:t+k})$是$p_m$在$i_{t:t+k}$中出现的次数,M决定使用多少的m-gram精度得分。由此可以看出,这样一个奖励机制更偏向于让推荐算法生成更多连续的m-gram序列。</p>\n<h4 id=\"知识级奖励\">知识级奖励</h4>\n<p>在这个奖励函数中我们不关注商品id的准确匹配,而是更多地关注反映在序列中的知识级的特征。给定真实的和预测的子序列$i_{t:t+k}$和$\\hat{i}<em>{t:t+k}$,我们仍然使用像公式5那样的简单方法来聚合TransE嵌入以获取子序列级的而知识表示,记为$c</em>{t:t+k}$和$\\hat{c}_{t:t+k}$。为了衡量两个向量之间的差异,采用了余弦相似度作为奖励函数：</p>\n<p><img src=\"https://i.imgur.com/6FDP29y.png\" alt=\"picture 7\"></p>\n<p>这里可以将余弦函数换成其他相似度度量函数。</p>\n<h3 id=\"学习过程\">学习过程</h3>\n<p>本模型中的一个关键点在于如何学习一个高效的知识级的状态表示。作者首先使用了蒙特卡洛算法采样一组子序列来训练MDP。基于这些子序列,提出一对排序机制来学习感应网络。整体的算法在下面给出,然后我们给出训练细节。</p>\n<p><img src=\"https://i.imgur.com/gRPDcc3.png\" alt=\"picture 8\"></p>\n<h4 id=\"使用截断策略梯度\">使用截断策略梯度</h4>\n<p>本文的任务是学习一个随机策略$\\pi$能够最大化期望积累奖励$J(\\Theta)$。$J(\\Theta)$的计算公式如下：</p>\n<p><img src=\"https://i.imgur.com/y5MYxEs.png\" alt=\"picture 9\"></p>\n<p>其中$\\gamma$是用于平衡当前奖励和未来奖励的因子,$\\Theta$是所有需要学习的参数。作者使用截断策略梯度来学习参数。具体来说,对于每一个状态$s_t$,KERL根据公式2的策略函数模仿一个截断k步子序列$\\hat{i}<em>{t:t+k}^{(l)}$。给定$\\hat{i}</em>{t:t+k}^{(l)}$,学习过程如下：</p>\n<p><img src=\"https://i.imgur.com/ySnQiLz.png\" alt=\"picture 10\"></p>\n<p>重复这个过程L次以获取一个最佳值。</p>\n<h4 id=\"训练感应网络\">训练感应网络</h4>\n<p>感知网络是本模型重要组成部分,用于基于当前喜好预测未来的喜好。为了训练这样的一个网络,一个比较直接的方法是用真实喜好去拟合（比图用公式6计算真实喜好）。但是知识图谱信息可能会包含噪声或者不相关信息。此外,在本文的场景中真实向量回归的监督信号很稀疏,因为根据一个子序列只能获得一个单一的真实喜好向量$f_{t:t+k}$。为了更好地学习感应网络,作者提出了一对排序策略来改进训练过程。</p>\n<p>对于状态$s_t$可以用公式6获得他们对应的知识表示,表示为$\\hat{f}<em>{t:t+k}^{(1)},\\hat{f}</em>{t:t+k}^{(2)},\\dots,\\hat{f}<em>{t:t+k}^{(L)}$。通过公式10计算他们的奖励值,能够形成一组比较作为额外的限制来改进学习。具体来说,给定$\\hat{f}</em>{t:t+k}^{(l)},\\hat{f}<em>{t:t+k}^{(l’)}$我们首先利用他们的奖励值在L个子序列上构建喜好顺序,然后增加一对约束项以训练感应网络,其中对于$1\\leq l,l’\\leq L$,如果$R</em>{kg}(i_{t:t+k},\\hat{i}<em>{t:t+k}^{(l)}) &gt; R</em>{kg}(i_{t:t+k},\\hat{i}<em>{t:t+k}^{(l’)})$,则$MLP(\\hat{f}</em>{t:t+k}^{(l)}) &gt; MLP(\\hat{f}_{t:t+k}^{(l’)})$。</p>\n<p><img src=\"https://i.imgur.com/Hl8fujR.png\" alt=\"picture 10\"></p>\n","categories":["强化学习"],"tags":["序列推荐"]},{"title":"Model-Based Reinforcement Learning with Adversarial Training for Online Recommendation","url":"/2022/05/24/Model-Based-Reinforcement-Learning-with-Adversarial-Training-for-Online-Recommendation/","content":"<h2 id=\"摘要-4\">摘要</h2>\n<p>作者提出了一个基于模型的强化学习方法，通过生成对抗网络对用户-代理交互建模进行离线策略学习。为了减少模型和策略的偏差，作者使用了一个鉴别器来评估生成的数据的质量并且衡量生成的奖励。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-4\">引言</h2>\n<p>由于用户多样的兴趣和行为模式，只有小部分商品展示给了用户，并且用户的反馈记录则更少。对于如此大的状态和操作空间，这提供了相对较少的关于用户系统交互的信息，因此也给构建基于历史交互的有效的推荐策略带来了大量的挑战。</p>\n<p>如果不与真正的用户进行互动，推荐系统就不能轻易地在状态和行动空间中探索之前未探索过的区域。但是与真实用户交互以获取奖励并更新模型代价是很高的，因为探索阶段可能会让用户对这个推荐系统的表现不满意导致弃用。这种情况下需要利用用户的历史数据来先学习一个策略。为此，作者基于模型的学习方法，其中作者从用户的离线数据中评估一个模型，并且用它来和学习器进行交互以获取一个推荐策略。</p>\n<p>基于模型的RL具有高效采样和降低离线数据噪声的优势。但是这种优势很容易由于其模型近似真实环境的固有偏差而减弱，并且在随后的策略更新中产生的剧烈变化可能会增加降低用户满意度的风险。</p>\n<p>为了解决这一问题，作者在推荐学习策略中引入了对抗训练。训练器被训练用来分辨分辨模仿的交互轨迹和真实的，以此来消除用户行为模型的偏差和改进策略学习。该工作的主要贡献如下：</p>\n<ul>\n<li>为了解决交互代价高的问题，提出了一个同一的解决办法来更高效地利用历史数据，同时引入对抗训练。使该策略学习的鲁棒性更强</li>\n<li>提出的模型通过了理论和经验的验证。试验结果表明该方法有更好的采样效率。</li>\n</ul>\n<h2 id=\"问题描述\">问题描述</h2>\n<p>本文的问题是从离线数据中学习一个策略，这样当部署到线上的时候能够最大化从用户交互中得来的奖励积累。</p>\n<h3 id=\"问题\">问题</h3>\n<p>推荐器就是一个学习代理，它根据策略来生成行动，每个行动会给出一个推荐列表。每次代理和环境发生交互时（比如用户的购买、点击等），会记录一个n个序列的集合$\\Omega={\\tau_1,…,\\tau_n}$，其中$\\tau_i$时包含了代理的行动、用户行为和奖励的第i个序列，即$\\tau_i={(a_0^i,c_0^i,r_0^i),…,(a_t^i,c_t^i,r_t^i)}$，其中$r_t^i$表示行动$a_t^i$（比如购买某个商品）的奖励，$c_t^i$是根据代理行动$a_t^i$做出的用户行为（比如点击推荐的商品）。为了讨论起来简单，之后会去掉上标i以表示整体的序列$\\tau$。基于观测到的序列，会学习一个策略$\\pi$以最大化期望累计奖励。</p>\n<h3 id=\"假设\">假设</h3>\n<p>为了缩小讨论范围，作者研究的是经典的用户行为类型（比如点击），并且做出以下假设：</p>\n<ol>\n<li>在每个时间步上，每个用户必须从推荐列表中点击一个商品</li>\n<li>推荐列表中未被点击的商品不会影响用户未来的表现。</li>\n<li>奖励只和被点击的商品相关。</li>\n</ol>\n<p>比如说，当以用户的购买作为奖励的时候，用户指挥购买点击的商品。</p>\n<h3 id=\"学习框架\">学习框架</h3>\n<p>本文中环境建模为一个用户行为模型U。S由时间t之前的交互历史决定。同时按照上面的假设，在时间步t，环境会在由$a_t$中的一个代理A推荐的商品中生成一个用户的点击$c_t$，然后奖励函数会根据该次点击生成一个奖励。</p>\n<h2 id=\"用于推荐的交互模型\">用于推荐的交互模型</h2>\n<p>以下展示用于推荐的交互模型，包括两个部分：</p>\n<ol>\n<li>用户行为模型U，在推荐商品上生成用户用户点击</li>\n<li>代理A根据策略生成推荐商品序列</li>\n</ol>\n<p>U和A相互交互生成用户序列以用于对抗策略的学习。</p>\n<h3 id=\"用户行为模型\">用户行为模型</h3>\n<p>根据给定的用户点击${c_0,…,c_{t-1}}$，用户行为模型U首先将每个时间点点击的商品投射到一个嵌入向量$e^u$上。状态$s_t^u$表示为点击历史的总和，比如说$s_t^u=h_u(e_0^u,…,e_{t-1}^u)$。作者使用RNN来对状态转换P进行建模，因此对于状态$s_t^u$，有：</p>\n<p>$$<br>\ns_t^u=h^u(s_{t-1}^u,e_{t-1}^u)<br>\n$$</p>\n<p>给定行动$a_t={a_{t(1)},…,a_{t(k)}}$，比如时间t时刻的topk个推荐，作者通过softmax计算推荐商品的点击概率</p>\n<p><img src=\"https://i.imgur.com/2CY7O8w.png\" alt=\"picture 1\"></p>\n<p>其中$V^c\\in R^k$是转换向量，表示每个推荐商品$a_{t(i)}$在状态$s_t^u$的评估质量。$E_t^u$是推荐商品的嵌入矩阵，$W^e$是点击权重矩阵，$b^e$是对应的偏置值。奖励状态-行动组$s_t^u,a_t$的奖励$r_t$计算如下：</p>\n<p><img src=\"https://i.imgur.com/d4nK6tF.png\" alt=\"picture 3\"></p>\n<p>基于上面的公式1和公式2，采用明确的奖励，用户行为模型U能够从离线数据$\\Omega$中根据最大似然估计获得：</p>\n<p><img src=\"https://i.imgur.com/O5Afg1m.png\" alt=\"picture 4\"></p>\n<p>其中$\\lambda_p$是一个超参数，用于平衡两个损失，$T_i$是观测序列$\\tau_i$的长度。</p>\n<h3 id=\"代理\">代理</h3>\n<p>代理应该按照环境所提供的状态采取行动，但是实际应用中，用户的状态是看不到的。此外，代理采取行动的状态和用户点击时的状态可能是不同的。因此，作者构建了一个代理端的状态模型来学习状态。与用户端的状态模型类似，给定投射的点击向量$e_0^u,…,e_{t-1}^u$，在代理端通过$s_t^a=h^a(s_{t-1}^a,e_t-1^a)$构建状态模型，其中$s_t^a$表示t时刻代理维护的状态。初始状态$s_0^a$是从分布p中得来的首个推荐，将其简单表示为$s_0$。</p>\n<p>基于当前的状态$s_t^a$，代理根据整个项目集生成一个长度k的推荐列表作为其行动$a_t$，策略$\\pi$下商品i的概率由下面的式子得出：</p>\n<p><img src=\"https://i.imgur.com/Urzff1q.png\" alt=\"picture 5\"></p>\n<p>其中$W_i^a$是权重矩阵$W^a$的第i行，C是整个推荐候选的集合，$b_i^a$是对应的偏置值。</p>\n<h2 id=\"对抗策略学习\">对抗策略学习</h2>\n<p>生成$\\hat{\\tau}_t={(\\hat{a}_0,\\hat{c}_0,\\hat{r}_0),…,(\\hat{a}_t,\\hat{c}_t,\\hat{r}_t)}$时，对于t&gt;0，我们可以根据公式4获得$\\hat{a}<em>t=A(\\hat{\\tau}</em>{0:t-1}^c)$，根据公式2获得$\\hat{c}<em>t=U_c(\\hat{\\tau}</em>{0:t-1}^c,\\hat{a}_t)$，根据公式1获得$\\hat{r}<em>t=U_r(\\hat{\\tau}</em>{0:t-1}^c,\\hat{c}_t)$。$\\tau^c$表示序列$\\tau$中的点击，$(\\hat{a}_0,\\hat{c}_0,\\hat{r}<em>0)$是根据$s_0^a$和$s_0^u$产生的。当$\\hat{c}<em>t=c</em>{end}$的时候，序列的生成就结束了，$c</em>{end}$是结束标志。生成的数据和真实离线的数据分别表示为g和data，在接下来不会再显示地区分$\\tau,\\hat{\\tau}$，可以根据器分布的名称区别。</p>\n<h3 id=\"对抗训练\">对抗训练</h3>\n<p>作者利用对抗训练使得IRecGAN模型生成高质量的序列，其能够捕获真实数据分布中的内在模式。一个鉴别器用于给出序列$\\tau$的评估，$D(\\tau)$表示$\\tau$从真实推荐环境中被生成的概率。鉴别器的评估可以通过最小化目标函数实现：</p>\n<p><img src=\"https://i.imgur.com/g2voodP.png\" alt=\"picture 6\"></p>\n<p>但是D只能评估一个完整的序列，因此不能够直接评估时间t时生成的部分序列。作者为此使用蒙特卡洛树搜索算法和由U和A生成的roll-out策略来获取策略生成的得分。时间步t上序列生成的分定义为:</p>\n<p><img src=\"https://i.imgur.com/86Vu7as.png\" alt=\"picture 7\"></p>\n<p>其中$MC^{U,A}(\\tau_{0:t};N)$是从U和A之间交互采样的N个序列。给定观测到的离线数据，U应当能够生成反映真实数据分布的点击和奖励。为了能够更好的学到一个U，可以设置真实的序列得分为1，最小化生成序列的得分和1的差距就可以了。因此，基于公式1和2，U的目标函数的梯度如下：</p>\n<p><img src=\"https://i.imgur.com/HHsrbid.png\" alt=\"picture 8\"></p>\n<p>其中$\\Theta_u,\\Theta_a$分别表示模型U和A的参数。为了使得A能够提供我们需要的推荐序列，我们也将$q_D(\\tau_{0:t})$作为时间步t的序列生成奖励。而由于$q_D(\\tau_{0:t})$评估的是0:t的序列质量，不关注t时刻之后的。为了能够评估整个序列，让A去最大化积累的奖励值。A的梯度表示为：</p>\n<p><img src=\"https://i.imgur.com/22PYa7R.png\" alt=\"picture 9\"></p>\n<h3 id=\"策略学习\">策略学习</h3>\n","categories":["序列推荐"],"tags":["强化学习"]},{"title":"Streaming GNN(DGNN)","url":"/2022/05/15/Streaming-GNN/","content":"<h2 id=\"引言-5\">引言</h2>\n<p>设计动态图网络面临巨大挑战：</p>\n<ul>\n<li>整体角度：动态图的结构不断变化，新的点、边不断演化，而获取不断变化的图结构又是必要的。</li>\n<li>局部角度：节点能够不断建立新的边，而建边的顺序对于理解节点的属性非常重要。</li>\n</ul>\n<p>作者聚焦于以下问题：</p>\n<ul>\n<li>新的交互产生时，如何持续地保持节点信息的跟新</li>\n<li>如何将交互信息传递到受影响的节点</li>\n<li>更新传播的时候如何聚合交互间的时间间隔</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"DGNN的框架\">DGNN的框架</h2>\n<p>本文中只讨论新的节点和边的建立而忽视节点和边的消失。DGNN由两部分组成：更新部分和传播部分。</p>\n<p>简单描述出现新的交互 ${v_s,v_g,t}$ 发生时两个部分的操作：</p>\n<ol>\n<li>更新部分只涉及两个交互节点和新边，比如下图中在2，5之间建立一个新的边</li>\n<li>传播部分会涉及两个交互节点和离他们较近的影响节点。会将 ${v_2,v_5,t_7}$ 的信息传播到影响节点。</li>\n</ol>\n<p><img src=\"https://i.imgur.com/QhXsmvp.png\" alt=\"picture 1\"></p>\n<h3 id=\"更新部分\">更新部分</h3>\n<p>总体的处理流程如下图所示，图中只以节点2做了例子来看是怎么更新的</p>\n<p><img src=\"https://i.imgur.com/7wZWosM.png\" alt=\"picture 2\"></p>\n<p>因为在有向图中每个节点会扮演两种角色，目标节点和源节点，因此要对这两种表示分别存储。对于节点v的时间t之前的作为源节点的cell memory 和隐状态分别为 $C^s_c(t-)$ 和 $h^s_v(t-)$ ,作为目标节点的分别为 $C^g_c(t-)$ 和 $h^g_v(t-)$ 。这里的t-表示无限接近t但是未到t的意思。比如说对于节点2 $C^s_c(t_7-)$ 等价于 $C^s_c(t_3)$ 。</p>\n<p>源节点和目的节点的隐状态在Merge Unit中聚合，生成节点v的总体特征表示　$u_v(t-)$ 。和上面的cell memory、隐状态一样该表示也需要存储以备新的交互产生时进行更新。</p>\n<p>下图展示两个更新部分在接收到  ${v_2,v_5,t_7}$ 时的操作。</p>\n<p><img src=\"https://i.imgur.com/PQDA6Wq.png\" alt=\"picture 3\"></p>\n<h4 id=\"交互单元\">交互单元</h4>\n<p>交互单元（b部分）利用接收到的 ${v_s,v_g,t}$ 为节点生成交互信息，该信息之后用于更新单元的输入。</p>\n<p>该处使用深度神经网络进行处理，公式如下：</p>\n<p>$$<br>\ne(t)=\\operatorname{act}\\left(W_{1} \\cdot u_{v_{s}}(t-)+W_{2} \\cdot u_{v_{g}}(t-)+b_{e}\\right)<br>\n$$</p>\n<h4 id=\"更新单元\">更新单元</h4>\n<p>使用lstm，但是要经过改进，使其能够接收时间间隔信息，以此来决定需要遗忘的程度。</p>\n<p>更新单元（c部分）如下图所示,该单元的输入包括 $C_v(t-),h_v(t-),\\Delta_t,e(t)$ 。输出就是更新后的 C和h。更新单元和LSTM的区别就在于图中的蓝色虚线部分，相当于对C先做一个预先操作，图中对应的公式如下：</p>\n<p><img src=\"https://i.imgur.com/ppo3j4H.png\" alt=\"picture 1\"></p>\n<p>其中 $C_v^I(t-1)$ 是短期记忆， $C_V^T(t-1)$ 是长期记忆，短期记忆根据时间间隔 $\\Delta_t$ 进行一定的调整，长期记忆用短期上一时间步传来的C减去短期记忆得到。其中的函数g是一个减函数，意味着时间间隔越长，短期记忆保留地越少。最后将折损的短期记忆和长期记忆相加。得到lstm中的C。</p>\n<h4 id=\"聚合单元\">聚合单元</h4>\n<p>聚合单元（d部分）是聚合源隐状态和目标隐状态为节点特征 $u_v$ 的。聚合单元以节点的连个隐状态作为输入，输出节点的特征表示：</p>\n<p>$$<br>\nu_{v_{s}}(t)=W^{s} \\cdot h_{v_{s}}^{s}(t)+W^{g} \\cdot h_{v_{s}}^{g}(t-)+b_{u}<br>\n$$</p>\n<h3 id=\"传播部分\">传播部分</h3>\n<p>本文选取的是交互节点的邻居节点作为影响节点。为了更新这些节点，交互信息应当被传播到他们的cell memory中。</p>\n<p>传播部分由三个单元组成，交互单元，传播单元和聚合单元。这里的交互单元和聚合单元与之前的更新部分是一样的。</p>\n<p>假设 ${v_s,v_g,t}$ 是一个新发生的交互，影响节点表示为 $N(v_s)$ 和 $N(v_g)$ 。在有向图中又可以进一步将这些邻接节点细分为 $N(v_s)=N^s(v_s)\\bigcup N^g(v_s),N(v_g)=N^s(v_g)\\bigcup N^g(v_g)$ 。这样就需要四种不同的传播单元了，但是他们的结构是一样的只是针对不同的节点情况。</p>\n<p>这里只描述从源节点到它的源邻居的情况，其他情况都是类似的。对于每一个节点 $v_x\\in N^s(v_s)$ ，传播交互信息的公式如下：</p>\n<p><img src=\"https://i.imgur.com/1CD2GkH.png\" alt=\"picture 2\"></p>\n<p>其中g也和上面一样是一个减函数，$\\Delta^s_t$ 是 $v_x$ 上一次和 $v_s$ 交互的时间和当前时间之差。同时由于太久之间两个节点的交互到目前可能两者已经没有关系了，引入了函数h，定义如下：</p>\n<p>$$<br>\nh\\left(\\Delta_{t}^{s}\\right)= \\begin{cases}1, &amp; \\Delta_{t}^{S} \\leq \\tau \\ 0, &amp; \\text { otherwise }\\end{cases}<br>\n$$</p>\n<p>当时间达到一个阈值的时候我们就不再传播到这个影响节点了。函数中的 $f_{a}\\left(u_{v_{x}}(t-), u_{v_{s}}(t-)\\right)$ 是注意力函数，用于获取两个节点之间的邻接关系的强弱的。最后的W是将交互信息映射到源邻居上的。</p>\n<p>下图展示了传播的过程：</p>\n<p><img src=\"https://i.imgur.com/6ihe3Mf.png\" alt=\"picture 4\"></p>\n<h3 id=\"参数学习\">参数学习</h3>\n<h4 id=\"边预测的参数学习\">边预测的参数学习</h4>\n<p>DGNN中每个节点只有一个总体的特征表示，但是每个节点可能是源节点或者目标节点。因此，对于边预测任务，首先将两个交互节点的总体特征映射为对应的角色。对于交互 $(v_s,v_g,t)$ ，做以下映射：</p>\n<p>$$<br>\n\\begin{aligned}<br>\n&amp;u_{v_{s}}^{s}(t-)=P^{s} \\cdot u_{v_{s}}(t-) \\<br>\n&amp;u_{v_{g}}^{g}(t-)=P^{g} \\cdot u_{v_{g}}(t-)<br>\n\\end{aligned}<br>\n$$</p>\n<p>对于损失函数的计算使用以下公式：</p>\n<p><img src=\"https://i.imgur.com/kCn3Gvf.png\" alt=\"picture 3\"></p>\n<p>其中Q是负样本的数量，$P_n(v)$ 是负样本的分布，直到时间t的总体损失为：</p>\n<p>$$<br>\n\\sum_{e \\in \\mathcal{E}(T)} J(e)<br>\n$$</p>\n<p>其中 $ \\math{E}(T)$ 表示直到时间T的所有交互。</p>\n<h4 id=\"点分类的参数学习\">点分类的参数学习</h4>\n<p>使用普通的交叉熵损失就可以了，首先把节点的特征映射为总类别数的长度，然后做softmax，时间t时的损失计算公式如下：</p>\n<p>$$<br>\nJ(v, t)=-\\sum_{i=0}^{N_{c}-1} y[i] \\log \\left(\\frac{\\exp \\left(u_{v}^{c}(t)\\right)[i]}{\\sum_{j=0}^{N_{c}-1} \\exp \\left(u_{v}^{c}(t)\\right)[j]}\\right)<br>\n$$</p>\n<p>训练的过程是半监督的，只有部分节点有标签，但是无标签的节点一样参与更新和传播过程。</p>\n","categories":["图神经网络"],"tags":["动态GCN"]},{"title":"What Happens Next? Event Prediction Using a Compositional Neural Network Model","url":"/2022/05/30/What-Happens-Next-Event-Prediction-Using-a-Compositional-Neural-Network-Model/","content":"<h2 id=\"摘要-5\">摘要</h2>\n<p>作者探讨了从文本中自动获取事件序列的知识的问题，旨在提供一个在叙述性生成系统中能够使用的预测模型。提出了一个神经网络能够同时学习描述时间的单词嵌入，将嵌入组合成事件表示的函数和预测事件相关性强度的相关函数。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-6\">引言</h2>\n<p>叙事生成系统在某种抽象层次上构建故事结构，涉及事件、动作和状态的序列，以及参与其中的角色和实体。</p>\n<p>作者旨在提供能够用于更多邻域的叙述生成。作者考虑一个组件，它采用与角色有关的事件/动作的上下文（到目前为止的故事）并衡量可能延续的合理性。特别之处在于，作者关注模式提取管道的前半部分，它解决了叙述完形填空预测任务，不关注随后的步骤，它推断出广义的类似脚本的模式。</p>\n<p>这篇文章做了两点贡献：</p>\n<ul>\n<li>提出了一个新的任务：<strong>多选择叙事填空（MCNC）</strong>。与叙事填空十分类似，但是更适合于在叙事生成中作为一个组件比较系统的有效性。在MCNC系统中，系统能够利用更多的事件相关信息。</li>\n<li>提出了一个神经网络模型用于预测是否两个事件会出现在同一个链上。</li>\n</ul>\n<h2 id=\"叙事生成\">叙事生成</h2>\n<p>假设每次实体是动词的参数时都描述了一个事件，事件由一对动词引理和动词与实体间的语法依赖关系表示，称之为predicate-GR。如下图所示。</p>\n<p><img src=\"https://i.imgur.com/7aTPYpt.png\" alt=\"picture 1\"></p>\n","categories":["强化学习"],"tags":["序列推荐"]},{"title":"gormv2 学习","url":"/2022/05/13/gormv2-%E5%AD%A6%E4%B9%A0/","content":"<h2 id=\"安装\">安装</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">go get -u gorm.io/gorm</span><br><span class=\"line\">go get -u gorm.io/driver/sqlite</span><br></pre></td></tr></table></figure>\n<h2 id=\"基本操作\">基本操作</h2>\n<h3 id=\"连接数据库\">连接数据库</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">DB, err := gorm.Open(mysql.New(mysql.Config&#123;</span><br><span class=\"line\">  DSN: conn,</span><br><span class=\"line\"> &#125;), &amp;gorm.Config&#123;</span><br><span class=\"line\">  SkipDefaultTransaction: <span class=\"literal\">false</span>, <span class=\"comment\">//跳过默认事务</span></span><br><span class=\"line\">  NamingStrategy: schema.NamingStrategy&#123;</span><br><span class=\"line\">   SingularTable: <span class=\"literal\">true</span>, <span class=\"comment\">// 复数形式 User的表名应该是users</span></span><br><span class=\"line\">   TablePrefix:   <span class=\"string\">&quot;t_&quot;</span>, <span class=\"comment\">//表名前缀 User的表名应该是t_users</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  DisableForeignKeyConstraintWhenMigrating: <span class=\"literal\">true</span>, <span class=\"comment\">//设置成为逻辑外键(在物理数据库上没有外键，仅体现在代码上)</span></span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"建表\">建表</h3>\n<p><code>*gorm.DB</code>没有<code>CreateTable()</code>方法了,需要先创建一个<code>*gorm.DB</code>的实例<code>db</code>,然后调用<code>db.Migarator().CreateTable()</code></p>\n<span id=\"more\"></span>\n<h3 id=\"查找\">查找</h3>\n<p>可以使用<code>db.Where(&quot;key=?&quot;,&quot;要查找的内容&quot;).Find(&amp;model)</code>，其中where中的内容可以自定义，Find函数也可以替换成别的，根据自己的需要替换即可</p>\n<p>如果是按照主键查找，可以直接去掉where在Find中增加“要查找的内容”就可以了。</p>\n<h3 id=\"创建记录-2\">创建记录</h3>\n<p>可以使用<code>db.Create(&amp;model)</code>就可以了。</p>\n<h3 id=\"删除记录-2\">删除记录</h3>\n<p>可以选择批量删除也可以选择单条删除。使用<code>db.Delete(&amp;model)</code>是按照主键删除单条记录，<code>db.Where(&quot;key=?&quot;,&quot;需要指定的内容&quot;).Delete(&amp;model&#123;&#125;)</code>就可以实现批量删除，当然where也可以用在单条删除中作为额外条件，如果不满足额外条件就不会删除。</p>\n<h3 id=\"更新记录\">更新记录</h3>\n<p>可以选择更新一条记录、一列记录、多列记录。</p>\n<p>一条记录：先find到所需修改的记录，然后再对他做更改</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.First(&amp;user)</span><br><span class=\"line\"></span><br><span class=\"line\">user.Name = <span class=\"string\">&quot;jinzhu 2&quot;</span></span><br><span class=\"line\">user.Age = <span class=\"number\">100</span></span><br><span class=\"line\">db.Save(&amp;user)</span><br></pre></td></tr></table></figure>\n<p>一列记录：需要指定条件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Model(&amp;User&#123;&#125;).Where(<span class=\"string\">&quot;active = ?&quot;</span>, <span class=\"literal\">true</span>).Update(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">db.Model(&amp;user).Update(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">db.Model(&amp;user).Where(<span class=\"string\">&quot;active = ?&quot;</span>, <span class=\"literal\">true</span>).Update(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>多列记录：如果使用struct更新，默认情况下指挥更新非零字段，如果想要更新零字段需要使用select指定或者使用map作为参数</p>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.Model(&amp;user).Updates(User&#123;Name: <span class=\"string\">&quot;hello&quot;</span>, Age: <span class=\"number\">18</span>, Active: <span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.Model(&amp;user).Updates(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"keyword\">interface</span>&#123;&#125;&#123;<span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;hello&quot;</span>, <span class=\"string\">&quot;age&quot;</span>: <span class=\"number\">18</span>, <span class=\"string\">&quot;active&quot;</span>: <span class=\"literal\">false</span>&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"连接数据库-2\">连接数据库</h3>\n<figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\">db, err := gorm.Open(mysql.New(mysql.Config&#123;</span><br><span class=\"line\">  DSN: <span class=\"string\">&quot;root:123@(localhost:8080)/micro?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>,</span><br><span class=\"line\"> &#125;), &amp;gorm.Config&#123;</span><br><span class=\"line\">  NamingStrategy: schema.NamingStrategy&#123;</span><br><span class=\"line\">   SingularTable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"> &#125;)</span><br></pre></td></tr></table></figure>\n","categories":["后端"],"tags":["gorm"]},{"title":"ubuntu下某个apt的包所在路径","url":"/2022/04/28/ubuntu%E4%B8%8B%E6%9F%90%E4%B8%AAapt%E7%9A%84%E5%8C%85%E6%89%80%E5%9C%A8%E8%B7%AF%E5%BE%84/","content":"<p>ubuntu下使用apt-get的包如果出了问题不好删除可以在/etc/apt/sources.list.d中找到相关包的.list文件然后删除这个文件，其他该包相关文件的位置网上都有就不赘述了。</p>\n","categories":["ubuntu"],"tags":["apt-get"]},{"title":"ARL: Knowledge Graph Reasoning with Analogy-based Reinforcement Learning","url":"/2022/11/03/ARL-Knowledge-Graph-Reasoning-with-Analogy-based-Reinforcement-Learning/","content":"<h2 id=\"摘要\">摘要</h2>\n<p>强化学习知识图谱推理旨在通过现有的关系路径预测未知的尾实体。这能够极大地提升预测的效率，因为基于强化学习的方法不会向表征推理那样遍历全部的尾实体。同时，这种方法提升了推理的可解释性。但是由于存在极大的探索空间，基于强化学习的模型必须限制每个路径的检索空间，这可能会导致丢失正确答案。此外，对于一些连接稀疏的比较孤立的尾实体，这种基于路径的推理会丢弃这些孤立的节点。为了解决这一问题，作者提出了基于类比的强化学习模型————类比强化学习网络，融入了LSTM，图注意力网络和虚拟连接生成机制。它将实体类比信息注入到模型的推理过程中并且使用虚拟连接生成，不仅提高了路径获得奖励的概率，而且增加了路径连接的宽度同时使孤立节点被遍历到的概率更高。同时，作者分析比较了不同的类比方法。实验结果表明ARL的表现在多个数据集上优于多跳方法。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言\">引言</h2>\n<p>现今，通过精细的神经网络设计和遍历全部实体的测试模式，基于嵌入的方法能够取得不错的效果。但是，这种方法无法做路径选取，因此它必须连续地遍历全部的实体节点以在训练和测试的过程中获取得分。这在实际应用中是不现实的，因为知识图谱往往有数以百万计的节点。此外，这些方法更注重于新型的损失函数结构来缩小正样本和负样本之间的分布差距，这种做法在单独的推理过程中缺乏可解释性。强化学习机制所代表的基于路径的方法能够通过构建一个可解释的路径来找到最终结果从而解决这一问题。但是，强化学习模型需要标准化每个路径的映射长度来进行矩阵计算，这会导致潜在实体的丢失。同时，由于知识图谱的不完整性，会存在许多的碎片化信息，即孤立数据。在有向图中，这些数据有固定的出度实体，但是没有入度信息。如同下表所示，WIN18RR数据集中22%的节点是孤立实体。使用传统的路径检索方法是无法连接到这些节点的。</p>\n<p><img src=\"https://i.imgur.com/SfdiW2y.png\" alt=\"picture 1\"></p>\n<p>人能够轻易地处理孤立数据问题。因为我们能够通过孤立节点的出度信息建立基于类比的推理。比如说，通过下图的先验知识</p>\n<p><img src=\"https://i.imgur.com/Xc9O3mE.png\" alt=\"picture 2\"></p>\n<p>我们能够根据上述的先验信息预测&quot;Joe&quot;作为&lt;Amazon,Staff,?&gt;的潜在答案，因为&lt;Jim,Mike,Joe&gt;有着相同的出度关系。同时，我们不会选择Nicholas作为最可能的选项，因为他相较于Jim和Mike只有一个出度和他们是一样的。此外，我们同样能够知道对于Amazon-Staff问题的推理，department和work location在决策中应该拥有更高的权重。这是人类使用类比信息进行推理的能力。基于相似的想法，我们希望模仿人类推理过程中类比信息的特征提升多跳推理在知识图谱上的表现。</p>\n<p>总之，在这篇文章中，作者提出了一个类比强化学习模型使用采样后的类比信息来实现人类的联想能力。由于搜索域的扩展，ARL不仅能够减轻孤立节点的问题，而且能够加快收敛和提升推理结果的精度。具体来说，首先，我们通过激活出度采样算法获取一个潜在的类比节点集合。同时，激活出度采样算法使用图注意力机制来聚合不同query下的更好的实体表示。然后，我们对于每一跳中所选择的路径上的类比节点嵌入概率，并且基于不同的先验路径记录生成虚拟类比路径作为超链接来决定是否使用类比实体。此外，这些虚拟的类比路径将会被嵌入到现存的关系集中作为虚拟关系。最后，代理端学习两个策略并且使用一个多任务机制来使优化收敛。这两个策略简单描述就是：1）是否通过一个虚拟的类比路径或真实路径继续前进；2）何时结束并且发现最终的尾实体。这两个策略是在query关系，整体路径记录和聚合关系有上限制的，在路径寻找的过程中提供。同时，该策略使用正确的答案作为自监督信息来指导虚拟路径决策，减小了类比候选集的范围，避免了奖励稀疏的问题。本方法的贡献：</p>\n<ul>\n<li>第一个在深度学习框架下使用类比信息并且为知识图谱推理构建虚拟连接</li>\n<li>提出了孤立节点的问题定义，使用ARL解决了这一问题</li>\n<li>提出了一个激活出度采样算法来正确地采样，并且在推理过程中使用类比节点集。此外，我们总结分析了最近的知识图谱推理中相似的类比方法，反映出了出度采样算法的优势。</li>\n</ul>\n<h2 id=\"方法\">方法</h2>\n<h3 id=\"ARL的结构\">ARL的结构</h3>\n<ul>\n<li>Environment：ARL的知识图谱不仅包含真实边，还包含虚拟关系的三元组以及会被用到激活出度采样算法中的细节。此外，用户定义的限制关系和实体都被存储在环境中，因此后续的元组能够知道何时开始何时结束。当$e=e_h$时$r=Start$,$e=e_h$时End就会生效使得该块不会向后搜寻。</li>\n<li>State：状态空间由所有的合法的实体集和和关系集合组成。初始时，代理端知道他的起始实体$E_{1x}$和query$R_x$，但是答案$E_{tx}$是不可知的。然后，代理端开始通过知识图谱搜集更多的信息，并且会遍历以获取下一个实体直到找到最终的$E_{tx}$。因此，代理端在每一步的状态应该是$(E_{1x},R_x,E_{nx},E_{tx})$，并且只有当$E_{nx}=E_{tx}$的时候整个过程才会停止。</li>\n<li>Action: 之后代理端从时间戳t时刻的(E_1,R_x,E_2,E_5)中寻找下一个action $a_t$。</li>\n<li>Transition：在ARL中，定义转移函数为$S\\times X\\rightarrow S$。代理端在t+1时刻的转移等同于由t时刻的状态集合计算出的联合概率和t+1时刻所有行为的概率。</li>\n<li>Reward：当代理端抵达最终的状态时，设置奖励为1，否则为0；此外，在t-1时刻，如果$r_{t-1} \\in R_v$并且$E_{nx}=E_{tx}$，设置奖励为1.2来激励代理端向类比路径探索。如果虚拟和现实路径都设置为1，结果会使用更少的虚拟路径，从而造成收敛缓慢。同时，如果最终路径长度小于平均收敛时间步，奖励设置为1.2。</li>\n<li>Policy；对于有效集成的类比边集和有限视界确定性部分可观察 MDP,需要考虑两个策略函数$\\pi_{ana},\\pi{mdp}$。$\\pi_ana$表明类比路径或者真实路径是否需要在下一个行为中被选取，$\\pi_{mdp}$ 表示在下一步中可能被选取的事件的概率分布。对于这两个策略，都需要依赖历史信息$H_t$。使用一个长短期记忆网络来整合三个信息：上一时刻的H，上一时刻的选择和这一时刻的状态。<br>\n首先，对于$\\pi_ana$，代理端需要决定使用从类比边集中获取到的路径还是普通边集。对于每一个实体，存在一个具体的出度实体集合和出度关系集合，定义为$O_{es},O_{rs}$。我们采用图注意力网络来对根据$h_t$得到的聚合信息分配权重。然后我们融合历史信息$h_t$，权重关系嵌入$O_{rt}$和query嵌入$r_q$来执行类比路径决策。<br>\n需要注意的是，标签的分布是基于现存的图中的无监督信息，因为当前步是否可以通过类比路径获得在训练过程中是可见的。在训练过程中，最终的答案如果在事件步t还没有被找到，我们将会人工嵌入正确答案的候选集。<br>\n其次，对于$\\pi_{mdp}$，为了能够获得mdp的概率分布，除了上述的两个权重，我们同样需要开率相应的状态下的行为空间</li>\n</ul>\n<h3 id=\"激活出度采样算法\">激活出度采样算法</h3>\n<h4 id=\"类比节点选择\">类比节点选择</h4>\n<p>在模型训练之前，我们需要基于点集和关系集生成相应的字典。点集字典和关系集字典存储在以用于具体的数据集。</p>\n<h4 id=\"类比节点注入\">类比节点注入</h4>\n<p>我们使用一个基于邻接矩阵的图注意力层对$R_c$进行聚合。其嵌入在分类器中以决定是否对决策建立虚拟连接。这个过程最终采用并行多任务方式训练我们的强化学习架构，并且逐步更新权重的网络参数。</p>\n","categories":["知识图谱"],"tags":["知识推理"]},{"title":"BERT","url":"/2022/12/19/BERT/","content":"<h2 id=\"摘要-2\">摘要</h2>\n<p>BERT是用来从无标签文本中根据前后文本的联合条件预训练深度双向表示的。预训练好的BERT模型只需要一个额外的输出层就可以进行微调。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-2\">引言</h2>\n<p>作者认为目前的方法限制了预训练表示的发挥，尤其是微调方法。主要限制在于标准语言模型是无向的，这限制了预训练时的架构的选择。比如在GPT中使用的左-右架构，每个token只能注意之前的内容。这种限制会导致在token级别的任务上（比如问答）产生很不好的后果，因为对于问答来说融合上下文信息很重要。</p>\n<p>BERT使用MLM减轻了以往无向的限制。MLM随机对输入的一些token进行掩蔽，MLM随机掩蔽输入的token，任务是基于上下文预测被掩蔽的词汇id。与左-右的语言模型的预训练不同，MLM使得表示能够融合上下文。除了MLM，作者还使用了“下一句预测”任务来联合训练文本对的表示。</p>\n<h2 id=\"方法-2\">方法</h2>\n<p>本框架有两步：预训练和微调。预训练阶段，模型在不同预训练任务的无标签数据上训练。微调阶段，模型先根据预训练的参数初始化，再在下游任务中使用有标签数据进行微调。每个下游任务都有独立的微调模型，即便他们使用相同的初始化参数。</p>\n<h3 id=\"模型架构\">模型架构</h3>\n<p>BERT模型的架构是一个多层双向Transformer encoder。本文中，层数为L，隐藏层大小为H，自注意力头数量为A。</p>\n<ul>\n<li>$BERT_{base}$ ：L=12,H=768,A=12</li>\n<li>$BERT_{large}$ : L=24,H=1024,A=16</li>\n</ul>\n<h3 id=\"输入输出的表示\">输入输出的表示</h3>\n<p>为了能够更适应下游任务，输入的表示能够清晰的表示一个单独的句子和一对句子。在整个工作中，一个句子可以是一个任意跨度的连续文本，而非真正的一句话。</p>\n<p>作者使用一个具有30000个词汇的token表进行WordPiece embedding。每个句子的第一个token基本都是[CLS]，与此标记对应的最终隐藏状态用作分类任务的聚合序列表示。对于句子对或者多个句子，使用[SEP]将他们分开，然后对每一个token增加一个学到的embedding来表明它属于句子A还是句子B。如同下图，E是输入的embedding，最终的输出的[CLS]的隐状态向量是C，第i个token的向量是$T_i$。</p>\n<p><img src=\"https://i.imgur.com/6ltSQI3.png\" alt=\"picture 1\"></p>\n<p>对于一个给定的token而言，它的输入表示是通过对相应的token，片段和位置embedding结合得到的。构建的过程如下图。</p>\n<p><img src=\"https://i.imgur.com/MVcFfN4.png\" alt=\"picture 3\"></p>\n<h3 id=\"预训练BERT\">预训练BERT</h3>\n<h4 id=\"任务1：Masked-LM\">任务1：Masked LM</h4>\n<p>在这个任务中，最终的被mask的token的表示被送到输出层并进行softmax来获取该处本应该的词汇。</p>\n<p>虽然通过掩蔽的方式能够获得双向预训练模型，但是这样我们的预训练过程和和微调过程中的输入数据就不同了，因为[MASK]在微调阶段是不存在的。为了解决这一问题，作者并非都用[MASK]来替代被掩蔽的token。对于被掩蔽的token，80%使用[MASK]代替，10%使用随机token代替，10%不变。</p>\n<h4 id=\"任务2：next-sentence-prediction\">任务2：next sentence prediction</h4>\n<p>为了能够训练一个能够理解句子之间关系的模型，作者在一个二值化的下一句预测任务上预训练，该任务可以从任何单语言语料库中简单地生成。具体来说，当选择句子A和B作为训练数据时，B有50%是真实的下一句，标签为IsNext，50%不是，标签为NotNext。如图1中所示，C是用来进行下一句预测的。</p>\n<h3 id=\"微调BERT\">微调BERT</h3>\n<p>由于Transformer中的自注意机制允许，因此微调非常简单通过交换适当的输入和输出，BERT可以为许多下游任务建模——无论它们涉及单个文本还是文本对。</p>\n<p>对于每一个任务，只需要简单地增加具体任务的输入和输出到BERT中就可以端到端地微调BERT。在输入处，预训练中的句子A和句子B类似于(1)释义中的句子对；(2)蕴涵中的假设-前提对；(3)问答中的问题-段落对；（4）文本分类或者序列标记的退化的$text-\\emptyset$对。在输出处，token的表示送入输出层以进行token级别的任务，比如序列标记或者问答，[CLS]表示送入输出层以进行分类，比如蕴含或者情感分析。</p>\n","categories":["BERT"]},{"title":"CircEvent","url":"/2022/10/23/CircEvent/","content":"<h2 id=\"摘要-3\">摘要</h2>\n<p>目前的研究注重于挖掘时间内在关系，我们称之为环境。但是环境本身隐式地包含了事件发生的规律，这对于叙述性事件预测非常重要。作者将环境融入到叙述性事件预测里面，提出了CircEvent，采用多头注意力机制在局部和全局检索环境。作者还引入了注意力权重的冠以话来利用对齐的事件和局部环境。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-3\">引言</h2>\n<p>事件环境包括天气，位置信息以及主要行为。根据不同的事件环境，同一事件链会指向不同的后续事件。传统方法多受预测事件的前一事件的影响较大，属于局部最优，而CircEvent方法能够根据环境信息实现全局最优。</p>\n<p>作者打算从原始事件文本中抽取环境信息，但是非结构化的时间文本包含了太多的无关信息。为了解决这一问题，作者使用了两个多头注意力网络分别从局部和全局的角度来聚合事件表示和环境信息。</p>\n<p>在局部层面上，事件来自一个具体的句子，包含了最相关的环境。作者使用一个多头注意力来检索局部环境此外，上下文的环境信息同样对事件表示有所帮助，作者使用了另一个多头注意力来获取全局的环境信息。</p>\n<p>在环境信息检索之后，作者使用transformer作为基础来对上下文事件和环境进行编码。transformer解码器用于计算候选集的相似度得分。</p>\n<h2 id=\"具体方法\">具体方法</h2>\n<h3 id=\"事件表示\">事件表示</h3>\n<p>每个事件由三个部分组成，主谓宾。作者使用平均池化层和最大池化层对数据的嵌入向量进行处理后拼接以获取到事件的嵌入向量。</p>\n<p>$$<br>\ns(e)=[max(w_s);avg(w_s)]<br>\n$$</p>\n<p>将事件链中的主语、谓语和宾语都用相同的方式获取到这样的一个向量表示即$s(e),p(e),o(e)$。之后事件的表示通过他们三者的线性相加得到：</p>\n<p>$$<br>\ne(e)=g(W_ss(e)+W_pp(e)+W_oo(e)+b)<br>\n$$</p>\n<h3 id=\"事件环境表示\">事件环境表示</h3>\n<ul>\n<li>局部环境：使用双向RNN对句子的隐藏层进行检索，然后使用多头注意力对句子的隐状态进行聚合。具体来说就是对句子中的每个词视为一个时间步的输入，通过双向得到一个$\\mathop{h_i}\\limits ^{\\rightarrow}$ 和 $\\mathop{h_i}\\limits ^{\\leftarrow}$，然后将他们拼接得到$h_i$，再将所有的隐状态堆叠形成一个隐状态矩阵$H=[h_1,h_2,\\dot,h_n]$。局部的多头注意力的使用就是事件嵌入向量作为query，隐状态矩阵作为key和value。</li>\n<li>全局环境：跟局部环境是一样的，但是他的query使用的是上下文事件的序列，key和value使用的是局部环境下的上下文事件。</li>\n</ul>\n<h3 id=\"编码层和解码层\">编码层和解码层</h3>\n<p>两个基本都是按照原本的transformer结构来的，编码层接收事件链作为输入，解码层接收候选集作为输入。并且使用一个线性层最后输出5个得分，作为5个事件的最终的风，最后使用softmax进行处理获取到预测事件。</p>\n","categories":["事件预测"]},{"title":"CLIP","url":"/2022/11/15/CLIP/","content":"<h2 id=\"摘要-4\">摘要</h2>\n<p>最新的计算机视觉系统训练用于预测一个固定的目标类。这种严格的监督格式限制了泛化性和实用性，因为需要额外的标记数据来指定其他视觉概念。直接从图像的源相关文本是一个很好的替代方法，能够利用更广泛的监督源。我们证明了预测哪个标题与哪个图像对应的简单预训练任务是一种有效且可扩展的方式，可以在从互联网收集的 4 亿（图像、文本）对数据集上从头开始学习 SOTA 图像表示。在预训练之后，使用自然语言来引用学习过的视觉概念(或描述新的概念)，从而实现模型到下游任务的零帧转移。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-4\">引言</h2>\n<p>借助互联网上这种形式的大量公开数据，我们创建了一个4亿对(图像、文本)的新数据集，并演示了一个简化版的<br>\nConVIRT从零开始训练，我们称之为CLIP，意为Contrastive Language-Image Pre-training，是一种有效的自然语言监督学习方法。</p>\n<h2 id=\"方法-3\">方法</h2>\n<h3 id=\"自然语言监督\">自然语言监督</h3>\n<p>方法的核心是通过从包含在自然语言中的监督信息里学习感知。与其他训练方法相比，学习自然语言有几个潜在的优势。与标准的众包标签相比，自然语言监管在图像分类方面要容易得多，因为它不要求注释采用经典的“机器学习兼容格式”，如典型的1 / n多数票“黄金标签”。相反，研究自然语言的方法可以被动地从网络上大量文本的监督中学习。从自然语言中学习也比大多数无监督或自我监督的学习方法有一个重要的优势，它不是“仅仅”学习一个表示，而是将该表示连接到语言，从而实现灵活的零镜头迁移。</p>\n<h3 id=\"创建足够大的数据集\">创建足够大的数据集</h3>\n<p>自然语言监督的一个主要动机是这种形式的大量数据可以在互联网上公开。由于现有的数据集没有充分反映这种可能性，只考虑这些数据集的结果将低估这一研究领域的潜力。为了解决这个问题，我们构建了一个新的数据集，包含4亿对(图像、文本)对，这些数据来自互联网上的各种公开来源。为了尝试覆盖尽可能广泛的视觉概念集，我们将搜索(图像、文本)对作为构建过程的一部分，其文本包含500,000个query集中的一个。</p>\n<h3 id=\"选择高效的预训练方法\">选择高效的预训练方法</h3>\n<p>在我们的努力过程中，我们发现训练效率是成功扩展自然语言监督的关键，我们基于这个指标选择了最终的预训练方法。我们最初的方法类似于VirTex，从头开始联合训练图像CNN和文本转换器来预测图像的标题。然而，我们遇到了有效扩展该方法的困难。一个6300万参数的Transformer语言模型使用的计算能力是ResNet-50图像编码器的两倍，它学习识别ImageNet类的速度比预测相同文本的一词袋编码的更简单的基线慢三倍。</p>\n<p>这些方法有一个关键的相似之处,都尝试去对每个图像预测一个能与之匹配的准确的单词。但是由于图像相关的描述、评论和相关文本多种多样，这是一个困难的任务。之后，研究者们发现使用对比学习的方法比预测方法更快更好。</p>\n<p>给定一组N个(image,text)对，CLIP用于预测N*N个组合的真实发生的可能性。因此，CLIP通过联合训练一个图像编码器和一个文本编码器来最大化真实对的图像和文本的余弦相似度并且最小化虚假对的以学习一个多模型嵌入空间。</p>\n<h3 id=\"选择并且缩放模型\">选择并且缩放模型</h3>\n<p>对于图像编码器，考虑了两种架构。第一种采用ResNet-50作为基础架构，对其中的部分内容做了改动，并且将全局池化层更换为注意力池化。注意力池化层使用一个类似于transformer的多头注意力实现，其中query以全局池化的图像表示为条件。第二种架构采用Vision Transformer，基本没有做什么改动</p>\n<p>文本编码器使用Transformer。</p>\n","categories":["AI绘画"]},{"title":"Cloud storage design with golang","url":"/2023/08/27/Cloud-storage-design-with-golang/","content":"<h1>获取github的OAuth权限</h1>\n<ol>\n<li>设置前端点击页面向github发送授权申请,其中client_id为github上注册的</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://github.com/login/oauth/authorize?client_id=75a7167dcffc9070a417&amp;redirect_uri=http://localhost:8080/callbackgithub</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>github根据请求重定向到应用给出的重定向地址</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://localhost:8080/callbackgithub?code=xxxxxxx</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>应用给的重定向地址需要根据这个code进行获取授权token,body中需要包含client_id,client_secret（不能明文！！）,code</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">POST https://github.com/login/oauth/access_token</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>根据给回来的token向github发送获取用户信息,请求头中加入<code>authorization:&quot;Bearer [token]&quot;</code></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://api.github.com/user</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>","categories":["go"],"tags":["cloud storage"]},{"title":"From Discrimination to Generation： Knowledge Graph Completion with Generative Transformer","url":"/2022/12/15/From-Discrimination-to-Generation-Knowledge-Graph-Completion-with-Generative-Transformer/","content":"<h2 id=\"摘要-5\">摘要</h2>\n<p>知识图谱的补全旨在解决扩展缺少三元组的知识图谱问题。本文中，作者提出了GenKGC方法，将知识图谱的补全任务转变为seq-seq生成任务。介绍了关系引导的解释和实体感知的分层解码以此来学习更好的表示和快速推理。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-5\">引言</h2>\n<p>知识图谱补全目的是通过预测缺失的三元组来补全知识图谱。本文中，作者主要探讨了KGC的连接预测任务。</p>\n<p>以往的KGC方法（TransE,ComplEx,RotatE等）都是知识嵌入技术，通过对实体和关系映射到一个向量空间中，然后在这些embedding上通过使用预定义的得分函数获取预测的三元组。</p>\n<p>最近研究者提出了一些文本编码的方法（KG-BERT等），使用预训练好的模型对三元组进行编码并且输出每个候选的得分。</p>\n<p>以往的方法大多利用带有预定义评分函数的判别范式进行知识嵌入。这种判别策略在推理中需要对所有可能的三元组进行代价高昂的评分，并且存在负样本的不稳定性。并且这些深度知识嵌入方法忽略了细粒度的实体-关系之间的交互并且大规模的真实世界知识图需要很大的内存。</p>\n<p>作者第一步先通过seq-seq生成对KGC进行建模然后提出了一个GenKGC方法。将实体和关系作为输入序列并且使用预训练好的语言模型生成目标实体。遵循GPT-3的“文本学习”范式，模型可以通过连接与输入相关的选择样本来学习正确的输出答案，作者提出了通过增加相同关系的三元组进行关系指导的解释。在生成过程中，作者还提出了实体感知的层次解码来减少生成过程中的时间复杂度。</p>\n<h2 id=\"方法-4\">方法</h2>\n<h3 id=\"连接预测转变为seq-seq生成\">连接预测转变为seq-seq生成</h3>\n<p>一个完整的知识图谱表示为$G=(\\epsilon,\\mathbf{R},\\mathbf{T},\\mathbf{C},\\mathbf{D})$，其中$\\epsilon$表示实体集合，$\\mathbf{R}$表示关系集合，$\\mathbf{T}$表示三元组集合，$\\mathbf{C}$表示实体的类别,$\\mathbf{D}$表示实体的描述。为了补全知识图谱中的三元组，连接预测旨在根据头实体和关系预测尾实体</p>\n<p>本文中，作者使用标准encoder-decoder结构进行seq-seq生成。将每个实体和关系作为token序列。具体来说就是使用纯文本来表示实体和关系而不是使用embedding来缩小知识图谱中三元组和预训练语言模型之间的差异。给定三元组$(e_i,r_j,?)$，获取实体和关系的描述$d_{e_i},d_{r_j}$，然后将他们拼接。</p>\n<h3 id=\"关系指导的解释\">关系指导的解释</h3>\n<p>构建关系指导的解释样本$&lt;r_{in},t_{train}&gt;$。具体来说，在关系$r_j$的指导下对解释进行采样，由训练集中作为输入的多个三元组组成，最终的输入序列就是：</p>\n<p><img src=\"https://i.imgur.com/hbTbtva.png\" alt=\"picture 5\"></p>\n<h3 id=\"实体感知的层次解码\">实体感知的层次解码</h3>\n<p>使用Beam Search来获取$\\epsilon$topk个实体。给定一个三元组$(e_i,r_j,?)$，GenKGC通过一个自回归公式计算计算每一个$e\\in \\epsilon$，的得分:</p>\n<p><img src=\"https://i.imgur.com/J2WZU5o.png\" alt=\"picture 1\"></p>\n<p>其中z是是类别c中的|c|个token，y是e的文本表示中的N个token。</p>\n<p>作者采样了出现频次最少的类别类来限制实体的解码因为分辨低频实体比较困难。然后增加特殊的token作为预训练的语言模型词汇表中的类型来限制解码。为了确保生成的实体在实体候选集中，作者构建了一个前缀树来对实体名称进行解码，如下图。与顺序seq-seq模型相似，GenKGC也是使用标准的seq-seq目标函数进行优化。</p>\n<p><img src=\"https://i.imgur.com/eKzxPoa.png\" alt=\"picture 4\"></p>\n<p><img src=\"https://i.imgur.com/DRDW3AR.png\" alt=\"picture 3\"></p>\n","categories":["NLP"],"tags":["knowledge graph completion"]},{"title":"GAN","url":"/2022/11/14/GAN/","content":"<h2 id=\"摘要-6\">摘要</h2>\n<p>作者通过对抗过程对评估生成模型提出了一个新的框架，其中作者同时训练了两个模型：获取数据分布的生成模型$G$和一个判别模型$D$来估计样本是来自训练数据而非生成模型的概率。G的训练过程是以最大化D的错误率为目标。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-6\">引言</h2>\n<p>由于难以近似在最大似然估计和相关策略中出现的许多棘手的概率计算以及难以在生成环境中利用分段线性单元的优势。，深度生成模型的影响较小。作者为此提出了一个新的生成模型估计过程来绕过这些难点。在提出的生成网络框架中，生成模型和对手对抗（一个判断样本是否是生成的判别模型）。</p>\n<p>这个框架能够对多种模型和优化算法生成具体的训练算法。在本文中，作者研究了使用生成模型生成样本并且通过多层感知机添加随机噪声，判别模型也是一个多层感知机。</p>\n<h2 id=\"方法-5\">方法</h2>\n<p>为了学习生成器在数据x上的分布$p_g$，我们定义了输入噪声变量的先验$p_z(Z)$，然后将到数据空间的映射表示为$G(z;\\theta_g)$，其中G是由多层感知机表示的可微函数，$\\theta$是其参数。我们同样定义了一个多层感知机$D(x;\\theta_d)$作为判别模型输出一个单值。$D(x)$表示x来自数据而非生成模型的概率。我们训练D以最大化对生成数据和原始数据分配正确的标签的概率。同时训练G来最小化$log(1-D(G(z)))$。</p>\n<p>在训练的内循环中将D优化好很难并且有限数据集上会导致过拟合。因此，作者每k步训练一次D，这会让D维持在其最优解附近。在训练的早期，G很差，D可以很容易分辨数据，这样的话$log(1-D(G(z)))$始终饱和，不好优化。因此可以将优化目标改为$log(D(G(z)))$。这样可以保证能够有效果的同时在训练早期让梯度更加稳定。</p>\n","categories":["对抗生成网络"]},{"title":"Meta-ADD：A meta-learning based pre-trained model for concept drift active detection","url":"/2022/11/08/Meta-ADD-A-meta-learning-based-pre-trained-model-for-concept-drift-active-detection/","content":"<h2 id=\"摘要-7\">摘要</h2>\n<p>以往的概念漂移检测方法都需要依赖假设测试并且没法检测出漂移的类型信息，无法分析是什么导致了概念漂移的发生。本文中，为了摆脱假设并且获取到概念漂移的类型，我们提出了基于元学习的主动漂移检测，能够学习通过线下预训练一个模型来对概念漂移分类，并且在线上微调模型以改进检测的精度。具体来说，在预训练阶段，我们提取基于不同概念漂移的错误率元特征，之后通过将不同的概念漂移表示为对应的样例得到一个范例网络并以此训练一个元检测器。在检测阶段，元检测器通过一个简单的流式学习对自身进行微调以适应真实数据流。因此，Meta-ADD不需要假设测试来检测概念漂移并且能够识别漂移类型，能够直接支持漂移理解。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-7\">引言</h2>\n<p>本文中，我们提出了一个框架去学习能够分类概念漂移的漂移检测器。假设一个漂移检测器能够分类漂移，并且能够被预训练。当数据流输入时，它能够被直接用于漂移分类而不需要做假设性测试。但是，仍然有两个问题需要解决：</p>\n<ul>\n<li>如何预训练漂移检测器</li>\n<li>将预训练好的漂移检测器应用到不同的数据流上时，如何微调模型的参数以提升精度</li>\n</ul>\n<h2 id=\"方法-6\">方法</h2>\n<p>本工作聚焦于即时检测概念漂移的发生而非一个概念是否已经是过时概念。因此我们不使用重复发生的概念类型而是将其命名为正常类型来表明没有发生概念漂移。</p>\n<p>我们将两个时间窗的平均错误率的差距提取出来作为元特征。具体来说，对于每一种概念漂移，我们首先生成N个数据流。然后使用预测模型直接对数据流获取时间t的错误率$e_t$。此外，我们使用长度为n的窗口，其中有n条数据，由此可以得到该窗口的错误率，同理也可以得到下一窗口的错误率。</p>\n<h3 id=\"基于范例网络的元检测器\">基于范例网络的元检测器</h3>\n<p>预训练需要大量数据，而数据集不支持，因此该问题变成了一个小样本学习的问题。元学习利用其他任务学习来的东西能够很快转到另一个任务上，因此能够很好地解决这个问题。</p>\n<p>非参方法旨在使用非参学习器来作为元学习器而非参数模型。我们使用一个范例神经网络来对获取预训练的漂移检测器称之为元检测器。在范例神经网络中，分类任务被认为是找到每一个类别在于一空间中的中心然后对新样本预测其类别。</p>\n<p>对于数据流的概念漂移检测任务，这同样被认为是一个分类任务。如同前面提到的，四种类型的概念漂移被认为是四类。通过学习一个神经网络将数据流映射到一个向量空间中并且为不同的漂移类别抽取原型作为平均向量，概念漂移的检测通过选取最近的漂移原型根据数据流的嵌入信息可以做到。</p>\n<h3 id=\"主动漂移检测\">主动漂移检测</h3>\n<p>尽管元检测器可以在训练过程中得到并且应用到漂移检测中，每一种漂移类型的表示在不同数据集上是不同的。因此，当元检测器用于元检测器时，他必须能够适应数据流以获取更好的表现。</p>\n<p>为了更新元检测器，我们搜集每个时间步上的错误率样本，并且需要指导真实的漂移类型以更新检测器。但是真实的漂移类型是不可知的。</p>\n"},{"title":"Human-level control through deep reinforcement learning","url":"/2022/06/13/Human-level-control-through-deep-reinforcement-learning/","content":"<h2 id=\"摘要-8\">摘要</h2>\n<p>为了能够将强化学习应用到现实难度的场景下，代理端就会面临一个困难的任务：从高维传感其中获取高效的环境表示，并且以此来总结过去的经验应用到新的状态中。尽管强化学习已经在许多邻域获得了成功，但是其应用性局限于某些特定的邻域，这些邻域要么是能够获取有效的特征要么是有充分研究过的低维状态空间。本文中作者使用训练深度神经网络的技术来发展一个新的人工代理，称之为深度Q网络，能够直接从高维输入中学习有效的策略。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-8\">引言</h2>\n<p>本文的任务情景是代理通过一系列的观察，行动和奖励与环境进行交互。代理的目标是以一种最大化未来累计奖励的方法选择行动。公式上来说就是以深度卷积神经网络来近似最优动作-值函数</p>\n<p><img src=\"https://i.imgur.com/gN9yGcz.png\" alt=\"picture 1\"></p>\n<p>就是每个时间步t根据策略 $\\pi=P(a|s)$ 在 $\\gamma$ 折扣下的最大累计奖励。</p>\n<p>作者使用卷积网络参数化了一个近似值函数 $Q(s,a;\\theta_i)$ ，如下图所示，其中 $\\theta_i$ 是在第i次迭代时候的参数（weight）。为了实现经验回放，作者存储代理在每个时间步的经验 $e=(s_t,a_t,r_t,s_{t+1})$ 到数据集 $D_t={e_1,…,e_t}$ 上。学习过程中，在样本 $s,ar,s’$ 上使用Q学习，样本是从数据中随机正态抽取的。Q学习每一次迭代i都是用如下的损失函数进行更新</p>\n<p><img src=\"https://i.imgur.com/Nzibkyi.png\" alt=\"picture 2\"></p>\n<p>其中 $\\theta_i$ 是Q网络在第i次迭代的参数， $\\theta_i^-$ 是用于计算target的网络参数。</p>\n<h2 id=\"方法-7\">方法</h2>\n<h3 id=\"预处理\">预处理</h3>\n<p>直接使用Atari2600框架，是210×160像素的128色盘图片。采用基础的预处理步骤以减少输入的维度和并且处理其中的一些人为因素。首先，为了编码单个帧，我们取被编码帧和前一帧上每个像素颜色值的最大值。这对于消除游戏中出现的闪烁(有些对象只出现在偶数帧中，而有些对象只出现在奇数帧中)是必要的。其次，其次，我们从RGB帧中提取Y通道，也称为亮度，并将其缩放为84×84。下面的算法1使用这种方法对最近的m帧进行操作然后进行堆叠以产生Q函数的输入。</p>\n<h3 id=\"模型架构-2\">模型架构</h3>\n<p>因为Q将历史-动作对映射到他们的Q值的标量估计上，历史和动作已经被一些网络用作输入了。但是这样做有一个缺点，需要独立的前向传播以计算每个动作的Q值，使得成本与动作数量呈线性关系。作者使用的架构对于每一个可能的动作都有一个独立的输出单元，并且网络的输入只有一个状态表示，输出是对应的输入的每个独立动作的预测Q值。这种架构的好处就是通过一次前向传播就可以计算一个给定状态下的所有可能的行动的Q值。</p>\n<p>网络的具体结构如下图所示。神经网路的输入由预处理映射 $\\phi$ 生成的84×84×4的图像组成。第一个隐藏层使用32个8×8的步幅为4的卷积核与输入图像进行卷积，并且使用一个ReLU。第二个卷积层使用64个4×4的步幅为2的卷积核，也使用ReLU。第三个卷积层使用一个64个3×3的卷积核，使用ReLU。最后的隐藏层是一个全连接层，由512个隐藏单元组成。输出层是一个全连接层，其隐藏单元数量等于可能的行动数。</p>\n<p><img src=\"https://i.imgur.com/l2fSGMq.png\" alt=\"picture 3\"></p>\n<h3 id=\"训练细节\">训练细节</h3>\n<p>因为不同游戏间的分数差异是不同的，因此作者将奖励只分为正负1，0作为不奖励。实验中使用了RMSProp算法并且batch大小设置为32。训练过程中的行为策略是 $\\epsilon$ 贪心法，$\\epsilon$ 在前100万帧从1.0-0.1线性变化，并且最终固定在0.1。总共训练5千万帧，使用100万个最近帧作为复现记忆。</p>\n<p>与之前的方法类似，作者同样使用了跳帧技术。代理每k帧做一个行为而不是每一帧都要做，且最后一个行为在跳跃的帧上进行重复。因为运行一步需要的计算比代理选择行为的计算要少，这种技术允许代理在不显著增加运行时间的情况下多玩k次游戏。本文设置的k为4。</p>\n<h3 id=\"算法\">算法</h3>\n<p>每个时间步代理都会选择一个行为 $a_t$ 。行为被传递到模拟器并且改变内部状态和游戏得分。模拟器的内部状态是对代理不可见的，代理只观察来自模拟器的图像，即一个表示当前屏幕的向量。此外还会接收一个奖励 $r_t$ 表示游戏得分的改变。由于代理只能观察当前屏幕，因此任务只能被部分观察到，并且不可能只通过对当前的屏幕状态就能完全理解当前的情况。所以一系列的行为和观察 $s_t=x_1,a_1,x_2,a_2,…,a_{t-1},x_t$ 会被传入算法中，然后根据这些序列学习游戏的策略。这个式子给出了一个大的但是有限的马尔科夫链，每一个序列都是一个状态。因此，可以使用标准的强化学习方法，即只使用完整的序列 $s_t$ 作为时间t的状态表示。</p>\n<p>作者使用标准假设，即未来的奖励积累根据 $\\gamma$ 每个时间步进行折扣，定义未来时间步t的折扣返回为 $R_t=\\sum_{t’=t}^{T}\\gamma^{t’-t}r_{t’}$ ，其中T是整个时间步结束的时刻。定义最优行动-值函数为 $Q^*{s,a}=max_\\pi E[R_t|s_t=s,a_t=a,\\pi]$ 。</p>\n<p>根据Bellman灯饰，如果序列 $s’$ 在下个时间步的最优值 $Q^*{s,a}$ 对于所有的行为 $a’$ 是已知的 ，最优策略就是选择行为 $a’$ 以最大化奖励值</p>\n<p><img src=\"https://i.imgur.com/YiFftuY.png\" alt=\"picture 4\"></p>\n<p>但是该方法的实际应用不太好，因此使用一个Q网络。Q网络通过在每次迭代过程中训练参数 $\\theta_i$ 以最小化Bellman公式的均方误差，其中最优的解 $r+\\gamma max_{a’}Q^*(s’,a’)$ 被替换为 $y=r+\\gamma max_{a’}Q(s’,a’;\\theta_i^-)$ 。这样第i次迭代的时候的损失函数就应该是</p>\n<p><img src=\"https://i.imgur.com/3vDRsqY.png\" alt=\"picture 5\"></p>\n<p>可以注意到标签是根据网络的权重来生成的，这与传统的有监督学习的固定标签是不同的。在每个优化阶段，使用上一次迭代产生的参数来生成这一次迭代的损失。最终的梯度公式可以表示为</p>\n<p><img src=\"https://i.imgur.com/JNkUraJ.png\" alt=\"picture 6\"></p>\n","categories":["强化学习"]},{"title":"Springboot 学习","url":"/2023/09/15/Springboot-%E5%AD%A6%E4%B9%A0/","content":"<h2 id=\"自定义配置\">自定义配置</h2>\n<ul>\n<li>自定义配置文件：在application。properties中配置<code>spring.profiles.active=xxx</code>，自定义的配置文件命名为application-xxx.properties，则可以使用对应的xxx配置</li>\n<li>配置-实体映射：在需要映射的字段上加<code>@Value(&quot;$&#123;xxxx.xxx.name&#125;&quot;)</code>，或者在类上添加注解设置一批需要映射的字段的前缀<code>@ConfigurationProperties(prefix = &quot;xxxxx.xxx&quot;)</code></li>\n</ul>\n<span id=\"more\"></span>\n","categories":["Java"],"tags":["springboot"]},{"title":"Unified Structure Generation for Universal Information Extraction","url":"/2022/12/12/Unified-Structure-Generation-for-Universal-Information-Extraction/","content":"<h2 id=\"摘要-9\">摘要</h2>\n<p>信息提取受到其不同目标、异构结构和需求特定模式的影响。本文中，我们提出一个统一的文本-结构生成框架UIE，能够普适地对不同的信息抽取任务建模，自适应地生成目标结构，协作学习概括来自不同知识来源的IE能力。具体来说就是，UIE通过一个结构化的抽取语言对不同的抽取结构联合编码，通过基于schema的鼓励机制自适应地生成目标抽取————结构模式指示器，并且通过一个大型的预训练的文本-结构模型获取普通的信息抽取能力。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-9\">引言</h2>\n<p>信息抽取旨在定义并且结构化用户指定的无结构文本信息。目前大部分的信息抽取方法是任务导向的，产生了专门的结构、独立的模型和针对不同信息抽取任务的特定知识源。这些任务导向的解决方法阻碍了信息抽取系统结构化的发展、高效的知识共享和快速的跨域适应。因此发展一种通用的能够同一对抽取任务建模，自适应预测异构结构并且从不同源中高效学习的信息抽取结构很重要。</p>\n<p>总的来说，所有的IE任务都可以被建模成文本-结构转换。如下图，实体是一个命名跨度结构，事件是一个模式定义的记录结构。这些文本-结构转换能够被分解成原子操作：</p>\n<ul>\n<li>斑点法：针对给定的特定语义类型定位所需的范围。比如将“Steve”定义为人类实体，将“excited”定义为情绪表达。</li>\n<li>协助法：通过在预定义的模式中为跨分配语义角色来连接它们。比如将“Steve”和“Apple”通过“Work-for”连接起来。</li>\n</ul>\n<p>通过这些方式，不同的文本-结构转换能够转化为一系列的原子操作，并且所有IE模型都具有相同的潜在发现和关联能力。</p>\n<p><img src=\"https://i.imgur.com/ooWquys.png\" alt=\"picture 1\"></p>\n<p>基于以上的观察，我们提出了UIE。具体来说，为了对异构结构建模，我们设计了一个结构抽取语言能够有效地对不同的信息抽取结构编码成一个统一的表示。为了能够自适应地对不同IE任务生成目标结构，我们提出了结构模式指示器(SSI)，一个基于模式的激励机制，能够控制在UIE中注意哪些内容，连接哪些内容和生成哪些内容。为了学习普适的信息抽取能力，我们将UIE在大量的异构数据集上进行预训练。这样得到的预训练模型具有一个知识共享和快速迁移的稳定的基础。</p>\n<h2 id=\"通用信息提取的统一结构生成\">通用信息提取的统一结构生成</h2>\n<p>给定一个指定好的预定义模式s和文本x，信息抽取模型应该能够生成包含在x中的信息的关于模式s的结构。</p>\n<p>总体来说存在两个挑战，首先，由于IE任务的多样性，需要抽取不同的目标结构；其次，IE任务通常是需求导向的，而这往往使用不同的模式定义，因此我们需要自适应地控制抽取过程。</p>\n<h3 id=\"结构抽取语言\">结构抽取语言</h3>\n<p>本章描述如何对异构IE结构编码到统一的表示。基于上面的描述，IE结构生成能够被分成两个原子任务，并且可以表示所有的IE结构。</p>\n<p>我们设计了一个统一结构抽取语言。如下图所示，每一个SEL包含了三种语义单元：1）spotname表示源文本中存在一个集体的信息片段。2）assoname 表示存在一个具体的信息片段能够连接上一级的spot信息。3）infospan表示文本范围对应的具体spot或者asso信息片段。</p>\n<p><img src=\"https://i.imgur.com/z4N8B3v.png\" alt=\"picture 2\"></p>\n<h2 id=\"用于可控的IE结构生成的结构模式指示器\">用于可控的IE结构生成的结构模式指示器</h2>\n<p>使用SEL能够统一地生成不同的IE结构。但是，由于不同的IE任务有不同的模式，存在的挑战是如何自适应地控制抽取过程中的信息。下图展示了UIE的整体框架。</p>\n<p><img src=\"https://i.imgur.com/Nkp9wy6.png\" alt=\"picture 3\"></p>\n<h3 id=\"结构模式指示器\">结构模式指示器</h3>\n<p>为了描述一个任务的抽取目标，结构模式指示器构建一个基于模式的奖励并且在生成中用它作为前缀。具体来说，与spot-association结构相对应，结构模式指示器包含三种token：1）spotname：具体任务中的spot名称，比如Person。2）assoname：目标联系的名称，比如WordFor。3）特殊符号([spot],[asso],[text])。所有的SSI中的token都concat到一起并且放到原始文本之前，如上图所示，UIE的输入就如下：</p>\n<p><img src=\"https://i.imgur.com/EQohQiE.png\" alt=\"picture 4\"></p>\n<h3 id=\"UIE的结构生成\">UIE的结构生成</h3>\n<p>给定SSI s和文本 x作为输入，UIE通过生成线性SEL抽取目标信息。给定源文本序列x和模式指示器s，UIE首先计算隐藏特征$H=[s_1,\\dots,s_s,x_1,\\dots,x_x]$，如下：</p>\n<p><img src=\"https://i.imgur.com/8ds2Dbf.png\" alt=\"picture 5\"></p>\n<p>其中encoder事一个transformer encoder。然后UIE对输入的text进行解码到一个线性的SEL。在解码的dii步，UIE生成第i个token $y_i$，并且解码器的状态$h_i^d$如下：</p>\n<p><img src=\"https://i.imgur.com/2V0ZN9E.png\" alt=\"picture 6\"></p>\n<p>decoder也是一个transformer解码器，能够预测下一个token$y_i$的概率。decoder输出<eos>的时候结束预测，然后我们将预测的SEL表达式转换成抽取出的信息记录。</p>\n<p>和以往的将label看作特殊符号的信息抽取研究相比，文本-结构生成模式将标签看作是一个自然语言符号。通过语言表达和生成标签与结构，本方法能够有效地将预训练好的模型的知识进行转换，并且在相关任务中共享知识因为标签有着相同的语义并且有相同的label-文本关系。</p>\n<h2 id=\"预训练和微调UIE\">预训练和微调UIE</h2>\n<h3 id=\"预训练预料的构建\">预训练预料的构建</h3>\n<p>我们从网络数据源中收集了大量的预训练语料。</p>\n<p>$D_{pair}$是文本-结构的相似数据，其中每一条数据都是一个(token序列x,结构化记录y)对。用于预训练UIE的文本-结构转换能力。</p>\n<p>$D_{record}$是一个结构数据集其中每一个结构都是一个结构化记录y。来自于ConceptNet和WikiData。用于预训练UIE的结构解码能力。</p>\n<p>$D_{text}$是一个非结构化的文本数据集，来自于英文WikiPedia。用于训练UIE的语义编码能力。</p>\n<h3 id=\"预训练\">预训练</h3>\n<h4 id=\"文本-结构预训练\">文本-结构预训练</h4>\n<p>为了获取基础的文本-结构映射能力，使用$D_{pair}={(x,y)}$预训练UIE。具体来说，对于每一个(x,y)对，我们抽取y中的spot类型$s_{s+}$和associating类型$s_{a+}$作为正模式$s_{+}=s_{s+}\\cup s_{a+}$。但是，如果只使用正模式会发现模型只能记住预训练数据中的三元组。因此对每个对构建负spots，比如我们首先采样负spot$s_{s-}$和负associate集合$s_{a-}$，然后将他们concate起来$s_{meta}=s_{+}\\cup s_{s-}\\cup s_{a-}$，并且构建出最终的抽取目标。比如说，person和work for是记录中的正模式$((person:Steve(work for:Apple)))$，然后我们采样vehicle和located in作为负模式来构建元模式。最终文本-结构的目标函数就是：</p>\n<p><img src=\"https://i.imgur.com/cGTQDiv.png\" alt=\"picture 7\"></p>\n<h4 id=\"结构生成预训练\">结构生成预训练</h4>\n<p>将UIE的decoder作为结构化语言模型训练，$D_{record}$中每个记录都是一个SEL的表达式：</p>\n<p><img src=\"https://i.imgur.com/iBH47I1.png\" alt=\"picture 8\"></p>\n<p>通过预训练结构生成，解码器能够获取SEL的规律和不同标签之间的交互</p>\n<h4 id=\"改进语义表达\">改进语义表达</h4>\n<p>在文本-结构预训练的过程中，我们继续使用掩蔽语言模型任务预训练UIE来改进UIE的语义表示。具体来说，我们在预训练阶段增加了基于跨度破环的掩蔽语言模型目标：</p>\n<p><img src=\"https://i.imgur.com/coICcPl.png\" alt=\"picture 9\"></p>\n<p>其中$x’$是破环的源文本$x’'$是破坏的目标跨度。这种与训练能够有效地减轻spotname和assoname的灾难性遗忘问题。</p>\n<h4 id=\"最终的预训练\">最终的预训练</h4>\n<p>使用T5-v1.1-base和T5-v1.1-large初始化UIE-base和UIE-large，最终的目标函数如下：</p>\n<p><img src=\"https://i.imgur.com/ib4IJn3.png\" alt=\"picture 10\"></p>\n<p>为了方便实现，我们统一将预训练数据表示为三元组。对于文本数据x，构建三元组（None,x’,x’'）。对于文本记录数据(x,y)，我们通过在元schema s 上对每个文本记录对构建(s,x,y)。对于每一个记录，我们使用（None,None,y）作为三元组表示。</p>\n<h3 id=\"按需微调\">按需微调</h3>\n<p>给定预训练好的UIE模型，我们能够通过微调快速地将他用到不同的IE任务。给定一个有标签的语料$D_{task}={(s,x,y)}$，我们使用teacher-forcing交叉熵微调UIE模型：</p>\n<p><img src=\"https://i.imgur.com/RaxTFjN.png\" alt=\"picture 11\"></p>\n<p>为了减轻自回归模型解码过程中的曝光偏差，我们设计了一个拒绝机制以进行高效微调。具体来说，给定一个样本(s,x,y)，我们首先对y使用SEL语言编码，然后我们随机插入几个[NULL]单元（比如（spotname,[NULL]）,(assoname,[NULL])）到真实SEL中，如下图，在文本中插入facility，然后再记录中插入(facility:[NULL])。通过这种方式，UIE能够高效地学习去生成[NULL]拒绝误导生成。</p>\n","categories":["NLP"],"tags":["information extraction"]},{"title":"VQGAN-CLIP","url":"/2022/12/06/VQGAN-CLIP/","content":"<h2 id=\"摘要-10\">摘要</h2>\n<p>作者提出了提出了一个新的方法能够通过多模态编码器指导图像生成从文本生成高质量图像并且不需要任何训练。证明了如何使用CLIP来指导VQNGAN进行生成图像。</p>\n<span id=\"more\"></span>\n<h2 id=\"引言-10\">引言</h2>\n<p>本文中，作者对于图像生成和编辑提出了一个联合方法，使用预训练好的图像-文本编码器来驱动图像生成模型。作者通过使用多模态编码器定义一个损失函数来评估(text,image)的相似度并且进行反向传播跳帧图像生成的潜在空间。作者迭代地更新生成的候选项指导满足与文本足够相似。</p>\n<p>本方法的一大优势在于不需要额外的训练。只需要一个预训练好的图像生成器和一个联合图像-文本编码器。</p>\n<h2 id=\"方法-8\">方法</h2>\n<p>给定一个文本提示并且使用GAN迭代地生成候选图像，在每一步使用CLIP来改进图像。通过将候选图像的embedding和文本的embedding之间的平方球距作为损失函数，并且通过CLIP对图像的GAN的潜在向量表示进行微分来优化图像，称之为z向量，过程如下。</p>\n<p>为了生成一个图像，初始图像包含随机的像素值。优化过程回不断替换图像，指导输出图像能够匹配目标文本。同样对于图像编辑，使用初始需要编辑的图像进行初始化，描述我们想要怎么修改图像的文本和生成图像的使用方式一样，并且不需要修改模型架构。</p>\n<h3 id=\"离散的图像潜在空间\">离散的图像潜在空间</h3>\n<p>与文本自身的离散特性不同，图像的空间是连续的。前人通过构建一个有限embedding的codebook词汇表使用向量量化来表示一种离散潜在表示的模态。这也可以用到图像中，通过构建一个卷积自编码器实现。驶入图像首先通过编码器，然后计算向量的量化嵌入并且为了实现从狗再乘回到原本的词汇表中。</p>\n","categories":["AI绘画"]},{"title":"docker启动mysql镜像","url":"/2023/04/01/docker%E5%90%AF%E5%8A%A8mysql%E9%95%9C%E5%83%8F/","content":"<h2 id=\"启动mysql容器\">启动mysql容器</h2>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -p 3306:3306 --name cloudrestaurant -e MYSQL_ROOT_PASSWORD=123456 -d mysql</span><br></pre></td></tr></table></figure>\n<h2 id=\"进入mysql的命令行\">进入mysql的命令行</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -it 容器名称 bash</span><br></pre></td></tr></table></figure>\n<h2 id=\"\"></h2>\n<span id=\"more\"></span>","categories":["docker"],"tags":["mysql"]},{"title":"八股文","url":"/2023/09/23/%E5%85%AB%E8%82%A1%E6%96%87/","content":"<h2 id=\"JVM、JRE和JDK\">JVM、JRE和JDK</h2>\n<ul>\n<li>JVM是java运行时的虚拟机，不同平台都有各自的虚拟机，从而支持java的跨平台</li>\n<li>JRE是虚拟机和程序所需要的核心类库（java.lang等）。<strong>想要在机器上运行java，装一个jre就行了</strong></li>\n<li>JDK是给开发人员使用的，包括了JRE。其中的开发工具有编译工具（javac.exe）、打包工具（jar.exe）等</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"字节码和其好处\">字节码和其好处</h2>\n<ul>\n<li>字节码是java代码编译后的文件(.class)，只面向虚拟机。</li>\n<li>好处： 解决了传统解释型语言执行效率低的 问题，同时又保留了解释型语言可移植的特点。无需重新编译就可以在不同系统运行。</li>\n</ul>\n<h2 id=\"访问修饰符\">访问修饰符</h2>\n<ul>\n<li>private：同一类之内可见。修饰变量、方法</li>\n<li>default：同一包内可见。修饰类、接口、变量、方法</li>\n<li>protected：同一包内的类和子类可见。修饰变量、方法</li>\n<li>public：全局可见。修饰类、接口、变量、方法</li>\n</ul>\n<h2 id=\"和\">&amp;和&amp;&amp;</h2>\n<ul>\n<li>&amp;：两种用法：逻辑与和按位与</li>\n<li>&amp;&amp;：短路运算符，左边false就不执行右边</li>\n</ul>\n<h2 id=\"final关键字\">final关键字</h2>\n<p>在代码中不可被继承、重写、改变。<strong>但是final修饰的变量不可变的是引用，如果引用指向的地址变了，那这个变量的内容就变了</strong></p>\n<h2 id=\"跳出多重循环\">跳出多重循环</h2>\n<p>在想跳出的循环钱加上标号，里层循环使用带有标号的break，就可以跳出外层循环。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"> ok:</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; j++) &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;i=&quot;</span> + i + <span class=\"string\">&quot;,j=&quot;</span> + j);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j == <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span> ok;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"面向对象五大原则\">面向对象五大原则</h2>\n<ul>\n<li>单一职责：类功能要单一，从而解耦合</li>\n<li>不可修改：可以拓展，不许修改</li>\n<li>里氏替换：子类可以替换父类出现在父类能够出现的地方</li>\n<li>依赖倒置：高层次的模块不依赖低层次的，应该一来一抽象。</li>\n<li>接口分离：多个功能用多个接口实现，不要做成一个通用接口</li>\n</ul>\n<h2 id=\"抽象类和接口\">抽象类和接口</h2>\n<p>抽象类对类找通用性，模板设计；接口对行为进行通用，是行为的规范</p>\n<h3 id=\"相同点\">相同点</h3>\n<ul>\n<li>都不能实例化</li>\n<li>都位于继承的顶端，用于被继承</li>\n<li>都包含抽象方法，子类必须覆写这些方法</li>\n</ul>\n<h3 id=\"不同点\">不同点</h3>\n<ul>\n<li>抽象类可以有构造器，接口不能有</li>\n<li>抽象类中的修饰符任意，接口默认public</li>\n<li>抽象类字段任意，接口字段默认static，final</li>\n</ul>\n<h2 id=\"和-equals\">== 和 equals()</h2>\n<ul>\n<li>==: 基本数据类型比较值，引用数据类型比较地址是否相等</li>\n<li>equals(): 如果没有重写，与==一样。否则按照重写的逻辑来</li>\n<li>String对象因为创建时会从池子中找是否有相同的值，有就给地址，所以用==的话不合适</li>\n</ul>\n<h2 id=\"hashCode-和-equals\">hashCode() 和 equals()</h2>\n<p>将对象假如hashSet的时候，如果两个对象hashCode相等，会判断是否equals，如果equals，就不放了。</p>\n<p>也就是说，euqals的对象哈希值一定相等，所以改了equals的逻辑，hashcode也要跟着改</p>\n<h2 id=\"IO流\">IO流</h2>\n<ul>\n<li>InputStream/Reader： 前者是字节流，后者是字符流</li>\n<li>OutputStream/Writer：同上</li>\n</ul>\n<h3 id=\"BIO-NIO-and-AIO\">BIO,NIO and AIO</h3>\n<ul>\n<li>BIO：Block IO，同步阻塞式IO，就是传统IO，简单使用，并发能力低。<strong>一个连接一个线程。</strong> 数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题</li>\n<li>NIO：Non IO， 同步非阻塞式IO，客户端和服务器端通过channel通讯，实现了多路复用。<strong>一个请求一个线程。</strong></li>\n<li>AIO：Asynchronous IO，实现了异步非阻塞IO，异步IO操作基于事件和回调机制。<strong>一个有效请求一个线程。</strong> 它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>\n</ul>\n<h2 id=\"反射\">反射</h2>\n<h3 id=\"获取反射的三个方法\">获取反射的三个方法</h3>\n<ul>\n<li>建立对象： new 对象 $\\rightarrow$ 调用对象.getClass()</li>\n<li>通过路径：Class.forName(“package.Class”)</li>\n<li>通过类名: ClassName.class</li>\n</ul>\n<h2 id=\"String\">String</h2>\n<p><code>String a=&quot;a&quot;</code> 和 <code>String a=new String(&quot;a&quot;)</code>是不一样的，前者放到常量池，后者放到堆内存。</p>\n<p>使用hashmap用String做key好处是：String不可变，其hashCode可以缓存下来不需要再次计算</p>\n<h3 id=\"StringBuffer-and-StringBuilder\">StringBuffer and StringBuilder</h3>\n<p>StringBuilder 对方法加了同步锁，线程安全；StringBuffer没有加锁，线程不安全。</p>\n<h2 id=\"List\">List</h2>\n<h3 id=\"ArrayList-and-LinkedList-区别\">ArrayList and LinkedList 区别</h3>\n<ul>\n<li>ArrayList是动态数组，LinkedList是双向链表</li>\n<li>前者随机访问效率高</li>\n<li>后者增加和删除的效率高</li>\n<li>后者更占内存，因为要存引用</li>\n<li>都不保证线程安全</li>\n</ul>\n<h2 id=\"Class-forName-和-classloader\">Class.forName 和 classloader</h2>\n<ul>\n<li>都可以进行类的加载</li>\n<li>前者除了将文件加载到jvm，还对类进行解释，执行其中的static</li>\n<li>前者可用参数控制是否加载static块</li>\n</ul>\n<h2 id=\"IO\">IO</h2>\n<h3 id=\"节点流和处理流\">节点流和处理流</h3>\n<ul>\n<li>从一个特定的IO设备（磁盘、网络等）读写数据，称为节点流</li>\n<li>对已存在的流进行连接或封装，通过封装后的流实现数据读写，成为处理流</li>\n</ul>\n<h2 id=\"自定义类加载器\">自定义类加载器</h2>\n<h3 id=\"应用场景\">应用场景</h3>\n<ul>\n<li>加密：编译后的代码加密后无法使用classloader加载，自定义加载器里面先解密，再加载</li>\n<li>从非标准的来源加载代码</li>\n</ul>\n<h3 id=\"双亲委派模型过程\">双亲委派模型过程</h3>\n<ul>\n<li>从已经加载的类中查询是否已经加载，如有，则返回已经加载的类</li>\n<li>如果没有，就让父类加载器加载，采用同样的策略，直到启动类</li>\n<li>如果启动类也加载失败了，会抛出异常，并且用当前加载器的findClass加载</li>\n</ul>\n<h2 id=\"Collection框架下面实现比较\">Collection框架下面实现比较</h2>\n<ul>\n<li>实体类实现Comparable接口，并且实现compareTo(T t)方法</li>\n<li>创建外部比较器，实现Comparator的compare(T t1, T t2)</li>\n</ul>\n<h2 id=\"Iterator-和-ListIterator区别\">Iterator 和 ListIterator区别</h2>\n<ul>\n<li>使用Iterator可以遍历所有集合，但是只能单一向前方向遍历。不能改变集合中的元素。</li>\n<li>ListIterator只能遍历List实现的对象，但是可以向前或者向后，同时ListIterator可以在遍历过程中改编List的元素，也可以获取到索引。</li>\n</ul>\n<h2 id=\"快速失败-fail-fast-和安全失败-fail-safe\">快速失败(fail-fast)和安全失败(fail-safe)</h2>\n<h3 id=\"快速失败\">快速失败</h3>\n<p>使用迭代器遍历集合时，如果对内容进行了修改，会抛出错误</p>\n<p>原理：迭代过程中使用modCount变量，如果元素发生变化，就会改变modCount值，每次使用next()的时候会检测这个值是否变化，变化了就会抛出异常</p>\n<p>场景：java.util的包下面的集合类都是快速失败的，不能多线程修改</p>\n<h3 id=\"安全失败\">安全失败</h3>\n<p>采用安全失败的集合容器，遍历的时候不是在原本内容上遍历，而是在副本上遍历</p>\n<p>原理：迭代时对副本遍历，所以对原集合的修改不能被检测到</p>\n<p>缺点：迭代器从遍历开始时拿到副本，此时原集合发生变化不会被感知到</p>\n<p>场景：java.util.concurrent包下面的容器都是安全失败，可以多线程并发使用，并发修改</p>\n<h2 id=\"JVM\">JVM</h2>\n<p>jvm五大区域：程序计数器、虚拟机栈、本地方法栈、java堆、方法区</p>\n<ul>\n<li>程序计数器：线程私有，很小的内存空间，作为当前线程的行号指示器，记录当前虚拟机正在执行的线程指令地址</li>\n<li>虚拟机栈：线程私有，每个方法执行的时候都会创建一个栈帧，用于存储局部变量表、操作数、动态链接和方法返回等信息，线程请求栈深度超过虚拟机允许的最大深度时会抛出溢栈错误</li>\n<li>本地方法栈：线程私有，保存native方法的信息，jvm创建的线程调用native方法后，jvm不会创建栈帧，而是简单地动态链接并直接调用该方法</li>\n<li>堆：所有线程共享的一块内存，所有对象的实例和数组都在堆上分配内存，垃圾回收常在这个区域发生</li>\n<li>方法去：存放已经被加载的类信息、常量、静态变量、即时编译器编译后的代码。jdk1.8后不存在了，被元数据区替代，方法区被分为两个部分：加载的类信息和运行时常量池。加载的类信息保存在元数据区中，运行时常量保存在堆中。</li>\n</ul>\n<h2 id=\"heap和stack的区别\">heap和stack的区别</h2>\n<h3 id=\"申请方式\">申请方式</h3>\n<ul>\n<li>stack： 系统自动分配，声明的局部变量系统会自动在栈中分配空间</li>\n<li>heap：需要手动申请，例如new</li>\n</ul>\n<h3 id=\"申请后的系统响应\">申请后的系统响应</h3>\n<ul>\n<li>stack： 只要栈的剩余空间足够，系统就会提供空间，否则报异常</li>\n<li>heap： 操作系统有一个记录空闲内存地址的链表，系统收到程序申请的时候，会遍历该链表，找到第一个符合申请空间的堆节点，将节点从内存中去掉，把空间分配给程序。由于找到的空间可能偏大，系统会把多余的空间收回放入空闲链表</li>\n</ul>\n<h3 id=\"申请大小的限制\">申请大小的限制</h3>\n<ul>\n<li>stack： 栈是向低地址扩展的数据结构，是连续的存储空间。栈顶地址和栈的最大容量是系统预设好的，因此如果申请的空间朝服哦栈的剩余空间，会报错，获得的空间较小</li>\n<li>heap： 堆是向高地址扩展的数据结构，不连续。堆的大小受限制于计算机系统的虚拟内存。获取堆空间灵活性较大，空间也较大</li>\n</ul>\n<h2 id=\"java中的垃圾回收算法\">java中的垃圾回收算法</h2>\n<h3 id=\"标记清除法\">标记清除法</h3>\n<ul>\n<li>第一步： 利用可达性去遍历内存，把存活对象和垃圾对象标记</li>\n<li>第二步： 再遍历一遍，将所有标记的对象回收掉</li>\n<li>特点： 效率不高，标记和清除后会产生大量不连续空间。</li>\n</ul>\n<h3 id=\"标记整理法\">标记整理法</h3>\n<ul>\n<li>第一步： 利用可达性去遍历内存，把存活对象和垃圾对象标记</li>\n<li>第二步： 将所有存活对象向一端移动，端边界的对象都回收</li>\n<li>特点： 适用于存活对象多，垃圾少的情况</li>\n</ul>\n<h3 id=\"复制算法\">复制算法</h3>\n<p>将内存按照容量大小分为相等两块，每块只用一次，一块用完后，将存活对象移到另一块，再把使用过的内存空间清除</p>\n<p>特点：不产生空间碎片，内存使用率极低</p>\n<h3 id=\"分代收集算法\">分代收集算法</h3>\n<p>根据对象存活周期不同，将内存划分为几块。java虚拟机将内存分为新生代和老生代，新生代中大量对象死去和少量对象存活，使用复制算法；老生代中对象存活率高，采用标记清理或者标记整理。</p>\n","categories":["General"],"tags":["八股"]},{"title":"类脑超大规模深度神经网络系统","url":"/2023/02/06/%E7%B1%BB%E8%84%91%E8%B6%85%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/","content":"<p>目前的大规模神经网络难以到达人脑生物神经网络连接的规模，在多通道协同处理、知识存储和迁移、持续学习方面表现不佳。作者构建一种启发于人脑功能机制的大规模神经网络模型，以脑区划分和脑区功能机制为启发，借鉴脑功能分区来模块化构建大规模神经网络模型，根据场景输入和目标, 自动构建神经网络通路, 设计神经网络模型来获得输出。该神经网络模型关注输入到输出空间的关系构建, 通过不断学习, 提升模型的关系映射能力, 目标在于让该模型具备多通道协同处理能力, 实现知识存储和持续学习。</p>\n<span id=\"more\"></span>\n<h2 id=\"背景\">背景</h2>\n<p>神经网络规模大小与识别精度之间存在很强的关联性，神经网络模型越大, 任务处理表现就越好。人脑生物神经网络的复杂程度远超目前的人工神经网络模型，并且大规模神经网络的训练需要消耗巨大的计算资源和时间。因此, 大规模神经网络模型需要一种新的组织方式, 以实现自身的高效训练和灵活使用。</p>\n<p>目前的神经网络的局限性：</p>\n<ul>\n<li>由于特定任务确定了输入/输出空间的边界,任务相关的大规模输入数据为大规模神经网络学习提供了条件, 使得大规模神经网络展现出强大的端到端表示能力和非线性函数的无限逼近能力。但当输入/输出空间的边界不确定, 或者输入空间发生变化, 人工神经网络模型往往难以适应, 表现出较低的迁移性, 无法直接迁移到不同任务中并取得较好的结果。</li>\n<li>同时, 与大脑学习机制不同, 神经网络不具有持续学习能力。当任务发生变化, 输入/输出空间的相关关系随之改变, 神经网络难以持续学习更新已学习到的空间映射应对任务变化。</li>\n<li>神经网络如何存储知识是存在争议的, 神经网络映射能否实现知识迁移, 怎么样去实现, 还在探索之中。</li>\n</ul>\n<p>人脑生物神经网络的复杂性, 使得大规模神经网络模型设计存在瓶颈,需要一种新的类脑机制指导大规模神经网络设计和学习。</p>\n<p>本文提出一种启发于脑功能机制的超大规模深度神经网络模型，该模型以脑功能和神经网络研究为基础, 集成海量数据集和预训练模型, 借鉴类脑功能的协同机制, 利用模型设计组件, 完成针对不同任务场景的神经网络模型设计。<code>关注如何构建输入/输出的映射关系, 而不是神经网络连接细节</code>。目标在于使神经网络模型具备多通道协同处理能力, 提升输入/输出关系的映射能力, 实现知识存储, 让模型具备可持续学习能力应对任务的变化。</p>\n<p>具体研究内容：</p>\n<ul>\n<li>基于人脑功能研究成果, 研究如何基于大脑功能机制构建类脑神经网络功能区。</li>\n<li>构建类脑功能区, 设计数据库系统, 实现类脑功能区灵活管理。</li>\n<li>基于脑功能协同工作机制研究模型设计组件平台, 完成针对特定场景的神经网络模型设计, 构建分布式训练组件提供算法和分布式训练支持。</li>\n<li>完成超大规模神经网络模型构建, 研究从场景输入到构建神经网络模型作为输出的通路, 并在多个不同模态任务进行可行性验证。</li>\n</ul>\n<h2 id=\"类脑大规模神经网络模型设计\">类脑大规模神经网络模型设计</h2>\n<p>整个模型包含4层架构(研究基础、类脑功能区、算法平台、应用平台)的解决方案, 如图1所示, 所有数据和类脑功能区通过数据库系统进行管理。</p>\n<p><img src=\"https://i.imgur.com/KtQg9Yq.png\" alt=\"picture 1\"></p>\n<h3 id=\"类脑研究基础\">类脑研究基础</h3>\n<p>脑功能和脑区存在多对多的关系, 即一个脑功能涉及多个脑区, 一个脑区可能服务多种功能。</p>\n<h3 id=\"类脑功能区设计\">类脑功能区设计</h3>\n<p>视觉、听觉、语言、情感这4个功能覆盖的脑区较多, 这也和目前神经网络研究的主要领域相符. 所以, 目前我们构建的超大规模的类脑网络模型主要包括了视觉功能区、听觉功能区和语言功能区以及情感功能区。</p>\n<p>以视觉脑功能区为例, 介绍如何依据脑区的功能特点构建类脑功能区, 如图2所示. 根据目前掌握的数据, 视觉功能和30多个脑区相关, 与其相关的二级功能可以细分为动作、颜色、形状和其他。</p>\n<p><img src=\"https://i.imgur.com/fgm2Orh.png\" alt=\"picture 2\"></p>\n<h3 id=\"类脑功能区协同工作\">类脑功能区协同工作</h3>\n<p>模型借鉴大脑脑区协作机制指导类脑功能区协同工作, 实现多通道数据处理。在特定应用场景下, 对脑区活动进行监测, 分析脑区的在特定任务场景下的结构关联和功能关联, 并以此作为类脑功能区协作的基础。</p>\n<p><img src=\"https://i.imgur.com/lpr0ZlI.png\" alt=\"picture 3\"></p>\n<h3 id=\"类脑功能区数据存储和管理系统\">类脑功能区数据存储和管理系统</h3>\n<p>将目前开源或者可用的神经网络结构和预训练模型以及依赖的数据集进行整理和归纳, 按照类脑功能区的构建原则, 将所有神经网络模型映射到对应的脑功能区中。为了实现类脑功能区的高效管理和使用. 我们设计了一套“人工编码”对神经网络模型重新进行描述。</p>\n<p><img src=\"https://i.imgur.com/y9jRJKV.png\" alt=\"picture 4\"></p>\n<p>设计了一个完整的信息管理系统实现类脑功能区的管理: 首先, 将脑功能区的字典进行单独存储与维护, 作为基本模型的属性之一; 其次, 对于模型本身, 拆分成基本网络模型和预训练模型两个部分,其中, 基本模型包含模型本身的各种属性, 包括所归属的子功能区、网络结构特征、评价指标、以及拥有的关键层等, 而针对预训练模型则记录其训练平台、数据集、优化器等信息; 最后, 对上传的神经网络模型和预训练模型分类存储。</p>\n<p><img src=\"https://i.imgur.com/nTnPPkg.png\" alt=\"picture 5\"></p>\n<h2 id=\"算法平台中间件\">算法平台中间件</h2>\n<p>该算法平台中间件主要功能是基于现有类脑功能区中的数据和模型, 根据应用场景需求完成新的神经网络模型设计. 目前主要包括3个组件：</p>\n<ul>\n<li>神经网络模型设计组件, 构建面向任务的网络模型</li>\n<li>知识储存和学习组件, 实现预训练模型的存储和更新. 引入注意机制, 持续学习优化模型设计组件的性能</li>\n<li>分布式训练组件, 为神经网络模型的分布式训练和存储提供算法支撑</li>\n</ul>\n<h3 id=\"模型设计组件\">模型设计组件</h3>\n<p>演化计算是一种基于种群的优化算法, 借鉴生物界自然选择和自然遗传机制而发展起来的通用问题求解方法. 它一般包括基因编码、种群初始化、交叉变异算子、选择保留等基本操作。进化计算是一种成熟的具有高鲁棒性和广泛适用性的全局优化方法, 具有自组织、自适应、自学习的特性, 能够不受问题性质的限制。</p>\n<p>基因1和基因2分别对两个模态的类脑功能区进行编码, 每个基因有3个部分组成, 分别用来编码优化器、网络结构特征、网络规模大小.基因1和基因2构成一个个体, 多个个体构成种群。</p>\n<p><img src=\"https://i.imgur.com/Isaj0cy.png\" alt=\"picture 6\"></p>\n<p>首先是设计一种整数编码, 对神经网络模型特征进行编码, 例如优化器、网络结构特征、模型规模. 给定一个整数编码, 即可解码出一个神经网络模型. 当涉及到多个模态的网络, 根据多个功能区协同工作的机制, 分别对多个类脑功能区进行编码, 然后将多个编码信息组成一条基因, 即对应到一个个体. 个体通过解码可以得到多个不同模态的神经网络模型, 多个网络融合后可以用于解决多模态的问题. 一个种群往往包含多个个体. 其次, 用个体在多模态目标任务上的性能指标作为个体的适应度值. 最后, 通过演化算法的演化操作: 选择、变异、交叉生成新的种群, 通过不断的演化, 最终找出适应度值最高的个体, 即是针对当前应用场景最佳的神经网络模型设计。</p>\n<h4 id=\"基于强化学习的模型设计方法\">基于强化学习的模型设计方法</h4>\n<p>结合强化学习的强大能力, 我们也可以用来搜索模型的网络结构。整个流程大概分为控制器以一定的概率生成结构A, 训练模型结构A得到模型A的精度, 然后用强化学习的技术去计算梯度, 更新我们的控制器RNN. 如此循环往复, 直到达到某个终止条件结束搜索。</p>\n<p>神经网络的结构和连接可以表示为可变长度的字符编码, 所以我们可以利用如RNN来生成这样的字符串, 用来表征不同的网络结构。</p>\n<p><img src=\"https://i.imgur.com/x9x6IGL.png\" alt=\"picture 7\"></p>\n<h4 id=\"基于可微梯度的模型设计方法\">基于可微梯度的模型设计方法</h4>\n<p>基于梯度的网络结构搜索方法是把离散的网络结构搜索空间转化为连续的搜索空间表示. 这样, 在进行搜索和优化的时候, 能够加快搜索效率和节约搜索所消耗的资源。</p>\n<p>其中, 通过编码器可以把离散的网络结构编码成连续的空间表示, 性能预测器则可以输出更好的网络结构嵌入表示. 最后就是解码器,是把搜索得到的更好的网络结构嵌入表示解码为最终的结构。该方法通过编码器得到连续的空间表示后是直接通过梯度优化, 得到我们想要更好的网络结构表示。</p>\n<p><img src=\"https://i.imgur.com/a1UnH8Q.png\" alt=\"picture 8\"></p>\n<h3 id=\"知识存储与学习组件\">知识存储与学习组件</h3>\n<p>为了实现神经网络的知识存储, 进而达到语义分析和推理, 我们认为: 除了脑启发的神经网络架构之外, 还需要大量训练数据和大规模网络结构将学习到的知识存储到神经网络中。</p>\n<p>主要功能是对已有知识进行存储和学习、辅助类脑功能区在特定任务场景下的神经网模型设计. 该组件要存储的是经过预训练的、专门用于感知的(如视觉分类、听觉分类、自然语言处理)预训练模型, 并能通过新的数据对预训练模型进行更新。</p>\n<p>在类脑神经网络模型应对新任务进行神经网络模型设计时, 如何选择预训练模块也非常关键, 决定了新神经网络模型对输入/输出空间的映射能力. 为了更好地利用这些预训练模型, 该组件引入人脑注意力机制, 在不同应用场景下, 选择一些关键的信息输入进行处理, 选出最佳的预训练模型, 辅助模型设计组件构建新的神经网络模型。</p>\n<h3 id=\"分布式训练组件\">分布式训练组件</h3>\n<h4 id=\"基于多节点的分布式训练平台\">基于多节点的分布式训练平台</h4>\n<p>在模型设计组件中, 每个多模态网络需要在目标数据集上进行验证, 得到的性能指标将作为反馈继续指导类脑功能区的协同工作。</p>\n<p>整个集群由两类节点组成: 服务节点和计算节点, 所有节点通过TCP/IP网络连接. 在我们构建的分布式集群中, 有1个服务器节点, 该节点主要负责集群的管理以及类脑功能区的管理. 多个计算节点主要负责多模态网络在数据集上进行验证, 所有节点异步向服务器节点发起任务请求. 该平台的特点是对计算节点性能没有一致性要求, 任何性能的计算节点都可以加入该集群, 提升分布式计算能力。</p>\n<p><img src=\"https://i.imgur.com/GyXp1RI.png\" alt=\"picture 9\"></p>\n<h4 id=\"大规模神经网络分布式训练算法\">大规模神经网络分布式训练算法</h4>\n<ul>\n<li>模型并行：神经网络的每个层可以被分配给不同计算节点进行训练, 整个训练过程如流水线. 该方法的优势在于神经网络模型可以分布式存储, 减小存储压力; 缺点在于神经网络在训练过程中, 各个节点间需要通信开销, 且实现困难, 模型一致性难以保证。</li>\n<li>数据并行：不同计算节点具有完整的模型副本和目标数据集的部分子集. 每个计算节点基于分配的子数据集对神经网络进行训练, 参数服务器收集各个计算节点的神经网络参数或者梯度, 并计算新的参数, 最后分发新参数给每个计算节点。</li>\n</ul>\n<h2 id=\"应用场景-2\">应用场景</h2>\n<h3 id=\"单模态应用场景研究\">单模态应用场景研究</h3>\n<p>介绍基于视觉功能区的单模态应用场景的构建. 我们构建的单模态应用场景为多目标跟踪, 并且这里的多目标追踪特指基于检测的多目标跟踪。</p>\n<h4 id=\"背景-2\">背景</h4>\n<p>基于检测的多目标跟踪实现流程(以检测视频中的多目标为例)如下：</p>\n<ul>\n<li>（1）给定视频的原始帧</li>\n<li>（2）运行目标检测模型获得给定视频原始帧中对象的边界框</li>\n<li>（3）对于每个检测到的物体，计算不同特征</li>\n<li>（4）对不同特征进行相似度计算</li>\n<li>（5）对不同帧的对象进行关联，为每个对象分配数字id</li>\n</ul>\n<p>本节介绍的这种基于检测的多目标跟踪方法并不是一个端到端的过程.我们可以将其看成是一个two-stage的过程: 第1步, 利用目标检测模型进行物体检测, 即上述实现流程中的步骤(1)、步骤(2); 第2步, 将检测到的物体进行联, 即上述实现流程中的步骤(3)步骤(5)。我们可以使用某种搜索算法去搜索视觉功能区中的目标检测模型来替换多目标追踪框架的第一步中的目标检测模型。</p>\n<h4 id=\"实验设计\">实验设计</h4>\n<p>其中, 检测这一层级中有Faster R-CNN, SSD, YOLOv3等目标检测模型. 这些模型的源文件和预训练好的参数都已经存储在我们的视觉功能区中. 实验选取的多目标跟踪框架为deep-sort。实验使用算法平台从视觉功能区中的检测子功能区中选择出一个目标检测模型, 用于构成deep-sort算法中的目标检测模块。</p>\n<p><img src=\"https://i.imgur.com/TDqFbuD.png\" alt=\"picture 10\"></p>\n<p>对检测子功能区中的目标检测模型进行简单编码作为视觉功能区的搜索空间</p>\n<p><img src=\"https://i.imgur.com/aLDSp2S.png\" alt=\"picture 11\"></p>\n<h3 id=\"多模态应用场景研究\">多模态应用场景研究</h3>\n<h4 id=\"背景-3\">背景</h4>\n<p>对于同一个事物有不同角度的观察, 每一个角度成为一个模态; 多个角度构成多个模态。单个模态对于事物的描述是有偏的, 通过多个模态来描述该事物能够减少这种偏移。</p>\n<p>事物的统一表示有联合表示(joint representation)和协同表示(coordinate representation)两种方法. 通常, 构建联合表示的核心问题之一即为如何将多个模态的数据进行融合. 一般可采用的数据融合操作为向量的连接、加权和、多线性池化和基于注意力机制的融合等, 然而不同的融合操作有不同性质, 这些性质影响着不同任务的最终表现. 而协同表示则类似于坐标系下的坐标, 用单个模态的表示作为多模态表示的一个分量. 协同表示的各个模态分量一般需要通过结构或者相似性约束来建模各个模态之间的内在联系.最新的研究表明, 多模态数据融合可以通过网络结构搜索完成。</p>\n<h4 id=\"基于类脑模神经网络模型的多模态应用\">基于类脑模神经网络模型的多模态应用</h4>\n<p>一般的, 多模态数据都选取高层特征来进行融合, 例如卷积神经网络(convolution neural network)的特征<br>\n图(feature map)或者循环神经网络(recurrent neural network)的特征向量等。</p>\n<p>MFAS利用不同特征提取器构建不同模态的高层特征, 并从这些特征提取器中搜索了不同模态的特征组合来完成多次多模态特征融合。</p>\n<p>提出的类脑模型中, 特征提取器, 即模型组件由类脑网络模型的算法中间件提供.同时, 每个模型组件都会进行单模态数据的预训练. 最后, 自动化地完成多模态融合网络的构建.</p>\n<p>类脑神经网络模型的多模态问题的应用过程如下：</p>\n<ul>\n<li>算法平台中间件提供单模态的模型组件设计</li>\n<li>对单模态模型进行预训练</li>\n<li>采用预训练模型组件进行多模态融合网络的自动化构建</li>\n</ul>\n"},{"title":"多智能体","url":"/2023/12/27/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93/","content":"<h2 id=\"Organizations-in-TransVerse-Federated-Intelligence-for-Smart-Mobility\"><a href=\"#Organizations-in-TransVerse-Federated-Intelligence-for-Smart-Mobility\" class=\"headerlink\" title=\"Organizations in TransVerse: Federated Intelligence for Smart Mobility\"></a>Organizations in TransVerse: Federated Intelligence for Smart Mobility</h2><p>主要讲如何通过手机等现在智能工具的网络信息构建交通系统</p>\n<p>人文和社会因素对于交通系统至关重要，但自上而下的管理未能充分考虑这些因素。 因此，管理策略不适合人类的需求，并且不足以提供交通情报。 本文研究了一种基于去中心化&#x2F;分布式自治运营&#x2F;组织 (DAO) 的管理架构，该架构考虑了我们的交通元宇宙 TransVerse 中的技术和社会方面。 该设计将人们在物理空间的交通需求映射到网络空间的数字交通需求，利用区块链技术保证信息的安全交换，最终实现思想互联网（IoM）。 借助 IoM 中出现的联合智能，我们可以通过将共识、社区投票和智能合约纳入组织、协调和执行结构中来设计可靠且及时的流量决策。 还详细介绍了操作程序和关键技术。 为了证明基于 DAO 的管理的有效性，提供了世界模型驱动的协作信号控制的案例研究，表明其在未来交通管理中的应用前景。</p>\n<p>城市发展导致人口密度上涨，给城市交通带来了压力。物联网（IoT）通过将手机、智能手表、车载系统等这些设备和设施连接到各种网络来实时监控交通状况并及时做出决策。这些众包社交传感器生成的社交信号可以通过提供有关城市动态、社会行为和交通状况的及时、全面和丰富的数据来补充交通模型。 因此，有必要设计一种新的视角，将社会信号与尖端技术结合起来，让技术智能和社会智能相辅相成，创造出更加精细的交通智能。</p>\n<p>TransVerse 是一个由各种人工交通系统 (ATS) 组成的交通元宇宙联盟，允许所有交通参与者（包括人类、车辆和智能基础设施）通过心智互联网 (IoM) 连接起来的虚拟空间。它是根据去中心化&#x2F;分布式自治操作和组织 (DAO) 原则 [23] 以及人工系统、计算实验、并行执行而设计的。该设计的重点是构建具有特定目的的各种ATS，然后利用虚拟现实交互和并行执行来直接或间接改变人类的意图和行为，引导实际系统朝着预期目标的方向发展。</p>\n<span id=\"more\"></span>\n\n<p>ITS的传统定义是指应用先进科学技术，促进车辆、道路和用户之间的连接，从而形成安全、经济、节能、环保的统一交通系统。 设计理念侧重于技术元素，这些技术元素是众多智能交通系统技术的发明和实施背后的驱动力。然而，<strong>人们在DT中通常被认为是被动实体，而他们的主动参与却被忽视</strong>，导致DT在解决社会因素引起的CPSS中的不确定性、多样性和复杂性（UDC）方面遇到困难。 理解人类主观行为的复杂性有助于在交通系统中制定明智的选择。 例如，高峰时段通勤者挤满道路，道路变得越来越拥堵； 相反，当人们在工作时，他们的拥挤程度要低得多。 人们的生活方式与交通系统紧密相连，很明显，在交通进步和演变中，社会因素与技术因素同样重要，甚至更重要。 </p>\n<p>随后，提出了交通5.0的提议，公民在智能交通系统的检测、通信、计算、监管和监督中发挥积极作用。 交通5.0推动了智能交通系统定义的范式转变，<strong>从以技术为重点转向以人为本，以及研究领域从CPS向扩展的CPSS（称为TransVerse）的转变。 如图1所示，它强调六种智力（“6I”）：1）认知； 2）平行； 3）加密货币； 4）联合； 5）社交； 6）生态智能。</strong> “6I”将智能交通系统从基于特征的工程设计转变为面向场景的交通生态，从而使智慧城市的创建和可持续发展的“6S”目标得以实现：物理世界中的人身安全、信息 网络世界的安全、生态世界的环境可持续性、对个人需求的敏感性、为所有人服务和所有人的智能。</p>\n<p>TransVerse 中必须构建各种可靠且值得信赖的面向场景的 ATS 来进行计算实验。 现有的ITS基础设施和技术，例如空间地形数据集成和动态社会数据收集，都可以为场景构建过程做出贡献。 在整合静态和动态数据后，必须建立一种通过校准和认证（C＆C）以及验证和确认（V＆V）确保场景可信度的方法，即场景工程。 该工具可用于对齐和补充多模态数据集，并且当与生成对抗网络（GAN）或扩散模型等增强技术相结合时，它可以帮助<strong>缓解数据不平衡</strong>。 当这些技术结合起来时，我们将获得干净而丰富的数据，可用于渲染沉浸式虚拟场景。 这些基于场景的 ATS 可以绘制实时演变图并模拟未来事件，可能有助于组织在分配交通资源和应对变化方面做出更好的决策。 显然，TransVerse为数字模拟和城市管理提供了全面而广阔的网络空间。</p>\n<p><strong>TransVerse 的运作基础是人类行为与其周围环境之间的持续互动，这是有意识的逻辑行为，而不是反应性反应。</strong> 人类行为不能仅通过个体分析来理解，而必须在更广泛的社会互动背景下看待。 根据人类行为学，行为是生命的固有组成部分，身体体现行为，灵魂负责决定。 随着智能时代的到来，它扩展了人类的能力：机器人人（RH）是身体的物理延伸，可以将我们从平凡、乏味或危险的任务中解放出来，而数字人（DH）则是 网络空间中人们的数字对应物极大地扩展了人类的认知活动。 它们的通信范围可以是一对一、一对多或多对一，具体取决于任务的复杂性和所需的计算量。 人机交互技术连接人类跨多个空间的活动，大幅提升人类能力并改变我们的生活方式：为物理空间而存在，为社会空间而存在，为网络空间而信仰</p>\n<p>有效的运输组织管理取决于做出正确决策的能力，这需要可靠的数据以及对形成和执行的信任。 尽管如此，<strong>数据不对称和信任不对称仍然是智能交通系统和组织管理改革进一步进展的主要障碍。</strong> 数据不对称凸显了旅行者可以获得的交通信息的巨大差异。 交通资源的可用性和需求之间也存在显着差异。 两者之间的时空关系的不平衡对许多人的日常生活产生了重大影响，尤其是居住在城市地区的人。 信任不对称的存在是由于多种因素造成的，包括私人信息的保护、信任水平的不同以及权力和责任的差异。 这可能导致各方之间缺乏信任，为有效沟通、协作和决策造成障碍。 此外，信任和数据通常齐头并进：信任是通过数据积累建立的，从而促进信息的持续交换。 通过基于区块链的平台 TransVerse，用户能够传达他们的旅程计划、见解和假设。 通过将这些联合数据融合在一起，创建了一个 IoM，消除了数据不对称，然后在区块链网络中传播。 区块链技术确保通过共识实现长期城市发展，执行交通法规，并通过代币激励和社区投票鼓励民主治理，以及通过智能合约实现流程自动化。 这个过程高度可靠，接受公众监督，并且准确性可验证，从而消除了信任不对称。 为了应对一些重要的原始数据无法通过交通区块链网络的挑战，我们可以利用联邦学习（FL）和多方安全计算（MPSC）来构建具有联邦数据和 利用云&#x2F;边缘计算系统加快这一过程。 经过训练的基础模型可以应用于新的场景和任务，避免“重新发明轮子”的问题。</p>\n<p>共识协议对于消除区块链网络中的信任不对称性以及确保 TransVerse 决策过程的可靠性至关重要。 区块链网络中采用了各种共识算法，最流行的算法是工作量证明（POW）、权益证明（POS）、委托POS（DPOS）、瑞波协议共识算法（RPCA）、实用拜占庭容错 （PBFT）和委托拜占庭容错（DBFT）。 每个选项都有自己的优点和缺点，因此在定制适用于交通管理的共识机制时需要找到最佳的折衷方案，因为这将决定前进的道路。 它还可以精心设计以纳入现有的监管规定，从而对每个人进行分布式监控。 这确保了决策是根据管理机构制定的法规和标准做出的，从而使交易更加安全可靠。</p>\n<p>TransVerse 以联盟的方式促进用户之间的协作，赋予他们发起提案、投票和分配任务的能力，从而实现去中心化&#x2F;分布式操作。 为了保证积极的结果，必须根据共识协议选择合适的投票机制，明确谁有资格投票以及投票对共享管理的影响。 在决策过程中，NFT 用于促进多个参与者之间的合作博弈，并指导他们的个人旅行意图，以促进整体交通可达性。 由于管理决策对不同个人和级别的影响不同，使用传统的同质激励来衡量它们已不再可行； 相反，使用以 NFT 为代表的经济激励是一种更有效的方式，以不可替代且不可转让的补偿形式来奖励成员。 NFT 与声誉、信任和关注等非货币激励相结合，可以满足各种参与者的需求，并可以根据个人对 DAO 的贡献进行分配，从而促进联邦智能。</p>\n<p>TransVerse 利用智能合约自动实施编码到区块链网络上的决策，确保去中心化和不变性。 最初，智能合约通常设计有交通管理规则和旅行意图协议，然后将其转换为 DAO 的可执行“If-Then”代码。 DAO 启动后，智能合约会根据分布式投票的结果进行调整和补充。 在 TransVerse 中，已经编程并生成了一组智能合约，用于记录访问权限、触发规定、通信规则和操作技术； 这些被打包到不同的代理中，这些代理可以持续观察触发条件并在没有任何外部干预的情况下自主执行，保证整个决策过程的效率和可信度。</p>\n<p>车辆基础设施系统（CVIS）和提供移动即服务（MaaS）。 区块链为多个用户轻松交换数据创建了一个值得信赖的平台，消除了信息障碍，并允许用户通过投票系统做出集体决策。 这促进了更智能的出行并更好地利用交通资源。 执行层强调解决问题，通过智能合约自主创建解决方案，保证快速运行。 这三个层面共同保证了TransVerse去中心化组织的顺利运行，让我们离“6S”交通系统更近了一步。</p>\n<h2 id=\"AI-ASSISTED-EDGE-CACHING-FOR-METAVERSE-OF-CONNECTED-AND-AUTOMATED-VEHICLES\"><a href=\"#AI-ASSISTED-EDGE-CACHING-FOR-METAVERSE-OF-CONNECTED-AND-AUTOMATED-VEHICLES\" class=\"headerlink\" title=\"AI-ASSISTED EDGE CACHING FOR METAVERSE OF CONNECTED AND AUTOMATED VEHICLES\"></a>AI-ASSISTED EDGE CACHING FOR METAVERSE OF CONNECTED AND AUTOMATED VEHICLES</h2><p>主要讲使用AI技术将虚拟世界所需要的文件存储到用户周边而非存储到服务器，降低获取成本，加快运行速度。</p>\n<p>即将到来的元宇宙将通过并行数字世界和物理世界之间的沉浸式信息交换，显着提高联网自动车辆（CAV）以及智能交通系统（ITS）的安全性和效率。 为了使虚拟世界能够更好地反映物理世界，虚拟世界应用程序需要获取大量文本、图片、语音和视频类型的感知信息。 边缘缓存被认为可以通过将所需内容存储在用户附近而不是存储在云端来提高传输质量和数据保护。 然而，CAV 的元界 (meta-CAV) 和 ITS 的元界 (meta-ITS) 的合格边缘缓存面临着无处不在的移动性、多样化的需求、动态内容流行度和异构基础设施的挑战。 在本文中，我们详细阐述了元 CAV 和元 ITS 的边缘缓存的要求和挑战。 然后，我们讨论如何在边缘缓存中使用人工智能 (AI)，以提高元 CAV 和元 ITS 的性能和安全性。 为了评估我们的想法，提供了基于多代理联合强化学习（MAFRL）的智能边缘缓存的案例研究。 给出了一些前瞻性研究方向来阐明更多想法。</p>\n<p>为每个物理用户创建一个化身来模拟人类与现实世界之间的交互。 由于虚拟世界是通过感知现实世界的多维实时信息来创建和操作的，因此可以记录数字世界如何响应化身的不同行为而变化，以指导物理世界中的实际政策设计。</p>\n<p>数字世界中的化身不仅需要模仿相应物理实体的行为，还需要根据交通状况做出自己的决定。 通过两个世界之间的双向数据传输，数字世界可以更好地模拟实际场景。 然而，meta-CAV和meta-ITS服务的应用将对传输质量提出严格的要求。 例如，CAV运动控制信息需要在0.5 ms内获取，ITS管理数据需要在10 ms内获取[3]。 而且，还会带来一些副作用，包括流量负担过大，超出了现有云存储架构的传输能力。 通过缓存，靠近用户的边缘服务器中的内容可以显着减轻通信开销并减少延迟</p>\n<p>与传统网络服务不同，元CAV和元ITS对边缘缓存提出了专门的要求。 首先，元界服务产生各种内容，包括文本、照片、音频和视频，这些内容具有多样化的服务质量（QoS）要求。 其次，元 CAV 和元 ITS 是高度动态的，这意味着缓存解决方案应该快速收敛以更新内容。 第三，异构网络，包括SAGIN、C-V2X和Wi-Fi，要求边缘缓存解决方案灵活且适合不同的网络和硬件。 我们可以发现，如何缓存各种内容涉及到很多因素，包括网络开销、QoS要求和内容流行度，而人工智能已经被用来解决传统缓存策略的问题</p>\n<p>本文重点介绍元 CAV 和元 ITS 的人工智能辅助内容缓存，以提高所提供服务的性能。 具体来说，我们讨论了元宇宙对内容缓存的新挑战和要求。 然后，阐述了如何在网络边缘采用人工智能来提高内容缓存的性能和安全保护。 为了清楚地解释我们的建议，我们给出了一个案例研究，其中利用 FL 和强化学习在网络边缘缓存元 CAV 和元 ITS 的内容。</p>\n<h2 id=\"From-Physical-to-Virtual-Widening-the-Perspective-on-Multi-Agent-Environments\"><a href=\"#From-Physical-to-Virtual-Widening-the-Perspective-on-Multi-Agent-Environments\" class=\"headerlink\" title=\"From Physical to Virtual: Widening the Perspective on Multi-Agent Environments\"></a>From Physical to Virtual: Widening the Perspective on Multi-Agent Environments</h2><p>主要讲虚拟现实的环境的设计如何更加真实。</p>\n<p>十多年来，环境被视为分析、开发或部署多代理系统 (MAS) 应用程序时的关键要素。 特别是，对于多代理平台的开发，它已成为一个关键概念，类似于基于位置的分布式系统领域的许多应用。 MAS 的一个新兴的、突出的应用领域与虚拟环境相关。 底层技术在某种程度上已经发展，这些应用程序已经从科学小说发展到研究论文，甚至真正的应用程序。 更重要的是，当前的技术使 MAS 成为此类虚拟环境的关键组件。 在本文中，我们扩大了 MAS 环境的概念，以涵盖新的和混合的物理、虚拟、模拟等形式的环境。 我们基于三个维度分析当前最有趣的应用领域：不同“现实”通过环境混合的方式、代理的基本性质、交互的可能形式和复杂性。除了这种特征之外，我们还讨论了如何扩大这种范围 可能环境的概念影响着它为各个领域中的应用程序开发提供的支持。</p>\n<p>在过去的十年中，由于应用领域的数量和复杂性以及多样化的增加，多代理系统（MAS）所应用的不同类型的环境有所增加。 具有巨大发展的一类环境与虚拟环境（VE）相关，它提出了对某些“现实”的越来越复杂和可靠的模拟，以供一个或多个用户沉浸其中。</p>\n<p>镜像世界、虚拟宇宙、网络空间并非没有关系。 他们的分析显示了三个主要的共同维度，涉及（i）它们在物理世界和虚拟世界之间同步的方式，（ii）代理（人工或人类）填充世界并相互合作&#x2F;竞争以实现其目标， (iii) 在这些互动中扮演不同角色的大量主体之间发生的社会关系和互动。 十年前，Weyns 等人提出了三类研究挑战，这是遵循将多智能体系统的环境视为主体思想的结果：第一类涉及“环境”的适当形式化，充分明确什么是“环境”。 代理以及整个系统的哪个元素是环境的一部分。基于这种形式化理解，期望开发不同类型环境的分类，也与应用领域的相应分类相关。第二类 挑战进一步推动这一点，并处理探索代理与其环境之间关系的挑战。这可以从三个维度来完成：与环境相关的代理的（软件）架构、管理代理之间交互的协议和法律。 代理及其环境以及由共享环境介导的代理之间，最后但并非最不重要的是环境拓扑对代理施加的约束。 第三类挑战涉及推进研究成果，解决工程环境中的前两类挑战（包括环境的设计和实施）。</p>\n<p>尽管最初从多个角度采取了广泛的方法，但重点是非常有限的环境类型，主要是 MAS 所需的组件和基础设施。 此类环境主要被确定为“真实”世界或一组非代理应用程序。在本贡献中，我们拓宽了对环境的视角，以系统地考虑混合形式。我们识别、分析和描述有趣的应用程序领域 对于 MAS，特别关注它们所处的不同类型的环境并与之相关。</p>\n"},{"title":"脚本事件预测数据集相关介绍","url":"/2022/10/31/%E8%84%9A%E6%9C%AC%E4%BA%8B%E4%BB%B6%E9%A2%84%E6%B5%8B%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9B%B8%E5%85%B3%E4%BB%8B%E7%BB%8D/","content":"<h2 id=\"两个基本数据集\">两个基本数据集</h2>\n<h3 id=\"NYT-Finance\">NYT&amp;Finance</h3>\n<p>本文采用中英文两个数据集验证模型效果，其中英文数据来源为纽约时报，使用C&amp;C工具进行词性标注与依赖性分析，基于OpenNLP对句子进行句法分析与共指消解。构造的数据集每条事件链有8个已知事件，5个候选后续事件，其中一个为正确事件。</p>\n<p><img src=\"https://i.imgur.com/7E8Hxiv.png\" alt=\"picture 1\"></p>\n<p>截图所示为一条训练样本数据，数据结构为由2个列表及一个标签组成的列表，第一个列表包含8个元组，每个元组为一个事件表示，元组中的第一个元素为句中动词，第二个元素为句中动词原型，第三个元素为主语和动词的关系，第四个元素为主语，第五个元素为宾语，第六个元素为宾语补足语。第二个列表中包含5个元组，为5个候选事件表示，元组内容和已知事件中的元组内容相同。最后一个标签为候选事件中正确事件的下标，下标从0开始。<br>\n数据集的统计信息如表。</p>\n<table>\n<thead>\n<tr>\n<th>表头</th>\n<th>金融数据集</th>\n<th>NYT数据集</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>document</td>\n<td>373310</td>\n<td>830643</td>\n</tr>\n<tr>\n<td>事件链</td>\n<td>2341</td>\n<td>140331</td>\n</tr>\n<tr>\n<td>事件关联网络关系</td>\n<td>4038</td>\n<td>6187046</td>\n</tr>\n</tbody>\n</table>\n<span id=\"more\"></span>\n<p>我们使用的是每个8元组的第一个词作为该元组的表示，然后构建一个map将表示映射到唯一的id。这样就能形成id表示的事件链和对应的候选集列表。</p>\n<p>对数据的处理代码中：</p>\n<ul>\n<li>prepare_dataset.ipynb:是构建company_event的代码</li>\n<li>six_tuple_to_kg.ipynb:是构建这两个数据集的id事件链和id候选集的代码</li>\n<li>icew_preprocess.ipynb:是处理两个ICEW***.txt文件的代码</li>\n</ul>\n<p>data里面有处理好的数据，data_process里面有raw_data和处理程序。</p>\n<h2 id=\"两个我们自己处理之后的出来的数据集\">两个我们自己处理之后的出来的数据集</h2>\n<h3 id=\"ICEWS14-15\">ICEWS14 &amp; 15</h3>\n<p>我们从这两个数据集中提取出了一串连续的事件链，事件链长度为7好像，需要自己随机从id中生成候选集，这个数据集其实可用可不用，参考性没有那么大。</p>\n","categories":["事件预测"],"tags":["数据集"]},{"title":"脚本事件预测引入外部知识","url":"/2022/11/27/%E8%84%9A%E6%9C%AC%E4%BA%8B%E4%BB%B6%E9%A2%84%E6%B5%8B%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8%E7%9F%A5%E8%AF%86/","content":"<!-- ## Improving Distributional Similarity with Lessons Learned from Word Embeddings -->\n<h2 id=\"ConceptNet\">ConceptNet</h2>\n<p>一个连接自然语言中单词和短语的知识图谱，其中的边是有标签的。比如&quot;a dog has a tail&quot;表现在图中就是(dog,HasA,tail)。ConceptNet使用所选中的关系的封闭类，例如IsA、UsedFor和CapableOf，用于表示独立于语言或其连接的术语来源的关系。这些关系中也分对称的(RelatedTo,Antonym等)和非对称的(LocatedAt,CreatedBy等)。ConceptNet中的节点是一个单词或者短语。</p>\n<p>作者先用PPMI方法搭配SVD获取每个单词的嵌入，然后对这些嵌入再进行一次改进生成既考虑ConceptNet也考虑分布式词嵌入的向量。</p>\n<ul>\n<li>PPMI方法：PMI方法建立一个矩阵M，每一行代表一个词w，每一列代表一个上下文c，$M_{ij}$表示$w_i$和$c_j$的关联程度。PMI值可以表示为：</li>\n</ul>\n<p><img src=\"https://i.imgur.com/NFIUs6z.png\" alt=\"picture 1\"></p>\n<p>其中的$D$表示全部的(w,c)集合，$# (w,c)$表示该对在其中出现的次数。如果矩阵中的$M_ij$所表示的(w,c)对在全局中都没有出现，那么其PMI值就为log0即$-\\inf$,因此有人提出新的方法即PPMI，公式如下：</p>\n<p><img src=\"https://i.imgur.com/AMNMVyK.png\" alt=\"picture 2\"></p>\n<p>但是PPMI存在的问题就是对于不频繁事件会打高分，比如某一对(w,c)只出现了一次，根据公式，他的得分也会很大。</p>\n<p>然后SVD将M分解为$U\\times \\Sigma \\times V^T$，其中UV是正规的，$\\Sigma$是特征值降序的对角矩阵。只保留top d个元素可以得到$M_d=U_d\\times \\Sigma_d \\times V^T_d$,这样就可以对embedding做降维，即$W^{SVD}=U_d\\times \\Sigma_d , C^{SVD}=V_d$</p>\n<ul>\n<li>改进embedding方法：提出一个新的embedding$q_i$来尽可能接近其原始embedding$\\hat{q}_i$和相关边，表示为：</li>\n</ul>\n<p><img src=\"https://i.imgur.com/1nXWAtu.png\" alt=\"picture 3\"></p>\n<span id=\"more\"></span>\n<h2 id=\"KagNet-Knowledge-Aware-Graph-Networks-for-Commonsense-Reasoning\">KagNet: Knowledge-Aware Graph Networks for Commonsense Reasoning</h2>\n<h3 id=\"节点embedding\">节点embedding</h3>\n<p>使用的是ConceptNet,但由于该图过大，包含了太多的冗余信息，因此对于每一个问题和回答$c_i$,$c_j$，只保留这两个节点之间少于k步的路径，其余路径全部删除，生成一个ConceptNet的子图。然后先在这个生成的schema graph上进行预训练获取一个初级的embedding。然后再使用一次图卷积得到更好的embedding。</p>\n<p><img src=\"https://i.imgur.com/RRvWOuM.png\" alt=\"picture 14\"></p>\n<p><img src=\"https://i.imgur.com/rDJbGxu.png\" alt=\"picture 15\"></p>\n<h3 id=\"关系embedding\">关系embedding</h3>\n<p>$c_i^{(q)},c_j^{(a)}$之间的第k个路径表示为$P_{i,j}[k]$，即：</p>\n<p><img src=\"https://i.imgur.com/Ppxy1EP.png\" alt=\"picture 4\"></p>\n<p>每个三元组可以表示成其中三个组成部分的embedding的拼接，然后使用LSTM对路径进行学习，最终输出的隐藏层状态视为$c_i^{(q)},c_j^{(a)}$之间的潜在关系。最终的q&amp;a之间的关系embedding可以表示为：</p>\n<p><img src=\"https://i.imgur.com/MvCWNDL.png\" alt=\"picture 5\"></p>\n<!-- ## WebChild 2.0:Fine-Grained Commonsense Knowledge Distillation\n\n使用WebChile2.0作为外部知识库。-->\n<h2 id=\"ATOMIC-An-Atlas-of-Machine-Commonsense-for-If-Then-Reasoning\">ATOMIC: An Atlas of Machine Commonsense for If-Then Reasoning</h2>\n<p>提出了一种基于分类的if-then的推理类型：（1）if-Event-then-MentalState(eg. a 夸 b -&gt; b开心) （2）if-Event-then-Event(eg. a 拿车钥匙-&gt;a 开车) （3）if-Event-then-Persona(eg. a 报警 -&gt; a是个守法的人) 或者 （1） 原因 （2）影响 （3）状态</p>\n<p><img src=\"https://i.imgur.com/TWuZTN7.png\" alt=\"picture 6\"></p>\n<p>作者将事件分解为$e={e_0,e_1,\\dots,e_{n-1} }$，$e_i$是其中的单词,将这组单词编码成一个h维的隐状态，然后使用GRU对一连串事件进行输入并且推断最后一个事件信息。</p>\n<h2 id=\"WordNet\">WordNet</h2>\n<p>wordnet根据单词的语义分组，相同语义的单词组合在一起称为synset（同义词集），一个一词多义的单词将出现在它的每个语义对应的同义词集中<br>\nwordnet为每一个synset提供了简短，概要的定义，并记录不同synset之间的语义关系<br>\n在 wordnet中，名词，动词，形容词和副词各自组织成一个同义词的网络，四种不同词性的网络之间没有连接</p>\n<h2 id=\"Graph-Based-Reasoning-over-Heterogeneous-External-Knowledge-for-Commonsense-Question-Answering\">Graph-Based Reasoning over Heterogeneous External Knowledge for Commonsense Question Answering</h2>\n<p>ConceptNet是常用的常识知识库，包含有百万级别的节点和边。ConceptNet中的三元组包括4个部分：两个节点，一个关系以及关系的权重。</p>\n<p>针对每个问题和选项，首先识别出其在给定的ConceptNet图中对应的实体。然后在图中搜索从问题中的实体到选项中的实体的路径，路径小于3。接着，将覆盖到的三元组合并到一个图中，其中节点是三元组，边表示三元组间的关系。我们将此图称为Concept-Graph。</p>\n<p>如果两个三元组有相同的实体，则为两个三元组间添加连边。为了获得ConceptNet节点的上下文词表示，我们根据ConceptNet中的关系模板，将三元组转换为自然语言序列。</p>\n<p><img src=\"https://i.imgur.com/C4nmyPA.png\" alt=\"picture 8\"></p>\n<p>然后根据图结构对这些能够用到推理中的证据进行排序之后和question以及answer拼接输入到XLNet中来获取相关的上下文词块表示。</p>\n<h2 id=\"Using-External-Knowledge-for-Financial-Event-Prediction-Based-on-Graph-Neural-Networks\">Using External Knowledge for Financial Event Prediction Based on Graph Neural Networks</h2>\n<p>使用了一个自己搜集的财经新闻的相关数据对Finance数据集进行指导，每个item为(industry,verb)对，对于industry因为数量较少使用了onehot编码，使用预训练好的BERT对verb获取embedding，然后将两个embedding进行拼接。由于一个事件可能会与多个新闻相关节点有关，因此再使用图注意力进行一次聚合。然后对于一个事件的表示可以用事件的表示和相关新闻的表示结合。</p>\n<h2 id=\"Integrating-External-Event-Knowledge-for-Script-Learning\">Integrating External Event Knowledge for Script Learning</h2>\n<p>使用了ASER作为外部知识。首先从知识库中检索相关事件，然后对检索结果重新排序并且获得最佳事件。由于ASER中的事件数量非常多，因此使用了弹性搜索来对所有的事件构建索引，然后使用逆索引方式，输入一个事件就会返回topK个相关事件，由TFIDF或者BM25得分排序。</p>\n<p>但是上面的打分方法对于事件中的组成的权重是不区分的，然而事件中的动词往往包含的信息更加重要，因此设计了一个基于规则的打分机制来对给定事件和检索到的事件进行打分，动词相同就加4分，其他部分相同就加2分。然后选择打分最高的事件作为外部知识。另外，不是每个事件都能再ASER中找到相关事件，但是弹性搜索依然会返回一个事件列表，因此设置了一个阈值，如果一个脚本事件所有的相关事件得分都小于这个阈值，就不为这个事件引入外部知识。</p>\n<p><img src=\"https://i.imgur.com/AqrlmgK.png\" alt=\"picture 9\"></p>\n<p>作者提出了三种使用外部知识的方法：</p>\n<ul>\n<li>仅使用尾实体：使用RoBERTa-base对选取的外部知识三元组的tail获取表示，然后使用注意力机制将外部知识融入到表示中</li>\n</ul>\n<p><img src=\"https://i.imgur.com/yzArINM.png\" alt=\"picture 11\"></p>\n<ul>\n<li>使用事件模板：将ASER中的三元组转变成自然语言模式，然后再使用RoBERTa-base对该句子获取表示，使用注意力机制融入外部知识，比如(He does receive a call, Precedence, He departs away)-&gt;(He does receive<br>\na call happen before he departs away)</li>\n</ul>\n<p><img src=\"https://i.imgur.com/78yZFuu.png\" alt=\"picture 12\"></p>\n<ul>\n<li>使用表示融合：对每个ASER中的relation使用一个向量表示，即便在不同的三元组中也使用同一个向量表示。头实体和尾实体的表示使用RoBERTa-base获取，然后将三者拼接并且做一个Linear转换，然后使用attention融合信息。</li>\n</ul>\n<p><img src=\"https://i.imgur.com/9qBF85A.png\" alt=\"picture 13\"></p>\n<p><img src=\"https://i.imgur.com/FMculZ8.png\" alt=\"picture 10\"></p>\n"},{"title":"spring security 开发过程记录","url":"/2023/10/11/spring-security-%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/","content":"<h2 id=\"spring-security\"><a href=\"#spring-security\" class=\"headerlink\" title=\"spring security\"></a>spring security</h2><p>需要创建配置类并且注册一个bean，来对路由进行权限访问控制</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// spring security 6.0+</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> SecurityFilterChain <span class=\"title\">filterChain</span><span class=\"params\">(HttpSecurity httpSecurity)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> httpSecurity</span><br><span class=\"line\">                .csrf(csrf-&gt;csrf.disable())</span><br><span class=\"line\">                .authorizeHttpRequests(auth-&gt;auth</span><br><span class=\"line\">                        .requestMatchers(<span class=\"string\">&quot;/actuator/**&quot;</span>).permitAll()</span><br><span class=\"line\">                        .anyRequest().authenticated())</span><br><span class=\"line\">                .httpBasic(Customizer.withDefaults())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>"},{"title":"面试问答","url":"/2023/10/12/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/","content":"<h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><h3 id=\"三大分类\"><a href=\"#三大分类\" class=\"headerlink\" title=\"三大分类\"></a>三大分类</h3><h4 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a>创建型模式</h4><ul>\n<li>单例模式：一个类只有一个实例，并且提供一个访问该实例的全局节点<br>  实现方式：默认构造函数设为私有；新建一个静态构建方法作为构造函数；首次调用时创建新对象，并存储，之后的调用都返回存储的对象；</li>\n<li>生成器模式：能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。<br>  优点: 对于成员变量较多的类，无需在构造函数中全部列出，而是用那些初始化哪些<br>  实现方式：其实就和@Builder的原理一样</li>\n<li>工厂方法模式：定义一个创建对象的抽象方法，由子类决定要实例化的类。<br>  优点：新增功能的时候，只需要新建一个类，让这个类自己决定要实例化哪些类<br>  缺点：每个产品都要有一个对应的创建类，太多冗余了<br>  实现方式：让所有产品都实现同一个接口；创建类中添加空的工厂方法，返回类型为产品的接口；为每个产品写一个创建者子类；</li>\n<li>抽象工厂模式：能创建一系列相关对象，无需指定其具体类<br>  优点：同一工厂类的产品互相匹配<br>  缺点：需要引入众多的接口<br>  实现方式：对所有产品声明接口（椅子，桌子）；所有的该产品变体实现这个接口（红木椅子，桃木椅子，红木桌子，桃木桌子）；声明抽象工厂，包含所有产品创建的方法，返回值为接口类型（造椅子，造桌子）；变体产品的工厂类继承抽象工厂（桃木工厂，红木工厂）；</li>\n<li>原型模式：使你能够复制已有对象， 而又无需使代码依赖它们所属的类。<br>  实现方式：将对象实现一个克隆接口，将克隆的过程交给该对象本身进行</li>\n</ul>\n<span id=\"more\"></span>\n\n<h4 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h4><ul>\n<li>适配器模式：使接口不兼容的对象能够相互合作。<br>  实现方式：声明客户端接口，描述客户端如何与服务交互；创建遵循客户端接口的适配器类；类中添加一个成员变量保存对于服务对象的引用；适配器的方法中将实际的服务内容由服务对象执行，自己只负责转换数据格式。</li>\n<li>桥接模式：将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。</li>\n<li>装饰模式：将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。<br>  实现方式：找出基本组件和可选层次的通用方法。 创建一个组件接口并在其中声明这些方法；创建一个具体组件类， 并定义其基础行为；创建装饰基类， 使用一个成员变量存储指向被封装对象的引用；将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为；</li>\n</ul>\n<h4 id=\"行为模式\"><a href=\"#行为模式\" class=\"headerlink\" title=\"行为模式\"></a>行为模式</h4><h2 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h2><h3 id=\"类加载过程\"><a href=\"#类加载过程\" class=\"headerlink\" title=\"类加载过程\"></a>类加载过程</h3><p>加载 $\\rightarrow$ 连接 $\\rightarrow$ 初始化。其中连接分为三步：验证 $\\rightarrow$ 准备 $\\rightarrow$ 解析。</p>\n<p>加载主要完成三件事：</p>\n<ol>\n<li>通过全类名获取类的二进制字节流</li>\n<li>将字节流代表的静态存储结构转换为方法区运行时的数据结构</li>\n<li>内存中生成一个该类对象，作为其中方法的访问入口</li>\n</ol>\n<h3 id=\"加载规则\"><a href=\"#加载规则\" class=\"headerlink\" title=\"加载规则\"></a>加载规则</h3><p>对于已经加载的类会被放在 ClassLoader 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</p>\n<h3 id=\"加载器类别\"><a href=\"#加载器类别\" class=\"headerlink\" title=\"加载器类别\"></a>加载器类别</h3><ul>\n<li>BootstrapClassLoader(启动类加载器)：加载lib下的包和类。顶层加载器，没有父级，加载JDK内部核心类库</li>\n<li>ExternalClassLoader(扩展类加载器)：加载lib&#x2F;ext下的包和类</li>\n<li>AppClassLoader(应用程序类加载器)：加载用户的类</li>\n</ul>\n<h3 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h3><ul>\n<li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li>\n<li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 loadClass()方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 BootstrapClassLoader 中。</li>\n<li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 findClass() 方法来加载类）。</li>\n<li>如果子类加载器也无法加载这个类，那么它会抛出一个 ClassNotFoundException 异常。</li>\n</ul>\n<p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p>\n<h2 id=\"新生代和老年代的区别\"><a href=\"#新生代和老年代的区别\" class=\"headerlink\" title=\"新生代和老年代的区别\"></a>新生代和老年代的区别</h2><p>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old)。新生代 ( Young ) 又被划分为三个区域：Eden、S0、S1。 这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。</p>\n<h3 id=\"新生代\"><a href=\"#新生代\" class=\"headerlink\" title=\"新生代\"></a>新生代</h3><p>特点是产生大量的死亡对象,并且要是产生连续可用的空间, 所以使用复制清除算法和并行收集器进行垃圾回收.对年轻代的垃圾回收称作初级回收 (minor gc)。</p>\n<p>初级回收将年轻代分为三个区域, 一个新生代 , 2个大小相同的复活代, 应用程序只能使用一个新生代和一个复活代, 当发生初级垃圾回收的时候,gc挂起程序, 然后将新生代和复活代中的存活对象复制到另外一个非活动的复活代中,然后一次性清除新生代和复活代，将原来的非复活代标记成为活动复活代。将在指定次数回收后仍然存在的对象移动到老年代中，初级回收后，得到一个空的可用的新生代。</p>\n<h3 id=\"老年代\"><a href=\"#老年代\" class=\"headerlink\" title=\"老年代\"></a>老年代</h3><p>Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。</p>\n<h2 id=\"标记算法\"><a href=\"#标记算法\" class=\"headerlink\" title=\"标记算法\"></a>标记算法</h2><h3 id=\"计数法\"><a href=\"#计数法\" class=\"headerlink\" title=\"计数法\"></a>计数法</h3><p>每个对象都有一个计数器，被引用了加一，移除引用减一。但这种方法比较麻烦，而且也会有循环依赖的问题，因此并不被广泛使用。第二种是根可达算法，即以 GCRoots 为基础去扫描整个引用链，从而找到所有的可达对象，那剩下的其他对象就是不可达的垃圾对象了。</p>\n<h3 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h3><p>这种实现方案分为两个阶段，分别是：标记阶段、清除阶段。在标记阶段，它从 GCRoots 节点开始扫描整个引用链，找到所有可达的对象。在清除阶段，扫描整个引用链的不可达对象，然后将垃圾对象清除掉。</p>\n<p>但这种方式有一个很大的缺点：整个过程必须「Stop the World」。这就导致整个应用程序必须停止，不能做任何改变，这是非常不友好的。 CMS 回收器出现之前的所有回收器，都是用这种方式实现的，因此 GC 停顿时间都比轿长。</p>\n<h3 id=\"三色标记算法\"><a href=\"#三色标记算法\" class=\"headerlink\" title=\"三色标记算法\"></a>三色标记算法</h3><p>三色标记算法指的是将所有对象分为白色、黑色和灰色三种类型。黑色表示从 GCRoots 开始，已扫描过它全部引用的对象，灰色指的是扫描过对象本身，还没完全扫描过它全部引用的对象，白色指的是还没扫描过的对象。</p>\n<ul>\n<li>初始标记阶段，指的是标记 GCRoots 直接引用的节点，将它们标记为灰色，这个阶段需要 「Stop the World」。</li>\n<li>并发标记阶段，指的是从灰色节点开始，去扫描整个引用链，然后将它们标记为黑色，这个阶段不需要「Stop the World」。</li>\n<li>重新标记阶段，指的是去校正并发标记阶段的错误，这个阶段需要「Stop the World」。</li>\n<li>并发清除，指的是将已经确定为垃圾的对象清除掉，这个阶段不需要「Stop the World」。</li>\n</ul>\n<h3 id=\"多标与漏标\"><a href=\"#多标与漏标\" class=\"headerlink\" title=\"多标与漏标\"></a>多标与漏标</h3><p>多标问题指的是原本应该回收的对象，被多余地标记为黑色存活对象，从而导致该垃圾对象没有被回收。 多标问题会出现，是因为在并发标记阶段，有可能之前已经被标记为存活的对象，其引用被删除，从而变成了不可达对象。</p>\n<p>漏标问题指的是原本应该被标记为存活的对象，被遗漏标记为黑色，从而导致该垃圾对象被错误回收。</p>\n<p>漏标问题就非常严重了，其会导致存活对象被回收，会严重影响程序功能。</p>\n<p>那么我们的垃圾回收器是怎么解决这个问题的呢？</p>\n<p>答案是：增加一个「重新标记」阶段。无论是在 CMS 回收器还是 G1 回收器，它们都在并发标记阶段之后，新增了一个「重新标记」阶段来校正「并发标记」阶段出现的问题。</p>\n<h3 id=\"漏标解决方案\"><a href=\"#漏标解决方案\" class=\"headerlink\" title=\"漏标解决方案\"></a>漏标解决方案</h3><h4 id=\"CMS解决方案\"><a href=\"#CMS解决方案\" class=\"headerlink\" title=\"CMS解决方案\"></a>CMS解决方案</h4><p>既然有黑色对象在自己标记后，又重新指向了白色对象。那么我就把这个黑色对象的引用记录下来，在后续「重新标记」阶段再以这个黑色对象为根，对其引用进行重新扫描。通过这种方式，被黑色对象引用的白色对象就会变成灰色，从而变为存活状态。</p>\n<p>既然灰色对象在扫描完成前删除了对白色对象的引用，那么我是否能在灰色对象取消引用之前，先将灰色对象引用的白色对象记录下来。随后在「重新标记」阶段再以白色对象为根，对它的引用进行扫描，从而避免了漏标的问题。通过这种方式，原本漏标的对象就会被重新扫描变成灰色，从而变为存活状态。</p>\n<h2 id=\"数据库存储过程和触发器\"><a href=\"#数据库存储过程和触发器\" class=\"headerlink\" title=\"数据库存储过程和触发器\"></a>数据库存储过程和触发器</h2><h3 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h3><p>使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用 “CALL 存储过程名字” 即可自动完成</p>\n<h3 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h3><p>MySQL 的触发器和存储过程一样，都是嵌入到 MySQL 中的一段程序，是 MySQL 中管理数据的有力工具。不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行不需要使用 CALL 语句来调用，也不需要手工启动，而是通过对数据表的相关操作来触发、激活从而实现执行。比如当对 student 表进行操作（INSERT，DELETE 或 UPDATE）时就会激活它执行。</p>\n<h2 id=\"线程安全和锁\"><a href=\"#线程安全和锁\" class=\"headerlink\" title=\"线程安全和锁\"></a>线程安全和锁</h2><h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><ul>\n<li>不可变对象一定线程安全</li>\n<li>绝对线程安全：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。</li>\n<li>相对线程安全：是通常意义上的线程安全，它需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保证措施。</li>\n<li>线程兼容：线程兼容是指对象本身不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中是可以安全使用的。Java API中的大部分的类都是属于线程兼容的，如ArrayList和HashMap等。</li>\n<li>线程对立：线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中使用的代码。</li>\n</ul>\n<h4 id=\"实现方法\"><a href=\"#实现方法\" class=\"headerlink\" title=\"实现方法\"></a>实现方法</h4><ul>\n<li>互斥同步：互斥同步是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。</li>\n<li>非阻塞同步：一种基于冲突检测的乐观并发策略的同步操作：先进行操作，如果没有其他线程争用共享数据，那操作就成功；如果共享数据有争用，产生了冲突，就在采取其他的补偿措施（比如不断的重试，直到成功）。这种乐观并发策略的很多实现都不需要把线程挂起，因此称为非阻塞同步。</li>\n</ul>\n<h3 id=\"锁优化\"><a href=\"#锁优化\" class=\"headerlink\" title=\"锁优化\"></a>锁优化</h3><ul>\n<li>自适应自旋：互斥同步最大的性能问题在于阻塞，线程的阻塞与唤醒需要内核态参与。因此，加入自旋（忙循环），即让线程不挂起，而执行一段无操作循环，等待有锁线程释放锁。利用自适应自旋，通过前一次在同一锁上的自旋时间接锁的拥有者状态决定自旋时间。</li>\n<li>锁消除：虚拟机（JVM）即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判断依据来源于逃逸分析的数据支持。</li>\n<li>锁粗化：原则上需要将同步块的作用方位限制得尽量小——只在共享数据的实际作用域进行同步。但如果一系列连续操作都对同一个对象反复加锁和解锁，甚至加锁出现在循环体中，频繁进行互斥同步操作会导致不必要的性能消耗。因此，可以将加锁同步的范围扩展（粗化）到整个操作序列外部。</li>\n<li>轻量级锁：相对于传统锁机制而言，其本意是在没有多线程竞争的前提下，减少传统的重量级锁使用系统互斥量产生的性能消耗。</li>\n</ul>\n<h2 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h2><h2 id=\"加密算法\"><a href=\"#加密算法\" class=\"headerlink\" title=\"加密算法\"></a>加密算法</h2><h3 id=\"对称加密算法\"><a href=\"#对称加密算法\" class=\"headerlink\" title=\"对称加密算法\"></a>对称加密算法</h3><p>又称为 共享密钥加密算法。在 对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密。</p>\n<h3 id=\"非对称加密算法\"><a href=\"#非对称加密算法\" class=\"headerlink\" title=\"非对称加密算法\"></a>非对称加密算法</h3><p>又称为 公开密钥加密算法。它需要两个密钥，一个称为 公开密钥 (public key)，即 公钥，另一个称为 私有密钥 (private key)，即 私钥。</p>\n<h3 id=\"签名加密算法\"><a href=\"#签名加密算法\" class=\"headerlink\" title=\"签名加密算法\"></a>签名加密算法</h3><h4 id=\"MD5\"><a href=\"#MD5\" class=\"headerlink\" title=\"MD5\"></a>MD5</h4><p>MD5 用的是 哈希函数，它的典型应用是对一段信息产生 信息摘要，以 防止被篡改。严格来说，MD5 不是一种 加密算法 而是 摘要算法。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串</p>\n<h4 id=\"SHA1\"><a href=\"#SHA1\" class=\"headerlink\" title=\"SHA1\"></a>SHA1</h4><p>SHA1 是和 MD5 一样流行的 消息摘要算法，然而 SHA1 比 MD5 的 安全性更强。对于长度小于 2 ^ 64 位的消息，SHA1 会产生一个 160 位的 消息摘要。基于 MD5、SHA1 的信息摘要特性以及 不可逆 (一般而言)，可以被应用在检查 文件完整性 以及 数字签名 等场景。</p>\n<h4 id=\"HMAC算法\"><a href=\"#HMAC算法\" class=\"headerlink\" title=\"HMAC算法\"></a>HMAC算法</h4><p>HMAC 是密钥相关的 哈希运算消息认证码（Hash-based Message Authentication Code），HMAC 运算利用 哈希算法 (MD5、SHA1 等)，以 一个密钥 和 一个消息 为输入，生成一个 消息摘要 作为 输出。</p>\n<p>HMAC 发送方 和 接收方 都有的 key 进行计算，而没有这把 key 的第三方，则是 无法计算 出正确的 散列值的，这样就可以 防止数据被篡改。</p>\n<h4 id=\"RSA算法\"><a href=\"#RSA算法\" class=\"headerlink\" title=\"RSA算法\"></a>RSA算法</h4><p>RSA 是第一个能同时用于 加密 和 数字签名 的算法，它能够 抵抗 到目前为止已知的 所有密码攻击，已被 ISO 推荐为公钥数据加密标准。</p>\n<p>RSA 加密算法 基于一个十分简单的数论事实：将两个大 素数 相乘十分容易，但想要对其乘积进行 因式分解 却极其困难，因此可以将 乘积 公开作为 加密密钥。</p>\n<h2 id=\"TCP建立连接为什么要三次\"><a href=\"#TCP建立连接为什么要三次\" class=\"headerlink\" title=\"TCP建立连接为什么要三次\"></a>TCP建立连接为什么要三次</h2><p>三次握手的目的，是为了防止A端已经失效的连接请求突然又传到B端，被误认为是A端再次发出的一个新的连接请求，如果B端这时又再次向A发出确认报文，表示同意建立连接，就会产生错误。</p>\n<p>四次挥手的本质原因是tcp是全双公的，通信是双向的， A到B是一个通道，B到A又是另一个通道。</p>\n<p>四次挥手释放连接时，等待2MSL的意义：第 一，为了保证A发送的最有一个ACK报文段能够到达B。第二，就是防止上面提到的已失效的连接请求报文段出现在本连接中。</p>\n<h2 id=\"应用层协议有哪些\"><a href=\"#应用层协议有哪些\" class=\"headerlink\" title=\"应用层协议有哪些\"></a>应用层协议有哪些</h2><ol>\n<li>DNS(域名系统)：DNS 是互联网使用的命名系统，用来把人们使用的机器名字（域名）转换为 IP 地址。</li>\n<li>FTP(文件传输协议)：FTP 是使用得最广泛的文件传送协议。FTP 提供交互式的访问，常用于局域网的文件存储服务器。</li>\n<li>Telnet（远程终端协议）： telnet 是一个简单的远程终端协议，结合端口使用，常用于服务探测。</li>\n<li>HTTP（超文本传送协议）：HTTP 是面向事务的应用层协议，它是互联网能够可靠地交换文件的重要基础。</li>\n<li>SMTP（电子邮件协议）：SMTP 是简单邮件传送协议。SMTP规定了在两个相互通信的 SMTP 进程之间应如何交换信息。</li>\n<li>POP3（邮件读取协议）：POP3，全称是 Post Office Protocol 3，该协议通常被用来接收电子邮件。</li>\n<li>SNMP（简单网络管理协议）：SNMP 协议由三部分组成，包括：SNMP本身、管理信息结构 SMI 和管理信息 MIB。SNMP 定义了管理站和代理之间所交换的分组格式。SMI 定义了命名对象类型的通用规则，以及把对象和对象的值进行编码。MIB 在被管理的实体中创建了命名对象，并规定类型。</li>\n<li>TFTP（简单文件传送协议）：TFTP是TCP&#x2F;IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，它基于UDP协议而实现的，提供不复杂、开销不大的文件传输服务。默认端口号是 69。</li>\n</ol>\n<h2 id=\"邮件的正则表达式\"><a href=\"#邮件的正则表达式\" class=\"headerlink\" title=\"邮件的正则表达式\"></a>邮件的正则表达式</h2><p>^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+. [a-zA-Z]{2,}$</p>\n<h2 id=\"xml转json\"><a href=\"#xml转json\" class=\"headerlink\" title=\"xml转json\"></a>xml转json</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">xmlToJson</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//使用DOM4j</span></span><br><span class=\"line\">        SAXReader saxReader = <span class=\"keyword\">new</span> SAXReader();</span><br><span class=\"line\">        <span class=\"comment\">//读取文件</span></span><br><span class=\"line\">        Document read = saxReader.read(<span class=\"string\">&quot;G:\\\\IDEAProjects\\\\JavaStudy\\\\Mooc\\\\src\\\\main\\\\resources\\\\score.xml&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//使用json的xml转json方法</span></span><br><span class=\"line\">        JSONObject jsonObject = XML.toJSONObject(read.asXML());</span><br><span class=\"line\">        <span class=\"comment\">//设置缩进转为字符串</span></span><br><span class=\"line\">        System.out.println(jsonObject.toString(<span class=\"number\">3</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jsonObject.toString(<span class=\"number\">3</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"优化sql，让模糊查询走索引\"><a href=\"#优化sql，让模糊查询走索引\" class=\"headerlink\" title=\"优化sql，让模糊查询走索引\"></a>优化sql，让模糊查询走索引</h2><p>%匹配符不能在字符前面</p>\n<p>原本语句</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> `<span class=\"keyword\">column</span>` <span class=\"keyword\">FROM</span> `<span class=\"keyword\">table</span>` <span class=\"keyword\">WHERE</span> `field` <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%keyword%&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>优化语句</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> `<span class=\"keyword\">column</span>` <span class=\"keyword\">FROM</span> `<span class=\"keyword\">table</span>` <span class=\"keyword\">WHERE</span> `field` <span class=\"keyword\">like</span> <span class=\"string\">&#x27;keyword%&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>再优化</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> `<span class=\"keyword\">column</span>` <span class=\"keyword\">FROM</span> `<span class=\"keyword\">table</span>` <span class=\"keyword\">WHERE</span> LOCATE(<span class=\"string\">&#x27;keyword&#x27;</span>, `field`)<span class=\"operator\">&gt;</span><span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"启动线程的方式\"><a href=\"#启动线程的方式\" class=\"headerlink\" title=\"启动线程的方式\"></a>启动线程的方式</h2><ol>\n<li>继承Thread类，重写run方法（不推荐）</li>\n<li>实现runable接口，或者匿名内部类(new Thread(new Runable(){}))</li>\n<li>实现callable接口</li>\n<li>创建线程池</li>\n</ol>\n<h2 id=\"JUC包-java-util-concurrent\"><a href=\"#JUC包-java-util-concurrent\" class=\"headerlink\" title=\"JUC包(java.util.concurrent)\"></a>JUC包(java.util.concurrent)</h2><ol>\n<li>locks部分：在java.util.concurrent.locks包中，提供更加强大的显式锁，比如 重入锁ReentrantLock、读写锁ReadWriteLock；</li>\n<li>collections部分：在java.util.concurrent包中，提供一系列高性能的并发容器，比如ConcurrentHashMap、CopyOnWriteArrayList等；</li>\n<li>atomic部分：在java.util.concurrent.atomic包中，提供原子变量类相关的功能，是构建非阻塞算法CAS的基础，比如AtomicInteger</li>\n<li>executor部分：在java.util.concurrent包中，提供线程池相关的功能，用于批量创建、管理线程，比如ThreadPoolExecutor等，以及对线程任务的加强，比如Callable等</li>\n<li>tools部分：在java.util.concurrent包中，提供简单高效的同步工具类，如信号量Semaphore、闭锁CountDownLatch、栅栏CyclicBarrier等；</li>\n</ol>\n<h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><h3 id=\"数据类型和使用场景\"><a href=\"#数据类型和使用场景\" class=\"headerlink\" title=\"数据类型和使用场景\"></a>数据类型和使用场景</h3><p>Redis 提供了丰富的数据类型，常见的有五种数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。</p>\n<p>随着 Redis 版本的更新，后面又支持了四种数据类型： BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</p>\n<h4 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h4><ul>\n<li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</li>\n<li>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li>\n<li>Hash 类型：缓存对象、购物车等。</li>\n<li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li>\n<li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li>\n<li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li>\n<li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li>\n<li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li>\n<li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li>\n</ul>\n<h3 id=\"Redis线程模型\"><a href=\"#Redis线程模型\" class=\"headerlink\" title=\"Redis线程模型\"></a>Redis线程模型</h3><p>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</p>\n<h3 id=\"Redis持久化\"><a href=\"#Redis持久化\" class=\"headerlink\" title=\"Redis持久化\"></a>Redis持久化</h3><ul>\n<li>AOF 日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li>\n<li>RDB 快照：将某一时刻的内存数据，以二进制的方式写入磁盘；</li>\n<li>混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；</li>\n</ul>\n<h3 id=\"Redis集群\"><a href=\"#Redis集群\" class=\"headerlink\" title=\"Redis集群\"></a>Redis集群</h3><h4 id=\"如何实现服务高可用\"><a href=\"#如何实现服务高可用\" class=\"headerlink\" title=\"如何实现服务高可用\"></a>如何实现服务高可用</h4><ul>\n<li>主从复制：主从复制是 Redis 高可用服务的最基础的保证，实现方案就是将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式，且主从服务器之间采用的是「读写分离」的方式。主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。</li>\n<li>哨兵模式：在使用 Redis 主从服务的时候，会有一个问题，就是当 Redis 的主从服务器出现故障宕机时，需要手动进行恢复。为了解决这个问题，Redis 增加了哨兵模式（Redis Sentinel），因为哨兵模式做到了可以监控主从服务器，并且提供主从节点故障转移的功能。</li>\n<li>切片集群模式：当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 Redis 切片集群（Redis Cluster ）方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</li>\n</ul>\n<h3 id=\"如何避免缓存雪崩\"><a href=\"#如何避免缓存雪崩\" class=\"headerlink\" title=\"如何避免缓存雪崩\"></a>如何避免缓存雪崩</h3><ul>\n<li>将缓存失效时间随机打散： 我们可以在原有的失效时间基础上增加一个随机值（比如 1 到 10 分钟）这样每个缓存的过期时间都不重复了，也就降低了缓存集体失效的概率。</li>\n<li>设置缓存不过期： 我们可以通过后台服务来更新缓存数据，从而避免因为缓存失效造成的缓存雪崩，也可以在一定程度上避免缓存并发问题。</li>\n</ul>\n<h3 id=\"如何避免缓存击穿\"><a href=\"#如何避免缓存击穿\" class=\"headerlink\" title=\"如何避免缓存击穿\"></a>如何避免缓存击穿</h3><ul>\n<li>互斥锁方案（Redis 中使用 setNX 方法设置一个状态位，表示这是一种锁定状态），保证同一时间只有一个业务线程请求缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li>\n<li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li>\n</ul>\n<h3 id=\"热点数据动态缓存策略\"><a href=\"#热点数据动态缓存策略\" class=\"headerlink\" title=\"热点数据动态缓存策略\"></a>热点数据动态缓存策略</h3><p>热点数据动态缓存的策略总体思路：通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据。</p>\n<h3 id=\"故障转移选取新的master的标准是什么\"><a href=\"#故障转移选取新的master的标准是什么\" class=\"headerlink\" title=\"故障转移选取新的master的标准是什么\"></a>故障转移选取新的master的标准是什么</h3><ul>\n<li>与master断开的时常：slave与master的断开时长超过了down-after-milliseconds的10倍</li>\n<li>slave优先级：优先级高的先被选</li>\n<li>优先级相同: slave复制数据多的作为master</li>\n<li>以上都相同，选择run id小的</li>\n</ul>\n<h2 id=\"分布式问题\"><a href=\"#分布式问题\" class=\"headerlink\" title=\"分布式问题\"></a>分布式问题</h2><h3 id=\"需要满足的特性\"><a href=\"#需要满足的特性\" class=\"headerlink\" title=\"需要满足的特性\"></a>需要满足的特性</h3><ul>\n<li>互斥性：对同一条数据，智能有一台应用能够拿到锁</li>\n<li>高可用性：分布式锁的服务以集群的方式部署</li>\n<li>防止锁超时：用户不主动释放，则过一段时间就自动释放，防止死锁</li>\n<li>独占性：加锁和解锁必须由一台服务器进行，谁加的锁，谁解</li>\n</ul>\n"},{"title":"面试复习-2025","url":"/2025/06/07/%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/","content":"<h2 id=\"Kafaka-Related\"><a href=\"#Kafaka-Related\" class=\"headerlink\" title=\"Kafaka-Related\"></a>Kafaka-Related</h2><h3 id=\"详细介绍\"><a href=\"#详细介绍\" class=\"headerlink\" title=\"详细介绍\"></a>详细介绍</h3><ul>\n<li>Topic: 消息分多个主题，不同的主题进入到不同的队列中，e.g. 买入信息topic，卖出信息topic</li>\n<li>Broker: 一个独立的kafka服务器节点，多个broker保证高并发</li>\n<li>Partition: 每个topic的队列拆分成多个partition， 配合多个broker节点保证服务的高并发，多个partition部署在多个不同的broker上</li>\n<li>Replica: 每个partition需要拥有自己的副本，保证当一个partition挂掉之后，会有副本接替他的工作</li>\n<li>offset：zookeeper中维护每个partition的偏移量，consumer消费时读取偏移量，并且从此处开始读</li>\n</ul>\n<span id=\"more\"></span>\n\n<h4 id=\"Partition\"><a href=\"#Partition\" class=\"headerlink\" title=\"Partition\"></a>Partition</h4><ul>\n<li>指定了消息发送的partition编号，则发送到这个partition上</li>\n<li>未指定编号，但是存在key，根据key的hash值选择一个partition</li>\n<li>未指定编号，不存在key，发送满一个Batch_Size_Config后，轮询下一个partition</li>\n</ul>\n<h4 id=\"Replica\"><a href=\"#Replica\" class=\"headerlink\" title=\"Replica\"></a>Replica</h4><p>每个partition副本都是一个目录，其中包含若干个segment段文件：</p>\n<ol>\n<li>.log: 数据文件</li>\n<li>.index: 索引文件，偏移量索引，包含offset和position，仅包含4kB量，即磁盘的一个分区，这样只用读取一次磁盘就可以；同时由于稀疏存储(默认每隔4kB建立一个索引)，可以很快定位到数据在.log中的区间</li>\n<li>.timeindex： 索引文件，包含timestamp和offset</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$KAFKA_LOG_DIR</span>/order-0/</span><br><span class=\"line\">├── 00000000000000000000.log</span><br><span class=\"line\">├── 00000000000000000000.index</span><br><span class=\"line\">├── 00000000000000000000.timeindex</span><br><span class=\"line\">├── 00000000000000001000.log</span><br><span class=\"line\">├── 00000000000000001000.index</span><br><span class=\"line\">├── 00000000000000001000.timeindex</span><br><span class=\"line\">├── leader-epoch-checkpoint</span><br><span class=\"line\">└── partition.metadata</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"高可用和选举机制\"><a href=\"#高可用和选举机制\" class=\"headerlink\" title=\"高可用和选举机制\"></a>高可用和选举机制</h4><ul>\n<li>ISR列表：只保存与leader partition数据完全一致的partition，选择ISR中最前面一个</li>\n<li>OSR列表：数据比leader严重落后或者不同步的replica，可以配置当ISR不可用时，是否选用OSR中的</li>\n</ul>\n<h4 id=\"消费者分组消费机制\"><a href=\"#消费者分组消费机制\" class=\"headerlink\" title=\"消费者分组消费机制\"></a>消费者分组消费机制</h4><ul>\n<li>本地offset管理：从服务端拉取offset信息，保存到redis或者本地，可以防止重复消费</li>\n</ul>\n<h4 id=\"消息序列化机制\"><a href=\"#消息序列化机制\" class=\"headerlink\" title=\"消息序列化机制\"></a>消息序列化机制</h4><ul>\n<li>自定义一个通用的 Serializer</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GenericJsonSerializer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializer</span>&lt;<span class=\"title\">Object</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ObjectMapper objectMapper = <span class=\"keyword\">new</span> ObjectMapper();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">byte</span>[] serialize(String topic, Object data) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (data == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> objectMapper.writeValueAsBytes(data);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (JsonProcessingException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SerializationException(<span class=\"string\">&quot;Error serializing JSON&quot;</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>配置多个 KafkaTemplate，分别使用不同的序列化器</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ProducerFactory&lt;String, User&gt; <span class=\"title\">userProducerFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Map&lt;String, Object&gt; config = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    config.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class=\"line\">    config.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DefaultKafkaProducerFactory&lt;&gt;(config);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> KafkaTemplate&lt;String, User&gt; <span class=\"title\">userKafkaTemplate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> KafkaTemplate&lt;&gt;(userProducerFactory());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ProducerFactory&lt;String, Order&gt; <span class=\"title\">orderProducerFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Map&lt;String, Object&gt; config = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    config.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);</span><br><span class=\"line\">    config.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, AvroSerializer.class); <span class=\"comment\">// 假设你有特殊需求</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DefaultKafkaProducerFactory&lt;&gt;(config);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> KafkaTemplate&lt;String, Order&gt; <span class=\"title\">orderKafkaTemplate</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> KafkaTemplate&lt;&gt;(orderProducerFactory());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>发送时带上类型信息（例如 header 中加类名）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ProducerRecord&lt;String, Object&gt; record = <span class=\"keyword\">new</span> ProducerRecord&lt;&gt;(<span class=\"string\">&quot;topic&quot;</span>, object);</span><br><span class=\"line\">record.headers().add(<span class=\"string\">&quot;type&quot;</span>, object.getClass().getName().getBytes());</span><br><span class=\"line\">kafkaTemplate.send(record);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"消息分区路由机制\"><a href=\"#消息分区路由机制\" class=\"headerlink\" title=\"消息分区路由机制\"></a>消息分区路由机制</h4><ul>\n<li>consumer分配partition机制： range均分，轮询均分，sticky策略(尽量保持分区的均匀并与上一次分配尽量保持一致)</li>\n</ul>\n<h4 id=\"生产者消息缓存机制\"><a href=\"#生产者消息缓存机制\" class=\"headerlink\" title=\"生产者消息缓存机制\"></a>生产者消息缓存机制</h4><ul>\n<li>缓存在本地然后一批一批发送到服务端</li>\n<li>先存入到RecordAccumulator中,当大小达到配置值或者等待时间到，发送到sender中</li>\n</ul>\n<h4 id=\"发送应答机制\"><a href=\"#发送应答机制\" class=\"headerlink\" title=\"发送应答机制\"></a>发送应答机制</h4><ul>\n<li>ack&#x3D;0,1,all （不确认，leader确认，全部确认）</li>\n</ul>\n<h4 id=\"生产者消息幂等性\"><a href=\"#生产者消息幂等性\" class=\"headerlink\" title=\"生产者消息幂等性\"></a>生产者消息幂等性</h4><ul>\n<li>retries_config： 生产者发送消息重试次数</li>\n<li>生产者发送消息时，会附加一个sequenceNumber，服务器验证为当前sequence+1才会放入队列</li>\n<li>通过业务数据库+乐观锁，实现每个业务只被处理一次，e.g. version+1</li>\n</ul>\n<h4 id=\"消息压缩算法\"><a href=\"#消息压缩算法\" class=\"headerlink\" title=\"消息压缩算法\"></a>消息压缩算法</h4><ul>\n<li>生产者和服务端要采用同样的压缩算法， 默认为不压缩，性能紧张时可以使用压缩</li>\n</ul>\n<h3 id=\"事务消息\"><a href=\"#事务消息\" class=\"headerlink\" title=\"事务消息\"></a>事务消息</h3><ol>\n<li>背景：为什么要有事务消息？</li>\n</ol>\n<p>在实际业务里可能遇到这种场景：</p>\n<p>你消费一条消息 → 处理后写入数据库 → 还要往 Kafka 另一个 topic 发送一条结果消息。</p>\n<p>如果中途失败，可能会出现：数据库写了但消息没发，或者消息发了但数据库没写，导致数据不一致。</p>\n<p>Kafka 的事务机制就是为了解决 Producer 多条消息原子写入 + 消费与生产原子绑定 的问题。<br>2. Kafka 的事务机制如何工作</p>\n<p>Kafka 的事务实现依赖两个关键点：</p>\n<p>(1) 幂等生产（Idempotent Producer）</p>\n<p>每条消息有唯一的 (ProducerID, Partition, SequenceNumber) 三元组标识。</p>\n<p>Broker 根据序列号判断消息是否已经写过，避免重复写入。</p>\n<p>(2) 事务协调器（Transaction Coordinator）</p>\n<p>Kafka 内部有一个 事务协调器（Transaction Coordinator），专门管理事务。<br>事务过程类似于数据库的 两阶段提交（2PC）：</p>\n<p>🚀 流程</p>\n<p>BEGIN_TRANSACTION<br>Producer 向 Coordinator 声明开启事务。</p>\n<p>写入消息（未提交状态）<br>Producer 把消息写入 topic 的 partition，但这些消息标记为 未提交。</p>\n<p>消费者（开启 isolation.level&#x3D;read_committed）此时看不到。</p>\n<p>PREPARE_COMMIT<br>Producer 发送请求给 Coordinator 表示事务要提交。</p>\n<p>Coordinator 记录事务日志，确保即使宕机也能恢复。</p>\n<p>COMMIT or ABORT</p>\n<p>如果一切正常 → Coordinator 通知所有分区提交事务。</p>\n<p>如果失败 → Coordinator 通知所有分区回滚（这些消息对外不可见）。</p>\n<p>👉 这样可以保证：事务里的消息，要么全部生效，要么全部不生效。</p>\n<h4 id=\"Kafka配置事务消息\"><a href=\"#Kafka配置事务消息\" class=\"headerlink\" title=\"Kafka配置事务消息\"></a>Kafka配置事务消息</h4><ul>\n<li>Producer端</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">    producer.beginTransaction(); // 开启事务</span><br><span class=\"line\"></span><br><span class=\"line\">    producer.send(new ProducerRecord&lt;&gt;(&quot;topic1&quot;, &quot;key1&quot;, &quot;value1&quot;));</span><br><span class=\"line\">    producer.send(new ProducerRecord&lt;&gt;(&quot;topic2&quot;, &quot;key2&quot;, &quot;value2&quot;));</span><br><span class=\"line\"></span><br><span class=\"line\">    producer.commitTransaction(); // 提交事务</span><br><span class=\"line\">&#125; catch (Exception e) &#123;</span><br><span class=\"line\">    producer.abortTransaction();  // 事务失败回滚</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Consumer端</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">isolation.level=read_committed</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"观察者模式和发布订阅模式\"><a href=\"#观察者模式和发布订阅模式\" class=\"headerlink\" title=\"观察者模式和发布订阅模式\"></a>观察者模式和发布订阅模式</h3><p>观察者模式</p>\n<p><img src=\"https://i.imgur.com/dowydWm.png\" alt=\"picture 31\">  </p>\n<p>发布订阅模式<br><img src=\"https://i.imgur.com/2nNUXMp.png\" alt=\"picture 32\">  </p>\n<h3 id=\"生产问题\"><a href=\"#生产问题\" class=\"headerlink\" title=\"生产问题\"></a>生产问题</h3><h4 id=\"消息丢失\"><a href=\"#消息丢失\" class=\"headerlink\" title=\"消息丢失\"></a>消息丢失</h4><ul>\n<li>生产者发送消息失败：1. 不管broker是否相应立即返回 2. 发出的消息过大，broker无法存储<ol>\n<li>设置ack，必须确认后才可以认为发送成功</li>\n<li>设置重试次数</li>\n<li>异步回调信息<code>producer.send(msg,callback)</code></li>\n</ol>\n</li>\n<li>服务端写入磁盘失败： 收到消息后写入时宕机，别的follower会被选为leader，此时的follower是落后的<ol>\n<li>使用partition的副本机制，设置多个replica</li>\n<li>设置<code>min.insync.replicas</code>设置至少写入多少replica才算写入成功</li>\n</ol>\n</li>\n<li>消费者拉取消息失败：1. 消费者配置了自动commit，不管是否处理成功，都会commit 2. 多线程业务处理，某个线程出现异常，还是会自动提交<ol>\n<li>关闭自动提交，使用手动提交<code>enable.auto.commit=false</code></li>\n<li>多线程业务等待全部线程完成再commit</li>\n<li>消费者消费消息要进行幂等处理，防止重复消费（需要从业务角度出发，比如看消息中的业务类ID是否已经处理过，kafka本身无法保证消费端的幂等）</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"kafka消费慢，服务端一直rebalance\"><a href=\"#kafka消费慢，服务端一直rebalance\" class=\"headerlink\" title=\"kafka消费慢，服务端一直rebalance\"></a>kafka消费慢，服务端一直rebalance</h4><h5 id=\"问题背景\"><a href=\"#问题背景\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h5><p>Devops发现kafka的消费者组一直在rebalance,导致无法进行消费，积压大量的数据</p>\n<h5 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h5><p>可能的原因：</p>\n<ol>\n<li>订阅topic的分区数量发生变化（排除，没有人改过）</li>\n<li>订阅的topic个数发生变化 （排除，没有人改过）</li>\n<li>消费者组内部的成员数量发生变化 （可能是消费端消费的时候超时，或者网络连接缓慢）</li>\n</ol>\n<h5 id=\"排查过程\"><a href=\"#排查过程\" class=\"headerlink\" title=\"排查过程\"></a>排查过程</h5><ol>\n<li>最近这一块的相关业务部门是deadline，请求比较多</li>\n<li>consumer里面处理消息的业务代码涉及到比较复杂的逻辑，处理时间过长，导致会被认为挂掉了</li>\n<li>consumer会重试加入group，导致不停的rebalance</li>\n<li>数据库在高并发的状态下可能处理时间超时（基本排除）</li>\n</ol>\n<h5 id=\"消费代码分析\"><a href=\"#消费代码分析\" class=\"headerlink\" title=\"消费代码分析\"></a>消费代码分析</h5><p>发现消费代码部分采用了多线程的方式进行，并且饱和策略设置的是CallerRunsPolicy, 当流量较大时，线程被占满并且任务队列也满了，就会交给主线程处理，导致主线程被block住</p>\n<h5 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h5><p>将queueCapacity设置成了1000，减少了一次拉取的batch的数量</p>\n<h4 id=\"kafka消息积压\"><a href=\"#kafka消息积压\" class=\"headerlink\" title=\"kafka消息积压\"></a>kafka消息积压</h4><h5 id=\"问题背景-1\"><a href=\"#问题背景-1\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h5><p>kafka的log中显示某个<code>xxxx-server.xxxx.xxxx</code>topic存在大量积压</p>\n<h5 id=\"问题分析-1\"><a href=\"#问题分析-1\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h5><p>可能的原因</p>\n<ol>\n<li>生产消息太快</li>\n<li>消费消息太慢</li>\n</ol>\n<p>查看是否消费端存在大量报错，查看哪些线程耗时比较久</p>\n<h5 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h5><ul>\n<li>消费端<ol>\n<li>将消费节点扩展到与broker数量相同</li>\n<li>设置手动提交</li>\n<li>设置批量消费</li>\n</ol>\n</li>\n<li>服务端<ol>\n<li>扩展broker数量</li>\n</ol>\n</li>\n<li>生产端<ol>\n<li>动态配置开关降级，关闭mq的生产（比较困难，不太好通过）</li>\n<li>等积压处理完后，进行消息的补偿，但是要注意消费端消费时的幂等性</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"实际应用\"><a href=\"#实际应用\" class=\"headerlink\" title=\"实际应用\"></a>实际应用</h3><ul>\n<li>创建kafka server</li>\n</ul>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># an example of the docker compose file of creating a node cluster. Creating more ones are the same </span></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">kafka-node-0:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">bitnami/kafka:latest</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">kafka-node-0</span></span><br><span class=\"line\">    <span class=\"attr\">hostname:</span> <span class=\"string\">kafka-node-0</span></span><br><span class=\"line\">    <span class=\"attr\">restart:</span> <span class=\"string\">unless-stopped</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">kafka-servers-net</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;19092:9092&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/etc/timezone:/etc/timezone:ro</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">/etc/localtime:/etc/localtime:ro</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">kafka0_data:/bitnami/kafka:rw</span></span><br><span class=\"line\">    <span class=\"attr\">environment:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">KAFKA_CFG_NODE_ID=0</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">KAFKA_ENABLE_KRAFT=yes</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">ALLOW_PLAINTEXT_LISTENER=yes</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">KAFKA_CFG_PROCESS_ROLES=broker,controller</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">KAFKA_KRAFT_CLUSTER_ID=weirdozhang19990615xxx</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://:9092</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=0@kafka-node-0:9093,1@kafka-node-1:9093,2@kafka-node-2:9093</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">KAFKA_CFG_INTER_BROKER_LISTENER_NAME=PLAINTEXT</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>调用producer consumer</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># create topic(first time) when topic was created, user `send message `</span></span><br><span class=\"line\">kafka-topics.sh \\</span><br><span class=\"line\">  --create \\</span><br><span class=\"line\">  --topic your-topic-name \\</span><br><span class=\"line\">  --bootstrap-server kafka-node-0:9092,kafka-node-1:9092,kafka-node-2:9092 \\</span><br><span class=\"line\">  --partitions 3 \\</span><br><span class=\"line\">  --replication-factor 2</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># send message</span></span><br><span class=\"line\">docker run -it --rm \\</span><br><span class=\"line\">  --network kafka-servers-net \\</span><br><span class=\"line\">  bitnami/kafka:latest \\</span><br><span class=\"line\">  kafka-console-producer.sh \\</span><br><span class=\"line\">    --bootstrap-server kafka-node-0:9092,kafka-node-1:9092,kafka-node-2:9092 \\</span><br><span class=\"line\">    --topic test-topic</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># receive message </span></span><br><span class=\"line\">docker run -it --rm \\</span><br><span class=\"line\">  --network kafka-servers-net \\</span><br><span class=\"line\">  bitnami/kafka:latest \\</span><br><span class=\"line\">  kafka-console-consumer.sh \\</span><br><span class=\"line\">    --bootstrap-server kafka-node-0:9092 \\</span><br><span class=\"line\">    --topic test-topic \\</span><br><span class=\"line\">    --from-beginning</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>查看kafka server存储状态和信息</li>\n</ul>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it kafka-node-0 \\</span><br><span class=\"line\">  kafka-topics.sh \\</span><br><span class=\"line\">  --bootstrap-server localhost:9092 \\</span><br><span class=\"line\">  --describe \\</span><br><span class=\"line\">  --topic test-topic</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Redis-Related\"><a href=\"#Redis-Related\" class=\"headerlink\" title=\"Redis-Related\"></a>Redis-Related</h2><h3 id=\"详细介绍-1\"><a href=\"#详细介绍-1\" class=\"headerlink\" title=\"详细介绍\"></a>详细介绍</h3><h4 id=\"部署模式\"><a href=\"#部署模式\" class=\"headerlink\" title=\"部署模式\"></a>部署模式</h4><h5 id=\"主从部署（Master-Slave-Replication）\"><a href=\"#主从部署（Master-Slave-Replication）\" class=\"headerlink\" title=\"主从部署（Master-Slave Replication）\"></a>主从部署（Master-Slave Replication）</h5><p>主节点负责客户端的写请求，并且同步到从节点，从节点会承担读请求。 默认情况下，每个redis服务器都是主节点，且一个主节点可以有多个从节点。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#  主节点</span></span><br><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  --name redis-master \\</span><br><span class=\"line\">  --network redis-net \\</span><br><span class=\"line\">  -p 6379:6379 \\</span><br><span class=\"line\">  redis:latest \\</span><br><span class=\"line\">  redis-server --appendonly yes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#  从节点</span></span><br><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  --name redis-slave-1 \\</span><br><span class=\"line\">  --network redis-net \\</span><br><span class=\"line\">  -p 6380:6379 \\</span><br><span class=\"line\">  redis:latest \\</span><br><span class=\"line\">  redis-server --replicaof redis-master 6379</span><br><span class=\"line\"></span><br><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  --name redis-slave-2 \\</span><br><span class=\"line\">  --network redis-net \\</span><br><span class=\"line\">  -p 6381:6379 \\</span><br><span class=\"line\">  redis:latest \\</span><br><span class=\"line\">  redis-server --replicaof redis-master 6379</span><br></pre></td></tr></table></figure>\n\n<p>缺点：复制延时，从节点越多，同步的时间越长；主节点down掉后，需要手动将从节点变成主节点，没法自动选举</p>\n<h5 id=\"哨兵部署\"><a href=\"#哨兵部署\" class=\"headerlink\" title=\"哨兵部署\"></a>哨兵部署</h5><p>当多数哨兵节点认为主节点出现故障，则触发故障转移，下线主节点，并且选择一个从节点作为主节点。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker compose 文件</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">  <span class=\"attr\">redis-net:</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">bridge</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\">  <span class=\"attr\">redis-master-data:</span></span><br><span class=\"line\">  <span class=\"attr\">redis-slave-1-data:</span></span><br><span class=\"line\">  <span class=\"attr\">redis-slave-2-data:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">redis-master:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span> </span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">redis-master</span></span><br><span class=\"line\">    <span class=\"attr\">hostname:</span> <span class=\"string\">redis-master</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;redis-server&quot;</span>, <span class=\"string\">&quot;--appendonly&quot;</span>, <span class=\"string\">&quot;yes&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-net</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-master-data:/data</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;6379:6379&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">redis-slave-1:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span> </span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">redis-slave-1</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;redis-server&quot;</span>, <span class=\"string\">&quot;--appendonly&quot;</span>, <span class=\"string\">&quot;yes&quot;</span>, <span class=\"string\">&quot;--replicaof&quot;</span>, <span class=\"string\">&quot;redis-master&quot;</span>, <span class=\"string\">&quot;6379&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-net</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-slave-1-data:/data</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;6380:6379&quot;</span>   <span class=\"comment\"># 🔧 映射从节点 1 到宿主机 6380</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">redis-slave-2:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span></span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">redis-slave-2</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;redis-server&quot;</span>, <span class=\"string\">&quot;--appendonly&quot;</span>, <span class=\"string\">&quot;yes&quot;</span>, <span class=\"string\">&quot;--replicaof&quot;</span>, <span class=\"string\">&quot;redis-master&quot;</span>, <span class=\"string\">&quot;6379&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-net</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-slave-2-data:/data</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;6381:6379&quot;</span>   <span class=\"comment\"># 🔧 映射从节点 2 到宿主机 6381</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">redis-sentinel-1:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span> </span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">redis-sentinel-1</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;redis-sentinel&quot;</span>, <span class=\"string\">&quot;/etc/redis/sentinel.conf&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-master</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./sentinel/sentinel.conf:/etc/redis/sentinel.conf</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-net</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;26379:26379&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">redis-sentinel-2:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span> </span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">redis-sentinel-2</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;redis-sentinel&quot;</span>, <span class=\"string\">&quot;/etc/redis/sentinel.conf&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-master</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./sentinel/sentinel.conf:/etc/redis/sentinel.conf</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-net</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">redis-sentinel-3:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span> </span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">redis-sentinel-3</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;redis-sentinel&quot;</span>, <span class=\"string\">&quot;/etc/redis/sentinel.conf&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">depends_on:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-master</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./sentinel/sentinel.conf:/etc/redis/sentinel.conf</span></span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-net</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># sentinel.conf file</span></span><br><span class=\"line\"><span class=\"string\">port</span> <span class=\"number\">26379</span></span><br><span class=\"line\"><span class=\"string\">sentinel</span> <span class=\"string\">monitor</span> <span class=\"string\">mymaster</span> <span class=\"string\">redis-master</span> <span class=\"number\">6379 </span><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"string\">sentinel</span> <span class=\"string\">down-after-milliseconds</span> <span class=\"string\">mymaster</span> <span class=\"number\">5000</span></span><br><span class=\"line\"><span class=\"string\">sentinel</span> <span class=\"string\">parallel-syncs</span> <span class=\"string\">mymaster</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"string\">sentinel</span> <span class=\"string\">failover-timeout</span> <span class=\"string\">mymaster</span> <span class=\"number\">10000</span></span><br><span class=\"line\"><span class=\"string\">sentinel</span> <span class=\"string\">resolve-hostnames</span> <span class=\"literal\">yes</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"集群部署\"><a href=\"#集群部署\" class=\"headerlink\" title=\"集群部署\"></a>集群部署</h5><p>将数据分成多个slot分布在多个redis节点上，主节点负责读写请求和集群维护，从节点只进行数据同步和状态信息复制。</p>\n<p>redis集群有16384个哈希槽，每个节点负责一部分hash槽，key通过crc16校验后对16384取余来决定放到那个槽里</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">&#x27;3.8&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\">  <span class=\"attr\">redis-cluster-node-1:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span> </span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">redis-cluster-node-1</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;7001:6379&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;16380:16379&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;redis-server&quot;</span>, <span class=\"string\">&quot;/usr/local/etc/redis/redis.conf&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-net</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">redis-cluster-node-2:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span> </span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">redis-cluster-node-2</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;7002:6379&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;16381:16379&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;redis-server&quot;</span>, <span class=\"string\">&quot;/usr/local/etc/redis/redis.conf&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-net</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">redis-cluster-node-3:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span> </span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">redis-cluster-node-3</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;7003:6379&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;16382:16379&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;redis-server&quot;</span>, <span class=\"string\">&quot;/usr/local/etc/redis/redis.conf&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-net</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">redis-cluster-node-4:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span> </span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">redis-cluster-node-4</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;7004:6379&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;16383:16379&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;redis-server&quot;</span>, <span class=\"string\">&quot;/usr/local/etc/redis/redis.conf&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-net</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">redis-cluster-node-5:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span> </span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">redis-cluster-node-5</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;7005:6379&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;16384:16379&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;redis-server&quot;</span>, <span class=\"string\">&quot;/usr/local/etc/redis/redis.conf&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-net</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">redis-cluster-node-6:</span></span><br><span class=\"line\">    <span class=\"attr\">image:</span> <span class=\"string\">redis</span> </span><br><span class=\"line\">    <span class=\"attr\">container_name:</span> <span class=\"string\">redis-cluster-node-6</span></span><br><span class=\"line\">    <span class=\"attr\">ports:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;7006:6379&quot;</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">&quot;16385:16379&quot;</span></span><br><span class=\"line\">    <span class=\"attr\">volumes:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">./redis.conf:/usr/local/etc/redis/redis.conf</span></span><br><span class=\"line\">    <span class=\"attr\">command:</span> [<span class=\"string\">&quot;redis-server&quot;</span>, <span class=\"string\">&quot;/usr/local/etc/redis/redis.conf&quot;</span>]</span><br><span class=\"line\">    <span class=\"attr\">networks:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">redis-net</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">networks:</span></span><br><span class=\"line\">   <span class=\"attr\">redis-net:</span></span><br><span class=\"line\">    <span class=\"attr\">driver:</span> <span class=\"string\">bridge</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># redis.conf</span></span><br><span class=\"line\">port 6379</span><br><span class=\"line\">cluster-enabled yes</span><br><span class=\"line\">cluster-config-file nodes.conf</span><br><span class=\"line\">cluster-node-timeout 5000</span><br><span class=\"line\">appendonly yes</span><br><span class=\"line\">protected-mode no</span><br><span class=\"line\"><span class=\"built_in\">bind</span> 0.0.0.0</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker <span class=\"built_in\">exec</span> -it redis-cluster-node-1 bash</span><br><span class=\"line\"></span><br><span class=\"line\">redis-cli --cluster create 172.21.0.2:6379 172.21.0.3:6379 172.21.0.4:6379 172.21.0.5:6379 172.21.0.6:6379 172.21.0.7:6379 --cluster-replicas 1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h4><h5 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> session session1</span><br><span class=\"line\">get session</span><br><span class=\"line\">exist session</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h5><p>只能string</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">lpush message 1 2 3</span><br><span class=\"line\">lrange message 0 -1</span><br><span class=\"line\"><span class=\"comment\"># 先进先出</span></span><br><span class=\"line\">lpop message </span><br><span class=\"line\"><span class=\"comment\"># 先进后出</span></span><br><span class=\"line\">rpop message</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">hset user_1 name weirdo age 123</span><br><span class=\"line\">hgetall user_1</span><br><span class=\"line\">hget user_1 name</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Unordered-Set\"><a href=\"#Unordered-Set\" class=\"headerlink\" title=\"Unordered Set\"></a>Unordered Set</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">sadd luck1 xxx</span><br><span class=\"line\">smembers luck1</span><br><span class=\"line\"><span class=\"comment\"># specific remove</span></span><br><span class=\"line\">srem luck1 xxx</span><br><span class=\"line\"><span class=\"comment\"># random pop</span></span><br><span class=\"line\">spop luck1</span><br><span class=\"line\"><span class=\"comment\"># query </span></span><br><span class=\"line\">sismember luck1 xxx</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Sorted-Set-ZSet\"><a href=\"#Sorted-Set-ZSet\" class=\"headerlink\" title=\"Sorted Set(ZSet)\"></a>Sorted Set(ZSet)</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">zadd resou 1 xxx1</span><br><span class=\"line\">zadd resou 2 xxx2</span><br><span class=\"line\"></span><br><span class=\"line\">zrevrange sort 0 10</span><br><span class=\"line\">zrevrange sort 0 10 withscores</span><br><span class=\"line\"></span><br><span class=\"line\">zincrby resou 1 xxx1</span><br><span class=\"line\"></span><br><span class=\"line\">zadd resou2 1 xxx1</span><br><span class=\"line\"><span class=\"comment\">#  合并两个zset</span></span><br><span class=\"line\">zunionstore unionResou 2 resou resou1</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Bit-Map\"><a href=\"#Bit-Map\" class=\"headerlink\" title=\"Bit-Map\"></a>Bit-Map</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">setbit name 0 1</span><br><span class=\"line\">setbit name 1 1</span><br><span class=\"line\">setbit name 2 0</span><br><span class=\"line\"><span class=\"comment\"># 获取1号位的值</span></span><br><span class=\"line\">getbit name 1</span><br><span class=\"line\"><span class=\"comment\"># name中1的总数</span></span><br><span class=\"line\">bitcount name </span><br><span class=\"line\"><span class=\"comment\"># name中第一次出现0</span></span><br><span class=\"line\">bitposition name 0</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"HyperLogLogs\"><a href=\"#HyperLogLogs\" class=\"headerlink\" title=\"HyperLogLogs\"></a>HyperLogLogs</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">pfadd name weirdo</span><br><span class=\"line\">pfcount name <span class=\"comment\"># 1</span></span><br><span class=\"line\">pfadd name weirdo weirdo2 weirdo</span><br><span class=\"line\">pfcount name <span class=\"comment\"># 2</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Geospatial\"><a href=\"#Geospatial\" class=\"headerlink\" title=\"Geospatial\"></a>Geospatial</h5><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">geoadd city 113.00000 28.21667 changsha</span><br><span class=\"line\">geopos city changsha</span><br><span class=\"line\"></span><br><span class=\"line\">geodist city changsha beijing</span><br><span class=\"line\">geodist city changsha beijing km</span><br><span class=\"line\"></span><br><span class=\"line\">georadius city 112 28 500 km</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h4><h5 id=\"为什么需要分布式锁\"><a href=\"#为什么需要分布式锁\" class=\"headerlink\" title=\"为什么需要分布式锁\"></a>为什么需要分布式锁</h5><p><img src=\"https://i.imgur.com/9TbaLW3.png\" alt=\"picture 18\">  </p>\n<h5 id=\"分布式锁需要具备的条件\"><a href=\"#分布式锁需要具备的条件\" class=\"headerlink\" title=\"分布式锁需要具备的条件\"></a>分布式锁需要具备的条件</h5><p>一个最基本的分布式锁需要满足：</p>\n<ul>\n<li>互斥：任意一个时刻，锁只能被一个线程持有。</li>\n<li>高可用：锁服务是高可用的，当一个锁服务出现问题，能够自动切换到另外一个锁服务。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。这一般是通过超时机制实现的。</li>\n<li>可重入：一个节点获取了锁之后，还可以再次获取锁。</li>\n<li>高性能：获取和释放锁的操作应该快速完成，并且不应该对整个系统的性能造成过大影响。</li>\n<li>非阻塞：如果获取不到锁，不能无限期等待，避免对系统正常运行造成影响。</li>\n</ul>\n<h5 id=\"redis实现分布式锁\"><a href=\"#redis实现分布式锁\" class=\"headerlink\" title=\"redis实现分布式锁\"></a>redis实现分布式锁</h5><p><img src=\"https://i.imgur.com/QqcsNRV.png\" alt=\"picture 19\">  </p>\n<p>这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程&#x2F;进程访问</p>\n<p>为了避免锁无法被释放，我们可以想到的一个解决办法就是：给这个 key（也就是锁） 设置一个过期时间 。</p>\n<p>这样确实可以解决问题，不过，这种解决办法同样存在漏洞：如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。</p>\n<p><img src=\"https://i.imgur.com/9OLmGCp.png\" alt=\"picture 20\">  </p>\n<h5 id=\"可重入锁\"><a href=\"#可重入锁\" class=\"headerlink\" title=\"可重入锁\"></a>可重入锁</h5><p>所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 synchronized 和 ReentrantLock 都属于可重入锁。</p>\n<p>可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。</p>\n<h5 id=\"redis解决集群情况下的分布式锁-的可靠性\"><a href=\"#redis解决集群情况下的分布式锁-的可靠性\" class=\"headerlink\" title=\"redis解决集群情况下的分布式锁 的可靠性\"></a>redis解决集群情况下的分布式锁 的可靠性</h5><p><img src=\"https://i.imgur.com/acrJ1sM.png\" alt=\"picture 21\">  </p>\n<p>Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。</p>\n<p>即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。</p>\n<p>Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。</p>\n<p>Reddison实现了RedLock算法并且能够用于分布式环境</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Config config = <span class=\"keyword\">new</span> Config();</span><br><span class=\"line\">config.useClusterServers().addNodeAddress(<span class=\"string\">&quot;redis://127.0.0.1:7000&quot;</span>, <span class=\"string\">&quot;redis://127.0.0.1:7001&quot;</span>);</span><br><span class=\"line\">RedissonClient redisson = Redisson.create(config);</span><br><span class=\"line\"></span><br><span class=\"line\">RLock lock = redisson.getLock(<span class=\"string\">&quot;myLock&quot;</span>);</span><br><span class=\"line\">lock.lock(); <span class=\"comment\">// 集群模式下自动使用 Redlock</span></span><br><span class=\"line\">lock.unlock();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"缓存问题\"><a href=\"#缓存问题\" class=\"headerlink\" title=\"缓存问题\"></a>缓存问题</h4><ul>\n<li>缓存击穿：某个key失效，导致大量请求发送到sql服务器</li>\n</ul>\n<p>设置永不过期，或者延长过期时间；使用互斥锁，等待第一个请求构建完缓存之后，再释放锁，让其他请求访问key</p>\n<ul>\n<li>缓存雪崩：一批key失效，导致大量请求发送到sql服务器</li>\n</ul>\n<p>随机初始化过期时间；将热点key分部到不同的redis上</p>\n<ul>\n<li>缓存穿透：key不存在，redis中没有，发送到sql中</li>\n</ul>\n<p>参数合法性校验；bloom过滤器；拉黑用户；不管数据库有没有查到，都存入redis；</p>\n<h4 id=\"缓存一致性\"><a href=\"#缓存一致性\" class=\"headerlink\" title=\"缓存一致性\"></a>缓存一致性</h4><p>先改数据库，可能redis删除数据失败；先删redis，可能新的请求重新又把旧的数据写回到redis</p>\n<p>解决方案</p>\n<ul>\n<li>延迟双删：先删除redis数据，再更新数据库数据，延迟几百毫秒之后，再删除redis缓存数据</li>\n<li>队列+重试机制：更新数据库数据-&gt;删除缓存数据-&gt;删除失败-&gt;将需要删除的key发送到mq-&gt;推送要删除的key到客户端-&gt;再次删除</li>\n<li>异步更新缓存（基于订阅binlog的同步机制）：非业务客户端订阅binlog程序-&gt;获取需要操作的数据-&gt;删除缓存-&gt;删除失败-&gt;将需要删除的key发送到mq-&gt;推送要删除的key到非业务客户端-&gt;再次删除</li>\n</ul>\n<p>第三种比第二种好在不用对业务代码进行侵入</p>\n<h4 id=\"redis事务\"><a href=\"#redis事务\" class=\"headerlink\" title=\"redis事务\"></a>redis事务</h4><p>本质是一组命令的集合，一个事务中的所有命令都被序列化，按序执行，不被其他命令插入</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">multi </span><br><span class=\"line\"><span class=\"built_in\">set</span> xxx xxx</span><br><span class=\"line\"><span class=\"built_in\">set</span> xxx xxx</span><br><span class=\"line\"><span class=\"comment\">#  可以自行中断, 中断后，前面的修改作废</span></span><br><span class=\"line\">discard</span><br><span class=\"line\"><span class=\"built_in\">set</span> xxx xxx</span><br><span class=\"line\"><span class=\"built_in\">exec</span></span><br></pre></td></tr></table></figure>\n\n<p>部分支持事务：multi开启之后，命令逻辑执行错误，不会导致事务回滚，而是忽略错误语句，继续执行</p>\n<p>Watch命令，是一种乐观锁的实现方式，watch后，监控到有人更新，事务会被打断，必须更新最新值，才能成功执行事务</p>\n<h4 id=\"redis-持久化\"><a href=\"#redis-持久化\" class=\"headerlink\" title=\"redis 持久化\"></a>redis 持久化</h4><ul>\n<li>RDB：指定时间间隔内，将内存中的数据集快照写入磁盘（二进制序列化形式），每次生成一个全量的备份</li>\n</ul>\n<p>两个命令：save和bgsave，分别是是否在主线程执行</p>\n<ul>\n<li>AOF：对每条写入命令作为日志，append-only写入日志，重启redis之后，回放整个命令集合</li>\n</ul>\n<p>redis 提供三种写回硬盘的策略：</p>\n<ul>\n<li>Always：每次操作命令后，写入磁盘</li>\n<li>EverySec：操作命令后，写入缓冲区，每秒将缓冲区写入磁盘</li>\n<li>No：操作命令后，写入缓冲区，由操作系统决定何时写入硬盘</li>\n</ul>\n<h4 id=\"缓存淘汰和过期删除\"><a href=\"#缓存淘汰和过期删除\" class=\"headerlink\" title=\"缓存淘汰和过期删除\"></a>缓存淘汰和过期删除</h4><p>缓存淘汰和过期删除的区别：</p>\n<ul>\n<li>内存淘汰是指内存满了之后，redis会触发淘汰策略，淘汰一些不必要的内存资源</li>\n<li>过期删除是将已经过期的键值对进行删除，redis采用惰性删除+定期删除</li>\n</ul>\n<h5 id=\"内存淘汰\"><a href=\"#内存淘汰\" class=\"headerlink\" title=\"内存淘汰\"></a>内存淘汰</h5><ol>\n<li>不进行数据淘汰</li>\n</ol>\n<ul>\n<li>noeviction（默认的内存淘汰策略）：当内存满了之后，有新的写入，则报错，不淘汰任何数据</li>\n</ul>\n<ol start=\"2\">\n<li>进行数据淘汰</li>\n</ol>\n<ul>\n<li>volatile-random: 随机淘汰设置了过期时间的键值</li>\n<li>volatile-ttl：优先淘汰更早过期的键值</li>\n<li>volatile-lru：优先淘汰最久未使用的有过期时间的键值</li>\n<li>volatile-lfu：优先淘汰最少使用的有过期时间的键值</li>\n<li>allkeys-random： 淘汰随机键值</li>\n<li>allkeys-lru： 淘汰最久未使用的键值</li>\n<li>allkeys-lfu： 淘汰最少使用的键值</li>\n</ul>\n<h5 id=\"过期删除策略\"><a href=\"#过期删除策略\" class=\"headerlink\" title=\"过期删除策略\"></a>过期删除策略</h5><p>redis采用定期删除+惰性删除</p>\n<ul>\n<li>惰性删除：redis在访问或者修改key之前，都会调用<code>expireIfNeeded</code>，如果过期，则选择删除，返回null</li>\n<li>定期删除：定期随机抽一批键值对，删除其中的过期的，redis中是20个，如果其中过期数量大于5（也就是25%），则继续抽取一批进行删除，如果小于5，则停止。等待下一次的定期删除</li>\n</ul>\n<h4 id=\"压缩列表\"><a href=\"#压缩列表\" class=\"headerlink\" title=\"压缩列表\"></a>压缩列表</h4><ul>\n<li><p>压缩列表（ziplist）是什么</p>\n<p>它是 Redis 里早期用于存储 小规模 list、hash、zset 的底层结构。</p>\n<p>ziplist 是一块连续的内存区域，里面一个接一个存放 entry（元素）。</p>\n<p>每个 entry 包含：</p>\n<p>prevlen：上一个元素的长度，用来支持双向遍历。</p>\n<p>encoding：当前元素的数据类型和长度信息。</p>\n<p>content：真正的数据内容。</p>\n</li>\n<li><p>连锁更新（cascade update）是什么</p>\n<p>重点在 prevlen 字段：</p>\n<p>为了实现双向遍历，entry 需要存储 前一个 entry 的长度（prevlen）。</p>\n<p>如果前一个 entry 比较短（小于 254 字节），prevlen 只需要 1 字节 存储。</p>\n<p>如果前一个 entry 比较长（≥254 字节），prevlen 就需要 5 字节 存储。</p>\n<p>连锁更新发生的场景：</p>\n<p>假设有一系列元素，长度都比较短（&lt;254），所以每个 entry 的 prevlen 都是 1 字节。</p>\n<p>现在你在列表头部插入了一个大元素（比如长度 300 字节）。</p>\n<p>下一个元素的 prevlen 字段需要从 1 字节扩展到 5 字节。</p>\n<p>但因为它自己变长了，后面的元素存储位置也要整体后移。</p>\n<p>如果下一个元素的长度因此超过了 254，导致它的后继元素的 prevlen 也要扩展……<br>👉 就会产生 连锁更新，可能会传导到整个列表。</p>\n</li>\n<li><p>listpack</p>\n</li>\n</ul>\n<p><img src=\"https://i.imgur.com/p49LSaU.png\" alt=\"picture 34\">  </p>\n<h4 id=\"Redis-IO多路复用\"><a href=\"#Redis-IO多路复用\" class=\"headerlink\" title=\"Redis IO多路复用\"></a>Redis IO多路复用</h4><p>IO多路复用其实是使用一个线程来检查多个Socket的就绪状态。</p>\n<p><img src=\"https://i.imgur.com/Gool2Uo.png\" alt=\"picture 35\">  </p>\n<h3 id=\"实际问题\"><a href=\"#实际问题\" class=\"headerlink\" title=\"实际问题\"></a>实际问题</h3><h4 id=\"大key问题\"><a href=\"#大key问题\" class=\"headerlink\" title=\"大key问题\"></a>大key问题</h4><p>如何检测：</p>\n<ul>\n<li>改写客户端，在sdk中加入埋点，实时上报给大key检测平台</li>\n<li>rdbtools 开源工具包，在redis实例上执行bgsave对RDB文件进行分析</li>\n</ul>\n<h2 id=\"JAVA-Related\"><a href=\"#JAVA-Related\" class=\"headerlink\" title=\"JAVA-Related\"></a>JAVA-Related</h2><h3 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h3><h4 id=\"OOM-原因\"><a href=\"#OOM-原因\" class=\"headerlink\" title=\"OOM 原因\"></a>OOM 原因</h4><ol>\n<li>一次性申请的对象太多：比如数据库拉取的数据太多一次性全部加载进内存</li>\n</ol>\n<p>更改申请对象的数量，只query我们需要的</p>\n<ol start=\"2\">\n<li>内存资源耗尽未释放：比如connection未关闭</li>\n</ol>\n<p>找到未释放的对象进行释放，使用池化思想</p>\n<ol start=\"3\">\n<li>本身资源不够</li>\n</ol>\n<p>jmap -heap 查看堆信息</p>\n<h4 id=\"OOM定位\"><a href=\"#OOM定位\" class=\"headerlink\" title=\"OOM定位\"></a>OOM定位</h4><ol>\n<li>系统已经挂了</li>\n</ol>\n<p>提前设置 <code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=</code>, 将堆的dump文件导出，使用visualJvm 查看该文件, 找到跟业务有关的最占内存的对象，找到GCRoot，查看线程调用栈</p>\n<ol start=\"2\">\n<li>系统还未OOM</li>\n</ol>\n<p>jmap -dump:format&#x3D;b,file&#x3D;xxxx.hprof threadId</p>\n<h4 id=\"排查过程-1\"><a href=\"#排查过程-1\" class=\"headerlink\" title=\"排查过程\"></a>排查过程</h4><h5 id=\"收集证据\"><a href=\"#收集证据\" class=\"headerlink\" title=\"收集证据\"></a>收集证据</h5><ul>\n<li>JVM参数配置</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/path/to/dumps</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>日志采集</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-Xlog:gc*:file=gc.log:time,uptime,level,tags   # JDK9+</span><br><span class=\"line\">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:gc.log # JDK8</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"分析Heap-Dump\"><a href=\"#分析Heap-Dump\" class=\"headerlink\" title=\"分析Heap Dump\"></a>分析Heap Dump</h5><p>将堆的dump文件导出，使用visualvm 查看该文件, 找到跟业务有关的最占内存的对象，找到GCRoot，查看线程调用栈</p>\n<h5 id=\"实时监控\"><a href=\"#实时监控\" class=\"headerlink\" title=\"实时监控\"></a>实时监控</h5><ul>\n<li>jconsole &#x2F; jvisualvm： 查看堆内存曲线、线程数、类加载数</li>\n<li>jstat: 每秒输出GC情况，观察Full GC是否频繁<code>jstat -gc &lt;pid&gt; 1000</code></li>\n<li>jmap: 查看对象实例数和内存占用前20名 <code>jmap -histo &lt;pid&gt; | head -20</code></li>\n<li>jstack: 查看线程堆栈，判断是否有死循环 <code>jstack &lt;pid&gt; &gt; thread.log</code></li>\n</ul>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><h4 id=\"多线程怎么实现的\"><a href=\"#多线程怎么实现的\" class=\"headerlink\" title=\"多线程怎么实现的\"></a>多线程怎么实现的</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 直接继承Thread类</span></span><br><span class=\"line\"><span class=\"comment\">// 特点：简单直接，但由于 Java 单继承，继承 Thread 会限制类的扩展性。</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello from MyThread!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">new</span> MyThread().start();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实现runnable接口</span></span><br><span class=\"line\"><span class=\"comment\">// 特点：更灵活，可以同时继承其他类；更常用。</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello from MyRunnable!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> MyRunnable()).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实现 Callable 接口 + Future</span></span><br><span class=\"line\"><span class=\"comment\">// 特点：相比 Runnable，Callable 可以有返回值，也可以抛出异常。</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\">Callable&lt;String&gt; task = () -&gt; <span class=\"string\">&quot;Hello from Callable!&quot;</span>;</span><br><span class=\"line\">ExecutorService executor = Executors.newSingleThreadExecutor();</span><br><span class=\"line\">Future&lt;String&gt; future = executor.submit(task);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(future.get()); <span class=\"comment\">// 会阻塞直到结果出来</span></span><br><span class=\"line\">executor.shutdown();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用线程池（推荐实际生产中用）</span></span><br><span class=\"line\"><span class=\"comment\">// 特点：通过线程池重复利用线程，避免频繁创建销毁带来的开销，是企业级项目中最常用的多线程模式。</span></span><br><span class=\"line\">ExecutorService executor = Executors.newFixedThreadPool(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    executor.submit(() -&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">executor.shutdown();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最佳实践</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CompletableFutureDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ExecutorService executor = Executors.newFixedThreadPool(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        CompletableFuture&lt;String&gt; cf = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123; Thread.sleep(<span class=\"number\">1000</span>); &#125; <span class=\"keyword\">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;异步结果&quot;</span>;</span><br><span class=\"line\">        &#125;, executor);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 可以链式处理</span></span><br><span class=\"line\">        cf.thenAccept(result -&gt; System.out.println(<span class=\"string\">&quot;收到结果: &quot;</span> + result));</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;主线程先干别的...&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 等待所有执行完成（可选）</span></span><br><span class=\"line\">        cf.get();</span><br><span class=\"line\"></span><br><span class=\"line\">        executor.shutdown();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sleep-和-wait-的区别\"><a href=\"#sleep-和-wait-的区别\" class=\"headerlink\" title=\"sleep() 和 wait()的区别\"></a>sleep() 和 wait()的区别</h4><p><img src=\"https://i.imgur.com/2WWQLHb.png\" alt=\"picture 33\">  </p>\n<h4 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h4><ol>\n<li>CountDownLatch, 设置需要几个线程完成, 当countDown被调用几次后，wait()方法就会通过</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CountDownLatch countDownLatch=<span class=\"keyword\">new</span> CountDownLatch(<span class=\"number\">3</span>);</span><br><span class=\"line\">countDownLatch.countDown();</span><br><span class=\"line\">countDownLatch.wait()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>CyclicBarrier</li>\n</ol>\n<p>用于 多线程互相等待，直到所有线程都到达屏障点才继续执行。</p>\n<p>可以循环使用（CountDownLatch 一次性）。</p>\n<p>调用await()来表示，当前已经到达屏障，当指定数量的线程到达屏障时，则线程继续运行，适合用于多阶段任务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CyclicBarrier barrier = <span class=\"keyword\">new</span> CyclicBarrier(<span class=\"number\">3</span>, () -&gt; System.out.println(<span class=\"string\">&quot;All threads reached barrier&quot;</span>));</span><br><span class=\"line\">barrier.await();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><h4 id=\"基本类型和包装类型的区别\"><a href=\"#基本类型和包装类型的区别\" class=\"headerlink\" title=\"基本类型和包装类型的区别\"></a>基本类型和包装类型的区别</h4><ul>\n<li>用途：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li>\n<li>存储方式：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li>\n<li>占用空间：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。默认值：成员变量包装类型不赋值就是 null ，而基本类型有默认值且不是 null。</li>\n<li>比较方式：对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。对于包装数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 equals() 方法。</li>\n</ul>\n<p>注意：基本数据类型存放在栈中是一个常见的误区！ 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆&#x2F;方法区&#x2F;元空间中。</p>\n<h4 id=\"包装类型的缓存机制\"><a href=\"#包装类型的缓存机制\" class=\"headerlink\" title=\"包装类型的缓存机制\"></a>包装类型的缓存机制</h4><p>Byte,Short,Integer,Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 TRUE or FALSE。</p>\n<p>对于 Integer，可以通过 JVM 参数 -XX:AutoBoxCacheMax&#x3D;<size> 修改缓存上限，但不能修改下限 -128。实际使用时，并不建议设置过大的值，避免浪费内存，甚至是 OOM。</p>\n<h3 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h3><h4 id=\"抽象类和接口的区别\"><a href=\"#抽象类和接口的区别\" class=\"headerlink\" title=\"抽象类和接口的区别\"></a>抽象类和接口的区别</h4><p><strong>两者的特点：</strong></p>\n<ul>\n<li>抽象类用于描述类的共同特性和行为，可以有成员变量、构造方法和具体方法。适用于有明显继承关系的场景。</li>\n<li>接口定义行为规范，可以有多个实现</li>\n</ul>\n<p><strong>两者的区别：</strong></p>\n<ul>\n<li>接口成员变量默认<code>public static final</code>, 其成员方法是 <code>public abstract</code>；抽象方法被abstract修饰，不能被<code>private、static、synchronized、native</code>修饰。</li>\n</ul>\n<h4 id=\"深拷贝浅拷贝\"><a href=\"#深拷贝浅拷贝\" class=\"headerlink\" title=\"深拷贝浅拷贝\"></a>深拷贝浅拷贝</h4><ul>\n<li>浅拷贝：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>\n<li>深拷贝：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>\n<li>引用拷贝： 两个不同的引用指向同一个对象。<br><img src=\"https://i.imgur.com/tJE9R68.png\" alt=\"picture 1\"></li>\n</ul>\n<h4 id=\"String、StringBuffer、StringBuilder-的区别？\"><a href=\"#String、StringBuffer、StringBuilder-的区别？\" class=\"headerlink\" title=\"String、StringBuffer、StringBuilder 的区别？\"></a>String、StringBuffer、StringBuilder 的区别？</h4><ul>\n<li>String 中的对象是不可变的，也就可以理解为常量，线程安全。</li>\n<li>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</li>\n<li>StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</li>\n</ul>\n<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。<br>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。<br>相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>\n<p>String 真正不可变有下面几点原因</p>\n<ul>\n<li>保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供&#x2F;暴露修改这个字符串的方法。</li>\n<li>String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。</li>\n</ul>\n<p>常量池相关：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String s1 = <span class=\"keyword\">new</span> String(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">String s2 = s1.intern();</span><br><span class=\"line\">String s3 = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">System.out.println(s1 == s2); <span class=\"comment\">// false</span></span><br><span class=\"line\">System.out.println(s2 == s3); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>intern() 方法的主要作用是确保字符串引用在常量池中的唯一性。</li>\n<li>当调用 intern() 时，如果常量池中已经存在相同内容的字符串，则返回常量池中已有对象的引用；否则，将该字符串添加到常量池并返回其引用。</li>\n</ul>\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p><img src=\"https://i.imgur.com/bXl5Qgn.png\" alt=\"picture 2\">  </p>\n<h4 id=\"如何使用-try-with-resources-代替try-catch-finally？\"><a href=\"#如何使用-try-with-resources-代替try-catch-finally？\" class=\"headerlink\" title=\"如何使用 try-with-resources 代替try-catch-finally？\"></a>如何使用 try-with-resources 代替try-catch-finally？</h4><p>Java 中类似于InputStream、OutputStream、Scanner、PrintWriter等的资源都需要我们调用close()方法来手动关闭，一般情况下我们都是通过try-catch-finally语句来实现这个需求，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (BufferedInputStream bin = <span class=\"keyword\">new</span> BufferedInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"keyword\">new</span> File(<span class=\"string\">&quot;test.txt&quot;</span>)));</span><br><span class=\"line\">     BufferedOutputStream bout = <span class=\"keyword\">new</span> BufferedOutputStream(<span class=\"keyword\">new</span> FileOutputStream(<span class=\"keyword\">new</span> File(<span class=\"string\">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((b = bin.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        bout.write(b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><h4 id=\"泛型的使用方式有哪几种？\"><a href=\"#泛型的使用方式有哪几种？\" class=\"headerlink\" title=\"泛型的使用方式有哪几种？\"></a>泛型的使用方式有哪几种？</h4><ul>\n<li>泛型类</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class=\"line\"><span class=\"comment\">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Generic</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> T key;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Generic</span><span class=\"params\">(T key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getKey</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>泛型接口</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Generator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">method</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 两种实现方式</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GeneratorImpl</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Generator</span>&lt;<span class=\"title\">T</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GeneratorImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Generator</span>&lt;<span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>泛型方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt; E &gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printArray</span><span class=\"params\">( E[] inputArray )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( E element : inputArray )&#123;</span><br><span class=\"line\">        System.out.printf( <span class=\"string\">&quot;%s &quot;</span>, element );</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      System.out.println();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><p>简单来说，Java 反射 (Reflection) 是一种在程序运行时，动态地获取类的信息并操作类或对象（方法、属性）的能力。</p>\n<h4 id=\"反射有什么优缺点？\"><a href=\"#反射有什么优缺点？\" class=\"headerlink\" title=\"反射有什么优缺点？\"></a>反射有什么优缺点？</h4><p>优点：</p>\n<ul>\n<li>灵活性和动态性：反射允许程序在运行时动态地加载类、创建对象、调用方法和访问字段。这样可以根据实际需求（如配置文件、用户输入、注解等）动态地适应和扩展程序的行为，显著提高了系统的灵活性和适应性。</li>\n<li>框架开发的基础：许多现代 Java 框架（如 Spring、Hibernate、MyBatis）都大量使用反射来实现依赖注入（DI）、面向切面编程（AOP）、对象关系映射（ORM）、注解处理等核心功能。反射是实现这些“魔法”功能不可或缺的基础工具。</li>\n<li>解耦合和通用性：通过反射，可以编写更通用、可重用和高度解耦的代码，降低模块之间的依赖。例如，可以通过反射实现通用的对象拷贝、序列化、Bean 工具等。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>性能开销：反射操作通常比直接代码调用要慢。因为涉及到动态类型解析、方法查找以及 JIT 编译器的优化受限等因素。不过，对于大多数框架场景，这种性能损耗通常是可以接受的，或者框架本身会做一些缓存优化。</li>\n<li>安全性问题：反射可以绕过 Java 语言的访问控制机制（如访问 private 字段和方法），破坏了封装性，可能导致数据泄露或程序被恶意篡改。此外，还可以绕过泛型检查，带来类型安全隐患。</li>\n<li>代码可读性和维护性：过度使用反射会使代码变得复杂、难以理解和调试。错误通常在运行时才会暴露，不像编译期错误那样容易发现。</li>\n</ul>\n<h4 id=\"反射的应用场景？\"><a href=\"#反射的应用场景？\" class=\"headerlink\" title=\"反射的应用场景？\"></a>反射的应用场景？</h4><ol>\n<li>依赖注入与控制反转（IoC）以 Spring&#x2F;Spring Boot 为代表的 IoC 框架，会在启动时扫描带有特定注解（如 @Component, @Service, @Repository, @Controller）的类，利用反射实例化对象（Bean），并通过反射注入依赖（如 @Autowired、构造器注入等）。</li>\n<li>注解处理注解本身只是个“标记”，得有人去读这个标记才知道要做什么。反射就是那个“读取器”。框架通过反射检查类、方法、字段上有没有特定的注解，然后根据注解信息执行相应的逻辑。比如，看到 @Value，就用反射读取注解内容，去配置文件找对应的值，再用反射把值设置给字段。</li>\n<li>动态代理与 AOP想在调用某个方法前后自动加点料（比如打日志、开事务、做权限检查）？AOP（面向切面编程）就是干这个的，而动态代理是实现 AOP 的常用手段。JDK 自带的动态代理（Proxy 和 InvocationHandler）就离不开反射。代理对象在内部调用真实对象的方法时，就是通过反射的 Method.invoke 来完成的。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DebugInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object target; <span class=\"comment\">// 真实对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DebugInvocationHandler</span><span class=\"params\">(Object target)</span> </span>&#123; <span class=\"keyword\">this</span>.target = target; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// proxy: 代理对象, method: 被调用的方法, args: 方法参数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;切面逻辑：调用方法 &quot;</span> + method.getName() + <span class=\"string\">&quot; 之前&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 通过反射调用真实对象的同名方法</span></span><br><span class=\"line\">        Object result = method.invoke(target, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;切面逻辑：调用方法 &quot;</span> + method.getName() + <span class=\"string\">&quot; 之后&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>对象关系映射（ORM）像 MyBatis、Hibernate 这种框架，能帮你把数据库查出来的一行行数据，自动变成一个个 Java 对象。它是怎么知道数据库字段对应哪个 Java 属性的？还是靠反射。它通过反射获取 Java 类的属性列表，然后把查询结果按名字或配置对应起来，再用反射调用 setter 或直接修改字段值。反过来，保存对象到数据库时，也是用反射读取属性值来拼 SQL。</li>\n</ol>\n<h3 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h3><h4 id=\"注解的解析方法有哪几种？\"><a href=\"#注解的解析方法有哪几种？\" class=\"headerlink\" title=\"注解的解析方法有哪几种？\"></a>注解的解析方法有哪几种？</h4><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p>\n<ul>\n<li>编译期直接扫描：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>\n<li>运行期通过反射处理：像框架中自带的注解(比如 Spring 框架的 @Value、@Component)都是通过反射来进行处理的。</li>\n</ul>\n<h3 id=\"序列化和反序列化\"><a href=\"#序列化和反序列化\" class=\"headerlink\" title=\"序列化和反序列化\"></a>序列化和反序列化</h3><h4 id=\"如果有些字段不想进行序列化怎么办？\"><a href=\"#如果有些字段不想进行序列化怎么办？\" class=\"headerlink\" title=\"如果有些字段不想进行序列化怎么办？\"></a>如果有些字段不想进行序列化怎么办？</h4><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>\n<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</p>\n<p>关于 transient 还有几点注意：</p>\n<ul>\n<li>transient 只能修饰变量，不能修饰类和方法。</li>\n<li>transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。</li>\n<li><strong>static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化</strong></li>\n</ul>\n<h3 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h3><h4 id=\"JDK-动态代理\"><a href=\"#JDK-动态代理\" class=\"headerlink\" title=\"JDK 动态代理\"></a>JDK 动态代理</h4><ul>\n<li>一个proxy需要有以下三个参数</li>\n</ul>\n<ol>\n<li>loader:类加载器，可以用代理对象<code>.getclass().getClassLoader()</code>获取</li>\n<li>interfaces: 被代理的对象实现的interfaces 可以用<code>.getClass().getInterfaces()</code>获取</li>\n<li>handler: 其中有一个invoke方法用来真正执行被代理对象的需要进行的操作</li>\n</ol>\n<ul>\n<li>定义一个代理类，必须要实现Invocation方法</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> shuang.kou</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@createTime</span> 2020年05月11日 11:23:00</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DebugInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 代理类中的真实对象</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DebugInvocationHandler</span><span class=\"params\">(Object target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之前，我们可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before method &quot;</span> + method.getName());</span><br><span class=\"line\">        Object result = method.invoke(target, args);</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;after method &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>用代理工厂生成代理对象</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdkProxyFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">getProxy</span><span class=\"params\">(Object target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Proxy.newProxyInstance(</span><br><span class=\"line\">                target.getClass().getClassLoader(), <span class=\"comment\">// 目标类的类加载器</span></span><br><span class=\"line\">                target.getClass().getInterfaces(),  <span class=\"comment\">// 代理需要实现的接口，可指定多个</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> DebugInvocationHandler(target)   <span class=\"comment\">// 代理对象对应的自定义 InvocationHandler</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>实际使用</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">SmsService smsService = (SmsService) JdkProxyFactory.getProxy(<span class=\"keyword\">new</span> SmsServiceImpl());</span><br><span class=\"line\">smsService.send(<span class=\"string\">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CGLIB动态代理\"><a href=\"#CGLIB动态代理\" class=\"headerlink\" title=\"CGLIB动态代理\"></a>CGLIB动态代理</h4><p>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</p>\n<p>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</p>\n<ul>\n<li>创建一个MethodInterceptor</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 自定义MethodInterceptor</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DebugMethodInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodInterceptor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> o           被代理的对象（需要增强的对象）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> method      被拦截的方法（需要增强的方法）</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args        方法入参</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> methodProxy 用于调用原始方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">intercept</span><span class=\"params\">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之前，我们可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;before method &quot;</span> + method.getName());</span><br><span class=\"line\">        Object object = methodProxy.invokeSuper(o, args);</span><br><span class=\"line\">        <span class=\"comment\">//调用方法之后，我们同样可以添加自己的操作</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;after method &quot;</span> + method.getName());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用CGLIB代理工厂生成代理类</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CglibProxyFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title\">getProxy</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建动态代理增强类</span></span><br><span class=\"line\">        Enhancer enhancer = <span class=\"keyword\">new</span> Enhancer();</span><br><span class=\"line\">        <span class=\"comment\">// 设置类加载器</span></span><br><span class=\"line\">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class=\"line\">        <span class=\"comment\">// 设置被代理类</span></span><br><span class=\"line\">        enhancer.setSuperclass(clazz);</span><br><span class=\"line\">        <span class=\"comment\">// 设置方法拦截器</span></span><br><span class=\"line\">        enhancer.setCallback(<span class=\"keyword\">new</span> DebugMethodInterceptor());</span><br><span class=\"line\">        <span class=\"comment\">// 创建代理类</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> enhancer.create();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>实际使用</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);</span><br><span class=\"line\">aliSmsService.send(<span class=\"string\">&quot;java&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</p>\n<h3 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h3><h4 id=\"堆内存分代模型\"><a href=\"#堆内存分代模型\" class=\"headerlink\" title=\"堆内存分代模型\"></a>堆内存分代模型</h4><ul>\n<li>新生代：存放新建的对象</li>\n</ul>\n<ol>\n<li>Eden区：新对象首先放在这里</li>\n<li>两个survivor区：Eden中存活的对象会被移动到这里</li>\n<li>新生代垃圾回收比较频繁，采用MinorGC</li>\n</ol>\n<ul>\n<li>老年代：存放生命周期较长的对象</li>\n</ul>\n<ol>\n<li>多次在新生代回收中幸存的对象</li>\n<li>老年代垃圾回收比新生代少，采用MajorGC或FullGC</li>\n</ol>\n<ul>\n<li>永久代&#x2F;元空间</li>\n</ul>\n<ol>\n<li>JVM方法区的一部分，用于存储类的元数据，静态变量等等</li>\n<li>jdk8之后永久代被替换为元空间，不在堆内存中，使用本地内存</li>\n</ol>\n<h4 id=\"垃圾回收工作原理\"><a href=\"#垃圾回收工作原理\" class=\"headerlink\" title=\"垃圾回收工作原理\"></a>垃圾回收工作原理</h4><h5 id=\"可达性分析\"><a href=\"#可达性分析\" class=\"headerlink\" title=\"可达性分析\"></a>可达性分析</h5><p>使用可达性分析算法判断对象是否存活。</p>\n<p>从GCRoot的引用对象出发，遍历所有可被引用的对象，如果对象不可达，则认为是垃圾</p>\n<p><img src=\"https://i.imgur.com/oHh5IHy.png\" alt=\"picture 3\">  </p>\n<p>GCRoot的来源：</p>\n<ul>\n<li>虚拟机栈（栈帧）中的本地变量引用（Java 局部变量&#x2F;参数）（每个 Java 线程）</li>\n<li>正在运行的 Java 线程（Thread 对象）（线程本身为 root）</li>\n<li>静态引用（类的 static 字段）（类加载器加载的类）</li>\n<li>常量引用（常量池）（如 String 常量池）</li>\n<li>JNI 全局引用 &#x2F; 本地引用（Native code 创建的引用）</li>\n<li>系统类加载器引用（ClassLoader）</li>\n<li>ReferenceQueue&#x2F;Finalizer 队列中的引用对象（java.lang.ref 包的参考对象）</li>\n</ul>\n<p>对象第一次不可达，则标记为死亡状态；若对象实现了finalize方法，会尝试自救，如果仍不可达，则正式认定为死亡。</p>\n<p>引用类型：</p>\n<ul>\n<li>强引用（StrongReference）：默认引用，只有当无强引用时对象才可回收。</li>\n<li>软引用（SoftReference）：在内存不足时才会回收（适合缓存）；JVM 可根据内存压力决定回收时机。</li>\n<li>弱引用（WeakReference）：一旦 GC 运行且对象只有弱引用，就会被回收（常用于 WeakHashMap）。</li>\n<li>虚引用（PhantomReference）：无法通过 get() 获取对象，常用于在对象回收前做清理（与 ReferenceQueue 配合）。</li>\n</ul>\n<p>这里弱引用举例：</p>\n<p>ThreadLocal在ThreadLocalMap中的Entry里作为Key是弱引用，当GC开始时，该Key会被回收，但是Value是强引用，导致这个entry不会被回收，所以会出现ThreadLocal导致的内存泄漏问题</p>\n<p>虚引用举例：</p>\n<p>虚引用本身是搭配ReferenceQueue使用的，本质是和实例对象创建一个关联，当实例对象被回收的时候，虚引用对象被放到reference queue中，相当于可以做通知，某某对象被回收了，如果有后续操作可以通过这种方式来触发</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.ref.PhantomReference;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.ref.ReferenceQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PhantomRefDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ReferenceQueue&lt;Object&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\">        Object obj = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建虚引用，关联到 queue</span></span><br><span class=\"line\">        PhantomReference&lt;Object&gt; phantomRef = <span class=\"keyword\">new</span> PhantomReference&lt;&gt;(obj, queue);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(phantomRef.get()); <span class=\"comment\">// 永远返回 null</span></span><br><span class=\"line\"></span><br><span class=\"line\">        obj = <span class=\"keyword\">null</span>; <span class=\"comment\">// 去掉强引用</span></span><br><span class=\"line\">        System.gc(); <span class=\"comment\">// 触发 GC</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 检查是否进入队列</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (queue.poll() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;对象已经被回收，虚引用进入队列&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h4><h5 id=\"标记-清除算法\"><a href=\"#标记-清除算法\" class=\"headerlink\" title=\"标记-清除算法\"></a>标记-清除算法</h5><ol>\n<li>遍历对象，标记出所有需要被回收的对象</li>\n<li>清除这些对象，释放相关内存</li>\n</ol>\n<p><img src=\"https://i.imgur.com/bYBtXor.png\" alt=\"picture 4\">  </p>\n<p>缺点：导致内存碎片化</p>\n<h5 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h5><p><img src=\"https://i.imgur.com/XTZJ0vi.png\" alt=\"picture 5\">  </p>\n<p>将存活的对象从一块内存复制到另一块内存中，清空原内存</p>\n<p>适用于新生代</p>\n<h5 id=\"标记整理算法\"><a href=\"#标记整理算法\" class=\"headerlink\" title=\"标记整理算法\"></a>标记整理算法</h5><p><img src=\"https://i.imgur.com/654bcGk.png\" alt=\"picture 6\">  </p>\n<p>标记存活的对象，将他们移动到内存一端，清理无用空间</p>\n<p>适用于老年代</p>\n<h4 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h4><h5 id=\"新生代收集器\"><a href=\"#新生代收集器\" class=\"headerlink\" title=\"新生代收集器\"></a>新生代收集器</h5><h6 id=\"SerialGC\"><a href=\"#SerialGC\" class=\"headerlink\" title=\"SerialGC\"></a>SerialGC</h6><p><img src=\"https://i.imgur.com/n6jdmFG.png\" alt=\"picture 7\">  </p>\n<p>单线程的垃圾收集器，效率高，但是会导致长时间停顿</p>\n<h6 id=\"ParNewGC\"><a href=\"#ParNewGC\" class=\"headerlink\" title=\"ParNewGC\"></a>ParNewGC</h6><p><img src=\"https://i.imgur.com/cJEQKhj.png\" alt=\"picture 8\">  </p>\n<p>并行收集器，支持多线程</p>\n<h6 id=\"ParallelGC\"><a href=\"#ParallelGC\" class=\"headerlink\" title=\"ParallelGC\"></a>ParallelGC</h6><p>多线程并行收集，关注吞吐量，减少垃圾回收占总时间占比</p>\n<h5 id=\"老生代收集器\"><a href=\"#老生代收集器\" class=\"headerlink\" title=\"老生代收集器\"></a>老生代收集器</h5><h6 id=\"CMSGC\"><a href=\"#CMSGC\" class=\"headerlink\" title=\"CMSGC\"></a>CMSGC</h6><p><img src=\"https://i.imgur.com/Vb2yEnF.png\" alt=\"picture 9\">  </p>\n<p>使用标记清除算法</p>\n<h6 id=\"G1-GC\"><a href=\"#G1-GC\" class=\"headerlink\" title=\"G1 GC\"></a>G1 GC</h6><p><img src=\"https://i.imgur.com/gAOVOAp.png\" alt=\"picture 10\">  </p>\n<p>将堆划分为多个区域，不再严格区分新生代和老年代</p>\n<p>G1 有两类 GC：</p>\n<ul>\n<li><p>年轻代 GC (Young GC)：回收 Eden + Survivor。</p>\n</li>\n<li><p>混合 GC (Mixed GC)：回收 Eden + Survivor + 部分 Old。</p>\n</li>\n<li><p>再加上 Full GC（极少发生，触发时会退化成 Serial GC）。</p>\n</li>\n</ul>\n<p>年轻代GC：</p>\n<ol>\n<li><p>Eden 区满时触发。</p>\n</li>\n<li><p>复制存活对象到 Survivor&#x2F;Old 区。</p>\n</li>\n<li><p>更新 Remembered Set（跨 Region 引用的记录）。</p>\n</li>\n<li><p>大部分是 并发的 Minor GC，但是有 短暂停顿（STW） 用于根扫描。</p>\n</li>\n</ol>\n<p>MixedGC：</p>\n<p>当 Old 区逐渐填满时，触发混合 GC：</p>\n<ol>\n<li>初始标记（STW）</li>\n</ol>\n<ul>\n<li><p>标记 GC Roots 直接可达的对象。</p>\n</li>\n<li><p>这个阶段很快。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>并发标记（Concurrent Marking）</li>\n</ol>\n<ul>\n<li><p>使用 三色标记算法 并发标记所有存活对象。</p>\n</li>\n<li><p>应用线程和 GC 线程同时运行。</p>\n</li>\n<li><p>如果发现某些 Region 全部不可达，可以立即回收（即“立即回收”特性）。</p>\n</li>\n</ul>\n<ol start=\"3\">\n<li>最终标记（STW）</li>\n</ol>\n<ul>\n<li><p>处理并发标记期间的“引用变动”（SATB: Snapshot-At-The-Beginning 技术）。</p>\n</li>\n<li><p>修正标记结果，确保准确性。</p>\n</li>\n</ul>\n<ol start=\"4\">\n<li>筛选回收（STW）</li>\n</ol>\n<ul>\n<li><p>根据每个 Region 的回收价值（垃圾比例 + 回收成本）选择一批 Region 进行回收。</p>\n</li>\n<li><p>将存活对象拷贝到别的 Region，腾出空间。</p>\n</li>\n</ul>\n<p>Full GC：</p>\n<ul>\n<li><p>如果内存压力过大，Mixed GC 跟不上，就会退化为 Full GC。</p>\n</li>\n<li><p>Full GC 是单线程 + STW，非常慢（通常要避免）。</p>\n</li>\n</ul>\n<h5 id=\"三色标记清除算法\"><a href=\"#三色标记清除算法\" class=\"headerlink\" title=\"三色标记清除算法\"></a>三色标记清除算法</h5><ol>\n<li><p>所有对象初始为白色</p>\n</li>\n<li><p>从 GC Roots 开始，把根对象标记为灰色</p>\n</li>\n<li><p>不断处理灰色对象：</p>\n<ul>\n<li>把它变为黑色</li>\n<li>把它引用的白色对象变为灰色</li>\n</ul>\n</li>\n<li><p>当灰色对象处理完后，剩下的白色对象就是真正的垃圾（不可达）</p>\n</li>\n</ol>\n<h4 id=\"垃圾回收流程\"><a href=\"#垃圾回收流程\" class=\"headerlink\" title=\"垃圾回收流程\"></a>垃圾回收流程</h4><p>假设：</p>\n<p>Eden &#x3D; 100MB，Survivor &#x3D; 10MB each（S0,S1），老年代 400MB。</p>\n<p>SurvivorRatio &#x3D; 8（Eden:Survivor&#x3D;8:1:1），MaxTenuringThreshold &#x3D; 15</p>\n<p>流程：</p>\n<p>程序新建对象 O1、O2、… 都先在 Eden 分配（可能使用 TLAB 提高并发分配效率）。</p>\n<p>Eden 满时触发 Minor GC：</p>\n<p>扫描 Root，标记可达对象（若 A 在 Eden 并被活引用，则被标记）。</p>\n<p>把存活对象复制到 S1（假设 S1 为空），并将在 S0 中已存活对象的年龄 +1，</p>\n<p>若某对象年龄 &gt;&#x3D; MaxTenuringThreshold 或 Survivor 空间不足则 晋升到老年代。</p>\n<p>如果老年代空间不足导致晋升失败 -&gt; 触发 Full GC（STW），做老年代标记-清理&#x2F;压缩。</p>\n<p>Full GC 后若空间仍不足 -&gt; OOME。</p>\n<h3 id=\"并发编程\"><a href=\"#并发编程\" class=\"headerlink\" title=\"并发编程\"></a>并发编程</h3><p><img src=\"https://i.imgur.com/PH1cZ8Q.png\" alt=\"picture 22\">  </p>\n<p>一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。</p>\n<h4 id=\"可以直接调用-Thread-类的-run-方法吗？\"><a href=\"#可以直接调用-Thread-类的-run-方法吗？\" class=\"headerlink\" title=\"可以直接调用 Thread 类的 run 方法吗？\"></a>可以直接调用 Thread 类的 run 方法吗？</h4><p>new 一个 Thread，线程进入了新建状态。调用 start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 但是，直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。总结：调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</p>\n<h4 id=\"死锁必要条件\"><a href=\"#死锁必要条件\" class=\"headerlink\" title=\"死锁必要条件\"></a>死锁必要条件</h4><ul>\n<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>\n<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>\n<li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li>\n</ul>\n<p>如何预防死锁？ 破坏死锁的产生的必要条件即可：</p>\n<ul>\n<li>破坏请求与保持条件：一次性申请所有的资源。</li>\n<li>破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>\n<li>破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>\n</ul>\n<h4 id=\"Volatile关键字\"><a href=\"#Volatile关键字\" class=\"headerlink\" title=\"Volatile关键字\"></a>Volatile关键字</h4><p>volatile 关键字可以保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>\n<h5 id=\"如何禁止指令重排序\"><a href=\"#如何禁止指令重排序\" class=\"headerlink\" title=\"如何禁止指令重排序\"></a>如何禁止指令重排序</h5><p>在 Java 中，volatile 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。 如果我们将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton uniqueInstance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getUniqueInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//类对象加锁</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (uniqueInstance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    uniqueInstance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> uniqueInstance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance &#x3D; new Singleton(); </p>\n<p>这段代码其实是分为三步执行：</p>\n<ol>\n<li>为 uniqueInstance 分配内存空间</li>\n<li>初始化 uniqueInstance</li>\n<li>将 uniqueInstance 指向分配的内存地址</li>\n</ol>\n<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>\n<h4 id=\"CAS算法\"><a href=\"#CAS算法\" class=\"headerlink\" title=\"CAS算法\"></a>CAS算法</h4><p>举一个简单的例子：</p>\n<p>线程 A 要修改变量 i 的值为 6，i 原值为 1（V &#x3D; 1，E&#x3D;1，N&#x3D;6，假设不存在 ABA 问题）。</p>\n<p>i 与 1 进行比较，如果相等， 则说明没被其他线程修改，可以被设置为 6 。i 与 1 进行比较，如果不相等，则说明被其他线程修改，当前线程放弃更新，CAS 操作失败。</p>\n<p>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>\n<h4 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h4><h5 id=\"如何使用synchronized\"><a href=\"#如何使用synchronized\" class=\"headerlink\" title=\"如何使用synchronized\"></a>如何使用synchronized</h5><ol>\n<li>修饰实例方法(锁当前对象实例)</li>\n</ol>\n<p>给当前对象实例加锁，进入给段代码前需要获取当前对象实例的锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//业务代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>修饰静态方法</li>\n</ol>\n<p>给当前类加锁，会作用域所有的对象示例，进入代码前要获取当前类的锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">method</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//业务代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>修饰代码块</li>\n</ol>\n<p>对括号内的指定对象&#x2F;类加锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//业务代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"synchronized底层原理\"><a href=\"#synchronized底层原理\" class=\"headerlink\" title=\"synchronized底层原理\"></a>synchronized底层原理</h5><h5 id=\"同步语句块\"><a href=\"#同步语句块\" class=\"headerlink\" title=\"同步语句块\"></a>同步语句块</h5><p>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</p>\n<p>在执行monitorenter时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>\n<p>对象锁的拥有者线程才可以执行 monitorexit 指令来释放锁。在执行 monitorexit 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p>\n<h5 id=\"同步方法\"><a href=\"#同步方法\" class=\"headerlink\" title=\"同步方法\"></a>同步方法</h5><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取而代之的是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁</p>\n<h4 id=\"锁升级\"><a href=\"#锁升级\" class=\"headerlink\" title=\"锁升级\"></a>锁升级</h4><h5 id=\"锁的状态\"><a href=\"#锁的状态\" class=\"headerlink\" title=\"锁的状态\"></a>锁的状态</h5><ol>\n<li><p>无锁<br>对于共享资源，不涉及多线程的竞争访问。</p>\n</li>\n<li><p>偏向锁<br>共享资源首次被访问时，JVM会对该共享资源对象做一些设置，比如将对象头中是否偏向锁标志位置为1，对象头中的线程ID设置为当前线程ID（注意：这里是操作系统的线程ID），后续当前线程再次访问这个共享资源时，会根据偏向锁标识跟线程ID进行比对是否相同，比对成功则直接获取到锁，进入临界区域（就是被锁保护，线程间只能串行访问的代码），这也是synchronized锁的可重入功能。</p>\n</li>\n<li><p>轻量级锁<br>当多个线程同时申请共享资源锁的访问时，这就产生了竞争，JVM会先尝试使用轻量级锁，以CAS方式来获取锁（一般就是自旋加锁，不阻塞线程采用循环等待的方式），成功则获取到锁，状态为轻量级锁，失败（达到一定的自旋次数还未成功）则锁升级到重量级锁。</p>\n</li>\n<li><p>重量级锁<br>如果共享资源锁已经被某个线程持有，此时是偏向锁状态，未释放锁前，再有其他线程来竞争时，则会升级到重量级锁，另外轻量级锁状态多线程竞争锁时，也会升级到重量级锁，重量级锁由操作系统来实现，所以性能消耗相对较高。<br>这4种级别的锁，在获取时性能消耗：重量级锁 &gt; 轻量级锁 &gt; 偏向锁 &gt; 无锁。</p>\n</li>\n</ol>\n<h5 id=\"锁升级过程\"><a href=\"#锁升级过程\" class=\"headerlink\" title=\"锁升级过程\"></a>锁升级过程</h5><ol>\n<li>当JVM启动后，一个共享资源对象直到有线程第一个访问时，这段时间内是处于无锁状态，对象头的Markword里偏向锁标识位是0，锁标识位是01。</li>\n</ol>\n<p><img src=\"https://i.imgur.com/eytoz7l.png\" alt=\"picture 23\">  </p>\n<ol start=\"2\">\n<li>当一个共享资源首次被某个线程访问时，锁就会从无锁状态升级到偏向锁状态，偏向锁会在Markword的偏向线程ID里存储当前线程的操作系统线程ID，偏向锁标识位是1，锁标识位是01。此后如果当前线程再次进入临界区域时，只比较这个偏向线程ID即可，这种情况是在只有一个线程访问的情况下，不再需要操作系统的重量级锁来切换上下文，提供程序的访问效率。</li>\n</ol>\n<p><img src=\"https://i.imgur.com/gyip2EE.png\" alt=\"picture 24\">  </p>\n<ol start=\"3\">\n<li>当第二个线程尝试获取偏向锁失败时，偏向锁会升级为轻量级锁，此时，JVM会使用CAS自旋操作来尝试获取锁，如果成功则进入临界区域，否则升级为重量级锁。<br>轻量级锁是在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，尝试拷贝锁对象头的Markword到栈帧的Lock Record，若拷贝成功，JVM将使用CAS操作尝试将对象头的Markword更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象头的Markword。若拷贝失败,若当前只有一个等待线程，则可通过自旋继续尝试， 当自旋超过一定的次数，或者一个线程在持有锁，一个线程在自旋，又有第三个线程来访问时，轻量级锁就会膨胀为重量级锁。</li>\n</ol>\n<p><img src=\"https://i.imgur.com/IxK08hP.png\" alt=\"picture 25\">  </p>\n<ol start=\"4\">\n<li>当轻量级锁获取锁失败时，说明有竞争存在，轻量级锁会升级为重量级锁，此时，JVM会将线程阻塞，直到获取到锁后才能进入临界区域，底层是通过操作系统的mutex lock来实现的，每个对象指向一个monitor对象，这个monitor对象在堆中与锁是关联的，通过monitorenter指令插入到同步代码块在编译后的开始位置，monitorexit指令插入到同步代码块的结束处和异常处，这两个指令配对出现。JVM的线程和操作系统的线程是对应的，重量级锁的Markword里存储的指针是这个monitor对象的地址，操作系统来控制内核态中的线程的阻塞和恢复，从而达到JVM线程的阻塞和恢复，涉及内核态和用户态的切换，影响性能，所以叫重量级锁。</li>\n</ol>\n<p>无锁-&gt;轻量级锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lockUpgradeTest1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Object obj = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;未开启偏向锁，对象信息&quot;</span>);</span><br><span class=\"line\">    System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (obj) &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;已获取到锁信息&quot;</span>);</span><br><span class=\"line\">        System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;已释放锁信息&quot;</span>);</span><br><span class=\"line\">    System.out.println(ClassLayout.parseInstance(obj).toPrintable());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>偏向锁-&gt;轻量级锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lockUpgradeTest3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// JVM默认4秒后才可以偏向锁，所以这里休眠5秒，锁对象就是偏向锁了</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Object object = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">    Thread t1 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;开启偏向锁，偏向锁延迟时间后，对象信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;已获取到锁信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;开启偏向锁，已释放锁信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t1&quot;</span>);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Thread t2 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;开启偏向锁，偏向锁延迟时间后，对象信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;已获取到锁信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;开启偏向锁，已释放锁信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">    t2.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>偏向锁-&gt;重量级锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lockUpgradeTest4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// JVM默认4秒后才可以偏向锁，所以这里休眠5秒，锁对象就是偏向锁了</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Object object = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">    Thread t1 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;加锁前对象信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;已获取到锁信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 让t2线程启动后并竞争锁</span></span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;已释放锁信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t1&quot;</span>);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 让t1线程先启动并拿到锁</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Thread t2 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;加锁前对象信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;已获取到锁信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;已释放锁信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">    t2.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>轻量级锁-&gt;重量级锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lockUpgradeTest4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// JVM默认4秒后才可以偏向锁，所以这里休眠5秒，锁对象就是偏向锁了</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">5000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Object object = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\">    Thread t1 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;加锁前对象信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;已获取到锁信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 让t2线程启动后并竞争锁</span></span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;已释放锁信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t1&quot;</span>);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 让t1线程先启动并拿到锁</span></span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">3000</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Thread t2 = <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;加锁前对象信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (object) &#123;</span><br><span class=\"line\">            System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;已获取到锁信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot;已释放锁信息&quot;</span> + ClassLayout.parseInstance(object).toPrintable());</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">    t2.start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ReentryLock\"><a href=\"#ReentryLock\" class=\"headerlink\" title=\"ReentryLock\"></a>ReentryLock</h4><p>ReentrantLock 里面有一个内部类 Sync，Sync 继承 AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在 Sync 中实现的。Sync 有公平锁 FairSync 和非公平锁 NonfairSync 两个子类。</p>\n<p>ReentrantLock 默认使用非公平锁，也可以通过构造器来显式的指定使用公平锁。</p>\n<h5 id=\"synchoronized-和-reentryLock对比\"><a href=\"#synchoronized-和-reentryLock对比\" class=\"headerlink\" title=\"synchoronized 和 reentryLock对比\"></a>synchoronized 和 reentryLock对比</h5><p>共同点： 都是可重入锁</p>\n<p>不同点：</p>\n<ol>\n<li>synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</li>\n<li>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说当前线程在等待获取锁的过程中，如果其他线程中断当前线程「 interrupt() 」，当前线程就会抛出 InterruptedException 异常，可以捕捉该异常进行相应处理。</li>\n<li>ReentrantLock可实现公平锁 :ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。</li>\n<li>ReentrantLock可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。</li>\n<li>ReentrantLock支持超时 ：ReentrantLock 提供了 tryLock(timeout) 的方法，可以指定等待获取锁的最长等待时间，如果超过了等待时间，就会获取锁失败，不会一直等待。</li>\n</ol>\n<h4 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h4><h5 id=\"ThreadLocal-内存泄漏\"><a href=\"#ThreadLocal-内存泄漏\" class=\"headerlink\" title=\"ThreadLocal 内存泄漏\"></a>ThreadLocal 内存泄漏</h5><p>每个线程维护一个名为 ThreadLocalMap 的 map。 当你使用 ThreadLocal 存储值时，实际上是将值存储在当前线程的 ThreadLocalMap 中，其中 ThreadLocal 实例本身作为 key，而你要存储的值作为 value。</p>\n<p>ThreadLocalMap 的 set() 和 createMap() 方法中，并没有直接存储 ThreadLocal 对象本身，而是使用 ThreadLocal 的哈希值计算数组索引，最终存储于类型为static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt;的数组中。</p>\n<p>ThreadLocalMap 的 key 和 value 引用机制：</p>\n<ul>\n<li>key 是弱引用：ThreadLocalMap 中的 key 是 ThreadLocal 的弱引用 (WeakReference&lt;ThreadLocal&lt;?&gt;&gt;)。 这意味着，如果 ThreadLocal 实例不再被任何强引用指向，垃圾回收器会在下次 GC 时回收该实例，导致 ThreadLocalMap 中对应的 key 变为 null。</li>\n<li>value 是强引用：即使 key 被 GC 回收，value 仍然被 ThreadLocalMap.Entry 强引用存在，无法被 GC 回收。</li>\n</ul>\n<p>当 ThreadLocal 实例失去强引用后，其对应的 value 仍然存在于 ThreadLocalMap 中，因为 Entry 对象强引用了它。如果线程持续存活（例如线程池中的线程），ThreadLocalMap 也会一直存在，导致 key 为 null 的 entry 无法被垃圾回收，即会造成内存泄漏。</p>\n<p>也就是说，内存泄漏的发生需要同时满足两个条件：</p>\n<ol>\n<li>ThreadLocal 实例不再被强引用；</li>\n<li>线程持续存活，导致 ThreadLocalMap 长期存在。</li>\n</ol>\n<h5 id=\"InheritableThreadLocal\"><a href=\"#InheritableThreadLocal\" class=\"headerlink\" title=\"InheritableThreadLocal\"></a>InheritableThreadLocal</h5><p>InheritableThreadLocal 实现了创建异步线程时，继承父线程 ThreadLocal 值的功能。该类是 JDK 团队提供的，通过改造 JDK 源码包中的 Thread 类来实现创建线程时，ThreadLocal 值的传递。</p>\n<p>InheritableThreadLocal 的值存储在哪里？</p>\n<p>在 Thread 类中添加了一个新的 ThreadLocalMap ，命名为 inheritableThreadLocals ，该变量用于存储需要跨线程传递的 ThreadLocal 值。</p>\n<h4 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h4><h5 id=\"拒绝策略\"><a href=\"#拒绝策略\" class=\"headerlink\" title=\"拒绝策略\"></a>拒绝策略</h5><ul>\n<li>ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。</li>\n<li>ThreadPoolExecutor.CallerRunsPolicy：调用执行者自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果你的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>\n<li>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。</li>\n<li>ThreadPoolExecutor.DiscardOldestPolicy：此策略将丢弃最早的未处理的任务请求。</li>\n</ul>\n<h4 id=\"Future类\"><a href=\"#Future类\" class=\"headerlink\" title=\"Future类\"></a>Future类</h4><h5 id=\"Calleable-和-Future之间的关系\"><a href=\"#Calleable-和-Future之间的关系\" class=\"headerlink\" title=\"Calleable 和 Future之间的关系\"></a>Calleable 和 Future之间的关系</h5><p>我们可以通过 FutureTask 来理解 Callable 和 Future 之间的关系。</p>\n<p>FutureTask 提供了 Future 接口的基本实现，常用来封装 Callable 和 Runnable，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法。ExecutorService.submit() 方法返回的其实就是 Future 的实现类 FutureTask。</p>\n<h5 id=\"CompletedFuture类有什么用\"><a href=\"#CompletedFuture类有什么用\" class=\"headerlink\" title=\"CompletedFuture类有什么用\"></a>CompletedFuture类有什么用</h5><p>Future 在实际使用过程中存在一些局限性，比如不支持异步任务的编排组合、获取计算结果的 get() 方法为阻塞调用。Java 8 才被引入CompletableFuture 类可以解决Future 的这些缺陷。CompletableFuture 除了提供了更为好用和强大的 Future 特性之外，还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p>\n<h5 id=\"一个任务需要依赖另外两个任务执行完之后再执行，怎么设计？\"><a href=\"#一个任务需要依赖另外两个任务执行完之后再执行，怎么设计？\" class=\"headerlink\" title=\"一个任务需要依赖另外两个任务执行完之后再执行，怎么设计？\"></a>一个任务需要依赖另外两个任务执行完之后再执行，怎么设计？</h5><p>这种任务编排场景非常适合通过CompletableFuture实现。这里假设要实现 T3 在 T2 和 T1 执行完后执行。代码如下（这里为了简化代码，用到了 Hutool 的线程工具类 ThreadUtil 和日期时间工具类 DateUtil）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// T1</span></span><br><span class=\"line\">CompletableFuture&lt;Void&gt; futureT1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;T1 is executing. Current time：&quot;</span> + DateUtil.now());</span><br><span class=\"line\">    <span class=\"comment\">// 模拟耗时操作</span></span><br><span class=\"line\">    ThreadUtil.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// T2</span></span><br><span class=\"line\">CompletableFuture&lt;Void&gt; futureT2 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;T2 is executing. Current time：&quot;</span> + DateUtil.now());</span><br><span class=\"line\">    ThreadUtil.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用allOf()方法合并T1和T2的CompletableFuture，等待它们都完成</span></span><br><span class=\"line\">CompletableFuture&lt;Void&gt; bothCompleted = CompletableFuture.allOf(futureT1, futureT2);</span><br><span class=\"line\"><span class=\"comment\">// 当T1和T2都完成后，执行T3</span></span><br><span class=\"line\">bothCompleted.thenRunAsync(() -&gt; System.out.println(<span class=\"string\">&quot;T3 is executing after T1 and T2 have completed.Current time：&quot;</span> + DateUtil.now()));</span><br><span class=\"line\"><span class=\"comment\">// 等待所有任务完成，验证效果</span></span><br><span class=\"line\">ThreadUtil.sleep(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h3><h4 id=\"Reader和Stream\"><a href=\"#Reader和Stream\" class=\"headerlink\" title=\"Reader和Stream\"></a>Reader和Stream</h4><p>InputStream&#x2F;OutputStream 针对的是字节流</p>\n<p>Reader&#x2F;Writer针对的是字符流</p>\n<h4 id=\"IO设计模式\"><a href=\"#IO设计模式\" class=\"headerlink\" title=\"IO设计模式\"></a>IO设计模式</h4><h5 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h5><p>装饰器（Decorator）模式 可以在不改变原有对象的情况下拓展其功能。装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。</p>\n<p>对于字节流来说， FilterInputStream （对应输入流）和FilterOutputStream（对应输出流）是装饰器模式的核心，分别用于增强 InputStream 和OutputStream子类对象的功能。我们常见的BufferedInputStream(字节缓冲输入流)、DataInputStream 等等都是FilterInputStream 的子类，BufferedOutputStream（字节缓冲输出流）、DataOutputStream等等都是FilterOutputStream的子类。</p>\n<p>举个例子，我们可以通过 BufferedInputStream（字节缓冲输入流）来增强 FileInputStream 的功能。BufferedInputStream 构造函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BufferedInputStream</span><span class=\"params\">(InputStream in)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BufferedInputStream</span><span class=\"params\">(InputStream in, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(in);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buf = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[size];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 应用</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> (BufferedInputStream bis = <span class=\"keyword\">new</span> BufferedInputStream(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">&quot;input.txt&quot;</span>))) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> content;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> skip = bis.skip(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((content = bis.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        System.out.print((<span class=\"keyword\">char</span>) content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h5><p>适配器（Adapter Pattern）模式 主要用于接口互不兼容的类的协调工作，你可以将其联想到我们日常经常使用的电源适配器。</p>\n<p>适配器模式中存在被适配的对象或者类称为 适配者(Adaptee) ，作用于适配者的对象或者类称为适配器(Adapter) 。适配器分为对象适配器和类适配器。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// InputStreamReader 是适配器，FileInputStream 是被适配的类</span></span><br><span class=\"line\">InputStreamReader isr = <span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(fileName), <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// BufferedReader 增强 InputStreamReader 的功能（装饰器模式）</span></span><br><span class=\"line\">BufferedReader bufferedReader = <span class=\"keyword\">new</span> BufferedReader(isr);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>装饰器模式 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。</li>\n<li>适配器模式 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。就比如说 StreamDecoder （流解码器）和StreamEncoder（流编码器）就是分别基于 InputStream 和 OutputStream 来获取 FileChannel对象并调用对应的 read 方法和 write 方法进行字节数据的读取和写入。</li>\n</ul>\n<h5 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h5><p>NIO 中的文件目录监听服务使用到了观察者模式。</p>\n<p>NIO 中的文件目录监听服务基于 WatchService 接口和 Watchable 接口。WatchService 属于观察者，Watchable 属于被观察者。</p>\n<p>Watchable 接口定义了一个用于将对象注册到 WatchService（监控服务） 并绑定监听事件的方法 register 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 WatchService 对象</span></span><br><span class=\"line\">WatchService watchService = FileSystems.getDefault().newWatchService();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化一个被监控文件夹的 Path 类:</span></span><br><span class=\"line\">Path path = Paths.get(<span class=\"string\">&quot;workingDirectory&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 将这个 path 对象注册到 WatchService（监控服务） 中去</span></span><br><span class=\"line\">WatchKey watchKey = path.register(</span><br><span class=\"line\">watchService, StandardWatchEventKinds...);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"IO模型\"><a href=\"#IO模型\" class=\"headerlink\" title=\"IO模型\"></a>IO模型</h4><h5 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO\"></a>BIO</h5><p>同步阻塞模型</p>\n<p><img src=\"https://i.imgur.com/a8h1ub3.png\" alt=\"picture 26\">  </p>\n<h5 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h5><p>同步非阻塞</p>\n<p>Java 中的 NIO 可以看作是 I&#x2F;O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p>\n<p><img src=\"https://i.imgur.com/loXGe0d.png\" alt=\"picture 27\">  </p>\n<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>\n<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。但是，这种 IO 模型同样存在问题：应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。这个时候，I&#x2F;O 多路复用模型 就上场了。</p>\n<p><img src=\"https://i.imgur.com/Hg3S4CD.png\" alt=\"picture 28\">  </p>\n<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>\n<p>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</p>\n<p>Java 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p>\n<p><img src=\"https://i.imgur.com/OnL0JAZ.png\" alt=\"picture 29\">  </p>\n<h5 id=\"AIO\"><a href=\"#AIO\" class=\"headerlink\" title=\"AIO\"></a>AIO</h5><p>异步IO</p>\n<p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>\n<p><img src=\"https://i.imgur.com/VfzvBU9.png\" alt=\"picture 30\">  </p>\n<h3 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h3><p><img src=\"https://i.imgur.com/oxfmr40.png\" alt=\"picture 0\">  </p>\n<h4 id=\"对象创建过程\"><a href=\"#对象创建过程\" class=\"headerlink\" title=\"对象创建过程\"></a>对象创建过程</h4><p><img src=\"https://i.imgur.com/Ge0b7Vd.png\" alt=\"picture 42\">  </p>\n<h4 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h4><p><img src=\"https://i.imgur.com/Hjfu7AE.png\" alt=\"picture 43\">  </p>\n<h2 id=\"分布式\"><a href=\"#分布式\" class=\"headerlink\" title=\"分布式\"></a>分布式</h2><h3 id=\"Zookeeper实现分布式锁\"><a href=\"#Zookeeper实现分布式锁\" class=\"headerlink\" title=\"Zookeeper实现分布式锁\"></a>Zookeeper实现分布式锁</h3><p>利用zookeeper的临时顺序节点和监听机制，实现分布式锁</p>\n<p><img src=\"https://i.imgur.com/23gBFOK.png\" alt=\"picture 36\">  </p>\n<p>Zookeeper是强一致性的，因为他的底层ZAB协议（原子广播协议）天然满足一致性和分区容错</p>\n<h3 id=\"分布式事务\"><a href=\"#分布式事务\" class=\"headerlink\" title=\"分布式事务\"></a>分布式事务</h3><p><img src=\"https://i.imgur.com/m6uVH58.png\" alt=\"picture 37\">  </p>\n<h3 id=\"Zookeeper作用\"><a href=\"#Zookeeper作用\" class=\"headerlink\" title=\"Zookeeper作用\"></a>Zookeeper作用</h3><p>zookeeper是分布式协调服务，能够支持集群部署，应用场景</p>\n<ul>\n<li>配置管理：分布式系统中，不同的节点往往有相同的配置信息，比如数据库连接等，zookeeper将这些集中存储，配置变更时，可以通知到各个节点</li>\n<li>服务注册与发现：服务提供者启动时将自己的服务信息（名称，地址，端口等）注册到zookeeper，服务消费者通过zookeeper查找并且获取服务提供者的信息。</li>\n<li>分布式锁：zookeeper可以创建临时顺序节点，然后检查自己的节点是否是序号最小的节点，如果是就表示获取到锁，进行执行，然后删除锁</li>\n</ul>\n<h3 id=\"限流算法\"><a href=\"#限流算法\" class=\"headerlink\" title=\"限流算法\"></a>限流算法</h3><ul>\n<li>滑动窗口限流算法</li>\n</ul>\n<p><img src=\"https://i.imgur.com/Eg5w3rK.png\" alt=\"picture 38\">  </p>\n<ul>\n<li><p>漏桶限流算法</p>\n</li>\n<li><p>令牌桶限流算法</p>\n</li>\n</ul>\n<p><img src=\"https://i.imgur.com/AwWLBz0.png\" alt=\"picture 39\">  </p>\n<p><img src=\"https://i.imgur.com/19Znjkg.png\" alt=\"picture 40\">  </p>\n<h3 id=\"分布式一致性算法\"><a href=\"#分布式一致性算法\" class=\"headerlink\" title=\"分布式一致性算法\"></a>分布式一致性算法</h3><h2 id=\"Sql-related\"><a href=\"#Sql-related\" class=\"headerlink\" title=\"Sql-related\"></a>Sql-related</h2><h3 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h3><h4 id=\"DML-和-DDL\"><a href=\"#DML-和-DDL\" class=\"headerlink\" title=\"DML 和 DDL\"></a>DML 和 DDL</h4><p>DML 语句和 DDL 语句区别：</p>\n<ul>\n<li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。</li>\n<li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li>\n</ul>\n<h4 id=\"常见索引类型\"><a href=\"#常见索引类型\" class=\"headerlink\" title=\"常见索引类型\"></a>常见索引类型</h4><ul>\n<li>B-Tree 索引：B-Tree（或称为平衡树）索引是最常见和默认的索引类型。它适用于各种查询条件，可以快速定位到符合条件的数据。B-Tree 索引适用于普通的查找操作，支持等值查询、范围查询和排序。</li>\n<li>唯一索引：唯一索引与普通的 B-Tree 索引类似，不同之处在于它要求被索引的列的值是唯一的。这意味着在插入或更新数据时，MySQL 会验证索引列的唯一性。</li>\n<li>主键索引：主键索引是一种特殊的唯一索引，它用于唯一标识表中的每一行数据。每个表只能有一个主键索引，它可以帮助提高数据的访问速度和数据完整性。</li>\n<li>全文索引：全文索引用于在文本数据中进行全文搜索。它支持在文本字段中进行关键字搜索，而不仅仅是简单的等值或范围查找。全文索引适用于需要进行全文搜索的应用场景。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 示例：</span></span><br><span class=\"line\"><span class=\"comment\">-- 添加B-Tree索引：</span></span><br><span class=\"line\">\t<span class=\"keyword\">CREATE</span> INDEX idx_name(索引名) <span class=\"keyword\">ON</span> 表名 (字段名);   <span class=\"comment\">-- idx_name为索引名，以下都是</span></span><br><span class=\"line\"><span class=\"comment\">-- 创建唯一索引：</span></span><br><span class=\"line\">\t<span class=\"keyword\">CREATE</span> <span class=\"keyword\">UNIQUE</span> INDEX idx_name <span class=\"keyword\">ON</span> 表名 (字段名);</span><br><span class=\"line\"><span class=\"comment\">-- 创建一个主键索引：</span></span><br><span class=\"line\">\t<span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> 表名 <span class=\"keyword\">ADD</span> <span class=\"keyword\">PRIMARY</span> KEY (字段名);</span><br><span class=\"line\"><span class=\"comment\">-- 创建一个全文索引</span></span><br><span class=\"line\">\t<span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> 表名 <span class=\"keyword\">ADD</span> FULLTEXT INDEX idx_name (字段名);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 通过以上示例，可以看出create 和 alter 都可以添加索引</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"MVCC的实现\"><a href=\"#MVCC的实现\" class=\"headerlink\" title=\"MVCC的实现\"></a>MVCC的实现</h4><ol>\n<li><p>读操作（SELECT）：当一个事务执行读操作时，它会使用快照读取。快照读取是基于事务开始时数据库中的状态创建的，因此事务不会读取其他事务尚未提交的修改。具体工作情况如下：</p>\n<ul>\n<li>对于读取操作，事务会查找符合条件的数据行，并选择符合其事务开始时间的数据版本进行读取。</li>\n<li>如果某个数据行有多个版本，事务会选择不晚于其开始时间的最新版本，确保事务只读取在它开始之前已经存在的数据。</li>\n<li>事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作。</li>\n</ul>\n</li>\n<li><p>写操作（INSERT、UPDATE、DELETE）：当一个事务执行写操作时，它会生成一个新的数据版本，并将修改后的数据写入数据库。具体工作情况如下：</p>\n<ul>\n<li>对于写操作，事务会为要修改的数据行创建一个新的版本，并将修改后的数据写入新版本。</li>\n<li>新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。</li>\n<li>原始版本的数据仍然存在，供其他事务使用快照读取，这保证了其他事务不受当前事务的写操作影响。</li>\n</ul>\n</li>\n<li><p>事务提交和回滚：</p>\n<ul>\n<li>当一个事务提交时，它所做的修改将成为数据库的最新版本，并且对其他事务可见。</li>\n<li>当一个事务回滚时，它所做的修改将被撤销，对其他事务不可见。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"一致性非锁定读和锁定读\"><a href=\"#一致性非锁定读和锁定读\" class=\"headerlink\" title=\"一致性非锁定读和锁定读\"></a>一致性非锁定读和锁定读</h4><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>一致性非锁定读</th>\n<th>锁定读（FOR UPDATE &#x2F; LOCK IN SHARE MODE）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>是否加锁</td>\n<td>❌ 否</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td>是否读取快照</td>\n<td>✅ 是（历史版本）</td>\n<td>❌ 否（当前版本）</td>\n</tr>\n<tr>\n<td>是否可阻塞其他事务</td>\n<td>❌ 否</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td>是否可能被阻塞</td>\n<td>❌ 否</td>\n<td>✅ 是</td>\n</tr>\n<tr>\n<td>读取一致性</td>\n<td>✅ 高（受 MVCC 控制）</td>\n<td>✅ 高</td>\n</tr>\n<tr>\n<td>使用场景</td>\n<td>读多写少，要求高并发</td>\n<td>需要修改或防止并发写入</td>\n</tr>\n</tbody></table>\n<p>查询展示类操作：推荐使用一致性非锁定读，提升并发和性能；</p>\n<p>更新前校验数据正确性：使用 SELECT … FOR UPDATE 确保数据在修改前不被其他事务更改；</p>\n<p>避免幻读：配合隔离级别和加锁读使用，防止并发插入导致幻读问题。</p>\n<p>举个例子：</p>\n<p><img src=\"https://i.imgur.com/fl70wEu.png\" alt=\"picture 41\">  </p>\n<h4 id=\"InnoDB-对-MVCC-的实现\"><a href=\"#InnoDB-对-MVCC-的实现\" class=\"headerlink\" title=\"InnoDB 对 MVCC 的实现\"></a>InnoDB 对 MVCC 的实现</h4><p>MVCC 的实现依赖于：隐藏字段、Read View、undo log。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改</p>\n<h5 id=\"隐藏字段\"><a href=\"#隐藏字段\" class=\"headerlink\" title=\"隐藏字段\"></a>隐藏字段</h5><p>在内部，InnoDB 存储引擎为每行数据添加了三个 隐藏字段：</p>\n<ul>\n<li>DB_TRX_ID（6字节）：表示最后一次插入或更新该行的事务 id。此外，delete 操作在内部被视为更新，只不过会在记录头 Record header 中的 deleted_flag 字段将其标记为已删除</li>\n<li>DB_ROLL_PTR（7字节） 回滚指针，指向该行的 undo log 。如果该行未被更新，则为空</li>\n<li>DB_ROW_ID（6字节）：如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索</li>\n</ul>\n<h5 id=\"ReadView\"><a href=\"#ReadView\" class=\"headerlink\" title=\"ReadView\"></a>ReadView</h5><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReadView</span> &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">trx_id_t</span> m_low_limit_id;      <span class=\"comment\">/* 大于等于这个 ID 的事务均不可见 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">trx_id_t</span> m_up_limit_id;       <span class=\"comment\">/* 小于这个 ID 的事务均可见 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">trx_id_t</span> m_creator_trx_id;    <span class=\"comment\">/* 创建该 Read View 的事务ID */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">trx_id_t</span> m_low_limit_no;      <span class=\"comment\">/* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">ids_t</span> m_ids;                  <span class=\"comment\">/* 创建 Read View 时的活跃事务列表 */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  m_closed;                     <span class=\"comment\">/* 标记 Read View 是否 close */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://i.imgur.com/oFPzyos.png\" alt=\"picture 11\">  </p>\n<h5 id=\"undo-log\"><a href=\"#undo-log\" class=\"headerlink\" title=\"undo-log\"></a>undo-log</h5><p>undo log 主要有两个作用：</p>\n<ul>\n<li>当事务回滚时用于将数据恢复到修改前的样子</li>\n<li>另一个作用是 MVCC ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 undo log 读取之前的版本数据，以此实现非锁定读</li>\n</ul>\n<h5 id=\"MVCC➕Next-key-Lock-防止幻读\"><a href=\"#MVCC➕Next-key-Lock-防止幻读\" class=\"headerlink\" title=\"MVCC➕Next-key-Lock 防止幻读\"></a>MVCC➕Next-key-Lock 防止幻读</h5><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！InnoDB 使用 Next-key Lock 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p>\n<h4 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h4><h5 id=\"联合索引\"><a href=\"#联合索引\" class=\"headerlink\" title=\"联合索引\"></a>联合索引</h5><p>减少回表可以通过创建联合索引来实现，当联合索引包含到我们所有需要的数据信息的时候，就不需要进行回表查询了。</p>\n<p>假设有一个联合索引 (column1, column2, column3)，其从左到右的所有前缀为 (column1)、(column1, column2)、(column1, column2, column3)（创建 1 个联合索引相当于创建了 3 个索引），包含这些列的所有查询都会走索引而不会全表扫描。</p>\n<h5 id=\"索引下推\"><a href=\"#索引下推\" class=\"headerlink\" title=\"索引下推\"></a>索引下推</h5><p>索引下推（Index Condition Pushdown，简称 ICP） 是 MySQL 5.6 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，执行部分 WHERE 字句的判断条件，直接过滤掉不满足条件的记录，从而减少回表次数，提高查询效率</p>\n<p><img src=\"https://i.imgur.com/b91KuLC.png\" alt=\"picture 12\">  </p>\n<p>最后，总结一下索引下推应用范围：</p>\n<ul>\n<li>适用于 InnoDB 引擎和 MyISAM 引擎的查询。</li>\n<li>适用于执行计划是 range、ref、eq_ref、ref_or_null 的范围查询。</li>\n<li>对于 InnoDB 表，仅用于非聚簇索引。索引下推的目标是减少全行读取次数，从而减少 I&#x2F;O 操作。对于 InnoDB 聚集索引，完整的记录已经读入 InnoDB 缓冲区。在这种情况下使用索引下推不会减少 I&#x2F;O。</li>\n<li>子查询不能使用索引下推，因为子查询通常会创建临时表来处理结果，而这些临时表是没有索引的。</li>\n<li>存储过程不能使用索引下推，因为存储引擎无法调用存储函数。</li>\n</ul>\n<h4 id=\"三大日志\"><a href=\"#三大日志\" class=\"headerlink\" title=\"三大日志\"></a>三大日志</h4><h5 id=\"redo-log\"><a href=\"#redo-log\" class=\"headerlink\" title=\"redo log\"></a>redo log</h5><p>redo log（重做日志）是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力。比如 MySQL 实例挂了或宕机了，重启时，InnoDB 存储引擎会使用 redo log 恢复数据，保证数据的持久性与完整性。</p>\n<p><img src=\"https://i.imgur.com/ad2UZhh.png\" alt=\"picture 13\">  </p>\n<p><img src=\"https://i.imgur.com/4pQYsjz.png\" alt=\"picture 14\">  </p>\n<p>硬盘上存储的 redo log 日志文件不只一个，而是以一个日志文件组的形式出现的，每个的redo日志文件大小都是一样的。比如可以配置为一组4个文件，每个文件的大小是 1GB，整个 redo log 日志文件组可以记录4G的内容。它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p>\n<p><img src=\"https://i.imgur.com/BKWjcIP.png\" alt=\"picture 15\">  </p>\n<h5 id=\"binlog\"><a href=\"#binlog\" class=\"headerlink\" title=\"binlog\"></a>binlog</h5><p>redo log 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎。而 binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于MySQL Server 层。不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。</p>\n<p>binlog 的写入时机也非常简单，事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到 binlog 文件中。因为一个事务的 binlog 不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。我们可以通过binlog_cache_size参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（Swap）。binlog 日志刷盘流程如下</p>\n<p><img src=\"https://i.imgur.com/Yq5Rs6n.png\" alt=\"picture 16\">  </p>\n<p>为了解决两份日志之间的逻辑一致问题，InnoDB 存储引擎使用两阶段提交方案。</p>\n<p>原理很简单，将 redo log 的写入拆成了两个步骤prepare和commit，这就是两阶段提交。</p>\n<p><img src=\"https://i.imgur.com/QSXu74r.png\" alt=\"picture 17\">  </p>\n<h5 id=\"undo-log-1\"><a href=\"#undo-log-1\" class=\"headerlink\" title=\"undo log\"></a>undo log</h5><p>undo log 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 DELETE 语句，那 undo log 就会记录一条相对应的 INSERT 语句。同时，undo log 的信息也会被记录到 redo log 中，因为 undo log 也要实现持久性保护。</p>\n<h3 id=\"SQL优化\"><a href=\"#SQL优化\" class=\"headerlink\" title=\"SQL优化\"></a>SQL优化</h3><p>使用行级锁进行优化的场景</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">--  避免脏写</span></span><br><span class=\"line\"><span class=\"keyword\">START</span> TRANSACTION;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> balance <span class=\"keyword\">FROM</span> account <span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"keyword\">FOR</span> UPDATE;</span><br><span class=\"line\">UPDATE account <span class=\"keyword\">SET</span> balance <span class=\"operator\">=</span> balance <span class=\"operator\">+</span> <span class=\"number\">100</span> <span class=\"keyword\">WHERE</span> id <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--  防止幻读和重复计数</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> orders <span class=\"keyword\">WHERE</span> status <span class=\"operator\">=</span> <span class=\"string\">&#x27;pending&#x27;</span> <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> id LIMIT <span class=\"number\">10</span> <span class=\"keyword\">FOR</span> UPDATE;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设计区分度高的索引\"><a href=\"#设计区分度高的索引\" class=\"headerlink\" title=\"设计区分度高的索引\"></a>设计区分度高的索引</h4><ul>\n<li>选择唯一性强&#x2F;不同值多的列作为单列索引</li>\n<li>组合索引，当单列的区分度较低的时候，可以用组合索引提升选择性</li>\n<li>使用前缀索引，对于长字符串列（手机号，邮箱等）可以使用前缀索引</li>\n</ul>\n<h3 id=\"分布式事务-1\"><a href=\"#分布式事务-1\" class=\"headerlink\" title=\"分布式事务\"></a>分布式事务</h3><h4 id=\"XA协议的2PC和3PC（强一致性）\"><a href=\"#XA协议的2PC和3PC（强一致性）\" class=\"headerlink\" title=\"XA协议的2PC和3PC（强一致性）\"></a>XA协议的2PC和3PC（强一致性）</h4><p>引入事务协调者，管理各个微服务，每个微服务是一个事务参与者</p>\n<p>2PC：</p>\n<ul>\n<li>准备阶段： 协调者发送一个准备命令，每个事务参与者收到命令后，执行事务相关操作，但是不提交，然后参与者返回相应，告诉协调者是否准备成功</li>\n<li>提交阶段：如果所有参与者都准备成功，就给他们发送一个提交命令；如果有一个参与者准备失败，就发送一个回滚命令</li>\n</ul>\n<p>优点是利用数据库自身功能完成本地事务的提交和回滚，不侵入业务代码<br>缺点是：会阻塞其他相同的请求，因为事务没有提交的情况下，会进行加锁； 资源浪费，如果一个参与者是挂掉的，那么肯定是要回滚的，那之前执行的事务操作就是浪费</p>\n<p>3PC：</p>\n<ul>\n<li>准备阶段，判断是否每个参与者都正常运行，避免有人挂掉</li>\n<li>预提交阶段：协调者发送预提交命令，参与者收到后，就执行事务，但不提交，返回协调者是否准备成功</li>\n<li>提交阶段：如果全成功就提交，否则就回滚</li>\n</ul>\n<h4 id=\"AT模式（最终一致性）\"><a href=\"#AT模式（最终一致性）\" class=\"headerlink\" title=\"AT模式（最终一致性）\"></a>AT模式（最终一致性）</h4><p>Seeta最流行和最常用的事务模式。是基于Undo Log的最终一致性，undolog记录了数据的原始值（也就是数据快照），用于回滚数据。</p>\n<ul>\n<li>第一阶段：每个参与者直接执行事务相关操作，并且直接提交，同时把事务的原始值记录在undolog中</li>\n<li>第二阶段：协调者根据所有参与者的执行结果，如果全成功，就通知参与者异步删除undolog；如果有人失败，就通知参与者根据undolog恢复数据并且删除undolog</li>\n</ul>\n<h4 id=\"TCC（最终一致性）\"><a href=\"#TCC（最终一致性）\" class=\"headerlink\" title=\"TCC（最终一致性）\"></a>TCC（最终一致性）</h4><p>Try Confirm Cancel。</p>\n<ul>\n<li>第一阶段： 尝试执行业务，预留资源，但不真正地执行操作</li>\n<li>如果所有服务器的TRY都成功，就Confirm执行；否则就取消</li>\n</ul>\n<p>比如创建一个订单，不要设置状态为已支付，而是设置为待支付，同时库存设置一个冻结库存字段，如果其他事务失败，冻结的库存数量要返还回去；confirm的时候，将订单设置为已支付，并且减掉对应的库存，然后冻结库存的数量清0</p>\n<p>TCC通过业务逻辑控制事务的提交和回滚，对业务代码侵入性较大，但是性能比2PC高很多。</p>\n<h4 id=\"实际项目中解决\"><a href=\"#实际项目中解决\" class=\"headerlink\" title=\"实际项目中解决\"></a>实际项目中解决</h4><p>需要用的三个文件</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">seata-k8s/</span><br><span class=\"line\"> ├── configmap.yaml</span><br><span class=\"line\"> ├── deployment.yaml</span><br><span class=\"line\"> ├── service.yaml</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># configmap.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ConfigMap</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">seata-config</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\"><span class=\"attr\">data:</span></span><br><span class=\"line\">  <span class=\"attr\">file.conf:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">    transport &#123;</span></span><br><span class=\"line\"><span class=\"string\">      type = &quot;TCP&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\">    <span class=\"string\">service</span> &#123;</span><br><span class=\"line\">      <span class=\"string\">vgroupMapping.my_tx_group</span> <span class=\"string\">=</span> <span class=\"string\">&quot;default&quot;</span></span><br><span class=\"line\">      <span class=\"string\">default.grouplist</span> <span class=\"string\">=</span> <span class=\"string\">&quot;seata-server:8091&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">store</span> &#123;</span><br><span class=\"line\">      <span class=\"string\">mode</span> <span class=\"string\">=</span> <span class=\"string\">&quot;db&quot;</span></span><br><span class=\"line\">      <span class=\"string\">db</span> &#123;</span><br><span class=\"line\">        <span class=\"string\">driverClassName</span> <span class=\"string\">=</span> <span class=\"string\">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class=\"line\">        <span class=\"string\">url</span> <span class=\"string\">=</span> <span class=\"string\">&quot;jdbc:mysql://mysql.default.svc.cluster.local:3306/seata?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&quot;</span></span><br><span class=\"line\">        <span class=\"string\">user</span> <span class=\"string\">=</span> <span class=\"string\">&quot;root&quot;</span></span><br><span class=\"line\">        <span class=\"string\">password</span> <span class=\"string\">=</span> <span class=\"string\">&quot;root&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"attr\">registry.conf:</span> <span class=\"string\">|</span></span><br><span class=\"line\"><span class=\"string\">    registry &#123;</span></span><br><span class=\"line\"><span class=\"string\">      type = &quot;file&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    config &#123;</span></span><br><span class=\"line\"><span class=\"string\">      type = &quot;file&quot;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#  deployment.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">seata-server</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">seata</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">seata</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">seata-server</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> <span class=\"string\">seataio/seata-server:1.7.0</span></span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">8091</span></span><br><span class=\"line\">          <span class=\"attr\">volumeMounts:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">seata-config-volume</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/seata-server/resources/registry.conf</span></span><br><span class=\"line\">              <span class=\"attr\">subPath:</span> <span class=\"string\">registry.conf</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">seata-config-volume</span></span><br><span class=\"line\">              <span class=\"attr\">mountPath:</span> <span class=\"string\">/seata-server/resources/file.conf</span></span><br><span class=\"line\">              <span class=\"attr\">subPath:</span> <span class=\"string\">file.conf</span></span><br><span class=\"line\">      <span class=\"attr\">volumes:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">seata-config-volume</span></span><br><span class=\"line\">          <span class=\"attr\">configMap:</span></span><br><span class=\"line\">            <span class=\"attr\">name:</span> <span class=\"string\">seata-config</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># service.yaml</span></span><br><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Service</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">seata-server</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">default</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">seata</span></span><br><span class=\"line\">  <span class=\"attr\">ports:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"attr\">protocol:</span> <span class=\"string\">TCP</span></span><br><span class=\"line\">      <span class=\"attr\">port:</span> <span class=\"number\">8091</span></span><br><span class=\"line\">      <span class=\"attr\">targetPort:</span> <span class=\"number\">8091</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">seata:</span></span><br><span class=\"line\">  <span class=\"attr\">data-source-proxy-mode:</span> <span class=\"string\">AT</span></span><br><span class=\"line\">  <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">application-id:</span> <span class=\"string\">your-app</span></span><br><span class=\"line\">  <span class=\"attr\">tx-service-group:</span> <span class=\"string\">my_tx_group</span></span><br><span class=\"line\">  <span class=\"attr\">registry:</span></span><br><span class=\"line\">    <span class=\"attr\">type:</span> <span class=\"string\">file</span></span><br><span class=\"line\">  <span class=\"attr\">service:</span></span><br><span class=\"line\">    <span class=\"attr\">vgroup-mapping:</span></span><br><span class=\"line\">      <span class=\"attr\">my_tx_group:</span> <span class=\"string\">default</span></span><br><span class=\"line\">    <span class=\"attr\">grouplist:</span></span><br><span class=\"line\">      <span class=\"attr\">default:</span> <span class=\"string\">seata-server:8091</span></span><br></pre></td></tr></table></figure>\n\n<p>7091是可以访问seata的ui界面的，8091是用于transaction的注册记录的</p>\n<p>需要建立一个新的seata数据库，其中放global_table,branch_table,distributed_lock,lock_table</p>\n<p>我使用的是AT模式，所以会在我们业务库中创建一个undolog表，然后在需要分布式事务的地方增加@GlobalTransactional注解</p>\n<p>遇到的问题是调用方回滚了，但是被调方没有回滚，先是在配置上改了很多地方，补充了一些可能有影响的配置，没有解决。</p>\n<p>检查seata的lock表和业务库中是否添加了undolog表，确认没有问题</p>\n<p>检查TC TM RM之间的通信，发现没有问题，项目启动时发送的注册信息能够被接收到。</p>\n<p>查看RM的接收到的request header有没有transaction id，发现没有，那就有眉目了。</p>\n<p>查看TM发送的时候有没有放入transaction id， 我们用的是httpexchange的方式，发现这种方式没有被seata做自动拦截，导致没有放入transaction id。</p>\n<p>在webclient中添加一个filter将xid加入，成功解决问题！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StockWebClient</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> WebClient <span class=\"title\">webClient</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> WebClient.builder()</span><br><span class=\"line\">                .baseUrl(<span class=\"string\">&quot;http://localhost:8081&quot;</span>)</span><br><span class=\"line\">                .filter((request,next)-&gt;&#123;</span><br><span class=\"line\">                    String xid= RootContext.getXID();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(xid!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                        request= ClientRequest.from(request)</span><br><span class=\"line\">                                .header(RootContext.KEY_XID,xid)</span><br><span class=\"line\">                                .build();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> next.exchange(request);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> StockClient <span class=\"title\">stockClient</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        WebClientAdapter webClientAdapter = WebClientAdapter.create(webClient());</span><br><span class=\"line\">        HttpServiceProxyFactory httpServiceProxyFactory= HttpServiceProxyFactory</span><br><span class=\"line\">                .builderFor(webClientAdapter).build();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> httpServiceProxyFactory.createClient(StockClient.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"sql优化\"><a href=\"#sql优化\" class=\"headerlink\" title=\"sql优化\"></a>sql优化</h3><h4 id=\"四月数据和五月数据执行速度差几千倍\"><a href=\"#四月数据和五月数据执行速度差几千倍\" class=\"headerlink\" title=\"四月数据和五月数据执行速度差几千倍\"></a>四月数据和五月数据执行速度差几千倍</h4><p>今天优化了一条sql，四月数据和五月数据执行速度差几千倍，结果五月是走索引的，刷新还变慢了<br>强制让他不走所以才能正常运行? why？</p>\n<p>简单直接的回答是：因为五月份的数据分布发生了巨大变化，导致数据库陈旧的“统计信息”给出了错误的建议，让优化器选择了一个看似高效（走索引）实则极慢的执行路径。</p>\n<h5 id=\"核心原因：索引失效与“回表”成本\"><a href=\"#核心原因：索引失效与“回表”成本\" class=\"headerlink\" title=\"核心原因：索引失效与“回表”成本\"></a>核心原因：索引失效与“回表”成本</h5><p>数据库优化器在决定是否使用索引时，会依赖一个核心指标：索引选择性（Index Selectivity）。<br>什么是索引选择性？<br>一个索引的选择性越好，意味着通过索引能过滤掉的数据越多，定位到目标数据的速度就越快。比如在一个有100万条记录的表里，通过索引能直接定位到2条数据，那选择性就极好。<br>反之，如果通过索引找到了50万条数据，那选择性就很差。<br>“走索引”不一定快</p>\n<p>走索引通常包含两步：① 访问索引找到数据行的物理地址；② <strong>回表（Table Access）</strong>根据物理地址去主表里把完整的数据捞出来。</p>\n<p>如果索引选择性很好（只捞几条或几百条数据），那“访问索引 + 回表”的总成本远低于从头到尾扫描整个表的成本（全表扫描）。<br>但如果索引选择性很差（比如要捞出全表30%以上的数据），那么大量的“回表”操作（这是随机I&#x2F;O，很慢）会累加起来，总成本反而会远远超过一次性的“全表扫描”（这是顺序I&#x2F;O，相对快）。</p>\n<p>你的问题所在<br> 💡<br>四月的情况：你的查询条件在四月的数据里，可能选择性很好。比如查询’某个评级’的债券，四月份符合条件的很少，优化器正确地判断出走索引+回表很快。</p>\n<p>五月的情况：到了五月，数据分布可能发生了剧变。比如，因为市场波动，大量债券被调整到了你查询的’某个评级’。这时，符合条件的记录可能占了当月数据的30%、50%甚至更多。</p>\n<p>优化器的误判：问题是，优化器并不知道五月的数据分布变了！它依然根据陈旧的统计信息（可能还是基于四月或更早的数据生成的）进行估算，它“以为”符合条件的记录还像以前一样少，于是错误地决定继续走索引。</p>\n<p>结果：数据库执行了一个“访问索引 + 海量回表”的灾难性操作，速度自然极慢。而你强制它不走索引（FORCE INDEX(NULL)或类似语法），它只能进行全表扫描，反而因为避免了海量的随机I&#x2F;O而变快了。</p>\n<h5 id=\"结合债券数据库的特点分析\"><a href=\"#结合债券数据库的特点分析\" class=\"headerlink\" title=\"结合债券数据库的特点分析\"></a>结合债券数据库的特点分析</h5><p>为什么数据分布会在一个月内发生如此大的变化？这在债券数据库中非常常见：</p>\n<p><strong>集中发行&#x2F;到期</strong>：某个大型发行人（如国开行、大型企业）可能在五月集中发行了大量新债，导致按发行人、发行日期查询时，五月的数据量远超四月。</p>\n<p><strong>评级调整</strong>：评级机构可能在月底或月初进行集中调整，导致某个信用评级（如AAA或BB）的债券数量剧增或剧减。</p>\n<p><strong>状态变更</strong>：大量债券在某个时间点集中付息、到期或发生违约，导致按债券状态（如存续、已到期）查询时的数据分布完全不同。</p>\n<p><strong>月末效应</strong>：很多统计和交易行为有月末或季末效应，导致某些指标（如估值、流动性指标）在月末的数据特征与月中完全不同。</p>\n<h3 id=\"Springboot-related\"><a href=\"#Springboot-related\" class=\"headerlink\" title=\"Springboot related\"></a>Springboot related</h3><h4 id=\"springboot-特点\"><a href=\"#springboot-特点\" class=\"headerlink\" title=\"springboot 特点\"></a>springboot 特点</h4><ul>\n<li>自动配置</li>\n<li>内嵌一个Tomcat web服务器</li>\n<li>本身提供了很多starter来引入依赖，方便版本管理</li>\n<li>Actuator执行器API，可以通过一组API端点监控正在运行的程序</li>\n</ul>\n<h4 id=\"SpringBootApplication注解如何工作\"><a href=\"#SpringBootApplication注解如何工作\" class=\"headerlink\" title=\"@SpringBootApplication注解如何工作\"></a>@SpringBootApplication注解如何工作</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@SpringBootApplication = @ComponentScan + @EnableAutoConfiguration + @Configuration</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>@Configuration: 该注释类可以创建bean到IOC容器中</li>\n<li>@ComponentScan: 扫描启动类所在包及其子包所有包，帮助创建实例</li>\n<li>@EnableAutoConfiguration： 检测某些类并且自动配置他们</li>\n</ul>\n<h4 id=\"我们需要在哪里使用“-Qualifier”注解？\"><a href=\"#我们需要在哪里使用“-Qualifier”注解？\" class=\"headerlink\" title=\"我们需要在哪里使用“@Qualifier”注解？\"></a>我们需要在哪里使用“@Qualifier”注解？</h4><p>此注解用于专门告诉 Spring Boot 从其所有可用实现 bean 中获取特定类。@Qualifier注解与“ @Autowired”注解一起用于依赖注入。</p>\n<p>假设我们有1 个接口和 2 个不同的实现类。</p>\n<p>例如：UserService 接口 &#x3D;&gt; AdminUserService、StaffUserService 类</p>\n<h2 id=\"AI-related\"><a href=\"#AI-related\" class=\"headerlink\" title=\"AI-related\"></a>AI-related</h2><table>\n<thead>\n<tr>\n<th>概念</th>\n<th>解释</th>\n<th>面试答法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>State</strong></td>\n<td>全局共享状态，流程中所有节点都能读写。一般用 <code>TypedDict</code> 或 <code>pydantic</code> 定义字段类型。</td>\n<td>“State 就是 LangGraph 的‘记事本’，所有 Agent 都共享它。”</td>\n</tr>\n<tr>\n<td><strong>Node</strong></td>\n<td>流程的基本单元，可以是 LLM 调用、工具调用、数据处理等。</td>\n<td>“Node 就像流程图的一个圆圈，负责处理数据并更新状态。”</td>\n</tr>\n<tr>\n<td><strong>Edge</strong></td>\n<td>节点之间的连接路径。分为普通边和条件边（Conditional Edge）。</td>\n<td>“Edge 决定了流程怎么走，条件边就像 if…else 分支。”</td>\n</tr>\n<tr>\n<td><strong>Graph</strong></td>\n<td>由节点和边组成的整个流程，支持循环、分支、并行。</td>\n<td>“Graph 是整个应用的地图。”</td>\n</tr>\n<tr>\n<td><strong>Multi-Agent</strong></td>\n<td>多个 Agent 协作完成任务，每个 Agent 可能是一个节点或一个子图。</td>\n<td>“多 Agent 是 LangGraph 的强项。”</td>\n</tr>\n</tbody></table>\n<h3 id=\"在-LangGraph-中，StateGraph-和-MessageGraph-有何区别？请详细解释它们各自的应用场景，并说明选择哪种图类型主要取决于哪些因素。\"><a href=\"#在-LangGraph-中，StateGraph-和-MessageGraph-有何区别？请详细解释它们各自的应用场景，并说明选择哪种图类型主要取决于哪些因素。\" class=\"headerlink\" title=\"在 LangGraph 中，StateGraph 和 MessageGraph 有何区别？请详细解释它们各自的应用场景，并说明选择哪种图类型主要取决于哪些因素。\"></a>在 LangGraph 中，StateGraph 和 MessageGraph 有何区别？请详细解释它们各自的应用场景，并说明选择哪种图类型主要取决于哪些因素。</h3><p>在 LangGraph 中，StateGraph 和 MessageGraph 都用于定义工作流图，但它们在状态管理和输入&#x2F;输出处理方式上有所不同：</p>\n<ul>\n<li><p>StateGraph：<br>状态管理：StateGraph 使用一个明确定义的、可合并的（mergeable）状态对象作为图的全局状态。你需要定义一个 State 类（通常是一个 TypedDict 或 Pydantic 模型）来表示这个状态。每个节点接收当前的完整 State，并返回一个 PartialState 来更新它。这种更新是合并（merge）操作，而不是完全替换。<br>应用场景：<br>需要精细化控制和跟踪全局状态的复杂代理： 例如，一个多轮对话代理，需要跟踪用户意图、对话历史、已收集的实体、工具调用结果等。<br>需要多个节点协同修改同一组数据的场景： 例如，一个数据处理管道，多个步骤逐步丰富和转换一个中心数据结构。<br>调试和可观测性： 由于状态是显式的且可序列化的，更容易在每个节点执行前后检查和记录状态，便于调试和理解流程。<br>选择因素： 当你的代理或工作流需要维护一个结构化的、持续变化的、可共享的数据上下文时，StateGraph 是更优的选择。</p>\n</li>\n<li><p>MessageGraph：<br>状态管理：MessageGraph 是 StateGraph 的一个特化，它将状态隐式地处理为一系列消息（BaseMessage 对象）。每个节点接收一个消息列表作为输入（通常是最新的消息），并返回一个或多个消息作为输出，这些消息会自动添加到图的全局消息列表中。<br>应用场景：<br>基于消息的对话代理： 特别适合构建类似 LangChain AgentExecutor 的对话代理，其中核心交互是用户和AI之间通过消息进行的。<br>简单的请求-响应流： 当你只需要处理一系列的消息传递，而不需要一个复杂、多维度的全局状态时。<br>快速原型开发： 对于许多对话应用，MessageGraph 提供了更便捷的接口，因为它自动处理了消息的累积。<br>选择因素： 当你的代理或工作流主要围绕消息的生产、消费和累积展开时，MessageGraph 提供了更简洁、更符合直观的抽象。它在内部将消息列表包装在一个 State 对象中。<br>主要选择因素：</p>\n</li>\n<li><p>状态的复杂性： 如果你需要跟踪多个维度的信息，并且这些信息需要被多个节点协同修改，选择 StateGraph。如果核心是消息的传递和累积，MessageGraph 更合适。<br>交互模式： 如果是对话代理，MessageGraph 通常更自然。<br>调试需求：StateGraph 由于其显式状态，在调试复杂状态转换时可能提供更清晰的视角。<br>定制化程度：StateGraph 提供了更大的灵活性来定义任意复杂的状态结构。</p>\n</li>\n</ul>\n<h3 id=\"MCP\"><a href=\"#MCP\" class=\"headerlink\" title=\"MCP\"></a>MCP</h3><p>MCP（Model Context Protocol）构建了AI大模型与外部应用程序间的上下文交换规范，这使得AI开发者能够以一致的规范将各种实时数据源、AI工具和外接功能连接到AIGC大模型中，就像Type-C让不同设备能够通过相同的接口连接到主机一样。MCP的目标是创建一个通用标准，使 AI 应用程序的开发和集成变得更加简单和统一。</p>\n<p>MCP由三个核心组件构成：Host、Client 和 Server。让我们通过一个实际案例来理解这些组件如何协同工作：</p>\n<p>假设我们正在使用AI Agent询问：”帮我女朋友购买丝袜？”</p>\n<p>Host：AI Agent作为 Host，负责接收我们的提问并与其中的AIGC大模型交互。 </p>\n<p>Client：当AIGC大模型需要确定丝袜购买方案时，Host 中内置的 MCP Client 会被激活。这个 Client 负责与适当的 MCP Server 建立连接。 </p>\n<p>Server：在这个例子中，丝袜购买方案 MCP Server 会被调用。它负责执行实际的丝袜购买方案确定操作，访问对应的电商API，并返回找到的丝袜购买方案。</p>\n<p>整个流程是这样的：我们的问题 → AI Agent(Host) → AIGC大模型 → 需要丝袜购买信息 → MCP Client 连接 → 丝袜购买 MCP Server → 执行操作 → 返回结果 → AIGC大模型生成回答 → 显示在AI Agent上。</p>\n<p>这种架构设计使得AI Agent中的AIGC大模型可以在不同场景下灵活调用各种应用工具和数据源，而AIGC开发者只需专注于开发对应的 MCP Server，无需关心 Host 和 Client 的实现细节。</p>\n<p>function call解决了AIGC大模型与外部应用工具之间交互的问题；而MCP则在此基础上对交互的整个流程进行规范化，从而解决海量数据、AIGC大模型、AI应用工具之间的“孤岛”问题。</p>\n<h3 id=\"RAG\"><a href=\"#RAG\" class=\"headerlink\" title=\"RAG\"></a>RAG</h3><h4 id=\"文本分割\"><a href=\"#文本分割\" class=\"headerlink\" title=\"文本分割\"></a>文本分割</h4><p>先按段落&#x2F;标题切（保证语义完整）</p>\n<p>再在长段落内用滑动窗口二次切分（避免过长）。</p>\n<p>常见设置：</p>\n<p>chunk_size &#x3D; 500 tokens</p>\n<p>chunk_overlap &#x3D; 50–100 tokens</p>\n<h4 id=\"显存问题\"><a href=\"#显存问题\" class=\"headerlink\" title=\"显存问题\"></a>显存问题</h4><ol>\n<li>Embedding 阶段</li>\n</ol>\n<p>  问题：</p>\n<p>  使用大型 Embedding 模型（比如 text-embedding-ada-002 本地化部署，或者 BERT&#x2F;SimCSE）时，批量文本分割太大 → 占用显存过高，容易 OOM。</p>\n<p>  向量维度过高（768, 1024+），批量处理时显存压力大。</p>\n<p>  优化：</p>\n<p>  控制 batch size（比如 32 → 8）；</p>\n<p>  考虑使用量化（FP16&#x2F;INT8）；</p>\n<p>  使用 CPU 或混合计算做 embedding（显存压力小，但牺牲速度）。</p>\n<p>  e.g.</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">  &lt;!-- 使用推理框架自带的参数设置 --&gt;</span><br><span class=\"line\"><span class=\"keyword\">from</span> transformers <span class=\"keyword\">import</span> AutoModelForCausalLM, AutoTokenizer</span><br><span class=\"line\"></span><br><span class=\"line\">model = AutoModelForCausalLM.from_pretrained(</span><br><span class=\"line\">    <span class=\"string\">&quot;meta-llama/Llama-2-7b-hf&quot;</span>,</span><br><span class=\"line\">    torch_dtype=<span class=\"string\">&quot;torch.float16&quot;</span>,   <span class=\"comment\"># FP16 推理</span></span><br><span class=\"line\">    device_map=<span class=\"string\">&quot;auto&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 或者使用量化库 --&gt;</span><br><span class=\"line\"><span class=\"keyword\">from</span> transformers <span class=\"keyword\">import</span> AutoModelForCausalLM, AutoTokenizer, BitsAndBytesConfig</span><br><span class=\"line\"></span><br><span class=\"line\">bnb_config = BitsAndBytesConfig(</span><br><span class=\"line\">    load_in_4bit=<span class=\"literal\">True</span>,</span><br><span class=\"line\">    bnb_4bit_compute_dtype=<span class=\"string\">&quot;float16&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">model = AutoModelForCausalLM.from_pretrained(</span><br><span class=\"line\">    <span class=\"string\">&quot;meta-llama/Llama-2-7b-hf&quot;</span>,</span><br><span class=\"line\">    quantization_config=bnb_config,</span><br><span class=\"line\">    device_map=<span class=\"string\">&quot;auto&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>检索阶段</li>\n</ol>\n<p>  问题：</p>\n<p>  使用 向量数据库在 GPU 上做 ANN 检索（如 FAISS GPU 版、Milvus GPU 索引），如果数据量大（百万级别以上），向量索引会吃掉大量显存。</p>\n<p>  embedding 全部放 GPU 显存，超大规模语料会直接爆显存。</p>\n<p>  优化：</p>\n<p>  使用 CPU 索引（FAISS IVFFlat &#x2F; HNSW），只在关键场景用 GPU。</p>\n<p>  向量量化（PQ &#x2F; OPQ &#x2F; IVF-PQ）降低存储成本。</p>\n<p>  分层存储：热门向量在 GPU，冷门向量在 CPU&#x2F;磁盘。</p>\n<p>检索优化思路</p>\n<p>  (1) 选择合适的索引类型</p>\n<p>IVF_FLAT：倒排索引，先分簇再精确搜索。适合百万级数据，查询比 brute-force 快很多。</p>\n<p>IVF_PQ：倒排 + 乘积量化 (Product Quantization)，存储占用大幅减少，速度快，但精度略有下降。适合大规模（亿级）。</p>\n<p>HNSW：基于图的近邻搜索，高精度 + 高查询性能，内存消耗较大，适合延迟敏感的应用。</p>\n<p>DISKANN：磁盘友好型索引，适合超大规模数据（上亿向量），用磁盘做近似搜索，节省内存。</p>\n<p>Milvus里常用的量化方法有：</p>\n<p>PQ (Product Quantization)</p>\n<p>把向量切成多个子空间，每个子空间做 k-means 聚类，用“簇中心 ID”代替真实值。</p>\n<p>存储占用从几十字节 → 几个字节，大大减少内存。</p>\n<p>代价：检索精度下降。</p>\n<p>OPQ (Optimized PQ)</p>\n<p>PQ 的改进版本，先做旋转变换再分块，能提高精度。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 创建索引 --&gt;</span><br><span class=\"line\"><span class=\"keyword\">from</span> pymilvus <span class=\"keyword\">import</span> Collection</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 假设已经有一个 collection</span></span><br><span class=\"line\">collection = Collection(<span class=\"string\">&quot;example_collection&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">index_params = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;index_type&quot;</span>: <span class=\"string\">&quot;IVF_PQ&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;metric_type&quot;</span>: <span class=\"string\">&quot;L2&quot;</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;params&quot;</span>: &#123;<span class=\"string\">&quot;nlist&quot;</span>: <span class=\"number\">1024</span>, <span class=\"string\">&quot;m&quot;</span>: <span class=\"number\">16</span>&#125;  <span class=\"comment\"># nlist=聚类数, m=PQ子空间数</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">collection.create_index(field_name=<span class=\"string\">&quot;embedding&quot;</span>, index_params=index_params)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- 检索时设置探测簇数量 --&gt;</span><br><span class=\"line\">search_params = &#123;<span class=\"string\">&quot;nprobe&quot;</span>: <span class=\"number\">16</span>&#125;</span><br><span class=\"line\">results = collection.search(</span><br><span class=\"line\">    data=[query_vector],</span><br><span class=\"line\">    anns_field=<span class=\"string\">&quot;embedding&quot;</span>,</span><br><span class=\"line\">    param=search_params,</span><br><span class=\"line\">    limit=<span class=\"number\">10</span>,</span><br><span class=\"line\">    expr=<span class=\"literal\">None</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>大模型推理阶段</li>\n</ol>\n<p>  问题：</p>\n<p>  上下文窗口大（比如 32K&#x2F;100K tokens），拼接后输入序列过长 → 显存爆炸。</p>\n<p>  多用户并发请求，多个 prompt 一起推理 → 显存不足。</p>\n<p>  模型本身体量大（7B&#x2F;13B&#x2F;70B），部署时 GPU 显存根本放不下。</p>\n<p>  优化：</p>\n<p>  分片 &#x2F; ZeRO &#x2F; tensor parallelism：多卡切分模型。</p>\n<p>  量化 (4bit&#x2F;8bit)：大幅降低显存需求（13B 模型从 ~30GB → ~8GB）。</p>\n<p>  动态 Batching：用 vLLM&#x2F;Triton，把多个请求合并推理，提升显存利用率。</p>\n<p>  上下文压缩：对长文本做摘要&#x2F;embedding 检索后截断，只保留最相关内容。</p>\n<h3 id=\"封装模型推理API服务？性能优化？\"><a href=\"#封装模型推理API服务？性能优化？\" class=\"headerlink\" title=\"封装模型推理API服务？性能优化？\"></a>封装模型推理API服务？性能优化？</h3><ol>\n<li>API 服务封装思路</li>\n</ol>\n<p>框架选择<br>常用的 Web 框架有 Spring Boot &#x2F; gRPC，根据场景选择：</p>\n<p>REST API：方便业务系统调用；</p>\n<p>gRPC：低延迟，适合高并发推理服务。</p>\n<p>接口设计</p>\n<p>输入：用户问题 &#x2F; 上下文参数；</p>\n<p>输出：模型预测结果（支持流式响应 Streaming，比如逐token返回，提升交互体验）。</p>\n<p>服务结构</p>\n<p>请求处理层：负责鉴权、限流、负载均衡；</p>\n<p>推理调度层：调用模型推理逻辑；</p>\n<p>缓存层：热门 query 结果缓存；</p>\n<p>监控层：Prometheus + Grafana，监控 QPS、延迟、失败率。</p>\n<h3 id=\"常见面试问题\"><a href=\"#常见面试问题\" class=\"headerlink\" title=\"常见面试问题\"></a>常见面试问题</h3><ul>\n<li>如何维护Chatbot的对话历史</li>\n</ul>\n<p>聊天记录部分：</p>\n<p>完整记录每次用户输入的提问和AI返回的回答，用于界面上展示</p>\n<p>记忆部分：</p>\n<ol>\n<li>短期记忆：维护最近10条记忆作为短期记忆</li>\n<li>长期记忆：对十条记忆之外的记忆做摘要，存入Milvus中，并且在用户信息发来之后做检索，找出最接近的一条作为记忆</li>\n</ol>\n<ul>\n<li>AI搜索和ElasticSearch的区别？怎么设计一个AI搜索</li>\n</ul>\n<p>ElasticSearch：</p>\n<p>把文档拆分成关键词（Token），每个词对应一个 posting list，里面记录出现在哪些文档，查询时使用关键词匹配，返回相似度最高的结果</p>\n<p>性能高，适合大规模的数据搜索。</p>\n<p>AISearch:</p>\n<p>把文本转成向量（embedding），存入向量数据库（如 Milvus、PGVector）。查询时把问题转成向量，计算语义相似度（cosine &#x2F; dot product）。</p>\n<p>语义理解能力强，可以与知识库结合，适合人机交互场景</p>\n<p>设计一个AI搜索：</p>\n<ol>\n<li>数据存储：文档存到ElasticSearch同时把文档做embedding存到向量数据库</li>\n<li>查询流程：用户输入做embedding，向量数据库检索k条，elasticsearch检索关键词匹配结果，对两者做一个甲醛排序，得到权重最高的k结果</li>\n<li>答案生成：把这k条结果拼接到prompt，发送给LLM</li>\n<li>优点：混合搜索既能保证准确性也能保证相关性</li>\n</ol>\n<ul>\n<li>怎么保证回答是 准确的、可溯源的？</li>\n</ul>\n<p>引入RAG保证回答可靠可溯源，把检索到的内容发送给大模型，让模型严格按照这个回答，来保证准确性；检索结果附带来源信息（文档 ID &#x2F; URL），模型生成答案时带上引用，保证可溯源；</p>\n<p>同时对用户问题和模型生成结果做完整的日志。</p>\n<ul>\n<li>你知道 RAG 的基本流程吗？怎么实现？<br>RAG 的基本流程是：</li>\n</ul>\n<p>用户问题 → embedding 向量化</p>\n<p>向量数据库检索 topK 文档 → 获取文档内容 + 元信息</p>\n<p>将检索到的文档拼接到 Prompt</p>\n<p>LLM 生成答案，同时可以引用来源</p>\n<p>返回给用户</p>\n<p>企业级实现中，通常会做文档 chunking、短期记忆管理、检索 + 排序优化，以及日志记录，保证答案既准确又可溯源。</p>\n<ul>\n<li>如果文档很大，你会怎么处理？</li>\n</ul>\n<ol>\n<li>文档预处理：</li>\n</ol>\n<p>将文档按照语义切分成小块，对每个chunk单独生成向量表示，并且带上元数据存储到milvus中</p>\n<ol start=\"2\">\n<li>检索策略：</li>\n</ol>\n<p>用户问题embedding，检索topk，返回chunk的原文和metadata</p>\n<ol start=\"3\">\n<li>prompt构建：</li>\n</ol>\n<p>拼接检索结果，选出最相关的chunk，聊天记忆和用户问题</p>\n<ul>\n<li>文档分割方法有哪些</li>\n</ul>\n<ol>\n<li><p>基于自然边界的分割（最推荐）</p>\n</li>\n<li><p>基于句子或固定 Token 长度的分割</p>\n</li>\n<li><p>基于语义相似度的智能分割（高阶方案）</p>\n</li>\n</ol>\n<p>根据相邻句子间的embedding的相似度来判断是否需要切割，相似度较低表示需要切割。</p>\n<p>企业中的实际切割方式</p>\n<ol>\n<li><p>文档解析与清理： 使用强大的解析库从PDF、Word、HTML等格式中提取纯文本和结构元数据（标题、列表等）。</p>\n</li>\n<li><p>结构分析： 识别文档的层次结构（标题等级、章节）。</p>\n</li>\n<li><p>递归分割为主： 采用基于递归分割的策略，优先使用 \\n\\n，然后是 \\n，最后是句子结束符，并严格设定块的大小上限（例如512或1024个token）。</p>\n</li>\n<li><p>强制重叠： 对所有最终生成的块应用重叠设置，重叠比例通常是块大小的10%-20%。</p>\n</li>\n<li><p>可选的后处理： 对过小的块进行合并（如合并连续的图片标题），或使用模型对块的质量进行过滤和排序。</p>\n</li>\n</ol>\n<ul>\n<li>你觉得多模态 AI 的实际应用场景有哪些？</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th>描述</th>\n<th>技术点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>智能客服</td>\n<td>用户上传产品图片 + 问题，AI识别图片并回答</td>\n<td>图像识别 + 文本生成</td>\n</tr>\n<tr>\n<td>电商推荐</td>\n<td>跨模态检索：用户上传图片 → 推荐相似商品</td>\n<td>Embedding + RAG</td>\n</tr>\n<tr>\n<td>财务智能分析</td>\n<td>扫描合同&#x2F;报表 → 提取信息 → 问答</td>\n<td>OCR + 文本理解 + 多模态检索</td>\n</tr>\n<tr>\n<td>内容创作</td>\n<td>文本描述生成插图或视频片段</td>\n<td>文本→图像生成、文本→视频生成</td>\n</tr>\n<tr>\n<td>医疗辅助</td>\n<td>医学影像 + 临床记录 → 诊断建议</td>\n<td>图像 + 文本多模态分析</td>\n</tr>\n</tbody></table>\n<ul>\n<li>如何控制高并发情况下的大模型的访问？</li>\n</ul>\n<p>大模型的部署使用Triton的方式，并在triton服务器上启动一个后端服务，接收文本-&gt;转成token-&gt;发送到大模型-&gt;返回token-&gt;转成文本</p>\n<ul>\n<li><p>技术上怎么把语音、图片接入到 AI 应用？</p>\n</li>\n<li><p>多模态Embedding，图文对齐了解吗</p>\n</li>\n<li><p>设计异步、高并发的问答系统</p>\n</li>\n</ul>\n<p>Semaphore 用来限制同一时间段内正在进行的模型调用数。在发起模型推理前 acquire()，推理完成或出错后 release()。对于异步&#x2F;反应式系统要注意不要在 Reactor&#x2F;NIO 事件循环中直接阻塞，应把阻塞调用放到 boundedElastic 或线程池。</p>\n<ul>\n<li>用于RAG的数据格式是什么，多少数据量，如何数据清洗？</li>\n</ul>\n<p>数据有三类：</p>\n<p>内部制度：公司风控手册、合规政策、内部审计规范；</p>\n<p>监管法规：不止美联储，还包括 SEC、FINRA、CFPB、OCC 等美国监管机构的公开规定；</p>\n<p>业务文档：风控系统操作说明书、内部培训材料；</p>\n<p>文档清洗：</p>\n<p>（1）文本提取</p>\n<p>PDF&#x2F;Word&#x2F;Excel → 统一转成纯文本；</p>\n<p>去除页眉页脚、目录、图片说明等“噪音”；</p>\n<p>对表格类内容，考虑结构化保存。</p>\n<p>（2）分块（Chunking）</p>\n<p>常用做法：每 5001000 tokens 一块，带 100200 tokens overlap，保证上下文完整；</p>\n<p>法规类文档适合按 章节、条款 切分，而不是机械按字数。</p>\n<p>（3）标准化 &amp; 清洗</p>\n<p>去除重复段落；</p>\n<p>正则清理掉多余符号、乱码；</p>\n<p>保留原始来源（加上 document_id + section_id，用于回答溯源）。</p>\n<ul>\n<li>Rerank缓存结果保存</li>\n</ul>\n<p>key &#x3D; SHA256(normalize(query) + “|” + sortedCandidateIds + “|” + rerankerModelVersion + “|” + docVersionsHash)</p>\n<p>value&#x3D; rankedDocIds</p>\n<ul>\n<li>CohereRerank</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;Document&gt; candidates = vectorRetriever.retrieve(query, <span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;ScoredDocument&gt; reranked = candidates.stream()</span><br><span class=\"line\">    .map(doc -&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> score = callCohereRerankAPI(query, doc.getContent());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ScoredDocument(doc, score);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .sorted(Comparator.comparingDouble(ScoredDocument::getScore).reversed())</span><br><span class=\"line\">    .collect(Collectors.toList());</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>高并发访问大模型解决方案</li>\n</ul>\n<ol>\n<li>用 Semaphore 或线程池控制并发，比如最大允许 8 个并发请求，其他排队。</li>\n<li>模型量化到(fp16&#x2F;int8)做推理</li>\n<li>batch处理用户请求</li>\n</ol>\n<ul>\n<li>LLM Agent的性能评估</li>\n</ul>\n<ol>\n<li>功能正确性（Functional Correctness）：Agent 是否能完成设计任务，比如回答问题、执行工具调用、完成工作流。</li>\n<li>Agent 的内部思考逻辑是否合理、连贯：log 追踪 Thought → Action → Observation</li>\n<li>多轮交互能力（Dialog &#x2F; Multi-turn Performance）：在连续对话或多步任务中保持上下文和状态</li>\n<li>工具调用效率：Agent 调用工具的效率和成功率</li>\n<li>用户体验（UX &#x2F; Human Evaluation）：最终用户的感受</li>\n</ol>\n","categories":["面试"],"tags":["kafka java redis"]},{"title":"实际面试问题","url":"/2025/06/13/%E5%AE%9E%E9%99%85%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/","content":"<h2 id=\"自我介绍\"><a href=\"#自我介绍\" class=\"headerlink\" title=\"自我介绍\"></a>自我介绍</h2><p>Hello, thank you for giving me this opportunity to introduce myself.</p>\n<p>My name is Qingyong, and I graduated with a degree in software engineering from Shanghai University. I have a solid foundation in software development, and I am passionate about applying my skills in OOCL.</p>\n<p>In my previous role at Citibank, I worked on MCA, namely Managers’ Control Assessment. My daily work involved using technologies such as Java, Spring Boot, Kafka, and MySQL to build and maintain scalable backend services. I enjoy solving practical problems and continuously improving processes.</p>\n<p>I am particularly interested in OOCL because of its global presence, innovative use of technology, and commitment to operational excellence. I believe my background and enthusiasm align well with your company’s culture and vision.</p>\n<p>I am excited about the possibility of contributing to your team and growing together with OOCL. Thank you for your time and consideration.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"blbl\"><a href=\"#blbl\" class=\"headerlink\" title=\"blbl\"></a>blbl</h2><ol>\n<li>实习拷打（10 分钟）</li>\n<li>线上 OOM 如何排查？</li>\n<li>Go 如何实现并发安全 Map？</li>\n<li>Go 与 Java &#x2F; C++ 区别？</li>\n<li>Go GC 机制</li>\n<li>微服务与 DDD 的理解</li>\n<li>MySQL 慢查询如何排查？</li>\n<li>QPS 飙高，接口需要做哪些优化？</li>\n<li>数据库如何扛住高并发请求？</li>\n<li>如何保存缓存数据库强一致性?</li>\n<li>MQ 消息堆积如何解决？</li>\n<li>Kafka 消费组和分区的关系</li>\n<li>如何保证消息有序？</li>\n<li>Go UT 有什么原则？</li>\n<li>内部单测包，怎么用，什么原理？</li>\n<li>AI 辅助编程看法</li>\n<li>算法题：Leetcode 143. 重排链表</li>\n</ol>\n<h2 id=\"兴业数金\"><a href=\"#兴业数金\" class=\"headerlink\" title=\"兴业数金\"></a>兴业数金</h2><ul>\n<li>OracleDB的分页查询</li>\n<li>Linux查看log命令</li>\n<li>Mybatis防止sql注入</li>\n<li>慢sql怎么分析？哪些情况导致索引失效？</li>\n<li>自动装箱&#x2F;拆箱</li>\n<li>redis缓存更新</li>\n</ul>\n<h2 id=\"新婆罗昌\"><a href=\"#新婆罗昌\" class=\"headerlink\" title=\"新婆罗昌\"></a>新婆罗昌</h2><h2 id=\"华美海润\"><a href=\"#华美海润\" class=\"headerlink\" title=\"华美海润\"></a>华美海润</h2><ul>\n<li>复杂表格怎么做成RAG</li>\n</ul>\n<p>使用LlamaParser来对PDf进行读取和解析，解析成MarkDown，切割文档时，除了要embedding切割和递归切割之外，还要用正则匹配的方式确保markdown中的表格名称不会被切割开</p>\n<ul>\n<li>embedding查询的召回率怎么验证的</li>\n</ul>\n<p>MRR和Recall@1,3,5来验证召回率:</p>\n<ul>\n<li>MRR就是<code>1/(1+rankIndex)</code>，针对一个问题一个答案的情况 rankIndex就是答案在检索到的内容中的排名</li>\n<li>recall@1,3,5就是<code>R&amp;H/R</code>, 针对一个问题多个答案的情况，就是比如答案有5个，R&#x3D;5,H&#x3D;检索内容的数量，R&amp;H就是检索内容中正确答案的数量，然后对三个召回率求平均就是平均召回率</li>\n</ul>\n<p>MRR&gt;0.7, reacll&gt;0.8</p>\n<h2 id=\"EATON\"><a href=\"#EATON\" class=\"headerlink\" title=\"EATON\"></a>EATON</h2><ul>\n<li><p>Spring常用的注入方式</p>\n</li>\n<li><p>多线程避免死锁</p>\n</li>\n</ul>\n<h2 id=\"Rakuten\"><a href=\"#Rakuten\" class=\"headerlink\" title=\"Rakuten\"></a>Rakuten</h2><ul>\n<li>介绍一下HTTP</li>\n</ul>\n<p>无状态的基于请求-相应模式的协议，基于TCP传输协议，支持明文传输（HTTP）和加密传输（HTTPS），HTTPS 在 HTTP 之上加入了 TLS&#x2F;SSL 层，提供了数据加密和身份认证。</p>\n<ul>\n<li>OSI模型第四层和第七层有什么协议</li>\n</ul>\n<p>第四层（传输层）：提供端到端的数据传输服务，控制数据的可靠性、顺序、流量、错误恢复等，建立主机间的连接或无连接通信。常见协议有：TCP，UDP</p>\n<p>第七层（应用层）：直接面向用户，为用户应用程序提供服务，定义数据格式、编码、对话控制、认证等。常见协议有：HTTP&#x2F;HTTPS，FTP&#x2F;SFTP，SMTP&#x2F;POP3&#x2F;IMAP，DNS，SSH</p>\n<ul>\n<li>HTTP1.0和HTTP1.1的区别</li>\n</ul>\n<p>HTTP&#x2F;1.0：每个请求都建立新连接 ➜ 性能差；</p>\n<p>HTTP&#x2F;1.1：</p>\n<p>支持长连接和复用连接；</p>\n<p>增强缓存机制；</p>\n<p>支持更多请求方法；</p>\n<p>支持虚拟主机（Host 字段）；</p>\n<p>性能比 HTTP&#x2F;1.0 提升明显。</p>\n<ul>\n<li>TTL（Time to Live）是什么</li>\n</ul>\n<p>TTL 的全称是 Time To Live，直译为“生存时间”或“存活时间”，在不同的技术场景中含义略有不同，但核心都是 “一个数据存在多久” 的概念。</p>\n<ol>\n<li>网络传输中的 TTL（IP 数据包）</li>\n</ol>\n<p>含义：一个 IP 数据包能经过多少个路由器（跳数）；</p>\n<p>作用：防止数据包在网络中无限循环。</p>\n<p>实现方式：</p>\n<p>初始由发送端设置（如 64）；</p>\n<p>每经过一个路由器，TTL 减 1；</p>\n<p>TTL 减到 0 就会被丢弃。</p>\n<ul>\n<li>TLS是什么</li>\n</ul>\n<p>TLS 的全称是 Transport Layer Security（传输层安全协议），是一种用来保障网络通信安全的协议，是现在互联网上最常用的安全通信基础，尤其是 HTTPS 的核心组成部分。</p>\n<table>\n<thead>\n<tr>\n<th>能力</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>加密</strong></td>\n<td>数据传输过程是加密的，别人截取也看不懂。</td>\n</tr>\n<tr>\n<td><strong>认证</strong></td>\n<td>确保对方身份真实（服务器有合法证书）。</td>\n</tr>\n<tr>\n<td><strong>完整性校验</strong></td>\n<td>保证数据没被篡改，有校验机制检测中途篡改的内容。</td>\n</tr>\n</tbody></table>\n<p><strong>举个例子：访问 <a href=\"https://example.com/\">https://example.com</a></strong></p>\n<p>浏览器请求服务器；</p>\n<p>服务器返回 TLS 证书（通常由权威 CA 签发）；</p>\n<p>浏览器验证证书合法性（未过期、域名匹配、信任链）；</p>\n<p>双方通过 密钥协商（握手），生成对称加密密钥；</p>\n<p>之后通信内容就通过这个密钥加密传输了，别人看不到内容。</p>\n<p><strong>TLS 用在哪里？</strong></p>\n<p>HTTPS（加密的 HTTP，TLS 是其安全核心）；</p>\n<p>邮件服务（如 SMTP over TLS）；</p>\n<p>数据库连接（如 MySQL TLS）；</p>\n<p>API 调用、安全传输协议（如 gRPC、MQTT）；</p>\n<p>VPN 加密通道等。</p>\n<p><strong>TLS 的组成模块（简要）：</strong></p>\n<p>对称加密：AES、ChaCha20 等，加密通信内容；</p>\n<p>非对称加密：RSA、ECDSA，用于身份认证与密钥交换；</p>\n<p>哈希函数：SHA256、SHA384，确保消息完整性；</p>\n<p>数字证书：由 CA 机构颁发，用于身份验证。</p>\n<ul>\n<li>TCP UDP区别</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>TCP</th>\n<th>UDP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>是否连接</strong></td>\n<td>面向连接（三次握手）</td>\n<td>无连接</td>\n</tr>\n<tr>\n<td><strong>是否可靠</strong></td>\n<td>可靠（有确认应答、重传机制）</td>\n<td>不可靠（丢了就丢了）</td>\n</tr>\n<tr>\n<td><strong>数据传输顺序</strong></td>\n<td>有序传输（数据按顺序到达）</td>\n<td>无序（可能乱序到达）</td>\n</tr>\n<tr>\n<td><strong>流量控制</strong></td>\n<td>有（根据接收端能力调整发送速度）</td>\n<td>无</td>\n</tr>\n<tr>\n<td><strong>拥塞控制</strong></td>\n<td>有（如慢开始、拥塞避免）</td>\n<td>无</td>\n</tr>\n<tr>\n<td><strong>传输效率</strong></td>\n<td>慢一些，但更安全可靠</td>\n<td>快，适用于实时性高的场景</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>对可靠性要求高的应用（如文件传输）</td>\n<td>对实时性要求高的应用（如视频、语音）</td>\n</tr>\n<tr>\n<td><strong>首部开销</strong></td>\n<td>大（20字节）</td>\n<td>小（8字节）</td>\n</tr>\n</tbody></table>\n<ul>\n<li>Redis你在项目里是怎么用的</li>\n</ul>\n<p>缓存热点数据：由于我们项目获取用户的信息需要从另一个服务中调取，同时每个用户的部门之间存在的上下级关系，导致获取一个用户的权限的approver需要较复杂的连表和filter操作。我们将用户id对应的能够审核其请求的用户id记录在redis中。</p>\n<p>Session &#x2F; Token 缓存</p>\n<p>使用场景：用户登录态管理、OAuth token 存储。<br>实现方式：存储用户信息并设置过期时间，或使用 JWT 搭配 Redis 存储黑名单。</p>\n<ul>\n<li>Redis复制方式</li>\n</ul>\n<ol>\n<li>启动复制（初次同步）<br>当你配置一个从节点连接主节点（使用 replicaof 命令或配置项）时，发生如下步骤：</li>\n</ol>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">1. 从节点发送 PSYNC 命令给主节点；</span><br><span class=\"line\">2. 主节点执行 bgsave 创建 RDB 快照；</span><br><span class=\"line\">3. 主节点将快照发送给从节点；</span><br><span class=\"line\">4. 主节点在生成快照期间的写命令会缓存在内存中；</span><br><span class=\"line\">5. 从节点加载快照后，主节点发送缓存的写命令；</span><br><span class=\"line\">6. 主从节点保持连接，主节点继续将新的写命令发送给从节点。</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>增量复制</li>\n</ol>\n<p>如果主从连接断开后重连，Redis 尝试使用 PSYNC 协议进行增量复制：<br>Redis 会通过 复制偏移量 与 复制积压缓冲区 来判断是否能从断点继续同步。如果可以，则只同步丢失的数据（高效）。如果偏移量太旧，就回退到全量复制。</p>\n<ul>\n<li>为什么想加入我们公司<br>I am very interested in joining Rakuten Institute of Technology because of its strong focus on technological innovation and its influence as part of a global internet company. I was impressed by the company’s emphasis on R&amp;D in areas like AI, data science, and scalable systems, which aligns well with both my academic background and professional experience.</li>\n</ul>\n<p>I previously worked at Citi, where I participated in the development of enterprise-level risk control systems using Java, Spring Boot, Kafka, and Redis, and I’m confident that these experiences will allow me to contribute effectively in your development team.</p>\n<p>Additionally, I appreciate the opportunity to work in an international and collaborative environment like Rakuten’s, which would allow me to grow both technically and culturally. I look forward to being part of a company that values innovation, performance, and continuous improvement.</p>\n<p>我希望加入乐天创研（上海），一方面是因为贵公司作为全球领先互联网企业的技术研发部门，非常注重前沿技术的探索与创新，尤其在人工智能、数据技术和大规模系统架构方面的投入让我非常钦佩，也和我未来的发展方向高度一致。</p>\n<p>此前我在花旗参与了多个企业级系统的开发工作，熟悉 Java、Spring Boot、Kafka、Redis 等后端技术栈，积累了扎实的微服务开发与系统集成经验，我相信这些都可以为贵公司的研发工作带来价值。</p>\n<p>此外，乐天倡导开放、协作的国际化研发氛围，对于我来说不仅能技术成长，也能增强跨文化的沟通与协作能力。我期待在这样一个注重创新与实践的平台中不断提升自己，也为公司创造更多价值。</p>\n<ul>\n<li>现在的项目用的是Java几？有使用相关的特性吗？</li>\n</ul>\n<p>String类型的变量可以调用新的方法</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>isBlank()</code></td>\n<td>判断是否是空白（包含空字符串和只含空格）</td>\n</tr>\n<tr>\n<td><code>lines()</code></td>\n<td>按行拆分字符串，返回 Stream</td>\n</tr>\n<tr>\n<td><code>strip() / stripLeading() / stripTrailing()</code></td>\n<td>替代 <code>trim()</code>，支持 Unicode</td>\n</tr>\n<tr>\n<td><code>repeat(int count)</code></td>\n<td>将字符串重复指定次数</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot; hello &quot;.strip();        // &quot;hello&quot;</span><br><span class=\"line\">&quot;abc\\nxyz&quot;.lines().count();  // 2</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Stream用过吗?有哪些特性?怎么用的?</li>\n</ul>\n<p>主要特性</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>声明式编程</strong></td>\n<td>通过链式调用表达业务逻辑，避免显式循环</td>\n</tr>\n<tr>\n<td><strong>惰性求值</strong></td>\n<td>中间操作不会立即执行，只有遇到终止操作才会触发执行</td>\n</tr>\n<tr>\n<td><strong>链式调用</strong></td>\n<td>多个操作可以组合在一起</td>\n</tr>\n<tr>\n<td><strong>非存储性</strong></td>\n<td>不会存储数据，只是对数据的“视图”</td>\n</tr>\n<tr>\n<td><strong>可并行性</strong></td>\n<td>支持并行流 <code>parallelStream()</code>，提高处理性能（适用于大数据量）</td>\n</tr>\n</tbody></table>\n<p>常用操作</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>filter(Predicate)</code></td>\n<td>过滤元素</td>\n</tr>\n<tr>\n<td><code>map(Function)</code></td>\n<td>映射每个元素</td>\n</tr>\n<tr>\n<td><code>distinct()</code></td>\n<td>去重</td>\n</tr>\n<tr>\n<td><code>sorted()</code> &#x2F; <code>sorted(Comparator)</code></td>\n<td>排序</td>\n</tr>\n<tr>\n<td><code>limit(n)</code> &#x2F; <code>skip(n)</code></td>\n<td>截断 &#x2F; 跳过</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>filter(Predicate)</code></td>\n<td>过滤元素</td>\n</tr>\n<tr>\n<td><code>map(Function)</code></td>\n<td>映射每个元素</td>\n</tr>\n<tr>\n<td><code>distinct()</code></td>\n<td>去重</td>\n</tr>\n<tr>\n<td><code>sorted()</code> &#x2F; <code>sorted(Comparator)</code></td>\n<td>排序</td>\n</tr>\n<tr>\n<td><code>limit(n)</code> &#x2F; <code>skip(n)</code></td>\n<td>截断 &#x2F; 跳过</td>\n</tr>\n</tbody></table>\n<ul>\n<li>Spring有哪些特性？（解释IOC和AOP）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>IOC（控制反转）</strong></td>\n<td>由 Spring 容器管理对象的创建与依赖注入</td>\n</tr>\n<tr>\n<td><strong>AOP（面向切面编程）</strong></td>\n<td>允许将通用功能（如日志、安全、事务）从业务逻辑中分离出来</td>\n</tr>\n<tr>\n<td><strong>声明式事务管理</strong></td>\n<td>通过注解或 XML 统一管理事务逻辑</td>\n</tr>\n</tbody></table>\n<p>IoC 是一种思想，指的是 将对象的创建与依赖关系的管理权从代码本身“反转”给框架（如 Spring 容器）来处理。</p>\n<p>IoC 的优点</p>\n<p>降低耦合：类之间无需关心彼此如何构造；</p>\n<p>提升可测试性：方便 mock 替换；</p>\n<p>增强可维护性：依赖关系集中管理；</p>\n<p>灵活配置：通过配置文件或注解动态改变注入行为。</p>\n<table>\n<thead>\n<tr>\n<th>方式</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>构造方法注入</td>\n<td>通过构造器传入依赖</td>\n<td><code>@Autowired public A(B b)</code></td>\n</tr>\n<tr>\n<td>Setter 方法注入</td>\n<td>通过 setter 方法注入</td>\n<td><code>@Autowired public void setB(B b)</code></td>\n</tr>\n<tr>\n<td>属性注入</td>\n<td>直接在字段上注入依赖</td>\n<td><code>@Autowired private B b;</code></td>\n</tr>\n</tbody></table>\n<p>AOP 通过在不修改原有代码的基础上，在方法调用的“前后”动态插入额外逻辑（称为“切面”）。</p>\n<p>Spring 的 AOP 基于：</p>\n<p>JDK 动态代理（如果目标类实现了接口）</p>\n<p>CGLIB 字节码生成技术（如果目标类没有接口）</p>\n<table>\n<thead>\n<tr>\n<th>概念</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>切面（Aspect）</strong></td>\n<td>通用功能模块，如日志切面</td>\n</tr>\n<tr>\n<td><strong>连接点（Join Point）</strong></td>\n<td>程序执行的某个点，如方法调用</td>\n</tr>\n<tr>\n<td><strong>通知（Advice）</strong></td>\n<td>在连接点执行的操作，如前置&#x2F;后置通知</td>\n</tr>\n<tr>\n<td><strong>切入点（Pointcut）</strong></td>\n<td>匹配连接点的表达式</td>\n</tr>\n<tr>\n<td><strong>织入（Weaving）</strong></td>\n<td>将切面逻辑织入主业务逻辑的过程</td>\n</tr>\n</tbody></table>\n<p>AOP 的优点</p>\n<p>关注点分离：业务逻辑中不再有杂质代码；</p>\n<p>可插拔性：只要配置切面，就能影响任意模块；</p>\n<p>解耦：日志、事务、权限都可以用统一模块处理；</p>\n<p>可扩展性强：面向接口编程 + 动态增强。</p>\n<ul>\n<li>Spring和SpringBoot的区别？</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>框架</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Spring</strong></td>\n<td>一个功能强大的轻量级开发框架，提供了 IOC、AOP、事务、MVC 等核心模块，是整个 Spring 家族的基础。</td>\n</tr>\n<tr>\n<td><strong>Spring Boot</strong></td>\n<td>基于 Spring 的快速开发框架，<strong>简化配置、自动装配</strong>，让你更快、更轻松地构建 Spring 应用，<strong>是 Spring 的增强封装</strong>。</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>对比项</th>\n<th>Spring</th>\n<th>Spring Boot</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>定位</strong></td>\n<td>一个基础开发框架</td>\n<td>一个快速构建 Spring 应用的脚手架</td>\n</tr>\n<tr>\n<td><strong>配置方式</strong></td>\n<td>XML + 注解配置繁琐</td>\n<td>基于注解 + 自动配置，开箱即用</td>\n</tr>\n<tr>\n<td><strong>依赖管理</strong></td>\n<td>手动添加每个 starter</td>\n<td>提供大量 <code>spring-boot-starter-*</code> 简化依赖管理</td>\n</tr>\n<tr>\n<td><strong>项目结构</strong></td>\n<td>需要手动搭建目录结构</td>\n<td>自动生成目录结构（Spring Initializr）</td>\n</tr>\n<tr>\n<td><strong>Web容器启动</strong></td>\n<td>需要部署到外部 Tomcat 等容器</td>\n<td>内嵌 Tomcat&#x2F;Jetty，应用可直接运行（<code>main</code> 方法）</td>\n</tr>\n<tr>\n<td><strong>日志配置</strong></td>\n<td>需要手动配置 log4j&#x2F;slf4j 等</td>\n<td>默认集成 Logback，自动配置</td>\n</tr>\n<tr>\n<td><strong>难易程度</strong></td>\n<td>学习曲线更陡</td>\n<td>更适合中小项目，入门简单</td>\n</tr>\n</tbody></table>\n<ul>\n<li>SpringBoot有哪些特性？</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>自动配置（Auto Configuration）</strong></td>\n<td>根据引入的依赖自动配置 Spring Bean，无需繁琐 XML 或注解配置</td>\n</tr>\n<tr>\n<td><strong>内嵌 Web 服务器</strong></td>\n<td>默认内置 Tomcat、Jetty、Undertow，无需外部部署容器，可直接运行</td>\n</tr>\n<tr>\n<td><strong>简化配置</strong></td>\n<td>使用 <code>application.properties</code> 或 <code>application.yml</code> 文件统一管理配置</td>\n</tr>\n<tr>\n<td><strong>快速启动</strong></td>\n<td>提供 <code>SpringApplication.run()</code> 入口类，一键启动整个服务</td>\n</tr>\n<tr>\n<td><strong>Starter 模块</strong></td>\n<td>提供大量 <code>spring-boot-starter-*</code> 模块，自动引入相关依赖</td>\n</tr>\n<tr>\n<td><strong>健康检查与监控</strong>（Actuator）</td>\n<td>提供系统运行状态、健康指标、Bean 信息、环境变量等监控接口</td>\n</tr>\n<tr>\n<td><strong>统一日志系统</strong></td>\n<td>默认使用 Logback，集成 SLF4J，简化日志配置</td>\n</tr>\n<tr>\n<td><strong>热部署支持</strong>（DevTools）</td>\n<td>自动重启项目，提升开发效率</td>\n</tr>\n<tr>\n<td><strong>Profile 支持</strong></td>\n<td>多环境配置（如 <code>application-dev.yml</code>、<code>application-prod.yml</code>）自动切换</td>\n</tr>\n<tr>\n<td><strong>Spring 全家桶无缝集成</strong></td>\n<td>与 Spring Security、Spring Data、Spring Cloud 等天然集成</td>\n</tr>\n</tbody></table>\n<ul>\n<li>SpringBoot的Starter是如何实现的？</li>\n</ul>\n<p>本质上就是把一堆依赖聚合在一起，保证版本的兼容；也可以设置自动装配类，实现导入即可用</p>\n<table>\n<thead>\n<tr>\n<th>部分</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Starter 模块</strong></td>\n<td>提供功能相关的依赖集合（比如 Redis、Kafka、JPA 的依赖）</td>\n</tr>\n<tr>\n<td><strong>Auto Configuration 模块</strong></td>\n<td>提供自动配置类，定义如何根据条件注册 Bean 到 Spring 容器中</td>\n</tr>\n</tbody></table>\n<ul>\n<li>事务怎么实现的?</li>\n</ul>\n<p>@transactional 或者 transactionTemplate</p>\n<p>@transactional 失效情况：</p>\n<ol>\n<li>同一个类中的方法调用@Transactional的方式时</li>\n<li>exception被catch而未被抛出</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ComplexService</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TransactionTemplate transactionTemplate;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">executeComplexLogic</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        transactionTemplate.execute(<span class=\"keyword\">new</span> TransactionCallback&lt;Void&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Void <span class=\"title\">doInTransaction</span><span class=\"params\">(TransactionStatus status)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 这里是你的业务逻辑</span></span><br><span class=\"line\">                <span class=\"comment\">// 如果需要回滚，可以调用 status.setRollbackOnly();</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>SpringCloud有了解过吗？</li>\n</ul>\n<p>Spring Cloud 是一套用于快速构建分布式系统的开发框架，它基于 Spring Boot，整合了各种微服务基础设施组件，提供了 配置管理、服务注册与发现、负载均衡、断路器、链路追踪、网关 等功能，简化了微服务架构下的开发复杂度。</p>\n<ul>\n<li><p>项目的数据量是多少？</p>\n</li>\n<li><p>项目是怎么监控的？</p>\n</li>\n</ul>\n<p>日志用Kibana，api的call和响应过程用AppDynamic，资源的监控用k8s</p>\n<p>我们项目部署在 Kubernetes 集群中，整体采用了多套工具组合实现应用性能监控、系统资源监控和日志采集分析。</p>\n<p>应用性能监控（APM）：<br>使用 AppDynamics 对服务进行链路追踪和性能分析，主要监控 API 的响应时间、吞吐量、错误率等关键指标。一旦某个接口响应变慢或报错增加，我们能迅速定位到具体的服务方法甚至数据库调用。</p>\n<p>日志监控：<br>日志方面采用了 ELK（Elasticsearch + Logstash + Kibana） 方案，其中：</p>\n<p>使用 Logstash&#x2F;Fluentd 采集服务容器日志；</p>\n<p>日志集中存储到 Elasticsearch；</p>\n<p>通过 Kibana 实现可视化分析与查询，比如快速查找错误堆栈、跟踪特定用户请求。</p>\n<p>资源与指标监控：<br>使用 Prometheus + Grafana 对 Kubernetes 节点和服务的资源使用情况（如 CPU、内存、网络流量）进行实时采集和可视化展示，部分服务还埋点了业务指标，比如订单成功率、队列堆积等。</p>\n<p>告警系统：<br>所有监控系统都接入了 Alertmanager 或企业通知系统（如邮件、钉钉、PagerDuty），当触发预设阈值时能第一时间通知相关开发或运维人员处理。<br>SpringBatch主要有哪些组件？</p>\n<ul>\n<li>数据库如何调优的？</li>\n</ul>\n<p><strong>SQL 语句优化：</strong></p>\n<p>避免全表扫描：通过分析慢查询日志，使用合适的索引优化 WHERE、JOIN、ORDER BY 等条件。</p>\n<p>控制返回列数量：尽量避免 SELECT *，只取实际需要的字段。</p>\n<p>分批处理大数据量查询：使用分页或游标，避免一次性拉取大量数据导致内存飙升。</p>\n<p>避免 N+1 查询问题：在 ORM 框架中，合理使用 JOIN 或批量查询。</p>\n<p><strong>数据库连接池优化：</strong></p>\n<p>使用连接池工具（如 HikariCP、Druid），并根据实际并发量设置合理的：</p>\n<p>最大连接数（maxPoolSize）</p>\n<p>最小空闲连接数</p>\n<p>最大等待时间等</p>\n<p>避免连接泄露，确保每次使用后能及时关闭或归还连接。</p>\n<p>redis接触过吗,怎么用的？</p>\n<p>Docker用过吗?</p>\n<h2 id=\"OOCL\"><a href=\"#OOCL\" class=\"headerlink\" title=\"OOCL\"></a>OOCL</h2><p><a href=\"https://docs.qq.com/doc/DY3pwd0RFR0NsY01x\">https://docs.qq.com/doc/DY3pwd0RFR0NsY01x</a></p>\n<ul>\n<li>SpringMVC 工作原理</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">浏览器</span><br><span class=\"line\">   ↓</span><br><span class=\"line\">DispatcherServlet</span><br><span class=\"line\">   ↓</span><br><span class=\"line\">HandlerMapping (找 Controller)</span><br><span class=\"line\">   ↓</span><br><span class=\"line\">HandlerAdapter (执行 Controller)</span><br><span class=\"line\">   ↓</span><br><span class=\"line\">Controller (处理业务)</span><br><span class=\"line\">   ↓</span><br><span class=\"line\">ViewResolver (找视图)</span><br><span class=\"line\">   ↓</span><br><span class=\"line\">View (渲染)</span><br><span class=\"line\">   ↓</span><br><span class=\"line\">浏览器</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>什么是Servlet</li>\n</ul>\n<p>Servlet 就是 Java 写的、运行在服务器上的一个小程序，用来接收、处理 HTTP 请求，然后生成 HTTP 响应。</p>\n<p>早期 Java Web 没有 Spring MVC 的时候，Servlet 就是核心：</p>\n<ol>\n<li>浏览器访问 <a href=\"http://xxx.com/hello\">http://xxx.com/hello</a></li>\n<li>服务器 Tomcat 收到请求</li>\n<li>找到你写的 HelloServlet</li>\n<li>执行 doGet() 或 doPost() 方法</li>\n<li>把结果写到 HttpServletResponse 里，返回给浏览器</li>\n</ol>\n<ul>\n<li>hashmap 寻位过程</li>\n</ul>\n<p>默认16个哈希桶，每个桶对应一个链表，当链表超过8时并且数组长度大于64，变成红黑树；否则简单扩容哈希桶个数，并且按照原hash值重新计算应该放到哪个hash桶</p>\n<ul>\n<li>jdbc原理</li>\n</ul>\n<p>JDBC 原理 &#x3D; 统一接口 + 驱动厂商实现 + TCP 传输 + 结果封装</p>\n<ul>\n<li>三次握手四次挥手</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>问题</th>\n<th>答案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>为什么要三次握手？</strong></td>\n<td>为了可靠建立连接，双向确认双方都可收发，避免旧连接干扰</td>\n</tr>\n<tr>\n<td><strong>为什么要 TIME_WAIT？</strong></td>\n<td>保证最后一个 ACK 能到达对方，防止旧连接的数据影响新连接，确保连接优雅关闭</td>\n</tr>\n<tr>\n<td><strong>为什么是 2 倍最大生存时间？</strong></td>\n<td>彻底清除网络中的残留包</td>\n</tr>\n</tbody></table>\n<ul>\n<li>线程池的种类</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>工厂方法</th>\n<th>线程池类型</th>\n<th>特点</th>\n<th>适用场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Executors.newFixedThreadPool(int n)</code></td>\n<td><strong>固定大小线程池</strong></td>\n<td>有固定数量的核心线程，超出的任务会排队</td>\n<td>执行长期任务、负载较均匀</td>\n</tr>\n<tr>\n<td><code>Executors.newSingleThreadExecutor()</code></td>\n<td><strong>单线程池</strong></td>\n<td>始终只有一个线程，任务顺序执行</td>\n<td>保证顺序执行（如日志写入）</td>\n</tr>\n<tr>\n<td><code>Executors.newCachedThreadPool()</code></td>\n<td><strong>可缓存线程池</strong></td>\n<td>没有核心线程，空闲线程会被回收，可无限增长</td>\n<td>大量短期异步小任务</td>\n</tr>\n<tr>\n<td><code>Executors.newScheduledThreadPool(int n)</code></td>\n<td><strong>定时&#x2F;周期线程池</strong></td>\n<td>核心线程数固定，可执行延迟&#x2F;周期任务</td>\n<td>定时任务</td>\n</tr>\n<tr>\n<td><code>Executors.newWorkStealingPool(int n)</code></td>\n<td><strong>工作窃取线程池</strong>（Java 8+）</td>\n<td>使用 ForkJoinPool 实现，自动调度</td>\n<td>并行流或递归拆分</td>\n</tr>\n</tbody></table>\n<ul>\n<li>数据库表的设计选择</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>需求</th>\n<th>推荐做法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>主键</td>\n<td>自增ID or 分布式ID</td>\n</tr>\n<tr>\n<td>软删除</td>\n<td>加 <code>is_deleted</code> 标记</td>\n</tr>\n<tr>\n<td>乐观锁</td>\n<td>加 <code>version</code> 字段</td>\n</tr>\n<tr>\n<td>审计</td>\n<td>加 <code>created_at</code>、<code>updated_at</code></td>\n</tr>\n<tr>\n<td>唯一约束</td>\n<td>使用 <code>unique index</code></td>\n</tr>\n<tr>\n<td>复杂状态</td>\n<td>状态机用 <code>enum</code> 或 <code>tinyint</code></td>\n</tr>\n</tbody></table>\n<ul>\n<li>三范式</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>范式</th>\n<th>定义</th>\n<th>通俗解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1NF</td>\n<td>每个字段只能有单一值</td>\n<td>表中不能出现“数组”或“多值列”</td>\n</tr>\n<tr>\n<td>2NF</td>\n<td>满足1NF，且非主属性完全依赖主键</td>\n<td>表里非主键字段必须完全依赖于主键，而不是部分依赖</td>\n</tr>\n<tr>\n<td>3NF</td>\n<td>满足2NF，且非主属性不传递依赖主键</td>\n<td>表里非主键字段不能依赖于其他非主键字段</td>\n</tr>\n</tbody></table>\n<ul>\n<li>UML是什么</li>\n</ul>\n<p>UML（Unified Modeling Language） 是一种面向对象的软件建模标准语言，它就是用「图」来画出程序结构、模块关系、类之间的依赖、流程、交互等，方便团队理解和沟通。<br><img src=\"https://i.imgur.com/s9EQLmR.png\" alt=\"picture 0\"></p>\n<ul>\n<li>脑筋急转弯：屋子里能放多少网球</li>\n</ul>\n<p>测量房间长宽高，将球体看成边长为直径的正方体，房间体积&#x2F;正方体体积</p>\n<ul>\n<li>设计模式是什么</li>\n</ul>\n<p>是一些在软件开发中反复出现、被验证可行的经典解决方案，<br>它不是具体代码，而是一种可复用的、最佳实践式的思路和模板。</p>\n<ul>\n<li>native是什么</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NativeExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 声明一个 native 方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 加载实现这个 native 方法的动态库</span></span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">&quot;NativeLib&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> NativeExample().sayHello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Java rest 调用</li>\n</ul>\n<p>先写一个config类@Configuration, 然后注入的方式进行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// restTemplate</span></span><br><span class=\"line\"><span class=\"comment\">// 简单易用</span></span><br><span class=\"line\"><span class=\"comment\">// 适合简单场景</span></span><br><span class=\"line\"><span class=\"comment\">// Spring 5 后官方推荐用 WebClient 代替</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.client.RestTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RestClientExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        RestTemplate restTemplate = <span class=\"keyword\">new</span> RestTemplate();</span><br><span class=\"line\"></span><br><span class=\"line\">        String url = <span class=\"string\">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// GET 请求</span></span><br><span class=\"line\">        String result = restTemplate.getForObject(url, String.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// webclient</span></span><br><span class=\"line\"><span class=\"comment\">// 推荐用于新项目</span></span><br><span class=\"line\"><span class=\"comment\">// 支持响应式流式处理</span></span><br><span class=\"line\"><span class=\"comment\">// 配置更灵活</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.reactive.function.client.WebClient;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebClientExample</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        WebClient webClient = WebClient.create();</span><br><span class=\"line\"></span><br><span class=\"line\">        String result = webClient.get()</span><br><span class=\"line\">                .uri(<span class=\"string\">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>)</span><br><span class=\"line\">                .retrieve()</span><br><span class=\"line\">                .bodyToMono(String.class)</span><br><span class=\"line\">                .block(); <span class=\"comment\">// 阻塞获取</span></span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>@xxxExchange使用</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义接口</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.service.annotation.HttpExchange;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.service.annotation.PostExchange;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@HttpExchange</span> <span class=\"comment\">// 声明这是一个 HTTP 客户端接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyApiClient</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostExchange(&quot;/api/create&quot;)</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">createSomething</span><span class=\"params\">(MyRequest request)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 配置config</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Bean;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.service.invoker.HttpServiceProxyFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiClientConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MyApiClient <span class=\"title\">myApiClient</span><span class=\"params\">(RestClientBuilder builder)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 创建 RestClient</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> restClient = builder.baseUrl(<span class=\"string\">&quot;http://localhost:8080&quot;</span>).build();</span><br><span class=\"line\">        <span class=\"comment\">// 2. 用 HttpServiceProxyFactory 生成接口代理</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpServiceProxyFactory.builderFor(RestClientAdapter.create(restClient))</span><br><span class=\"line\">                .build()</span><br><span class=\"line\">                .createClient(MyApiClient.class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>prebuff 两个协议之间的区别</li>\n</ul>\n<p>描述 Redis 的 客户端通信协议行为 的一种概念。<br>在 Redis 和客户端交互时，协议主要分两种：</p>\n<p>RESP2：旧版 Redis 协议（大多数 Redis &lt;&#x3D; 6.x 默认用它）</p>\n<p>RESP3：新版协议，从 Redis 6 开始支持，Redis 7 开始逐步推广。</p>\n<ul>\n<li>策略模式</li>\n</ul>\n<p>定义一个策略接口，用多种不同的策略实现这个接口，当使用到的时候，由调用时的上下文决定这个具体的策略类用哪一个实现</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 定义策略接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DiscountStrategy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">applyDiscount</span><span class=\"params\">(<span class=\"keyword\">double</span> price)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 具体策略</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NoDiscount</span> <span class=\"keyword\">implements</span> <span class=\"title\">DiscountStrategy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">applyDiscount</span><span class=\"params\">(<span class=\"keyword\">double</span> price)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PercentageDiscount</span> <span class=\"keyword\">implements</span> <span class=\"title\">DiscountStrategy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">applyDiscount</span><span class=\"params\">(<span class=\"keyword\">double</span> price)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> price * <span class=\"number\">0.9</span>; <span class=\"comment\">// 9折</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 上下文</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ShoppingCart</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DiscountStrategy discountStrategy;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ShoppingCart</span><span class=\"params\">(DiscountStrategy discountStrategy)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.discountStrategy = discountStrategy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">checkout</span><span class=\"params\">(<span class=\"keyword\">double</span> price)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> discountStrategy.applyDiscount(price);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 使用</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ShoppingCart cart1 = <span class=\"keyword\">new</span> ShoppingCart(<span class=\"keyword\">new</span> NoDiscount());</span><br><span class=\"line\">        ShoppingCart cart2 = <span class=\"keyword\">new</span> ShoppingCart(<span class=\"keyword\">new</span> PercentageDiscount());</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(cart1.checkout(<span class=\"number\">100</span>)); <span class=\"comment\">// 100</span></span><br><span class=\"line\">        System.out.println(cart2.checkout(<span class=\"number\">100</span>)); <span class=\"comment\">// 90</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>工厂模式</li>\n</ul>\n<p>简单工厂： 一个工厂负责全部的产品的生成，当有新的产品的时候需要更改现有的工厂类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 产品接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Drink</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">make</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 具体产品</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Coffee</span> <span class=\"keyword\">implements</span> <span class=\"title\">Drink</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">make</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Make Coffee&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tea</span> <span class=\"keyword\">implements</span> <span class=\"title\">Drink</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">make</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Make Tea&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 工厂类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DrinkFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Drink <span class=\"title\">createDrink</span><span class=\"params\">(String type)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"string\">&quot;coffee&quot;</span>.equalsIgnoreCase(type)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Coffee();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;tea&quot;</span>.equalsIgnoreCase(type)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Tea();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Unknown drink type&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 使用</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Drink coffee = DrinkFactory.createDrink(<span class=\"string\">&quot;coffee&quot;</span>);</span><br><span class=\"line\">        coffee.make(); <span class=\"comment\">// Make Coffee</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Drink tea = DrinkFactory.createDrink(<span class=\"string\">&quot;tea&quot;</span>);</span><br><span class=\"line\">        tea.make(); <span class=\"comment\">// Make Tea</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>工厂方法：定义一个工厂接口，由具体的工厂子类决定生成哪个产品，新增产品时不会干涉现有代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 产品接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductA</span> <span class=\"keyword\">implements</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Product A&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductB</span> <span class=\"keyword\">implements</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Product B&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工厂接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Product <span class=\"title\">createProduct</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体工厂A</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryA</span> <span class=\"keyword\">implements</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Product <span class=\"title\">createProduct</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ProductA();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体工厂B</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryB</span> <span class=\"keyword\">implements</span> <span class=\"title\">Factory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Product <span class=\"title\">createProduct</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ProductB();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 客户端</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FactoryMethodDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Factory factory = <span class=\"keyword\">new</span> FactoryA();</span><br><span class=\"line\">        Product product = factory.createProduct();</span><br><span class=\"line\">        product.show(); <span class=\"comment\">// Product A</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>抽象工厂</p>\n<p>提供一个创建一族相关对象的接口，而无需指定具体类。适用于 多产品族</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 产品A接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ProductA</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showA</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 产品B接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ProductB</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showB</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 产品A1</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductA1</span> <span class=\"keyword\">implements</span> <span class=\"title\">ProductA</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Product A1&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 产品A2</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductA2</span> <span class=\"keyword\">implements</span> <span class=\"title\">ProductA</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Product A2&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 产品B1</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductB1</span> <span class=\"keyword\">implements</span> <span class=\"title\">ProductB</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Product B1&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 产品B2</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProductB2</span> <span class=\"keyword\">implements</span> <span class=\"title\">ProductB</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">showB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Product B2&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 抽象工厂</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AbstractFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">ProductA <span class=\"title\">createProductA</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">ProductB <span class=\"title\">createProductB</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体工厂1</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteFactory1</span> <span class=\"keyword\">implements</span> <span class=\"title\">AbstractFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ProductA <span class=\"title\">createProductA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ProductA1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ProductB <span class=\"title\">createProductB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ProductB1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 具体工厂2</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ConcreteFactory2</span> <span class=\"keyword\">implements</span> <span class=\"title\">AbstractFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ProductA <span class=\"title\">createProductA</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ProductA2();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ProductB <span class=\"title\">createProductB</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ProductB2();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 客户端</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractFactoryDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        AbstractFactory factory = <span class=\"keyword\">new</span> ConcreteFactory1();</span><br><span class=\"line\">        ProductA a = factory.createProductA();</span><br><span class=\"line\">        ProductB b = factory.createProductB();</span><br><span class=\"line\">        a.showA(); <span class=\"comment\">// Product A1</span></span><br><span class=\"line\">        b.showB(); <span class=\"comment\">// Product B1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>处理内存泄漏的经验</li>\n</ul>\n"},{"title":"项目深挖","url":"/2025/09/11/%E9%A1%B9%E7%9B%AE%E6%B7%B1%E6%8C%96/","content":"<h2 id=\"项目内容\"><a href=\"#项目内容\" class=\"headerlink\" title=\"项目内容\"></a>项目内容</h2><p>mca系统记录部门里会出现的各种风险和控制措施，control inventory的用户他们确定用哪个控制措施去降低特定风险， gau和sau(具体部门的人）会采用这套控制措施并执行</p>\n<h3 id=\"基本数据结构\"><a href=\"#基本数据结构\" class=\"headerlink\" title=\"基本数据结构\"></a>基本数据结构</h3><p>Manager’s Control Assessment (MCA) 是花旗内部的风控管理系统，用于对公司关键流程（GPMP：Global Process and Management Procedure）进行 控制设计、监控执行和独立测试，确保流程风险可控、符合监管要求（类似 SOX 合规和风险框架）。</p>\n<p>每个 Control 对应一个 GPMP 流程，用于描述风险点和控制措施。<br>常见字段有：</p>\n<ul>\n<li>Id（主键）</li>\n<li>GPMPId（关联的流程 ID）</li>\n<li>Title（控制点标题）</li>\n<li>Description（控制点描述）</li>\n<li>Control Owner（责任人）</li>\n<li>Approver（审批人）</li>\n<li>Frequency（执行频率，比如 daily&#x2F;weekly&#x2F;monthly）</li>\n<li>Key Risk Indicator (KRI)：关键指标是什么，比如说用户选择了 异常交易率，审批延误率这两种指标</li>\n<li>Expected Outcome &#x2F; Control Target：指标的期望值，期望值为多少属于正常</li>\n<li>Sample Size：比如：抽样 100 笔付款检查合规性。</li>\n<li>Control Category &#x2F; Type（手工 &#x2F; 自动、预防 &#x2F; 检测）</li>\n<li>L1 &#x2F; L2 &#x2F; L3 Mapping（不同层级的流程或风险分类，比如 L1&#x3D;业务大类，L2&#x3D;子类，L3&#x3D;具体流程）</li>\n<li>Status（Draft, Pending Approve, Approved, Retired）</li>\n</ul>\n<p>Monitoring 是对 Control 的执行效果进行 量化跟踪，由系统或用户设定参数，系统自动比对并生成结果。<br>可能字段：</p>\n<ul>\n<li>MonitoringId</li>\n<li>ControlId（对应的 Control）</li>\n<li>Metric &#x2F; KPI（监控指标，比如失败率、异常数）</li>\n<li>Threshold（阈值，比如异常率不能超过 2%）</li>\n<li>Time Window（监控周期：daily&#x2F;weekly&#x2F;monthly）</li>\n<li>Alert Rule（超过阈值时触发告警）</li>\n<li>Escalation Level（告警升级路径）</li>\n<li>Status（Active, Suspended）</li>\n</ul>\n<p>Testing 是由 第三方或独立团队定期对 Control 的有效性做抽查。<br>字段可能有：</p>\n<ul>\n<li>TestingId</li>\n<li>ControlId</li>\n<li>Test Plan（测试计划：抽样多少、方法）</li>\n<li>Frequency（季度 &#x2F; 半年 &#x2F; 一年）</li>\n<li>Tester（责任人，独立于 Control Owner）</li>\n<li>Test Result（Pass &#x2F; Fail &#x2F; Partial）</li>\n<li>Evidence（附件或证明）</li>\n<li>Report（最终报告生成）</li>\n<li>Testing 和 Monitoring 的区别：</li>\n<li>Monitoring &#x3D; 自动化、持续监控</li>\n<li>Testing &#x3D; 抽样验证，更偏人工&#x2F;审计手段</li>\n</ul>\n<p>创建一个 Control 的流程：</p>\n<ul>\n<li>用户创建 Control，绑定 GPMP 流程，填好字段。</li>\n<li>Control 状态变为 Pending Approve。</li>\n<li>系统自动生成两个待办任务：</li>\n<li>Monitoring Pending Creation</li>\n<li>Testing Pending Creation</li>\n<li>任务进入 jBPM 流程，相关责任人配置参数</li>\n<li>审批通过后，Control 生效，并进入周期性运行（Monitoring 定时检测，Testing 定期执行）。</li>\n</ul>\n<span id=\"more\"></span>\n\n<h4 id=\"常见控制点\"><a href=\"#常见控制点\" class=\"headerlink\" title=\"常见控制点\"></a>常见控制点</h4><p>A. IT 类控制点</p>\n<ul>\n<li>Control：关键系统用户权限必须每季度复核</li>\n<li>Monitoring：监控“复核完成情况”</li>\n<li>监控什么：所有系统是否提交了权限复核报告（Yes&#x2F;No），完成率（已提交 ÷ 应提交）</li>\n<li>数据交互：MCA 系统会接收 IT 系统或管理员上传的复核结果文件&#x2F;状态数据。</li>\n</ul>\n<p>B. 财务类控制点</p>\n<ul>\n<li>Control：会计分录 &gt; X 美金需主管审批</li>\n<li>Monitoring：监控“审批流程执行情况”</li>\n<li>监控什么：当期抽样分录里，是否有缺少审批的记录，异常率多少。</li>\n<li>数据交互：MCA 系统通过接口&#x2F;API 从财务系统（如 Oracle ERP, SAP）拉取抽样数据，或由业务部门上传抽样报告。</li>\n</ul>\n<p>C. 人事合规类控制点</p>\n<ul>\n<li>Control：新员工必须在 30 天内完成合规培训</li>\n<li>Monitoring：监控“培训完成率”</li>\n<li>监控什么：员工培训系统（LMS）的课程完成状态（完成&#x2F;未完成），统计完成率。</li>\n<li>数据交互：MCA 系统通过接口调用 LMS 系统的数据，或定期导入报表。</li>\n</ul>\n<p>D. 运营流程类控制点</p>\n<ul>\n<li>Control：客户投诉需在 5 个工作日内处理完毕</li>\n<li>Monitoring：监控“处理时效”</li>\n<li>监控什么：CRM 系统中，投诉单的关闭时长是否 ≤ 5 天，异常单数量。</li>\n<li>数据交互：MCA 系统定期获取 CRM 系统的工单处理数据，做规则计算。</li>\n</ul>\n<h4 id=\"Monitoring-怎么跑\"><a href=\"#Monitoring-怎么跑\" class=\"headerlink\" title=\"Monitoring 怎么跑\"></a>Monitoring 怎么跑</h4><p>数据获取</p>\n<ul>\n<li>API&#x2F;接口：MCA 调用外部系统的服务（如 HR、ERP、LMS）。</li>\n<li>ETL&#x2F;数据仓库：MCA 读取公司统一的 Data Lake&#x2F;ODS 里的指标数据。</li>\n<li>手工上传：业务部门导出 Excel&#x2F;CSV，再导入 MCA 系统。</li>\n</ul>\n<p>指标计算</p>\n<ul>\n<li>MCA 内部有逻辑，把 Control 定义的条件翻译成计算公式。</li>\n</ul>\n<p>例如：</p>\n<p>培训完成率 &#x3D; 完成人数 ÷ 应参加人数<br>权限复核完成率 &#x3D; 已完成系统数 ÷ 总系统数</p>\n<p>阈值对比</p>\n<ul>\n<li>把计算结果和 Control 定义的目标（100%、95% 等）对比。</li>\n</ul>\n<p>结果展示&#x2F;告警</p>\n<ul>\n<li>如果达标 → 绿色（Pass）</li>\n<li>未达标 → 红色（Fail），可能生成 Issue 或 Task。</li>\n</ul>\n<h4 id=\"数据获取方式\"><a href=\"#数据获取方式\" class=\"headerlink\" title=\"数据获取方式\"></a>数据获取方式</h4><ol>\n<li>接口对接（API &#x2F; 服务调用）</li>\n</ol>\n<ul>\n<li>在花旗，很多核心系统都有标准接口（或者通过中台服务暴露数据），MCA 可以通过接口定期拉取数据：</li>\n</ul>\n<p>HR 系统（Workday &#x2F; PeopleSoft）</p>\n<p>Monitoring：员工入职&#x2F;离职流程是否按规定完成（比如离职当天是否关停系统权限）。</p>\n<p>实现：MCA 调用 HR 系统的 API，获取员工状态和时间戳数据。</p>\n<ul>\n<li>LMS（Learning Management System，培训系统）</li>\n</ul>\n<p>Monitoring：年度合规培训完成率。</p>\n<p>实现：MCA 调接口拿到培训完成情况，计算完成率。</p>\n<ul>\n<li>ERP&#x2F;财务系统（Oracle ERP, SAP）</li>\n</ul>\n<p>Monitoring：高风险分录是否有二次审批。</p>\n<p>实现：MCA 调用 ERP 接口获取分录审批日志。</p>\n<p>👉 特点：适合数据标准化、实时性要求高的场景。</p>\n<p>在花旗很多老系统（特别是地区性或遗留系统）并没有 API，这时就靠报表导入。</p>\n<p>例子 1：访问权限复核</p>\n<ul>\n<li><p>Control：每季度必须复核用户权限。</p>\n</li>\n<li><p>Monitoring：检查复核是否完成。</p>\n</li>\n<li><p>实现：系统管理员从 IAM&#x2F;Active Directory 导出 CSV 报表，上传到 MCA。MCA 自动解析，打勾是否完成。</p>\n</li>\n</ul>\n<p>例子 2：交易抽样检查</p>\n<ul>\n<li><p>Control：关键业务交易需抽样核查。</p>\n</li>\n<li><p>Monitoring：异常率统计。</p>\n</li>\n<li><p>实现：业务部门从交易系统导出 Excel 上传，MCA 自动算异常比例。</p>\n</li>\n</ul>\n<p>👉 特点：适合跨地区、不统一的老系统；靠“人-系统”结合。</p>\n<p>有些控制点没法通过数据直接验证，只能靠责任人手工确认。</p>\n<p>例子 1：委员会&#x2F;例会是否召开</p>\n<ul>\n<li><p>Control：季度风险委员会必须召开一次。</p>\n</li>\n<li><p>Monitoring：检查会议纪要是否提交。</p>\n</li>\n<li><p>实现：责任人在 MCA 上勾选“已召开”，并上传会议纪要 PDF。</p>\n</li>\n</ul>\n<p>例子 2：政策更新</p>\n<ul>\n<li><p>Control：年度合规政策需更新。</p>\n</li>\n<li><p>Monitoring：检查政策文件是否发布。</p>\n</li>\n<li><p>实现：责任人手工上传新文件。</p>\n</li>\n</ul>\n<p>例子 3：供应商尽职调查</p>\n<ul>\n<li><p>Control：供应商需每年重新尽调。</p>\n</li>\n<li><p>Monitoring：业务人员手动填写完成状态，附上尽调报告。</p>\n</li>\n</ul>\n<h3 id=\"业务完整逻辑\"><a href=\"#业务完整逻辑\" class=\"headerlink\" title=\"业务完整逻辑\"></a>业务完整逻辑</h3><p>GPMP创建之后，表示这是某个需要做风控的操作流程，这一部分是印度team负责的，我们就不是很清楚。</p>\n<p>在我们系统中可以创建Control来挂载到某个Process上，填好相应的需要监控的指标和数值（比如合规完成率、员工入职&#x2F;离职流程、财务分录是否有二次审批）。</p>\n<p>Monitoring根据control对应的process类型和设置的监控指标来获取数据，可以选择全自动&#x2F;半自动&#x2F;全手动的方式进行，然后就定期执行监控，根据设定的阈值进行预警</p>\n<p>Testing就是定期抽样检查是否真的执行，可以理解成，monitoring是一个提醒用户的东西，testing则是生成最终的报告，testing出来的结果就是你这个control是否有效的唯一凭证。</p>\n<p>control创建后status会变成Draft-Pending-Initiate,同时创建两个MTTool Creation Task，由该control的owner或者delegate进行填写，填写完成后会生成下一个Task，control进入下一个status Draft-Pending-Approve, 字段中填写的责任监管人会收到这个Task，选择approve&#x2F;reject。</p>\n<p>JBPM流程：创建Process，并且在该processID下创建M&#x2F;T Task,并且返回给用户，用户那边每次完成task都会call workflow service这边一个TaskId完成，两个TaskID都完成的话就会创建一个IBRC-Approve Task。然后接着完成。</p>\n<h3 id=\"SQL1000\"><a href=\"#SQL1000\" class=\"headerlink\" title=\"SQL1000\"></a>SQL1000</h3><ul>\n<li>场景</li>\n</ul>\n<p>Oracle 对单条 SQL 的 IN 列表有限制：最多 1000 个元素，如果你的查询涉及多个 IN 列表，问题会更加明显</p>\n<p>目标：提高性能并避免 ORA-01795 错误</p>\n<ul>\n<li><p>方案 A：拆分 IN 列表 + OR 连接</p>\n<p>  SQL 可读性差：IN 列表越大，SQL 越长</p>\n<p>  执行计划复杂：每个 IN 块会生成单独的访问路径，Oracle 需要分别优化每个 OR 条件</p>\n<p>  性能下降：大量 OR 会增加解析时间，尤其是索引扫描时，可能会触发全表扫描</p>\n<p>  总结：对于小量 IN 块可以接受，但大量数据（几千、几万）会明显慢</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SqlInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">StatementInspector</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">inspect</span><span class=\"params\">(String sql)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;&gt;&gt;&gt; SQL: &quot;</span> + sql);</span><br><span class=\"line\">        <span class=\"comment\">// 你可以在这里修改 SQL，比如替换 IN 子句</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sql;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方案 B：使用 XMLTable</p>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> t.<span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> <span class=\"keyword\">table</span> t</span><br><span class=\"line\"><span class=\"keyword\">JOIN</span> XMLTable(</span><br><span class=\"line\">      <span class=\"string\">&#x27;/ids/id&#x27;</span> PASSING xmltype(:xmlList)</span><br><span class=\"line\">      COLUMNS id NUMBER PATH <span class=\"string\">&#x27;.&#x27;</span></span><br><span class=\"line\">) x</span><br><span class=\"line\"><span class=\"keyword\">ON</span> t.col <span class=\"operator\">=</span> x.id;</span><br></pre></td></tr></table></figure>\n\n<p>可维护性好：SQL 简洁，参数量几万也没问题</p>\n<p>可扩展性强：动态生成 XML 或临时表即可支持任意大小的数据列表</p>\n<p>缺点</p>\n<p>需要额外构建 XML 或临时表，但成本低于 SQL 执行消耗</p>\n<p>临时表要管理生命周期（全局临时表每天重建或 SESSION 级别）</p>\n<ul>\n<li>为什么 XMLTable&#x2F;临时表更快？</li>\n</ul>\n<p>优化器优化更好：IN OR IN 会生成多条访问路径，优化器无法高效合并</p>\n<p>减少 SQL 解析时间：长 IN 列表会导致 SQL 文本巨大，解析成本高</p>\n<p>减少 OR 条件处理开销：OR 条件的代价高，尤其涉及索引扫描</p>\n<p>批量数据访问友好：JOIN 或 XMLTable 可以直接通过集合操作，高效使用缓存和索引</p>\n<p>总结：当 IN 列表超过几千，甚至上万时，XMLTable 或临时表方案显著优于拆分 OR 的方案，尤其是在金融&#x2F;风控场景的高并发、大数据查询中。</p>\n<ul>\n<li>不用临时表的原因</li>\n</ul>\n<ol>\n<li>临时表适合于用于复杂的场景，可以建索引，可以存储sql运行过程中的中间值，方便做join操作，但是我们的场景下需要的只是一个list全扫描的功能，用不到临时表；</li>\n<li>OracleDB和Mysql不一样，Mysql创建临时表会话结束就会自动销毁,OracleDB则是表结构一直存在，那对于我们有多个List的场景就不太适配，因为我们也不知道最后会有多少的超过1000的List；OracleDB只能选择删除数据，除非手动Drop表；</li>\n</ol>\n<h4 id=\"实际写的时候遇到的问题\"><a href=\"#实际写的时候遇到的问题\" class=\"headerlink\" title=\"实际写的时候遇到的问题\"></a>实际写的时候遇到的问题</h4><ul>\n<li>代码经过编译之后，参数名称变成var1,var2这种，需要用Param获取一下</li>\n<li>需要注入Spring管理的Entitymanager，否则不在当前事务内</li>\n<li>根据返回的结果类型来确定使用哪一个resultHandler</li>\n</ul>\n<h3 id=\"Transactional\"><a href=\"#Transactional\" class=\"headerlink\" title=\"@Transactional\"></a>@Transactional</h3><p>@Transactional 注解对同一个库的不同schema会生效，但是对不同库的不会生效，本质上是根据datasource来的。</p>\n<h4 id=\"传播行为\"><a href=\"#传播行为\" class=\"headerlink\" title=\"传播行为\"></a>传播行为</h4><table>\n<thead>\n<tr>\n<th>传播级别</th>\n<th>行为</th>\n<th>典型场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>REQUIRED</code></td>\n<td>加入已有事务或新建</td>\n<td>大部分业务方法</td>\n</tr>\n<tr>\n<td><code>REQUIRES_NEW</code></td>\n<td>总是新建事务，挂起已有事务</td>\n<td>审计日志、异步通知，失败不能影响主事务</td>\n</tr>\n<tr>\n<td><code>SUPPORTS</code></td>\n<td>有事务加入，无事务非事务执行</td>\n<td>可选事务操作</td>\n</tr>\n<tr>\n<td><code>MANDATORY</code></td>\n<td>必须在事务中执行</td>\n<td>核心业务强制要求事务</td>\n</tr>\n<tr>\n<td><code>NOT_SUPPORTED</code></td>\n<td>挂起当前事务，以非事务执行</td>\n<td>大数据导出、读历史数据无需锁</td>\n</tr>\n<tr>\n<td><code>NEVER</code></td>\n<td>必须非事务执行</td>\n<td>非事务场景保证不加锁</td>\n</tr>\n<tr>\n<td><code>NESTED</code></td>\n<td>当前事务存在则创建子事务保存点</td>\n<td>可以局部回滚，数据库支持保存点（如 Oracle、MySQL InnoDB）</td>\n</tr>\n</tbody></table>\n<p>这个传播行为是指被传播的时候的行为，而不是传播到下一个的时候的行为。本质上就是，用了这个传播级别了，每次访问数据库的时候的auto-commit就会不生效，而是由@Transactional来控制，相当于应用层面控制了事务。</p>\n<p><code>nested</code>和<code>required_new</code>的区别，在于requiredNew的两个事务完全不影响，但是nested中后面的子事务会被父事务的回滚影响到</p>\n<ul>\n<li>保存点的原理</li>\n</ul>\n<ol>\n<li><p>事务日志（Redo&#x2F;Undo log）：数据库在执行事务操作时，会把修改记录到 Undo Log（用于回滚）和 Redo Log（用于重做或崩溃恢复）。</p>\n</li>\n<li><p>创建保存点：当你 SAVEPOINT sp1; 时，数据库内部会记录一个指针（offset&#x2F;标记），标记当前 Undo Log 的位置。</p>\n</li>\n<li><p>回滚到保存点：执行 ROLLBACK TO sp1; 时，数据库会把事务撤销到这个标记位置，即只回滚保存点之后的操作。</p>\n</li>\n<li><p>释放保存点：执行 RELEASE SAVEPOINT sp1;，数据库会删除该保存点，节省内存。</p>\n</li>\n</ol>\n<p>所以保存点实际上就是 事务内部的一个“回滚标记”，通过 Undo Log 回退操作，不会像完整回滚那样撤销整个事务。</p>\n<h4 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h4><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>DEFAULT</code></td>\n<td>使用数据库默认隔离级别</td>\n</tr>\n<tr>\n<td><code>READ_UNCOMMITTED</code></td>\n<td>允许读取未提交数据（脏读）</td>\n</tr>\n<tr>\n<td><code>READ_COMMITTED</code></td>\n<td>只能读已提交数据（避免脏读）</td>\n</tr>\n<tr>\n<td><code>REPEATABLE_READ</code></td>\n<td>读到的数据在整个事务中一致（防止不可重复读）</td>\n</tr>\n<tr>\n<td><code>SERIALIZABLE</code></td>\n<td>串行化执行，完全隔离，最严格（防止幻读）</td>\n</tr>\n</tbody></table>\n<p>搭配propagation使用的，加入当前方法创建了一个新的事务，这个事务就按照这个隔离级别来，可以控制是否能够看到上层的修改。</p>\n<h4 id=\"其他参数\"><a href=\"#其他参数\" class=\"headerlink\" title=\"其他参数\"></a>其他参数</h4><ul>\n<li>readOnly: boolean,提示数据库这个操作是否只读</li>\n<li>timeout: 超时时间</li>\n<li>rollbackFor&#x2F;noRollbackFor: 指定哪些Exception回滚，哪些不回滚</li>\n<li>value&#x2F;transactionManager: 适用于多数据源场景</li>\n</ul>\n<p>在进入方法前，会去获取一个Datasource，如果有多个dataSource就指定名称或者@Primary，多个datasource的情况下需要自己配置TransactionManager。核心流程就是 ： <code>datasource-&gt;拿这个datasource对应的jpaProperty-&gt;两个一起构建一个EntityManager-&gt;再把EntityManager注册到TransactionManager</code>,比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableTransactionManagement</span></span><br><span class=\"line\"><span class=\"meta\">@EnableJpaRepositories(</span></span><br><span class=\"line\"><span class=\"meta\">        basePackages = &quot;com.weirdo.stockanalysis.dao.mysql&quot;,   // mysql的repository目录</span></span><br><span class=\"line\"><span class=\"meta\">        entityManagerFactoryRef = &quot;mysqlEntityManagerFactory&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">        transactionManagerRef = &quot;mysqlTransactionManager&quot;</span></span><br><span class=\"line\"><span class=\"meta\">)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MysqlDataSourceConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;mysqlDataSource&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ConfigurationProperties(prefix = &quot;spring.datasource.mysql&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> DataSource <span class=\"title\">mysqlDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DataSourceBuilder.create().build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;mysqlEntityManagerFactory&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LocalContainerEntityManagerFactoryBean <span class=\"title\">mysqlEntityManagerFactory</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            <span class=\"meta\">@Qualifier(&quot;mysqlEntityManagerFactoryBuilder&quot;)</span> EntityManagerFactoryBuilder builder,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            <span class=\"meta\">@Qualifier(&quot;mysqlDataSource&quot;)</span> DataSource dataSource</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> builder</span><br><span class=\"line\">                .dataSource(dataSource)</span><br><span class=\"line\">                .packages(<span class=\"string\">&quot;com.weirdo.stockanalysis.entity.mysql&quot;</span>) <span class=\"comment\">// mysql的实体类目录</span></span><br><span class=\"line\">                .persistenceUnit(<span class=\"string\">&quot;mysql&quot;</span>)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;mysqlTransactionManager&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PlatformTransactionManager <span class=\"title\">mysqlTransactionManager</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">            <span class=\"meta\">@Qualifier(&quot;mysqlEntityManagerFactory&quot;)</span> EntityManagerFactory entityManagerFactory</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    )</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JpaTransactionManager(entityManagerFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;mysqlEntityManagerFactoryBuilder&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> EntityManagerFactoryBuilder <span class=\"title\">mysqlEntityManagerFactoryBuilder</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;mysqlJpaProperties&quot;)</span> JpaProperties jpaProperties)</span> </span>&#123;</span><br><span class=\"line\">        JpaVendorAdapter jpaVendorAdapter = createJpaVendorAdapter(jpaProperties);</span><br><span class=\"line\">        Function&lt;DataSource, Map&lt;String, ?&gt;&gt; jpaPropertiesFactory =</span><br><span class=\"line\">                (dataSource) -&gt; jpaProperties.getProperties();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EntityManagerFactoryBuilder(jpaVendorAdapter, jpaPropertiesFactory, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> JpaVendorAdapter <span class=\"title\">createJpaVendorAdapter</span><span class=\"params\">(JpaProperties jpaProperties)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HibernateJpaVendorAdapter();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ConfigurationProperties(prefix = &quot;spring.jpa.mysql&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(name = &quot;mysqlJpaProperties&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> JpaProperties <span class=\"title\">mysqlJpaProperties</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JpaProperties();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h3><h4 id=\"组成部分：\"><a href=\"#组成部分：\" class=\"headerlink\" title=\"组成部分：\"></a>组成部分：</h4><ul>\n<li>Aspect（切面）：横切逻辑本身，如日志记录。</li>\n<li>Join point（连接点）：程序执行中的点，如方法调用、异常抛出。</li>\n<li>Pointcut（切入点）：定义在哪些 join point 执行 Aspect。</li>\n<li>Advice（通知）：具体的横切逻辑（前置、后置、环绕等）。</li>\n<li>Weaving（织入）：将切面逻辑与业务逻辑结合的过程。</li>\n</ul>\n<h4 id=\"SpringAOP\"><a href=\"#SpringAOP\" class=\"headerlink\" title=\"SpringAOP\"></a>SpringAOP</h4><p>默认CGLIB，可以通过配置修改</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring.aop.proxy-target-class=false</span>  <span class=\"comment\"># 强制使用 JDK动态代理</span></span><br></pre></td></tr></table></figure>\n\n<p>源码中表明，如果即使设置成true，当代理对象传入的是个接口的时候，仍然会使用JDK动态代理</p>\n<ul>\n<li>AOP能否拦截类的非interface中的public方法？</li>\n</ul>\n<p>需要看切点是切的接口还是切的实现类，如果切点设置的是接口就不能代理，如果设置的是类就能代理</p>\n<ul>\n<li><p>代理生成流程</p>\n</li>\n<li><p><code>AnnotationAwareAspectJAutoProxyCreator</code></p>\n<p>  扫描容器里的 Bean，判断哪些 Bean 需要代理（匹配切点）。</p>\n<p>  调用 wrapIfNecessary() 生成代理对象。</p>\n</li>\n<li><p>ProxyFactory</p>\n<p>  负责生成最终的代理对象。</p>\n</li>\n<li><p>原始 Bean 实例化完成后，<code>AnnotationAwareAspectJAutoProxyCreator</code>的<code>postProcessAfterInitialization</code> 会：</p>\n<p>  判断该 Bean 是否需要切面拦截。</p>\n<p>  如果需要，生成一个代理对象。</p>\n<p>  返回的就是代理对象，Spring 容器里的引用就被代理对象替代了。</p>\n</li>\n</ul>\n<h4 id=\"PointCut-语法\"><a href=\"#PointCut-语法\" class=\"headerlink\" title=\"PointCut 语法\"></a>PointCut 语法</h4><ul>\n<li>execution</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 拦截所有包下的服务类的所有 public 方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;execution(public * com.example.service.*.*(..))&quot;)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>within</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 匹配 com.example.service 包内所有类的所有方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;within(com.example.service..*)&quot;)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>args</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 拦截所有第一个参数是 String 类型的方法</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;args(java.lang.String, ..)&quot;)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>this&#x2F;target</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;this(com.example.service.MyService)&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;target(com.example.service.MyServiceImpl)&quot;)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>annotation</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;target(com.example.service.MyServiceImpl)&quot;)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>组合表达式</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// com.example.service 包内所有方法，排除测试类</span></span><br><span class=\"line\"><span class=\"meta\">@Pointcut(&quot;within(com.example.service..*) &amp;&amp; !within(com.example.service..*Test)&quot;)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>AOP 中的 JoinPoint 和 ProceedingJoinPoint 有什么区别？<br>JoinPoint → 获取方法参数、签名<br>ProceedingJoinPoint → 可执行目标方法（用于 @Around）\\</p>\n</li>\n<li><p>为什么同类内部方法调用 AOP 不生效？</p>\n</li>\n</ul>\n<p>因为 Spring AOP 依赖代理，self 调用不会经过代理对象，可以使用 AopContext.currentProxy() 调用自己通过注入代理对象自己调用</p>\n<ul>\n<li>Spring AOP 和事务的关系？</li>\n</ul>\n<p>@Transactional 本质就是基于 AOP 的动态代理 + 事务切面</p>\n<ul>\n<li>多个切面执行顺序如何控制？</li>\n</ul>\n<p>@Order 注解控制优先级，值越小优先级越高</p>\n<h4 id=\"编程式使用AOP\"><a href=\"#编程式使用AOP\" class=\"headerlink\" title=\"编程式使用AOP\"></a>编程式使用AOP</h4><ul>\n<li>可以通过继承实现Pointcut接口，通过编程方式定义pointcut。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.aop.ClassFilter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.aop.MethodMatcher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.aop.Pointcut;</span><br><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\"> * 自定义Pointcut</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@author</span> Elim</span></span><br><span class=\"line\"><span class=\"comment\"> * 2017年5月8日</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCustomPointcut</span> <span class=\"keyword\">implements</span> <span class=\"title\">Pointcut</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ClassFilter <span class=\"title\">getClassFilter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyCustomClassFilter();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> MethodMatcher <span class=\"title\">getMethodMatcher</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MyCustomMethodMatcher();</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCustomClassFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">ClassFilter</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//实现自己的判断逻辑，这里简单的判断对应Class的名称是以Service结尾的就表示匹配</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> clazz.getName().endsWith(<span class=\"string\">&quot;Service&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCustomMethodMatcher</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodMatcher</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//实现方法匹配逻辑</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> method.getName().startsWith(<span class=\"string\">&quot;find&quot;</span>);</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isRuntime</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(Method method, Class&lt;?&gt; targetClass, Object[] args)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以通过实现<code>MethodBeforeAdvice</code>,<code>AfterReturningAdvice</code>,<code>MethodInterceptor</code>等来实现Advice</li>\n</ul>\n<h4 id=\"AOP本质实现\"><a href=\"#AOP本质实现\" class=\"headerlink\" title=\"AOP本质实现\"></a>AOP本质实现</h4><p>通过使用字节码操作的工具，生成被代理的类，并且在切点前后放入我们自己设置的代码逻辑</p>\n<ul>\n<li>SpringAOP：</li>\n</ul>\n<ol>\n<li>读取@Aspect注解的类，生成对应的Advice对象</li>\n<li><code>AnnotationAwareAspectJAutoProxyCreator</code>会成为<code>BeanPostProcessor</code>，当Bean创建完成后调用<code>postProcessAfterInitialization(bean, beanName)</code></li>\n<li>通过<code>wrapIfNecessary(bean, beanName)</code>根据是否有适用的Advice判断是否需要代理（即是否满足切点）。不需要代理的话直接返回原本创建好的bean</li>\n<li>需要代理的话会创建代理，将Advic列表的被代理的对象传给ProxyFactory,生成具体的代理对象并且返回作为这个bean注册到容器中，之后有地方注入了这个bean，调用的都是代理对象</li>\n<li>代理类型根据是否强制设置CGLIB和代理的是否有接口来决定用JDK还是CGLIB</li>\n<li>执行方法的时候会进入<code>InvocationHandler.invoke()</code>或者<code>MethodInterceptor.intercept()</code></li>\n<li>根据advice列表生成拦截器链，然后再invoke中顺序调用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdkDynamicAopProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AdvisedSupport advised;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Object&gt; chain = <span class=\"keyword\">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (chain.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> method.invoke(target, args);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ReflectiveMethodInvocation(target, method, args, chain).proceed();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>CGLIB: 在CGLIB框架在创建代理对象的过程中，通过创建一个Enhancer对象，为其设置超类Class、回调函数。接着从其超类(目标类)的Class对象中获取所有Method对象，最终过滤出非final、非static的public修饰的方法，接着调用ASM框架的相关API去做一些创建类的信息、字段信息、方法信息等，将它们创建为一个byte字节组成的数组，即字节码对象。再通过ASM框架将程序内存中的字节码对象以Class文件写入指定路径（非必须步骤，需要自行设置），最后将得到的字节码对象转为代理Class对象以及回调函数通过反射创建一个实例对象。</li>\n</ul>\n<h4 id=\"AspectJ\"><a href=\"#AspectJ\" class=\"headerlink\" title=\"AspectJ\"></a>AspectJ</h4><p>可以拦截private, 构造方法和静态方法，因为他是在编译期间就把切面逻辑写到.class文件中，类加载的时候会修改其字节码，实现切面的插入</p>\n<h3 id=\"CompletableFuture\"><a href=\"#CompletableFuture\" class=\"headerlink\" title=\"CompletableFuture\"></a>CompletableFuture</h3><p>在调用查数据的时候，比如用户点进Control详情页面，就需要并行调用三个服务获取数据，<code>Gpmp, Monitoring, Testing</code>，这时候同步调用这三个服务能显著提升性能。</p>\n<p>不同的异步方案对比</p>\n<p><img src=\"https://i.imgur.com/n44WE3Y.png\" alt=\"picture 0\">  </p>\n<h4 id=\"执行流程\"><a href=\"#执行流程\" class=\"headerlink\" title=\"执行流程\"></a>执行流程</h4><ul>\n<li>cf1.thenApply(cf2)</li>\n</ul>\n<ol>\n<li>将观察者Completion(UniApply)注册到cf1，cf1将这个Uniapply压到Completion栈中</li>\n<li>cf1完成的时候，结果保存到result</li>\n<li>依次弹出栈中的XxxApply，通知观察者(cf2)尝试运行</li>\n</ol>\n<ul>\n<li>cf3&#x3D;cf1.thenCombine(cf2)</li>\n</ul>\n<p>跟上面基本一致，区别在于当cf1完成的时候会通知BiApply一次，cf2完成时也通知BiApply一次，只有当BiApply判断出两个cf都执行完了，才会启动cf3</p>\n<ul>\n<li>cf4&#x3D;CompletableFuture.allof(cf1,cf2,cf3)</li>\n</ul>\n<p>跟上面也基本一致，区别在于，这里也是用BiApply,只不过是all里面从前往后地构成一个树结构，执行的结果层层通知下去</p>\n<h4 id=\"ForkJoinPool\"><a href=\"#ForkJoinPool\" class=\"headerlink\" title=\"ForkJoinPool\"></a>ForkJoinPool</h4><p>Fork&#x2F;Join 框架基于”工作窃取”算法 (Work Stealing Algorithm)，该算法的核心思想是每个工作线程有自己的任务队列(双端队列, Deque)。当一个线程完成了自己队列中的任务时，便会窃取其他线程队列中的任务执行，这样就不会因为某个线程在等待而浪费 CPU 资源。</p>\n<p>需要手动创建ForkJoinTask，task内部是递归形式构建子任务，这样才能利用到ForkJoinPool的fork&#x2F;join特性，如果只是传入一个Runable&#x2F;Callable，那本质上和普通线程池差不多</p>\n<p>Fork&#x2F;Join 框架非常适合以下这些工作负载：</p>\n<p>递归任务：如斐波那契数列、归并排序等分治算法。<br>大规模数据处理：快速对集合、数组等进行并行操作。<br>图像处理：图像处理等数据量大的任务可以被分成多个小任务并行处理。</p>\n<p>一定要注意异步RPC调用的情况下如果是基于异步NIO的方式的话，要用CompletableFuture的异步回调，否则可能长期占用IO线程，影响服务响应</p>\n<p>比如说： <code>async.call()</code> 会返回一个<code>CompletableFuture&lt;xxx&gt;</code>，这时候回调函数最好写成<code>.thenSupplyAsync(xxx)</code>，这样就不会用IO线程来执行回调</p>\n<h3 id=\"HttpExchange\"><a href=\"#HttpExchange\" class=\"headerlink\" title=\"HttpExchange\"></a>HttpExchange</h3><h4 id=\"HttpExchange的实现方式\"><a href=\"#HttpExchange的实现方式\" class=\"headerlink\" title=\"HttpExchange的实现方式\"></a>HttpExchange的实现方式</h4><p>HttpExchange本身是一个接口，不涉及实现，具体的实现得看你用什么Client，可以用RestClient&#x2F;Webclient不同的实现有不同的效果</p>\n<h4 id=\"HttpExchange是阻塞的还是异步的\"><a href=\"#HttpExchange是阻塞的还是异步的\" class=\"headerlink\" title=\"@HttpExchange是阻塞的还是异步的\"></a>@HttpExchange是阻塞的还是异步的</h4><ol>\n<li>直接返回类或者list这种，是阻塞的</li>\n<li>支持返回Mono&#x2F;Flux类型，这种是异步的，可以通过Mono.zip(xServiceClient.callXX(),yServiceClient.call())</li>\n</ol>\n<h4 id=\"Mono-x2F-Flux-reactive-call\"><a href=\"#Mono-x2F-Flux-reactive-call\" class=\"headerlink\" title=\"Mono&#x2F;Flux reactive call\"></a>Mono&#x2F;Flux reactive call</h4><p><code>Mono&lt;User&gt; userMono = userServiceClient.getUser(&quot;123&quot;);</code> 像这样的代码是不会执行调用client的，必须得<code>userMono.subscribe()/userMono.block()</code>之后才可以</p>\n<p>也可以很方便的转成CompletableFuture类型 <code>userMono.toFuture()</code></p>\n<h4 id=\"发布-x2F-订阅模式\"><a href=\"#发布-x2F-订阅模式\" class=\"headerlink\" title=\"发布&#x2F;订阅模式\"></a>发布&#x2F;订阅模式</h4><p>通常我们调用的时候使用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Mono&lt;User&gt; mono = userServiceClient.getUser(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用户只写了 Consumer 回调，没有写 Subscriber</span></span><br><span class=\"line\">Disposable disposable=mono.subscribe(user -&gt; System.out.println(<span class=\"string\">&quot;Got user: &quot;</span> + user.getName()));</span><br></pre></td></tr></table></figure>\n\n<p>实际上框架内部会把我们传给subscribe的这个Consumer封装成一个subscriber，然后返回给你一个句柄类似的东西，你可以选择disposable.dispose()，就会停掉这个订阅者。</p>\n<p>subscriber是没有返回值的，因为响应式操作推荐流式传递和处理数据，如果有数据需要在获取后做转化，可以使用<code>map/flatMap</code>，flatMap是处理返回值为<code>Mono&lt;Mono&gt;</code>这种嵌套情况的，他会帮你自动展开，如下</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Mono&lt;User&gt; updatedMono =</span><br><span class=\"line\">        userMono.map(m -&gt; &#123;</span><br><span class=\"line\">            m.setId(<span class=\"number\">123</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> m; <span class=\"comment\">// ✅ 这里的 return 会进入下一个 Mono</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Mono&lt;Address&gt; addressMono = userMono.</span><br><span class=\"line\">flatMap(user -&gt; addressService.getAddress(user.getId()));</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>所有的流式操作都以<code>.subscribe()</code>作为起点开始真正的执行，中间的<code>map/doOnNext/doOnComplete</code>都是在做一些中间的操作，类似于声明式的Stream编程</p>\n<h3 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h3><p>项目中通过消息队列的方式通知进行报表的生成和拉取，这一部分是丢给线程池做的，由于年初的内部审查需求，大量部门发送了生成报表的请求，并被转发到listener，导致线程池的任务队列打满，无法向broker发送心跳</p>\n<h4 id=\"消费者组\"><a href=\"#消费者组\" class=\"headerlink\" title=\"消费者组\"></a>消费者组</h4><table>\n<thead>\n<tr>\n<th>功能</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>唯一消费</td>\n<td>组内每条消息只被一个消费者处理</td>\n</tr>\n<tr>\n<td>并行消费</td>\n<td>多个消费者同时消费多个分区，提高吞吐量</td>\n</tr>\n<tr>\n<td>弹性扩展</td>\n<td>增加消费者，自动分配更多分区</td>\n</tr>\n<tr>\n<td>容错</td>\n<td>消费者挂掉 → 分区被其他消费者接管</td>\n</tr>\n<tr>\n<td>广播消费</td>\n<td>不同消费者组可以独立消费同一主题，实现多业务逻辑处理</td>\n</tr>\n</tbody></table>\n<p>Kafka topic的分区数量是在创建topic的时候指定的，也可以通过java代码实现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">NewTopic newTopic = new NewTopic(topic, 3, (short) 1);</span><br><span class=\"line\">kafkaAdmin.createOrModifyTopics(newTopic);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Kafka如何保证信息不丢失\"><a href=\"#Kafka如何保证信息不丢失\" class=\"headerlink\" title=\"Kafka如何保证信息不丢失\"></a>Kafka如何保证信息不丢失</h4><ul>\n<li>生产者：</li>\n</ul>\n<ol>\n<li>配置ack&#x3D;all</li>\n<li>配置retry和超时时间</li>\n<li>配置enable.idempotence&#x3D;true</li>\n</ol>\n<ul>\n<li>消费者:</li>\n</ul>\n<ol>\n<li>手动提交commit，否则可能执行失败，但是自动commit了</li>\n<li>业务端设置乐观锁或者相关机制，保证只处理一次</li>\n</ol>\n<h4 id=\"Kafka的Offset是怎么管理的\"><a href=\"#Kafka的Offset是怎么管理的\" class=\"headerlink\" title=\"Kafka的Offset是怎么管理的\"></a>Kafka的Offset是怎么管理的</h4><ul>\n<li>存储位置：内部 Topic 存储，会周期性地将offset写入磁盘</li>\n<li>保存的形式：groupId + topic + partition → offset，就是每个消费组对每个topic的每个partion都会维护一个offset</li>\n<li>Springboot配置<code>enable-auto-commit=false</code>，并且自己配置一个<code>KafkaListenerContainerFactory</code>，设置其ackMode</li>\n</ul>\n<h4 id=\"消费者组-rebalance-是怎么发生的？\"><a href=\"#消费者组-rebalance-是怎么发生的？\" class=\"headerlink\" title=\"消费者组 rebalance 是怎么发生的？\"></a>消费者组 rebalance 是怎么发生的？</h4><ul>\n<li>触发条件</li>\n</ul>\n<ol>\n<li>消费者组成员变化：新消费者加入组&#x2F;消费者退出组（正常退出或崩溃）</li>\n<li>Topic 分区变化：Topic 增加或减少分区（一般增加，Kafka 不支持减少分区）</li>\n<li>会话超时：消费者在 session.timeout.ms 时间内未发送心跳给 Group Coordinator → 被认为死掉 → 触发 Rebalance</li>\n</ol>\n<h4 id=\"数据库事务和kafka事务合并\"><a href=\"#数据库事务和kafka事务合并\" class=\"headerlink\" title=\"数据库事务和kafka事务合并\"></a>数据库事务和kafka事务合并</h4><p>使用<code>ChainedTransactionManager</code>,在具体的处理方法上添加<code>@Transactional(transactionManager = &quot;chainedTransactionManager&quot;)</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">public ChainedTransactionManager chainedTransactionManager(</span><br><span class=\"line\">        PlatformTransactionManager dbTransactionManager,</span><br><span class=\"line\">        KafkaTransactionManager&lt;String, String&gt; kafkaTransactionManager) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    return new ChainedTransactionManager(dbTransactionManager, kafkaTransactionManager);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Kafka 延迟问题怎么排查？</li>\n</ul>\n<p>通过获取Kafka提供的API获取Kafka的Metrics，比如消息发送速率、请求发送耗时等</p>\n<h4 id=\"Kafka-生产者和消费者常用配置优化点？\"><a href=\"#Kafka-生产者和消费者常用配置优化点？\" class=\"headerlink\" title=\"Kafka 生产者和消费者常用配置优化点？\"></a>Kafka 生产者和消费者常用配置优化点？</h4><ul>\n<li>生产者：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>配置</th>\n<th>默认值</th>\n<th>优化建议</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>batch.size</code></td>\n<td>16 KB</td>\n<td>64~256 KB</td>\n<td>消息批量发送，增大可提高吞吐，但增大延迟</td>\n</tr>\n<tr>\n<td><code>linger.ms</code></td>\n<td>0</td>\n<td>5~50 ms</td>\n<td>等待更多消息组成 batch，增加吞吐但可能增加延迟</td>\n</tr>\n<tr>\n<td><code>compression.type</code></td>\n<td>none</td>\n<td>snappy &#x2F; lz4</td>\n<td>压缩减少网络和磁盘负载，提高吞吐</td>\n</tr>\n<tr>\n<td><code>acks</code></td>\n<td>1</td>\n<td>1 &#x2F; all</td>\n<td>1 延迟低，all 更可靠但吞吐略低</td>\n</tr>\n<tr>\n<td><code>max.in.flight.requests.per.connection</code></td>\n<td>5</td>\n<td>&lt;&#x3D; 5</td>\n<td>保证消息顺序，如果设置太大可能消息乱序</td>\n</tr>\n<tr>\n<td><code>buffer.memory</code></td>\n<td>32 MB</td>\n<td>64~256 MB</td>\n<td>内存缓冲区，避免发送堵塞</td>\n</tr>\n</tbody></table>\n<ul>\n<li>消费者：心跳间隔时间，手动&#x2F;自动提交</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>配置</th>\n<th>默认值</th>\n<th>优化建议</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>fetch.min.bytes</code></td>\n<td>1</td>\n<td>1 KB ~ 64 KB</td>\n<td>每次 poll 拉取最小数据量，减少网络请求</td>\n</tr>\n<tr>\n<td><code>fetch.max.bytes</code></td>\n<td>50 MB</td>\n<td>根据消息大小</td>\n<td>控制最大拉取数据，避免单次 poll 太大阻塞</td>\n</tr>\n<tr>\n<td><code>max.poll.records</code></td>\n<td>500</td>\n<td>500~2000</td>\n<td>一次 poll 拉取记录数，影响批量处理吞吐</td>\n</tr>\n<tr>\n<td><code>max.partition.fetch.bytes</code></td>\n<td>1 MB</td>\n<td>1~10 MB</td>\n<td>每个分区最大拉取量，配合批量处理优化</td>\n</tr>\n<tr>\n<td><code>fetch.max.wait.ms</code></td>\n<td>500</td>\n<td>10~100 ms</td>\n<td>拉取等待时间，平衡吞吐和延迟</td>\n</tr>\n</tbody></table>\n<h4 id=\"Kraft-x2F-raft\"><a href=\"#Kraft-x2F-raft\" class=\"headerlink\" title=\"Kraft&#x2F;raft\"></a>Kraft&#x2F;raft</h4><h5 id=\"Raft\"><a href=\"#Raft\" class=\"headerlink\" title=\"Raft\"></a>Raft</h5><p>Raft 是一种一致性算法，用于在分布式系统中维护一致的日志和状态。核心目标：</p>\n<ul>\n<li><p>Leader 选举：集群中选出一个 Leader 节点，处理客户端写请求</p>\n</li>\n<li><p>日志复制：Leader 接收到请求 → 写入本地日志 → 同步给 Followers → 达成一致</p>\n</li>\n<li><p>安全与容错：即使部分节点故障，只要大多数节点存活，系统依然可用<br>Followers 节点可以随时接收 Leader 日志复制</p>\n</li>\n</ul>\n<h4 id=\"副本同步机制\"><a href=\"#副本同步机制\" class=\"headerlink\" title=\"副本同步机制\"></a>副本同步机制</h4><ul>\n<li>数据写入时同步：根据ack的设置来</li>\n<li>follower定期拉取：拉取当前的log end offset </li>\n<li>ISR（In-Sync Replica）机制: Leader 只承认 ISR 中副本的数据为“已提交”（commit）</li>\n</ul>\n<h4 id=\"AppDynamic\"><a href=\"#AppDynamic\" class=\"headerlink\" title=\"AppDynamic\"></a>AppDynamic</h4><p>项目中在docker文件中配置java的启动命令，或者在lightspeed的web界面直接添加。</p>\n<p>流程是：</p>\n<ol>\n<li>kubectl创建一个namespace，并且把appd的相关controller、port等信息在其中创建secret</li>\n<li>应用的container启动前，先在initContainer的时候下载 agent.jar，然后挂载到目录上</li>\n<li>应用container启动的时候把上面的secret获取到作为环境变量</li>\n</ol>\n<figure class=\"highlight docker\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> openjdk:<span class=\"number\">17</span>-jdk-slim</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 复制你的 Spring Boot jar</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> target/myapp.jar /app/myapp.jar</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 复制 AppDynamics Agent</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> appdynamics-agent.jar /app/appdynamics-agent.jar</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 设置环境变量</span></span><br><span class=\"line\"><span class=\"keyword\">ENV</span> JAVA_OPTS=<span class=\"string\">&quot;-javaagent:/app/appdynamics-agent.jar \\</span></span><br><span class=\"line\"><span class=\"string\">-Dappdynamics.controller.hostName=controller.example.com \\</span></span><br><span class=\"line\"><span class=\"string\">-Dappdynamics.controller.port=8090 \\</span></span><br><span class=\"line\"><span class=\"string\">-Dappdynamics.agent.applicationName=MyApp \\</span></span><br><span class=\"line\"><span class=\"string\">-Dappdynamics.agent.tierName=Backend \\</span></span><br><span class=\"line\"><span class=\"string\">-Dappdynamics.agent.nodeName=Node1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 启动命令</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"bash\"> java <span class=\"variable\">$JAVA_OPTS</span> -jar /app/myapp.jar</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Seata\"><a href=\"#Seata\" class=\"headerlink\" title=\"Seata\"></a>Seata</h4><p>需要建立一个新的seata数据库，其中放global_table,branch_table,distributed_lock,lock_table</p>\n<p>我使用的是AT模式，所以会在我们业务库中创建一个undolog表，然后在需要分布式事务的地方增加@GlobalTransactional注解</p>\n<ol>\n<li>配置好tx_group和seata_server的地址,确保需要分布式事务的服务在一个group中</li>\n<li>再配置用Seata的DataSourceProxy代理datasource，要确认好用<code>Hikari</code>还是<code>Druid</code></li>\n<li>使用@GlobalTransactional</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>表名</th>\n<th>作用</th>\n<th>存储核心信息</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>global_table</code></td>\n<td>全局事务记录</td>\n<td>xid、全局事务状态、发起服务等</td>\n</tr>\n<tr>\n<td><code>branch_table</code></td>\n<td>分支事务记录</td>\n<td>xid、branch_id、资源、状态、锁键</td>\n</tr>\n<tr>\n<td><code>lock_table</code></td>\n<td>行级锁（AT 模式）</td>\n<td>row_key、xid、branch_id、锁状态</td>\n</tr>\n<tr>\n<td><code>distributed_lock</code></td>\n<td>TC 集群锁</td>\n<td>resource_id、xid、lock_owner</td>\n</tr>\n</tbody></table>\n<p>整个流程是：</p>\n<ol>\n<li>TM向TC申请一个XID，然后调用的时候传ID，涉及到global_transaction表</li>\n<li>TC收到XID之后，注册一个分支事务，涉及到branch_transaction表，并且记录undolog</li>\n<li>TM提交或者回滚的时候，告诉TC，TC会告诉RM</li>\n<li>RM收到通知也会提交&#x2F;回滚，然后删除undolog</li>\n</ol>\n<h4 id=\"XA协议的2PC和3PC（强一致性）\"><a href=\"#XA协议的2PC和3PC（强一致性）\" class=\"headerlink\" title=\"XA协议的2PC和3PC（强一致性）\"></a>XA协议的2PC和3PC（强一致性）</h4><p>引入事务协调者，管理各个微服务，每个微服务是一个事务参与者</p>\n<p>2PC：</p>\n<ul>\n<li>准备阶段： 协调者发送一个准备命令，每个事务参与者收到命令后，执行事务相关操作，但是不提交，然后参与者返回相应，告诉协调者是否准备成功</li>\n<li>提交阶段：如果所有参与者都准备成功，就给他们发送一个提交命令；如果有一个参与者准备失败，就发送一个回滚命令</li>\n</ul>\n<p>优点是利用数据库自身功能完成本地事务的提交和回滚，不侵入业务代码<br>缺点是：会阻塞其他相同的请求，因为事务没有提交的情况下，会进行加锁； 资源浪费，如果一个参与者是挂掉的，那么肯定是要回滚的，那之前执行的事务操作就是浪费</p>\n<p>3PC：</p>\n<ul>\n<li>准备阶段，判断是否每个参与者都正常运行，避免有人挂掉</li>\n<li>预提交阶段：协调者发送预提交命令，参与者收到后，就执行事务，但不提交，返回协调者是否准备成功</li>\n<li>提交阶段：如果全成功就提交，否则就回滚</li>\n</ul>\n<h4 id=\"AT模式（最终一致性）\"><a href=\"#AT模式（最终一致性）\" class=\"headerlink\" title=\"AT模式（最终一致性）\"></a>AT模式（最终一致性）</h4><p>Seeta最流行和最常用的事务模式。是基于Undo Log的最终一致性，undolog记录了数据的原始值（也就是数据快照），用于回滚数据。</p>\n<ul>\n<li>第一阶段：每个参与者直接执行事务相关操作，并且直接提交，同时把事务的原始值记录在undolog中</li>\n<li>第二阶段：协调者根据所有参与者的执行结果，如果全成功，就通知参与者异步删除undolog；如果有人失败，就通知参与者根据undolog恢复数据并且删除undolog</li>\n</ul>\n<h4 id=\"Seata-的事务角色有哪些？\"><a href=\"#Seata-的事务角色有哪些？\" class=\"headerlink\" title=\"Seata 的事务角色有哪些？\"></a>Seata 的事务角色有哪些？</h4><ul>\n<li>TC (Transaction Coordinator，事务协调器)： 一般是单独部署的 Seata Server</li>\n<li>TM (Transaction Manager，事务管理器)：事务的“发起人”，向 TC 发起开启&#x2F;提交&#x2F;回滚全局事务的请求；</li>\n<li>RM (Resource Manager，资源管理器)：事务的“执行者”，向 TC 注册分支事务，根据 TC 的指令提交或回滚本地事务。</li>\n</ul>\n<h4 id=\"Seata-如何保证幂等性和防悬挂？\"><a href=\"#Seata-如何保证幂等性和防悬挂？\" class=\"headerlink\" title=\"Seata 如何保证幂等性和防悬挂？\"></a>Seata 如何保证幂等性和防悬挂？</h4><ul>\n<li>幂等：当TM提交或者回滚的时候，TC会通知所有的RM，但是由于网络波动，TC没有收到RM的响应,TC会重试，就会导致重复提交；RM会判断branch_id对应的undolog的状态，已经完成就说明执行过了，就不会再执行了。</li>\n<li>防悬挂：RM已经使用了逻辑行级锁来保证在RM分支事务执行期间，别的分支事务不能更改这一行，但是无法防止其他的业务的事务修改这一行，会导致undo的时候覆盖掉别人的修改。</li>\n</ul>\n<h4 id=\"Seata-Undo-Log-如何避免膨胀？\"><a href=\"#Seata-Undo-Log-如何避免膨胀？\" class=\"headerlink\" title=\"Seata Undo Log 如何避免膨胀？\"></a>Seata Undo Log 如何避免膨胀？</h4><p>undolog里面记录的是事务前和事务后的数据，所以回滚也是固定回滚到事务前。可以配置seata固定时间删除undolog</p>\n<h3 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h3><h4 id=\"三大日志\"><a href=\"#三大日志\" class=\"headerlink\" title=\"三大日志\"></a>三大日志</h4><ul>\n<li>binlog: 主从复制（Replication）;从库通过读取主库的 binlog 来同步数据。属于mysql级别的</li>\n<li>redolog: 崩溃恢复时只重做已提交事务，数据库崩溃后，可以通过 redo log 恢复 最新的数据页。是几个文件循环写入的，属于InnoDB级别的</li>\n<li>undolog：事务回滚日志，用于回滚事务和MVCC</li>\n</ul>\n<p>事务提交三阶段</p>\n<ol>\n<li><p>写 redo log（prepare 阶段）。</p>\n</li>\n<li><p>写 binlog（commit 阶段）。</p>\n</li>\n<li><p>redo log 标记为 commit。</p>\n</li>\n</ol>\n<p>这样保证了：</p>\n<p>崩溃时，如果 redo log 有 prepare 但 binlog 没有 commit，事务会回滚，保证主从一致。</p>\n<p>崩溃时，如果 redo log 和 binlog 都写了，重启时就能用 redo log 恢复事务，保证不丢数据。</p>\n<h4 id=\"分库分表\"><a href=\"#分库分表\" class=\"headerlink\" title=\"分库分表\"></a>分库分表</h4><ul>\n<li>为什么要分库分表</li>\n</ul>\n<ol>\n<li>单库单表数据量太大，查询&#x2F;写入性能下降。</li>\n<li>单机磁盘、内存不足。</li>\n<li>高并发下锁冲突严重，无法支撑业务。</li>\n</ol>\n<ul>\n<li>分库和分表的区别</li>\n</ul>\n<ol>\n<li>分表：把一张表的数据拆成多张表，通常还是在同一个数据库实例里。解决的是 <strong>单表数据量过大</strong> 的问题。</li>\n<li>分库：把数据拆到不同的数据库实例，解决的是 <strong>数据库实例本身性能瓶颈</strong>（IO&#x2F;CPU&#x2F;存储）。</li>\n</ol>\n<ul>\n<li>分库分表常见方式</li>\n</ul>\n<ol>\n<li>水平拆分：按照某个字段取模、范围、哈希，把数据分散存储。</li>\n<li>垂直拆分：按照业务&#x2F;表的功能，把不同表放到不同库里。</li>\n</ol>\n<ul>\n<li>分库分表后的挑战</li>\n</ul>\n<ol>\n<li>跨库 join（需要应用层聚合）： 两个表在一个库，可以直接执行；不在一个库，分别去两个库查询，在应用层进行join或者聚合操作</li>\n<li>主键唯一性：可以用shardingsphere自带的分布式id生成器</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">t_order:</span><br><span class=\"line\">  key-generator:</span><br><span class=\"line\">    column: order_id</span><br><span class=\"line\">    type: SNOWFLAKE 使用snowflake生成主键id</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>数据迁移、扩容（需要数据迁移方案，避免热点）。</p>\n</li>\n<li><p>扩容怎么做</p>\n</li>\n</ul>\n<ol>\n<li>一开始一般选 2 的倍数个分片，比如 4 库 16 表。</li>\n<li>扩容时一般采用 双写 + 数据迁移 + 平滑切换 的方案。</li>\n</ol>\n<h4 id=\"路由ID（分片键）\"><a href=\"#路由ID（分片键）\" class=\"headerlink\" title=\"路由ID（分片键）\"></a>路由ID（分片键）</h4><p>在分库分表时，用来决定数据存储到哪个库、哪个表的字段</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 假设有 4 个库，每库 8 张表</span><br><span class=\"line\">int dbCount = 4;</span><br><span class=\"line\">int tableCount = 8;</span><br><span class=\"line\"></span><br><span class=\"line\">long userId = 123456789L;</span><br><span class=\"line\">int dbIndex = (int)(userId % dbCount);           // 决定库</span><br><span class=\"line\">int tableIndex = (int)(userId / dbCount % tableCount); // 决定表</span><br><span class=\"line\">String tableName = &quot;order_&quot; + dbIndex + &quot;_&quot; + tableIndex;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"ShardingSphere\"><a href=\"#ShardingSphere\" class=\"headerlink\" title=\"ShardingSphere\"></a>ShardingSphere</h5><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"attr\">shardingsphere:</span></span><br><span class=\"line\">    <span class=\"attr\">datasource:</span></span><br><span class=\"line\">      <span class=\"attr\">names:</span> <span class=\"string\">ds0,</span> <span class=\"string\">ds1</span></span><br><span class=\"line\">      <span class=\"attr\">ds0:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">com.zaxxer.hikari.HikariDataSource</span></span><br><span class=\"line\">        <span class=\"attr\">jdbc-url:</span> <span class=\"string\">jdbc:mysql://localhost:3306/db0</span></span><br><span class=\"line\">        <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">        <span class=\"attr\">password:</span> <span class=\"number\">123456</span></span><br><span class=\"line\">      <span class=\"attr\">ds1:</span></span><br><span class=\"line\">        <span class=\"attr\">type:</span> <span class=\"string\">com.zaxxer.hikari.HikariDataSource</span></span><br><span class=\"line\">        <span class=\"attr\">jdbc-url:</span> <span class=\"string\">jdbc:mysql://localhost:3306/db1</span></span><br><span class=\"line\">        <span class=\"attr\">username:</span> <span class=\"string\">root</span></span><br><span class=\"line\">        <span class=\"attr\">password:</span> <span class=\"number\">123456</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attr\">rules:</span></span><br><span class=\"line\">      <span class=\"attr\">sharding:</span></span><br><span class=\"line\">        <span class=\"attr\">tables:</span></span><br><span class=\"line\">          <span class=\"attr\">t_order:</span></span><br><span class=\"line\">            <span class=\"attr\">actual-data-nodes:</span> <span class=\"string\">ds$-&gt;&#123;0..1&#125;.t_order_$-&gt;&#123;0..3&#125;</span></span><br><span class=\"line\">            <span class=\"attr\">table-strategy:</span></span><br><span class=\"line\">              <span class=\"attr\">standard:</span></span><br><span class=\"line\">                <span class=\"attr\">sharding-column:</span> <span class=\"string\">user_id</span> <span class=\"string\">//</span> <span class=\"string\">选择路由id</span></span><br><span class=\"line\">                <span class=\"attr\">sharding-algorithm-name:</span> <span class=\"string\">order-inline</span> <span class=\"string\">//</span> <span class=\"string\">选择映射算法</span></span><br><span class=\"line\">        <span class=\"attr\">sharding-algorithms:</span></span><br><span class=\"line\">            <span class=\"attr\">order-inline:</span></span><br><span class=\"line\">                <span class=\"attr\">type:</span> <span class=\"string\">INLINE</span></span><br><span class=\"line\">                <span class=\"attr\">props:</span></span><br><span class=\"line\">                <span class=\"attr\">algorithm-expression:</span> <span class=\"string\">t_order_$-&gt;&#123;user_id</span> <span class=\"string\">%</span> <span class=\"number\">4</span><span class=\"string\">&#125;</span> <span class=\"string\">//</span> <span class=\"string\">表映射算法实际执行</span></span><br><span class=\"line\">            <span class=\"attr\">db-inline:</span></span><br><span class=\"line\">                <span class=\"attr\">type:</span> <span class=\"string\">INLINE</span></span><br><span class=\"line\">                <span class=\"attr\">props:</span></span><br><span class=\"line\">                <span class=\"attr\">algorithm-expression:</span> <span class=\"string\">ds$-&gt;&#123;user_id</span> <span class=\"string\">%</span> <span class=\"number\">2</span><span class=\"string\">&#125;</span> <span class=\"string\">//</span> <span class=\"string\">库映射算法</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"定时任务-x2F-定间隔任务\"><a href=\"#定时任务-x2F-定间隔任务\" class=\"headerlink\" title=\"定时任务&#x2F;定间隔任务\"></a>定时任务&#x2F;定间隔任务</h3><p>使用Quartz进行定时任务的持久化，防止任务丢失</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 任务的执行逻辑</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MonitoringJob</span> <span class=\"keyword\">implements</span> <span class=\"title\">Job</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MonitoringRepository monitoringRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AlertService alertService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> ExternalDataService externalDataService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(JobExecutionContext context)</span> <span class=\"keyword\">throws</span> JobExecutionException </span>&#123;</span><br><span class=\"line\">        JobDataMap dataMap = context.getMergedJobDataMap();</span><br><span class=\"line\">        String controlId = dataMap.getString(<span class=\"string\">&quot;controlId&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 读取最新 Monitoring 配置</span></span><br><span class=\"line\">        Monitoring monitoring = monitoringRepository.findByControlId(controlId);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (monitoring == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> alertFlag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (monitoring.getDataSourceType()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> API:</span><br><span class=\"line\">                <span class=\"keyword\">double</span> value = externalDataService.getMetric(monitoring.getDataSourceApi(), monitoring.getMetricName());</span><br><span class=\"line\">                alertFlag = value &gt; monitoring.getThreshold();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> FILE:</span><br><span class=\"line\">                <span class=\"keyword\">double</span> fileValue = externalDataService.parseReport(monitoring.getReportPath(), monitoring.getMetricName());</span><br><span class=\"line\">                alertFlag = fileValue &gt; monitoring.getThreshold();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> SELF_ASSESSMENT:</span><br><span class=\"line\">                <span class=\"keyword\">double</span> userValue = monitoring.getLastSelfAssessmentValue();</span><br><span class=\"line\">                alertFlag = userValue &gt; monitoring.getThreshold();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        monitoring.setLastRun(LocalDateTime.now());</span><br><span class=\"line\">        monitoring.setAlertFlag(alertFlag);</span><br><span class=\"line\">        monitoringRepository.save(monitoring);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (alertFlag) alertService.sendAlert(monitoring);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Monitoring executed for Control: &quot;</span> + controlId + <span class=\"string\">&quot;, alert: &quot;</span> + alertFlag);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Quartz任务管理</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QuartzMonitoringService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Scheduler scheduler;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建或更新任务</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">createMonitoringTask</span><span class=\"params\">(Control control)</span> <span class=\"keyword\">throws</span> SchedulerException </span>&#123;</span><br><span class=\"line\">        JobKey jobKey = JobKey.jobKey(<span class=\"string\">&quot;MonitoringJob_&quot;</span> + control.getId());</span><br><span class=\"line\">        TriggerKey triggerKey = TriggerKey.triggerKey(<span class=\"string\">&quot;MonitoringTrigger_&quot;</span> + control.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 删除旧任务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scheduler.checkExists(jobKey)) &#123;</span><br><span class=\"line\">            scheduler.deleteJob(jobKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        JobDetail jobDetail = JobBuilder.newJob(MonitoringJob.class)</span><br><span class=\"line\">                .withIdentity(jobKey)</span><br><span class=\"line\">                .usingJobData(<span class=\"string\">&quot;controlId&quot;</span>, control.getId())</span><br><span class=\"line\">                .build();</span><br><span class=\"line\"></span><br><span class=\"line\">        CronTrigger trigger = TriggerBuilder.newTrigger()</span><br><span class=\"line\">                .withIdentity(triggerKey)</span><br><span class=\"line\">                .withSchedule(CronScheduleBuilder.cronSchedule(convertFrequencyToCron(control.getMonitoringFrequency())))</span><br><span class=\"line\">                .build();</span><br><span class=\"line\"></span><br><span class=\"line\">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Scheduled Monitoring Job for Control: &quot;</span> + control.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">convertFrequencyToCron</span><span class=\"params\">(String frequency)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (frequency.toLowerCase()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;monthly&quot;</span>: <span class=\"keyword\">return</span> <span class=\"string\">&quot;0 0 2 1 * ?&quot;</span>; <span class=\"comment\">// 每月 1 号凌晨2点</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;weekly&quot;</span>: <span class=\"keyword\">return</span> <span class=\"string\">&quot;0 0 2 ? * MON&quot;</span>; <span class=\"comment\">// 每周一凌晨2点</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;daily&quot;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> <span class=\"string\">&quot;0 0 2 * * ?&quot;</span>; <span class=\"comment\">// 每天凌晨2点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除任务</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteMonitoringTask</span><span class=\"params\">(String controlId)</span> <span class=\"keyword\">throws</span> SchedulerException </span>&#123;</span><br><span class=\"line\">        JobKey jobKey = JobKey.jobKey(<span class=\"string\">&quot;MonitoringJob_&quot;</span> + controlId);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (scheduler.checkExists(jobKey)) &#123;</span><br><span class=\"line\">            scheduler.deleteJob(jobKey);</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Deleted Monitoring Job for Control: &quot;</span> + controlId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JBPM\"><a href=\"#JBPM\" class=\"headerlink\" title=\"JBPM\"></a>JBPM</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个Process</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ControlWorkflowService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RuntimeManager runtimeManager;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TaskService taskService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">startControlProcess</span><span class=\"params\">(ControlDto controlDto)</span> </span>&#123;</span><br><span class=\"line\">        RuntimeEngine engine = runtimeManager.getRuntimeEngine(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        RuntimeEngine sessionEngine = engine;</span><br><span class=\"line\">        KieSession ksession = sessionEngine.getKieSession();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 流程参数</span></span><br><span class=\"line\">        Map&lt;String, Object&gt; params = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;controlId&quot;</span>, controlDto.getId());</span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;creator&quot;</span>, controlDto.getCreator());</span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;monitoringApprover&quot;</span>, controlDto.getMonitoringApprover());</span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;testingApprover&quot;</span>, controlDto.getTestingApprover());</span><br><span class=\"line\">        params.put(<span class=\"string\">&quot;ibrcApprover&quot;</span>, controlDto.getIbrcApprover());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建流程实例</span></span><br><span class=\"line\">        WorkflowProcessInstance processInstance = (WorkflowProcessInstance)</span><br><span class=\"line\">                ksession.startProcess(<span class=\"string\">&quot;ControlCreationProcess&quot;</span>, params);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 手动创建 Monitoring &amp; Testing 任务</span></span><br><span class=\"line\">        createUserTask(<span class=\"string\">&quot;MonitoringCreation&quot;</span>, <span class=\"string\">&quot;MonitoringCreationTask&quot;</span>, controlDto.getMonitoringApprover(), processInstance.getId());</span><br><span class=\"line\">        createUserTask(<span class=\"string\">&quot;TestingCreation&quot;</span>, <span class=\"string\">&quot;TestingCreationTask&quot;</span>, controlDto.getTestingApprover(), processInstance.getId());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> processInstance.getId();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createUserTask</span><span class=\"params\">(String name, String taskName, String assignee, <span class=\"keyword\">long</span> processInstanceId)</span> </span>&#123;</span><br><span class=\"line\">        Task task = taskService.newTask();</span><br><span class=\"line\">        task.setName(taskName);</span><br><span class=\"line\">        task.setPriority(<span class=\"number\">1</span>);</span><br><span class=\"line\">        task.setProcessInstanceId(processInstanceId);</span><br><span class=\"line\">        task.setTaskData(<span class=\"keyword\">new</span> TaskData());</span><br><span class=\"line\">        task.setPeopleAssignments(<span class=\"keyword\">new</span> PeopleAssignments());</span><br><span class=\"line\">        task.getPeopleAssignments().setPotentialOwners(Collections.singletonList(<span class=\"keyword\">new</span> User(assignee)));</span><br><span class=\"line\"></span><br><span class=\"line\">        taskService.addTask(task, <span class=\"keyword\">new</span> HashMap&lt;&gt;());</span><br><span class=\"line\">        System.out.println(name + <span class=\"string\">&quot; Task created for &quot;</span> + assignee);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 完成任务</span></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkflowTaskService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TaskService taskService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">completeTask</span><span class=\"params\">(Long taskId, String userId, Map&lt;String, Object&gt; results)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 必须由指定 approver 完成</span></span><br><span class=\"line\">        Task task = taskService.getTaskById(taskId);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!task.getPeopleAssignments().getPotentialOwners().stream()</span><br><span class=\"line\">                .anyMatch(u -&gt; u.getId().equals(userId))) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;User &quot;</span> + userId + <span class=\"string\">&quot; is not the approver for this task&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 领取任务</span></span><br><span class=\"line\">        taskService.claim(taskId, userId);</span><br><span class=\"line\">        taskService.start(taskId, userId);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 完成任务</span></span><br><span class=\"line\">        taskService.complete(taskId, userId, results);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Task &quot;</span> + taskId + <span class=\"string\">&quot; completed by &quot;</span> + userId);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果两个并行任务完成，则生成 IBRC Review</span></span><br><span class=\"line\">        checkAndCreateIBRCReview(task.getProcessInstanceId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">checkAndCreateIBRCReview</span><span class=\"params\">(<span class=\"keyword\">long</span> processInstanceId)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Task&gt; tasks = taskService.createTaskQuery()</span><br><span class=\"line\">                .processInstanceId(processInstanceId)</span><br><span class=\"line\">                .list();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> monitoringDone = tasks.stream().noneMatch(t -&gt; t.getName().equals(<span class=\"string\">&quot;MonitoringCreationTask&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> testingDone = tasks.stream().noneMatch(t -&gt; t.getName().equals(<span class=\"string\">&quot;TestingCreationTask&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (monitoringDone &amp;&amp; testingDone) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建 IBRC Review Task</span></span><br><span class=\"line\">            Task ibrcTask = taskService.newTask();</span><br><span class=\"line\">            ibrcTask.setName(<span class=\"string\">&quot;IBRCReviewTask&quot;</span>);</span><br><span class=\"line\">            ibrcTask.setProcessInstanceId(processInstanceId);</span><br><span class=\"line\">            ibrcTask.setPriority(<span class=\"number\">1</span>);</span><br><span class=\"line\">            ibrcTask.setPeopleAssignments(<span class=\"keyword\">new</span> PeopleAssignments());</span><br><span class=\"line\">            <span class=\"comment\">// 这里假设 ibrcApprover 存在于流程参数中</span></span><br><span class=\"line\">            String ibrcApprover = <span class=\"string\">&quot;ibrc_user&quot;</span>; <span class=\"comment\">// 可从流程实例参数读取</span></span><br><span class=\"line\">            ibrcTask.getPeopleAssignments().setPotentialOwners(Collections.singletonList(<span class=\"keyword\">new</span> User(ibrcApprover)));</span><br><span class=\"line\"></span><br><span class=\"line\">            taskService.addTask(ibrcTask, <span class=\"keyword\">new</span> HashMap&lt;&gt;());</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;IBRC Review Task created for &quot;</span> + ibrcApprover);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"AI\"><a href=\"#AI\" class=\"headerlink\" title=\"AI\"></a>AI</h3><ul>\n<li><p>用LlamaParser来解决pdf提取成RAG的问题</p>\n</li>\n<li><p>MCP的开发，使用SPringAI可以开发两种模式的MCP</p>\n</li>\n</ul>\n<ol>\n<li>stdio: @Tool指定工具description@TooParameter指定工具参数的description，然后以把工具类注册到<code>ToolCallBackProvider</code>中jar包的形式进行读取，并且要把spring main方法的wei应用设置为false</li>\n<li>sse mcp：基本代码与stdio一致，只是调用的时候需要用http或者sse的方式调用</li>\n</ol>\n"}]