<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="-jCet6qPD7nML4-W6IY2HZwfSblJyWta_Jx7_AGHgIk">
  <meta name="baidu-site-verification" content="f349dc627a72ee616d62ed513574025d">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/orange/pace-theme-center-circle.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"weirdozz.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="gRPC如何生成代码 客户端上会有一个存根，提供和服务器上相同的方法，由gRPC自动生成。当调用其中方法的时候，存根会在后台调用gRPC框架，通过网络与服务器交换信息。">
<meta property="og:type" content="article">
<meta property="og:title" content="gRPC基础学习">
<meta property="og:url" content="https://weirdozz.github.io/2022/04/26/gRPC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Weirdo">
<meta property="og:description" content="gRPC如何生成代码 客户端上会有一个存根，提供和服务器上相同的方法，由gRPC自动生成。当调用其中方法的时候，存根会在后台调用gRPC框架，通过网络与服务器交换信息。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.imgur.com/CpGtllp.png">
<meta property="article:published_time" content="2022-04-26T10:53:06.000Z">
<meta property="article:modified_time" content="2022-05-30T11:19:44.205Z">
<meta property="article:author" content="Weirdo">
<meta property="article:tag" content="RPC框架">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.imgur.com/CpGtllp.png">


<link rel="canonical" href="https://weirdozz.github.io/2022/04/26/gRPC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://weirdozz.github.io/2022/04/26/gRPC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","path":"2022/04/26/gRPC基础学习/","title":"gRPC基础学习"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>gRPC基础学习 | Weirdo</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Weirdo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-film fa-fw"></i>电影</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书籍</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#gRPC%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81"><span class="nav-number">1.</span> <span class="nav-text">gRPC如何生成代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gRPC%E7%9A%84%E7%A7%98%E5%AF%86%E6%AD%A6%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">gRPC的秘密武器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9HTTP-2"><span class="nav-number">2.1.</span> <span class="nav-text">为什么选择HTTP&#x2F;2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-2%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">HTTP&#x2F;2工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-2%E5%92%8CHTTP-1-1"><span class="nav-number">2.3.</span> <span class="nav-text">HTTP&#x2F;2和HTTP&#x2F;1.1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gRPC%E5%92%8CREST%EF%BC%8C%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8gRPC"><span class="nav-number">3.</span> <span class="nav-text">gRPC和REST，何时使用gRPC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89protobuf%E5%B9%B6%E4%B8%94%E7%94%9F%E6%88%90go%E4%BB%A3%E7%A0%81"><span class="nav-number">4.</span> <span class="nav-text">定义protobuf并且生成go代码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89CPU%E6%B6%88%E6%81%AF"><span class="nav-number">4.1.</span> <span class="nav-text">定义CPU消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99Makefile"><span class="nav-number">4.2.</span> <span class="nav-text">编写Makefile</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E7%BC%93%E5%86%B2%E5%8C%BA%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6"><span class="nav-number">5.</span> <span class="nav-text">协议缓冲区深入研究</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%9D%A1%E6%B6%88%E6%81%AF"><span class="nav-number">5.1.</span> <span class="nav-text">一个文件中的多条消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%9A%E6%B6%88%E6%81%AF%E5%92%8C%E6%9E%9A%E4%B8%BE"><span class="nav-number">5.2.</span> <span class="nav-text">自定义类型：消息和枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%AD%98%E5%82%A8%E6%B6%88%E6%81%AF"><span class="nav-number">5.3.</span> <span class="nav-text">定义存储消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E9%94%AE%E7%9B%98%E6%B6%88%E6%81%AF"><span class="nav-number">5.4.</span> <span class="nav-text">定义键盘消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%B1%8F%E5%B9%95%E6%B6%88%E6%81%AF"><span class="nav-number">5.5.</span> <span class="nav-text">定义屏幕消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E6%B6%88%E6%81%AF"><span class="nav-number">5.6.</span> <span class="nav-text">定义笔记本电脑消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8GO%E4%B8%AD%E7%94%9F%E6%88%90%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96protobuf%E6%B6%88%E6%81%AF"><span class="nav-number">6.</span> <span class="nav-text">在GO中生成和序列化protobuf消息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E9%94%AE%E7%9B%98"><span class="nav-number">6.1.</span> <span class="nav-text">生成随机键盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BAcpu"><span class="nav-number">6.2.</span> <span class="nav-text">生成随机cpu</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA-GPU"><span class="nav-number">6.3.</span> <span class="nav-text">生成随机 GPU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA-RAM"><span class="nav-number">6.4.</span> <span class="nav-text">生成随机 RAM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%82%A8"><span class="nav-number">6.5.</span> <span class="nav-text">生成随机存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E5%B1%8F%E5%B9%95"><span class="nav-number">6.6.</span> <span class="nav-text">生成随机屏幕</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91"><span class="nav-number">6.7.</span> <span class="nav-text">生成随机笔记本电脑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96-protobuf-%E6%B6%88%E6%81%AF"><span class="nav-number">6.8.</span> <span class="nav-text">序列化 protobuf 消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86-protobuf-%E6%B6%88%E6%81%AF%E5%86%99%E5%85%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="nav-number">6.9.</span> <span class="nav-text">将 protobuf 消息写入二进制文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96-protobuf-%E6%B6%88%E6%81%AF"><span class="nav-number">6.10.</span> <span class="nav-text">从二进制文件中读取 protobuf 消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86-protobuf-%E6%B6%88%E6%81%AF%E5%86%99%E5%85%A5-JSON-%E6%96%87%E4%BB%B6"><span class="nav-number">6.11.</span> <span class="nav-text">将 protobuf 消息写入 JSON 文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8go%E4%B8%AD%E7%94%9F%E6%88%90%E4%B8%80%E5%85%83gRPC-API"><span class="nav-number">7.</span> <span class="nav-text">在go中生成一元gRPC API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA-proto-%E6%9C%8D%E5%8A%A1%E5%92%8C%E4%B8%80%E4%B8%AA%E4%B8%80%E5%85%83-RPC"><span class="nav-number">7.1.</span> <span class="nav-text">定义一个 proto 服务和一个一元 RPC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%B8%80%E5%85%83-RPC-%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81"><span class="nav-number">7.2.</span> <span class="nav-text">为一元 RPC 生成代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%B8%80%E5%85%83-RPC-%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">7.3.</span> <span class="nav-text">实现服务器的一元 RPC 处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E7%AC%94%E8%AE%B0%E6%9C%AC%E4%BF%A1%E6%81%AF%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD"><span class="nav-number">7.4.</span> <span class="nav-text">将笔记本信息保存在内存中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E4%B8%80%E5%85%83-RPC-%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">7.5.</span> <span class="nav-text">测试一元 RPC 处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E7%9C%9F%E5%AE%9E%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95%E4%B8%80%E5%85%83-RPC"><span class="nav-number">7.6.</span> <span class="nav-text">用真实连接测试一元 RPC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">7.7.</span> <span class="nav-text">编写主服务器和客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-Go-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%81%E5%BC%8F-gRPC"><span class="nav-number">8.</span> <span class="nav-text">在 Go 中实现服务器流式 gRPC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B5%81%E5%BC%8F-RPC-%E5%AE%9A%E4%B9%89%E6%B7%BB%E5%8A%A0%E5%88%B0-Protobuf"><span class="nav-number">8.1.</span> <span class="nav-text">将服务器流式 RPC 定义添加到 Protobuf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E4%B8%AD"><span class="nav-number">8.2.</span> <span class="nav-text">将搜索功能添加到内存存储中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">8.3.</span> <span class="nav-text">实现服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">8.4.</span> <span class="nav-text">实现客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E5%BC%8F-gRPC-%E5%88%86%E5%9D%97%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6-Go"><span class="nav-number">9.</span> <span class="nav-text">使用客户端流式 gRPC 分块上传文件 - Go</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8proto%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89client-streaming-RPC"><span class="nav-number">9.1.</span> <span class="nav-text">在proto文件中定义client-streaming RPC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%99%A8-2"><span class="nav-number">9.2.</span> <span class="nav-text">实现服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%AD%98%E5%82%A8"><span class="nav-number">9.2.1.</span> <span class="nav-text">实现图片存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-UploadImage-RPC"><span class="nav-number">9.2.2.</span> <span class="nav-text">实现 UploadImage RPC</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Weirdo"
      src="/images/weirdo.jpg">
  <p class="site-author-name" itemprop="name">Weirdo</p>
  <div class="site-description" itemprop="description">怕什么真理无穷，进一步有进一步的欢喜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weirdozz.github.io/2022/04/26/gRPC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/weirdo.jpg">
      <meta itemprop="name" content="Weirdo">
      <meta itemprop="description" content="怕什么真理无穷，进一步有进一步的欢喜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weirdo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          gRPC基础学习
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-26 18:53:06" itemprop="dateCreated datePublished" datetime="2022-04-26T18:53:06+08:00">2022-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-30 19:19:44" itemprop="dateModified" datetime="2022-05-30T19:19:44+08:00">2022-05-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/04/26/gRPC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/04/26/gRPC基础学习/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="gRPC如何生成代码">gRPC如何生成代码</h2>
<p>客户端上会有一个存根，提供和服务器上相同的方法，由gRPC自动生成。当调用其中方法的时候，存根会在后台调用gRPC框架，通过网络与服务器交换信息。</p>
<p><img src="https://i.imgur.com/CpGtllp.png" alt="picture 1"></p>
<span id="more"></span>
<p>为了服务器和客户端能够生成存根，我们首先需要写一个API的契约，在一个protocol buffer中编写服务及其有效负载的描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">syntax=&quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package proto;</span><br><span class="line"></span><br><span class="line">service Greeter&#123;</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;;</span><br><span class="line">  rpc SayList (HelloRequest) returns (stream HelloReply) &#123;&#125;;</span><br><span class="line">  rpc SayRecord (stream HelloRequest) returns (HelloReply) &#123;&#125;;</span><br><span class="line">  rpc SayRoute(stream HelloRequest) returns (stream HelloReply);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloRequest&#123;</span><br><span class="line">  string name=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloReply&#123;</span><br><span class="line">  string message=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个proto文件中，服务器和客户端的存根通过协议缓冲区编译器（protoc）生成。根据编程语言的不同，需要告诉编译器使用正确的gRPC插件。</p>
<h2 id="gRPC的秘密武器">gRPC的秘密武器</h2>
<h3 id="为什么选择HTTP-2">为什么选择HTTP/2</h3>
<p>gRPC 使用 HTTP/2 作为其传输协议，因此它继承了 HTTP/2 提供的一些强大功能，例如二进制帧，与其他基于文本的协议相比，它具有高性能和健壮、传输更轻、解码更安全。而且因为它是二进制的，所以它与协议缓冲区是一个很好的组合。</p>
<p>在 HTTP/2 中可以进行多路复用，这意味着客户端和服务器可以通过单个 TCP 连接并行发送多个请求和响应。这将有助于减少延迟并提高网络利用率。</p>
<p>HTTP/2 还使用 HPACK 压缩标头，这将降低开销成本并提高性能。</p>
<p>最后，HTTP/2 允许服务器推送，其中来自客户端的 1 个请求，服务器可以发送回多个响应。在许多情况下，当服务器确切地知道客户端需要什么资源并在它们被请求之前发送它们时，这对于减少客户端和服务器之间的往返延迟非常有价值。</p>
<p>可以用这个演示来看HTTP/2比1.1快多少<a target="_blank" rel="noopener" href="http://www.http2demo.io/">速度比较链接</a></p>
<h3 id="HTTP-2工作原理">HTTP/2工作原理</h3>
<p>有一个 TCP 连接可以承载多个双向流。每个流都有一个唯一的标识符，并携带多个双向消息。</p>
<p>每条消息，可以是请求或响应，都被分解成多个二进制帧。帧是承载不同类型数据的最小单位，例如 HEADERS、SETTINGS、PRIORITY、DATA 等。</p>
<p>事实上，这些流实际上并没有单独流动，而是它们的帧在连接上交错，到达另一端时会重新组合。多亏了这个二进制成帧层，HTTP/2 中的流多路复用成为可能。</p>
<h3 id="HTTP-2和HTTP-1-1">HTTP/2和HTTP/1.1</h3>
<ul>
<li>2是二进制协议，1是文本协议</li>
<li>2中会压缩标头，1中是纯文本</li>
<li>2允许多路复用，1不允许</li>
<li>2中可以在单个连接中发多个请求和响应，1中只能一个</li>
<li>服务器推送可以用2，但不能用1</li>
</ul>
<h2 id="gRPC和REST，何时使用gRPC">gRPC和REST，何时使用gRPC</h2>
<p>gRPC 使用 Protocol Buffer 来序列化有效载荷数据，它是二进制的，更小，而 REST 使用 JSON，它是文本，更大。</p>
<p>gRPC 中的 API 契约是严格的，需要在 proto 文件中明确定义。在 REST 中，它通常是松散的和可选的。如果需要，我们可以通过 OpenAPI 定义它，但这不是强制性的。</p>
<p>gRPC 和 REST 通信都使用 TLS/SSL 保护。</p>
<p>流式传输在 gRPC 中是双向的，而在 REST 中只有一种方式从客户端到服务器的请求。</p>
<p>因此，对于我们迄今为止提到的大多数事情，gRPC 都比 REST 更好。然而，有一件事是 REST 还是更好的，</p>
<p>那是浏览器支持。虽然所有浏览器都完全支持 REST，但对 gRPC 的支持是有限的，并且需要带有代理层的gRPC-web在 HTTP/1 和 HTTP/2 之间进行转换。</p>
<p>微服务是 gRPC 真正闪耀的地方，因为它支持低延迟和高吞吐量的通信，以及强大的 API 合约。</p>
<p>gRPC 也适用于多语言环境，因为它为许多编程语言提供了开箱即用的代码生成。</p>
<p>点对点实时通信也是 gRPC 的一个好地方，因为它对双向流有很好的支持。</p>
<p>最后，gRPC 是移动应用程序 (android/ios) 等网络受限环境的绝佳选择，因为它具有轻量级的消息格式。</p>
<h2 id="定义protobuf并且生成go代码">定义protobuf并且生成go代码</h2>
<p>注意消息的名字应该是UpperCamelCase，字段的名字应该是lower_snake_case。</p>
<p>我们可以使用许多内置的标量值数据类型，例如：string、bool、byte、float、double和许多其他整数类型。我们还可以使用我们自己的数据类型，例如枚举或其他消息。</p>
<p>每个消息字段都应该分配一个唯一的标签。并且标签比字段名更重要，因为 protobuf 将使用它来序列化消息。</p>
<p>标记只是一个任意整数，最小值为 1，最大值为 2 29 - 1，但从 19000 到 19999 的数字除外，因为它们是为内部协议缓冲区实现保留的。</p>
<p>请注意，从 1 到 15 的标签只需要 1 个字节进行编码，而从 16 到 2047 的标签需要 2 个字节。所以你应该明智地使用它们，比如：为非常频繁出现的字段保存从 1 到 15 的标签。</p>
<p>请记住，标签不需要是有序的（或连续的），但对于消息的同级字段，它们必须是唯一的。</p>
<h3 id="定义CPU消息">定义CPU消息</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// /proto/processor_message.proto</span><br><span class="line"></span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option go_package=&quot;../pb&quot;;</span><br><span class="line"></span><br><span class="line">message CPU &#123;</span><br><span class="line">  string brand = 1;</span><br><span class="line">  string name = 2;</span><br><span class="line">  uint32 number_cores = 3;</span><br><span class="line">  uint32 number_threads = 4;</span><br><span class="line">  double min_ghz = 5;</span><br><span class="line">  double max_ghz = 6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先安装protoc-gen-go和gRPC库</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u google.golang.org/grpc</span><br><span class="line">go get -u github.com/golang/protobuf/protoc-gen-go@v1.3.2</span><br></pre></td></tr></table></figure>
<p>之后可以执行此命令,生成go代码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=plugins=grpc:pb proto/*.proto</span><br></pre></td></tr></table></figure>
<p>此时的项目目录为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pcbook</span><br><span class="line">├── proto</span><br><span class="line">│   └── processor_message.proto</span><br><span class="line">├── pb</span><br><span class="line">│   └── processor_message.pb.go</span><br><span class="line">└── main.go</span><br></pre></td></tr></table></figure>
<h3 id="编写Makefile">编写Makefile</h3>
<p>我们用来生成代码的命令很长，所以当我们更新proto文件并想重新生成代码时，输​​入不是很方便。因此，让我们使用一个简短的命令创建一个 Makefile 来执行此操作。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">gen:</span></span><br><span class="line">    protoc --proto_path=proto proto/*.proto --go_out=plugins=grpc:pb</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm pb/*.go </span><br><span class="line"></span><br><span class="line"><span class="section">run:</span></span><br><span class="line">    go run main.go</span><br></pre></td></tr></table></figure>
<h2 id="协议缓冲区深入研究">协议缓冲区深入研究</h2>
<h3 id="一个文件中的多条消息">一个文件中的多条消息</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line">import &quot;memory_message.proto&quot;;</span><br><span class="line"></span><br><span class="line">message CPU &#123;</span><br><span class="line">  string brand = 1;</span><br><span class="line">  string name = 2;</span><br><span class="line">  uint32 number_cores = 3;</span><br><span class="line">  uint32 number_threads = 4;</span><br><span class="line">  double min_ghz = 5;</span><br><span class="line">  double max_ghz = 6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GPU &#123;</span><br><span class="line">  string brand = 1;</span><br><span class="line">  string name = 2;</span><br><span class="line">  double min_ghz = 3;</span><br><span class="line">  double max_ghz = 4;</span><br><span class="line">  Memory memory=5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义类型：消息和枚举">自定义类型：消息和枚举</h3>
<p>内存是一个非常流行的术语，可以在其他地方使用，例如 RAM 或存储（持久驱动器）。它有许多不同的度量单位，例如千字节、兆字节、千兆字节或太字节。所以我将它定义为自定义类型，在一个单独的memory_message.proto文件中，以便我们以后可以重用它。</p>
<p>首先，我们需要定义测量单位。为此，我们将使用枚举。因为这个单元应该只存在于内存的上下文中，所以我们应该将它定义为内存消息中的嵌套类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">message Memory &#123;</span><br><span class="line">  enum Unit &#123;</span><br><span class="line">    UNKNOWN = 0;</span><br><span class="line">    BIT = 1;</span><br><span class="line">    BYTE = 2;</span><br><span class="line">    KILOBYTE = 3;</span><br><span class="line">    MEGABYTE = 4;</span><br><span class="line">    GIGABYTE = 5;</span><br><span class="line">    TERABYTE = 6;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uint64 value = 1;</span><br><span class="line">  Unit unit = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>惯例是，始终使用特殊值作为枚举的默认值并为其分配标签 0。然后我们添加其他单位，从 BIT 到 TERABYTE。</p>
<p>内存消息将有 2 个字段：一个用于值，另一个用于单位。</p>
<h3 id="定义存储消息">定义存储消息</h3>
<p>让我们继续我们的项目。我将为storage_message.proto文件中的存储创建一条新消息。</p>
<p>存储可以是硬盘驱动器或固态驱动器。所以我们应该Driver用这两个值定义一个枚举。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">syntax =&quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option go_package=&quot;../pb&quot;;</span><br><span class="line"></span><br><span class="line">import &quot;proto/memory_message.proto&quot;;</span><br><span class="line"></span><br><span class="line">message Storage&#123;</span><br><span class="line">  enum Drive&#123;</span><br><span class="line">    UNKNOWN=0;</span><br><span class="line">    HDD=1;</span><br><span class="line">    SSD=2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Drive driver=1;</span><br><span class="line">  Memory memory=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义键盘消息">定义键盘消息</h3>
<p>接下来，我们将定义键盘消息。它可以具有 QWERTY、QWERTZ 或 AZERTY 布局。供您参考，QWERTZ 在德国被广泛使用。在法国，AZERTY 更受欢迎。</p>
<p>键盘可以背光或不背光，因此我们使用布尔字段。很简单，对吧？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax=&quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option go_package=&quot;../pb&quot;;</span><br><span class="line"></span><br><span class="line">message Keyboard&#123;</span><br><span class="line">  enum Layout&#123;</span><br><span class="line">    UNKONWN=0;</span><br><span class="line">    QWERTY=1;</span><br><span class="line">    QWERTZ=2;</span><br><span class="line">    AZERTY=3;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Layout layout=1;</span><br><span class="line">  bool backlit=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义屏幕消息">定义屏幕消息</h3>
<p>现在让我们写一个更复杂的信息：屏幕。它有一个嵌套的消息类型：Resolution. 我们这里使用嵌套类型的原因是：分辨率是一个与屏幕有着紧密联系的实体，它单独存在时没有任何意义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax=&quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option go_package=&quot;../pb&quot;;</span><br><span class="line"></span><br><span class="line">message Screen&#123;</span><br><span class="line">  message Resolution&#123;</span><br><span class="line">    uint32 width=1;</span><br><span class="line">    uint32 height=2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  enum Panel&#123;</span><br><span class="line">    UNKNOWN=0;</span><br><span class="line">    IPS=1;</span><br><span class="line">    OLED=2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  float size_inch=1;</span><br><span class="line">  Resolution resolution =2;</span><br><span class="line">  Panel panel =3;</span><br><span class="line">  bool multitouch=4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，我们有一个屏幕面板的枚举，可以是 IPS 或 OLED。然后屏幕尺寸以英寸为单位。最后是一个布尔字段来判断它是否是多点触控屏幕。</p>
<h3 id="定义笔记本电脑消息">定义笔记本电脑消息</h3>
<p>我想基本上我们已经定义了笔记本电脑的所有必要组件。现在让我们定义笔记本电脑消息。</p>
<p>它有一个字符串类型的唯一标识符。此 ID 将由服务器自动生成。它有一个品牌和一个名字。然后是CPU和RAM。我们需要导入其他 proto 文件来使用这些类型。</p>
<p>一台笔记本电脑可以有多个 GPU，所以我们使用repeated关键字告诉 protoc 这是一个 GPU 列表。</p>
<p>同样，笔记本电脑有多个存储也是正常的，所以这个字段也应该重复。</p>
<p>笔记本的重量如何？比方说，我们允许以千克或磅为单位指定它。为了做到这一点，我们可以使用一个新的关键字：oneof.</p>
<p>在这个块中，我们定义了 2 个字段，一个用于公斤，另一个用于磅。请记住，当您使用oneof字段组时，只有最后分配的字段才会保留其值。</p>
<p>然后我们再添加 2 个字段：美元价格和笔记本电脑的发布年份。最后，我们需要一个时间戳字段来存储我们系统中记录的最后更新时间。</p>
<p>Timestamp 是 Google 已经定义好的众所周知的类型之一，所以我们只需要导入包并使用它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">syntax=&quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">option go_package=&quot;../pb&quot;;</span><br><span class="line"></span><br><span class="line">import &quot;proto/memory_message.proto&quot;;</span><br><span class="line">import &quot;proto/processor_message.proto&quot;;</span><br><span class="line">import &quot;proto/storage_message.proto&quot;;</span><br><span class="line">import &quot;proto/screen_message.proto&quot;;</span><br><span class="line">import &quot;proto/keyboard_message.proto&quot;;</span><br><span class="line">import &quot;google/protobuf/timestamp.proto&quot;;</span><br><span class="line"></span><br><span class="line">message Laptop&#123;</span><br><span class="line">  string id=1;</span><br><span class="line">  string brand=2;</span><br><span class="line">  string name=3;</span><br><span class="line">  CPU cpu=4;</span><br><span class="line">  Memory ram=5;</span><br><span class="line">  repeated GPU gpus=6;</span><br><span class="line">  repeated Storage storages=7;</span><br><span class="line">  Screen screen=8;</span><br><span class="line">  Keyboard keyboard=9;</span><br><span class="line">  oneof weight&#123;</span><br><span class="line">    double weight_kg=10;</span><br><span class="line">    double weight_lb=11;</span><br><span class="line">  &#125;</span><br><span class="line">  double price_usd=12;</span><br><span class="line">  uint32 release_year=13;</span><br><span class="line">  google.protobuf.Timestamp updated_at=14;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后就可以一并生成go文件了。</p>
<h2 id="在GO中生成和序列化protobuf消息">在GO中生成和序列化protobuf消息</h2>
<p>创建一个sample包来生成一些随机的笔记本电脑数据。此时的项目目录结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pcbook</span><br><span class="line">├── proto</span><br><span class="line">├── pb</span><br><span class="line">├── sample</span><br><span class="line">│   ├── generator.go</span><br><span class="line">│   └── random.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── main.go</span><br><span class="line">└── Makefile</span><br></pre></td></tr></table></figure>
<h3 id="生成随机键盘">生成随机键盘</h3>
<p>首先我们需要一个键盘，所以我定义了一个函数NewKeyboard()，它返回一个指向pb.Keyboard对象的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sample</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;gitlab.com/techschool/pcbook/pb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewKeyboard returns a new sample keyboard</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewKeyboard</span><span class="params">()</span> *<span class="title">pb</span>.<span class="title">Keyboard</span></span> &#123;</span><br><span class="line">    keyboard := &amp;pb.Keyboard&#123;</span><br><span class="line">        Layout:  randomKeyboardLayout(),</span><br><span class="line">        Backlit: randomBool(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> keyboard</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它将有一个布局，所以我将编写一个函数来生成随机键盘布局。还有一个为背光字段生成随机布尔值的函数。让我们将它们写入新文件random.go中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sample</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomBool</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rand.Intn(<span class="number">2</span>) == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomKeyboardLayout</span><span class="params">()</span> <span class="title">pb</span>.<span class="title">Keyboard_Layout</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> rand.Intn(<span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> pb.Keyboard_QWERTY</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> pb.Keyboard_QWERTZ</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> pb.Keyboard_AZERTY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成随机cpu">生成随机cpu</h3>
<p>首先我们需要一个函数来返回一个随机的 CPU 品牌。让我们去random.go文件中定义它。一种简单的方法是从一组预定义的品牌中选择一个随机值，例如“Intel”和“AMD”。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomCPUBrand</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> randomStringFromSet(<span class="string">&quot;Intel&quot;</span>, <span class="string">&quot;AMD&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomStringFromSet</span><span class="params">(a ...<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[rand.Intn(n)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们将根据具有此功能的品牌生成一个随机的 CPU 名称。因为我们知道只有 2 个品牌，所以这里简单的 if 就足够了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomCPUName</span><span class="params">(brand <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> brand == <span class="string">&quot;Intel&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> randomStringFromSet(</span><br><span class="line">            <span class="string">&quot;Xeon E-2286M&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Core i9-9980HK&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Core i7-9750H&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Core i5-9400F&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Core i3-1005G1&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> randomStringFromSet(</span><br><span class="line">        <span class="string">&quot;Ryzen 7 PRO 2700U&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Ryzen 5 PRO 3500U&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Ryzen 3 PRO 3200GE&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们必须填写的下一个 CPU 字段是内核数。假设我们希望它介于 2 核和 8 核之间。所以我们需要一个randomInt()函数来生成 和 之间的随机min整数max。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomInt</span><span class="params">(min, max <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> min + rand.Int()%(max-min+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，下一个字段是minGhz，这是一个float64。我希望 CPU 的最低频率介于2.0和之间3.5。所以我们需要一个函数来生成float64范围 from minto max。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomFloat64</span><span class="params">(min, max <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> min + rand.Float64()*(max-min)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把所有东西放在一起，我们得到了这个NewCPU()函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewCPU returns a new sample CPU</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCPU</span><span class="params">()</span> *<span class="title">pb</span>.<span class="title">CPU</span></span> &#123;</span><br><span class="line">    brand := randomCPUBrand()</span><br><span class="line">    name := randomCPUName(brand)</span><br><span class="line"></span><br><span class="line">    numberCores := randomInt(<span class="number">2</span>, <span class="number">8</span>)</span><br><span class="line">    numberThreads := randomInt(numberCores, <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">    minGhz := randomFloat64(<span class="number">2.0</span>, <span class="number">3.5</span>)</span><br><span class="line">    maxGhz := randomFloat64(minGhz, <span class="number">5.0</span>)</span><br><span class="line"></span><br><span class="line">    cpu := &amp;pb.CPU&#123;</span><br><span class="line">        Brand:         brand,</span><br><span class="line">        Name:          name,</span><br><span class="line">        NumberCores:   <span class="keyword">uint32</span>(numberCores),</span><br><span class="line">        NumberThreads: <span class="keyword">uint32</span>(numberThreads),</span><br><span class="line">        MinGhz:        minGhz,</span><br><span class="line">        MaxGhz:        maxGhz,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cpu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成随机-GPU">生成随机 GPU</h3>
<p>NewGPU 函数将以相同的方式实现。我们编写了一个函数来返回一个随机的 GPU 品牌，它可以是“NVIDIA”或“AMD”。然后我们根据品牌生成一个随机的 GPU 名称。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomGPUBrand</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> randomStringFromSet(<span class="string">&quot;Nvidia&quot;</span>, <span class="string">&quot;AMD&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomGPUName</span><span class="params">(brand <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> brand == <span class="string">&quot;Nvidia&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> randomStringFromSet(</span><br><span class="line">            <span class="string">&quot;RTX 2060&quot;</span>,</span><br><span class="line">            <span class="string">&quot;RTX 2070&quot;</span>,</span><br><span class="line">            <span class="string">&quot;GTX 1660-Ti&quot;</span>,</span><br><span class="line">            <span class="string">&quot;GTX 1070&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> randomStringFromSet(</span><br><span class="line">        <span class="string">&quot;RX 590&quot;</span>,</span><br><span class="line">        <span class="string">&quot;RX 580&quot;</span>,</span><br><span class="line">        <span class="string">&quot;RX 5700-XT&quot;</span>,</span><br><span class="line">        <span class="string">&quot;RX Vega-56&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在只剩下一个领域：记忆。假设我们希望它在 2 到 6 GB 之间。因此，我们将在randomInt()此处使用该函数，并将其类型转换为uint64. 对于单元，只需使用Memory_GIGABYTEprotoc 生成的枚举即可。我们已经完成了 GPU。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewGPU returns a new sample GPU</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGPU</span><span class="params">()</span> *<span class="title">pb</span>.<span class="title">GPU</span></span> &#123;</span><br><span class="line">    brand := randomGPUBrand()</span><br><span class="line">    name := randomGPUName(brand)</span><br><span class="line"></span><br><span class="line">    minGhz := randomFloat64(<span class="number">1.0</span>, <span class="number">1.5</span>)</span><br><span class="line">    maxGhz := randomFloat64(minGhz, <span class="number">2.0</span>)</span><br><span class="line">    memGB := randomInt(<span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    gpu := &amp;pb.GPU&#123;</span><br><span class="line">        Brand:  brand,</span><br><span class="line">        Name:   name,</span><br><span class="line">        MinGhz: minGhz,</span><br><span class="line">        MaxGhz: maxGhz,</span><br><span class="line">        Memory: &amp;pb.Memory&#123;</span><br><span class="line">            Value: <span class="keyword">uint64</span>(memGB),</span><br><span class="line">            Unit:  pb.Memory_GIGABYTE,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gpu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成随机-RAM">生成随机 RAM</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewRAM returns a new sample RAM</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRAM</span><span class="params">()</span> *<span class="title">pb</span>.<span class="title">Memory</span></span> &#123;</span><br><span class="line">    memGB := randomInt(<span class="number">4</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">    ram := &amp;pb.Memory&#123;</span><br><span class="line">        Value: <span class="keyword">uint64</span>(memGB),</span><br><span class="line">        Unit:  pb.Memory_GIGABYTE,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ram</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成随机存储">生成随机存储</h3>
<p>然后是存储。我们将定义 2 个不同的函数：1 个用于 SSD，1 个用于 HDD。</p>
<p>对于 SSD，我们将驱动程序设置为Storage_SSD并且内存大小将从 128 GB 到 1024 GB。</p>
<p>对于 HDD，驱动程序必须是 Storage_HDD，内存大小在 1 到 6 TB 之间。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewSSD returns a new sample SSD</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSSD</span><span class="params">()</span> *<span class="title">pb</span>.<span class="title">Storage</span></span> &#123;</span><br><span class="line">    memGB := randomInt(<span class="number">128</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    ssd := &amp;pb.Storage&#123;</span><br><span class="line">        Driver: pb.Storage_SSD,</span><br><span class="line">        Memory: &amp;pb.Memory&#123;</span><br><span class="line">            Value: <span class="keyword">uint64</span>(memGB),</span><br><span class="line">            Unit:  pb.Memory_GIGABYTE,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ssd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewHDD returns a new sample HDD</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewHDD</span><span class="params">()</span> *<span class="title">pb</span>.<span class="title">Storage</span></span> &#123;</span><br><span class="line">    memTB := randomInt(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    hdd := &amp;pb.Storage&#123;</span><br><span class="line">        Driver: pb.Storage_HDD,</span><br><span class="line">        Memory: &amp;pb.Memory&#123;</span><br><span class="line">            Value: <span class="keyword">uint64</span>(memTB),</span><br><span class="line">            Unit:  pb.Memory_TERABYTE,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hdd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成随机屏幕">生成随机屏幕</h3>
<p>现在我们将制作一个新屏幕。屏幕尺寸在 13 到 17 英寸之间。这是一个float32数字，所以让我们定义一个randomFloat32函数。它与randomFloat64函数相同，除了类型应该是float32.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomFloat32</span><span class="params">(min, max <span class="keyword">float32</span>)</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> min + rand.Float32()*(max-min)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，屏幕分辨率。我们将高度设置为 1080 到 4320 之间的随机整数。并以 16 乘 9 的比率从高度计算宽度。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomScreenResolution</span><span class="params">()</span> *<span class="title">pb</span>.<span class="title">Screen_Resolution</span></span> &#123;</span><br><span class="line">    height := randomInt(<span class="number">1080</span>, <span class="number">4320</span>)</span><br><span class="line">    width := height * <span class="number">16</span> / <span class="number">9</span></span><br><span class="line"></span><br><span class="line">    resolution := &amp;pb.Screen_Resolution&#123;</span><br><span class="line">        Width:  <span class="keyword">uint32</span>(width),</span><br><span class="line">        Height: <span class="keyword">uint32</span>(height),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resolution</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是屏幕面板。在我们的应用中，只有两种类型的面板：IPS 或 OLED。所以我们在这里只使用 rand.Intn(2) ，一个简单的 if 就可以完成这项工作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomScreenPanel</span><span class="params">()</span> <span class="title">pb</span>.<span class="title">Screen_Panel</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> rand.Intn(<span class="number">2</span>) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pb.Screen_IPS</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pb.Screen_OLED</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们必须设置的最后一个字段是多点触控，它只是一个随机布尔值。然后我们有这个函数来生成一个新的屏幕：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewScreen returns a new sample Screen</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewScreen</span><span class="params">()</span> *<span class="title">pb</span>.<span class="title">Screen</span></span> &#123;</span><br><span class="line">    screen := &amp;pb.Screen&#123;</span><br><span class="line">        SizeInch:   randomFloat32(<span class="number">13</span>, <span class="number">17</span>),</span><br><span class="line">        Resolution: randomScreenResolution(),</span><br><span class="line">        Panel:      randomScreenPanel(),</span><br><span class="line">        Multitouch: randomBool(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> screen</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成随机笔记本电脑">生成随机笔记本电脑</h3>
<p>好了，所有组件都准备好了，现在我们可以生成一台新的笔记本电脑了。</p>
<p>首先，它需要一个唯一的随机标识符。因此，让我们为此创建一个 randomID() 函数。我将使用Google UUID。我们可以在终端运行这个命令来安装包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/google/uuid</span><br></pre></td></tr></table></figure>
<p>现在我们可以调用uuid.New()来获取一个随机 ID 并将其转换为字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomID</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uuid.New().String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们将生成类似于我们对 CPU 和 GPU 所做的笔记本电脑品牌和名称。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomLaptopBrand</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> randomStringFromSet(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Dell&quot;</span>, <span class="string">&quot;Lenovo&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomLaptopName</span><span class="params">(brand <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> brand &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Apple&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> randomStringFromSet(<span class="string">&quot;Macbook Air&quot;</span>, <span class="string">&quot;Macbook Pro&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Dell&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> randomStringFromSet(<span class="string">&quot;Latitude&quot;</span>, <span class="string">&quot;Vostro&quot;</span>, <span class="string">&quot;XPS&quot;</span>, <span class="string">&quot;Alienware&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> randomStringFromSet(<span class="string">&quot;Thinkpad X1&quot;</span>, <span class="string">&quot;Thinkpad P1&quot;</span>, <span class="string">&quot;Thinkpad P53&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在让我们使用这些函数来生成一个新的随机笔记本电脑。我们通过调用它们的生成器函数来添加 CPU 和 RAM。GPU 应该是一个值列表，所以我在这里定义了一个切片。假设我们现在只有 1 个 GPU。存储类似，但这次我将添加 2 个项目：1 个用于 SSD，另一个用于 HDD。屏幕和键盘字段非常简单。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewLaptop returns a new sample Laptop</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLaptop</span><span class="params">()</span> *<span class="title">pb</span>.<span class="title">Laptop</span></span> &#123;</span><br><span class="line">    brand := randomLaptopBrand()</span><br><span class="line">    name := randomLaptopName(brand)</span><br><span class="line"></span><br><span class="line">    laptop := &amp;pb.Laptop&#123;</span><br><span class="line">        Id:       randomID(),</span><br><span class="line">        Brand:    brand,</span><br><span class="line">        Name:     name,</span><br><span class="line">        Cpu:      NewCPU(),</span><br><span class="line">        Ram:      NewRAM(),</span><br><span class="line">        Gpus:     []*pb.GPU&#123;NewGPU()&#125;,</span><br><span class="line">        Storages: []*pb.Storage&#123;NewSSD(), NewHDD()&#125;,</span><br><span class="line">        Screen:   NewScreen(),</span><br><span class="line">        Keyboard: NewKeyboard(),</span><br><span class="line">        Weight: &amp;pb.Laptop_WeightKg&#123;</span><br><span class="line">            WeightKg: randomFloat64(<span class="number">1.0</span>, <span class="number">3.0</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">        PriceUsd:    randomFloat64(<span class="number">1500</span>, <span class="number">3500</span>),</span><br><span class="line">        ReleaseYear: <span class="keyword">uint32</span>(randomInt(<span class="number">2015</span>, <span class="number">2019</span>)),</span><br><span class="line">        UpdatedAt:   timestamppb.Now(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> laptop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="序列化-protobuf-消息">序列化 protobuf 消息</h3>
<p>现在我们将创建一个新serializer包并编写一些函数来将笔记本电脑对象序列化为文件。所以让我们在这里创建一个file.go文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pcbook</span><br><span class="line">├── proto</span><br><span class="line">├── pb</span><br><span class="line">├── sample</span><br><span class="line">│   ├── generator.go</span><br><span class="line">│   └── random.go</span><br><span class="line">├── serializer</span><br><span class="line">│   └── file.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── main.go</span><br><span class="line">└── Makefile</span><br></pre></td></tr></table></figure>
<h3 id="将-protobuf-消息写入二进制文件">将 protobuf 消息写入二进制文件</h3>
<p>第一个函数将用于将 protobuf 消息以二进制格式写入文件。在我们的例子中，消息将是笔记本电脑对象。我们可以使用该proto.Message接口使其更通用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteProtobufToBinaryFile writes protocol buffer message to binary file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteProtobufToBinaryFile</span><span class="params">(message proto.Message, filename <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    data, err := proto.Marshal(message)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot marshal proto message to binary: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = ioutil.WriteFile(filename, data, <span class="number">0644</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot write binary data to file: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我将向您展示如何为其编写单元测试。让我们在这里创建一个file_test.go。注意，_test文件名中有后缀是必须的，所以 Go 可以理解它是一个测试文件。</p>
<p>我通常要求t.Parallel()几乎所有的单元测试，以便它们可以并行运行，并且可以轻松检测到任何条件。</p>
<p>假设我们要将对象序列化为文件tmp夹中的 notebook.bin 文件。所以我们需要先创建tmp文件夹。</p>
<p>然后使用该NewLaptop()功能制作一个新的laptop1. 并调用该WriteProtobufToBinaryFile()函数将其保存到laptop.bin文件中。由于此函数返回错误，我们必须检查此错误是否为nil，这意味着文件已成功写入。</p>
<p>为此，我经常使用testify 包。在终端中运行此命令以获取它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/stretchr/testify</span><br></pre></td></tr></table></figure>
<p>然后我们可以简单地调用require.NoError(t, err).</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serializer_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/stretchr/testify/require&quot;</span></span><br><span class="line">    <span class="string">&quot;gitlab.com/techschool/pcbook/sample&quot;</span></span><br><span class="line">    <span class="string">&quot;gitlab.com/techschool/pcbook/serializer&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFileSerializer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Parallel()</span><br><span class="line"></span><br><span class="line">    binaryFile := <span class="string">&quot;../tmp/laptop.bin&quot;</span></span><br><span class="line"></span><br><span class="line">    laptop1 := sample.NewLaptop()</span><br><span class="line">    err := serializer.WriteProtobufToBinaryFile(laptop1, binaryFile)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从二进制文件中读取-protobuf-消息">从二进制文件中读取 protobuf 消息</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReadProtobufFromBinaryFile reads protocol buffer message from binary file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadProtobufFromBinaryFile</span><span class="params">(filename <span class="keyword">string</span>, message proto.Message)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    data, err := ioutil.ReadFile(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot read binary data from file: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = proto.Unmarshal(data, message)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot unmarshal binary to proto message: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，让我们测试一下。在我们的单元测试中，我将定义一个新laptop2对象，并调用ReadProtobufFromBinaryFile()以将文件数据读入该对象。我们将检查没有错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFileSerializer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Parallel()</span><br><span class="line"></span><br><span class="line">    binaryFile := <span class="string">&quot;../tmp/laptop.bin&quot;</span></span><br><span class="line"></span><br><span class="line">    laptop1 := sample.NewLaptop()</span><br><span class="line">    err := serializer.WriteProtobufToBinaryFile(laptop1, binaryFile)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    laptop2 := &amp;pb.Laptop&#123;&#125;</span><br><span class="line">    err = serializer.ReadProtobufFromBinaryFile(binaryFile, laptop2)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    require.True(t, proto.Equal(laptop1, laptop2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还想检查是否laptop2包含与 相同的数据laptop1。为此，我们可以使用包proto.Equal提供的功能golang/protobuf。这个函数必须返回true，所以我们require.True()在这里使用。</p>
<h3 id="将-protobuf-消息写入-JSON-文件">将 protobuf 消息写入 JSON 文件</h3>
<p>现在由于数据是以二进制格式写入的，我们无法读取它。让我们编写另一个函数来将其序列化为JSON格式。</p>
<p>在这个函数中，我们必须先将 protobuf 消息转换为JSON字符串。为此，我将创建一个名为 的新函数，并将其编码在同一个包下的ProtobufToJSON()单独json.go文件中。serializer</p>
<p>现在要将 protobuf 消息转换为 JSON，我们可以使用jsonb.Marshaler结构体。基本上，我们只需要调用marshaler.MarshalToString()函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serializer</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/protobuf/encoding/protojson&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/protobuf/proto&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProtobufToJSON transfer a protobuf to json string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProtobufToJSON</span><span class="params">(message proto.Message)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	marshaler := protojson.MarshalOptions&#123;</span><br><span class="line">		EmitUnpopulated: <span class="literal">true</span>,</span><br><span class="line">		Indent:          <span class="string">&quot;  &quot;</span>,</span><br><span class="line">		UseProtoNames:   <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> marshaler.Marshal(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以配置一些东西，例如：</p>
<ul>
<li>将枚举写为整数或字符串。</li>
<li>写入具有默认值的字段或不写入。</li>
<li>我们要使用的缩进是什么。</li>
<li>我们是否要使用原始文件中的原始字段名称。</li>
<li>现在让我们使用这些配置，稍后我们将尝试其他值。</li>
</ul>
<p>现在回到我们的函数，在调用之后ProtobufToJSON，我们得到了JSON字符串。我们需要做的就是将该字符串写入文件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WriteProtobufToJSONFile writes protocol buffer message to JSON file</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteProtobufToJSONFile</span><span class="params">(message proto.Message, filename <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    data, err := ProtobufToJSON(message)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot marshal proto message to JSON: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = ioutil.WriteFile(filename, []<span class="keyword">byte</span>(data), <span class="number">0644</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;cannot write JSON data to file: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，现在让我们在单元测试中调用这个函数。检查没有返回错误，然后运行测试。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFileSerializer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Parallel()</span><br><span class="line"></span><br><span class="line">    binaryFile := <span class="string">&quot;../tmp/laptop.bin&quot;</span></span><br><span class="line">    jsonFile := <span class="string">&quot;../tmp/laptop.json&quot;</span></span><br><span class="line"></span><br><span class="line">    laptop1 := sample.NewLaptop()</span><br><span class="line"></span><br><span class="line">    err := serializer.WriteProtobufToBinaryFile(laptop1, binaryFile)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    err = serializer.WriteProtobufToJSONFile(laptop1, jsonFile)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    laptop2 := &amp;pb.Laptop&#123;&#125;</span><br><span class="line">    err = serializer.ReadProtobufFromBinaryFile(binaryFile, laptop2)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    require.True(t, proto.Equal(laptop1, laptop2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在go中生成一元gRPC-API">在go中生成一元gRPC API</h2>
<p>gRPC 有 4 种类型：一元、客户端流式传输、服务器流式传输和双向流式传输。</p>
<h3 id="定义一个-proto-服务和一个一元-RPC">定义一个 proto 服务和一个一元 RPC</h3>
<p>第一步，我们将创建一个新laptop_service.proto文件。</p>
<p>在这个文件中，我们定义了一条CreateLaptopRequest消息，它只包含一个字段：我们要创建的笔记本电脑。</p>
<p>message CreateLaptopRequest {<br>
Laptop laptop = 1;<br>
}</p>
<p>然后CreateLaptopResponse消息也只有 1 个字段：创建的笔记本电脑的 ID。</p>
<p>message CreateLaptopResponse {<br>
string id = 1;<br>
}</p>
<p>我们用关键字定义了 LaptopService service。然后在其中，一元 RPC 定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service LaptopService &#123;</span><br><span class="line">  rpc CreateLaptop(CreateLaptopRequest) returns (CreateLaptopResponse&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为一元-RPC-生成代码">为一元 RPC 生成代码</h3>
<p>使用<code>make gen</code>生成代码</p>
<h3 id="实现服务器的一元-RPC-处理程序">实现服务器的一元 RPC 处理程序</h3>
<p>现在让我们实现LaptopServiceServer!</p>
<p>我将创建一个新service文件夹，并laptop_server.go在其中创建一个文件。</p>
<p>我将声明一个LaptopServer结构和一个NewLaptopServer()函数来返回它的一个新实例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LaptopServer is the server that provides laptop services</span></span><br><span class="line"><span class="keyword">type</span> LaptopServer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLaptopServer returns a new LaptopServer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLaptopServer</span><span class="params">()</span> *<span class="title">LaptopServer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;LaptopServer&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们需要实现接口CreateLaptop所需的LaptopServiceServer功能。</p>
<p>它接受一个上下文和一个CreateLaptopRequest对象作为输入，并返回一个CreateLaptopResponse或一个错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// CreateLaptop Create a laptop</span><br><span class="line">func (server *LaptopServer) CreateLaptop(ctx context.Context, req *pb.CreateLaptopRequest) (*pb.CreateLaptopResponse, error) &#123;</span><br><span class="line">	laptop := req.GetLaptop()</span><br><span class="line">	log.Printf(&quot;recieve a create-laptop request with id:%s&quot;, laptop.Id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们调用GetLaptop函数从请求中获取笔记本电脑对象。</p>
<p>如果客户端已经生成了笔记本电脑ID，我们必须检查它是否有效UUID。</p>
<p>为此，我们使用Google UUID包。在终端中运行这个命令来安装它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/google/uuid</span><br></pre></td></tr></table></figure>
<p>之后，我们可以使用uuid.Parse()函数来解析笔记本电脑的 ID。</p>
<p>如果它返回错误则意味着提供的 ID 无效，我们应该向客户端返回 nil 响应以及错误状态代码。</p>
<p>为此，我们使用包的status和codes子grpc包。在这种情况下，我们返回InvalidArgument代码，因为笔记本电脑 ID 是由客户端提供的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(laptop.Id) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// check if it&#x27;s a valid UUID</span></span><br><span class="line">    _, err := uuid.Parse(laptop.Id)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.InvalidArgument, <span class="string">&quot;laptop ID is not a valid UUID: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    id, err := uuid.NewRandom()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.Internal, <span class="string">&quot;cannot generate a new laptop ID: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    laptop.Id = id.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果客户端没有发送笔记本电脑 ID，我们将在服务器上使用uuid.NewRandom()命令生成它。</p>
<p>如果发生错误，我们将它与 一起返回codes.Internal，这意味着内部服务器错误。否则，我们只需将 设置laptop.ID为生成的随机 UUID。</p>
<p>接下来我们应该检查请求是否超时或被客户端取消，因为如果是，那么没有理由继续处理请求。</p>
<p>要检查这一点，我们只需使用以下ctx.Err()函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ctx.Err() == context.Canceled &#123;</span><br><span class="line">    log.Print(<span class="string">&quot;request is canceled&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.Canceled, <span class="string">&quot;request is canceled&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ctx.Err() == context.DeadlineExceeded &#123;</span><br><span class="line">    log.Print(<span class="string">&quot;deadline is exceeded&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, status.Error(codes.DeadlineExceeded, <span class="string">&quot;deadline is exceeded&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将笔记本信息保存在内存中">将笔记本信息保存在内存中</h3>
<p>通常在此之后，我们应该将笔记本电脑保存到数据库中。然而，这是一门关于 gRPC 的课程，所以我只想专注于它。因此，为简单起见，我将只使用内存存储。它对于以后的单元测试也将非常有用。</p>
<p>laptop_store.go让我们在service文件夹中创建一个新文件</p>
<p>由于我们可能有不同的存储类型，我们将其定义为LaptopStore接口，具有ave()将笔记本电脑保存到商店的功能。</p>
<p>然后我们将编写一个InMemoryLaptopStore来实现这个接口。稍后，如果我们想将笔记本电脑保存到数据库中，我们总是可以实现另一个DBLaptopStore来这样做。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LaptopStore is a interface to store laptop</span></span><br><span class="line"><span class="keyword">type</span> LaptopStore <span class="keyword">interface</span> &#123;</span><br><span class="line">	Save(laptop *pb.Laptop) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InMemoryLaptopStore store laptops in memory</span></span><br><span class="line"><span class="keyword">type</span> InMemoryLaptopStore <span class="keyword">struct</span> &#123;</span><br><span class="line">	mutex sync.RWMutex</span><br><span class="line">	data  <span class="keyword">map</span>[<span class="keyword">string</span>]*pb.Laptop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个InMemoryLaptopStore中，我们使用映射来存储数据，其中键是笔记本电脑 ID，值是笔记本电脑对象。</p>
<p>我们需要一个读写互斥体来处理多个并发请求以保存笔记本电脑。</p>
<p>现在让我们声明一个函数来返回一个新的 InMemoryLaptopStore，并初始化其中的数据映射：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewInMemoryLaptopStore returns a new InMemoryLaptopStore</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInMemoryLaptopStore</span><span class="params">()</span> *<span class="title">InMemoryLaptopStore</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;InMemoryLaptopStore&#123;</span><br><span class="line">        data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*pb.Laptop),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后Save按照界面要求实现笔记本功能。</p>
<p>首先，我们需要在添加新对象之前获取写锁。请记住推迟解锁命令。</p>
<p>接下来，我们检查笔记本电脑 ID 是否已经存在于map中。如果是这样，只需向调用者返回一个错误。</p>
<p>应导出ErrAlreadyExists该变量，以便可以在此服务包之外使用它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ErrAlreadyExists is returned when a record with the same ID already exists in the store</span></span><br><span class="line"><span class="keyword">var</span> ErrAlreadyExists = errors.New(<span class="string">&quot;record already exists&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save saves the laptop to the store</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *InMemoryLaptopStore)</span> <span class="title">Save</span><span class="params">(laptop *pb.Laptop)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    store.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> store.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> store.data[laptop.Id] != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrAlreadyExists</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    other, err := deepCopy(laptop)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    store.data[other.Id] = other</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果笔记本电脑不存在，我们可以将其保存到商店。但是，为了安全起见，我们应该对膝上型电脑对象进行深拷贝。</p>
<p>为此，我们可以使用copier包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/jinzhu/copier</span><br></pre></td></tr></table></figure>
<p>然后我们可以用它来实现deepCopy()功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deepCopy</span><span class="params">(laptop *pb.Laptop)</span> <span class="params">(*pb.Laptop, error)</span></span> &#123;</span><br><span class="line">    other := &amp;pb.Laptop&#123;&#125;</span><br><span class="line"></span><br><span class="line">    err := copier.Copy(other, laptop)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;cannot copy laptop data: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> other, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，让我们回到我们的笔记本电脑服务器并laptopStore在结构中添加一个新字段LaptopServer。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LaptopServer is the server that provides laptop services</span></span><br><span class="line"><span class="keyword">type</span> LaptopServer <span class="keyword">struct</span> &#123;</span><br><span class="line">    laptopStore LaptopStore</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewLaptopServer returns a new LaptopServer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLaptopServer</span><span class="params">(laptopStore LaptopStore)</span> *<span class="title">LaptopServer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;LaptopServer&#123;laptopStore&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在CreateLaptop()函数中，我们可以调用server.Store.Save()将输入的笔记本电脑保存到商店。</p>
<p>如果有错误，将错误返回codes.Internal给客户端。通过检查错误是否已经存在记录，我们可以让客户更清楚地处理。</p>
<p>为此，<a target="_blank" rel="noopener" href="http://xn--errors-hz8iy45au65am53b4s2cpt1a.Is">我们只需调用errors.Is</a>()函数。如果是true，我们返回AlreadyExists状态码而不是Internal。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *LaptopServer)</span> <span class="title">CreateLaptop</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ctx context.Context,</span></span></span><br><span class="line"><span class="params"><span class="function">    req *pb.CreateLaptopRequest,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="params">(*pb.CreateLaptopResponse, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    err := server.laptopStore.Save(laptop)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        code := codes.Internal</span><br><span class="line">        <span class="keyword">if</span> errors.Is(err, ErrAlreadyExists) &#123;</span><br><span class="line">            code = codes.AlreadyExists</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(code, <span class="string">&quot;cannot save laptop to the store: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;saved laptop with id: %s&quot;</span>, laptop.Id)</span><br><span class="line"></span><br><span class="line">    res := &amp;pb.CreateLaptopResponse&#123;</span><br><span class="line">        Id: laptop.Id,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试一元-RPC-处理程序">测试一元 RPC 处理程序</h3>
<p>现在我将向您展示如何测试它。让我们创建一个service/laptop_server_test.go文件并将包名称设置为service_test. 然后我们创建一个函数TestServerCreateLaptop()。</p>
<p>我想测试很多不同的情况，所以让我们使用表驱动测试。一个测试用例将有一个名称、一个输入的笔记本电脑对象、一个笔记本电脑商店和一个预期的状态码。</p>
<p>第一种情况是客户端生成的带有笔记本电脑 ID 的成功呼叫。所以笔记本电脑将是一个sample.NewLaptop()，商店只是一个新的InMemoryLaptopStore，而预期的代码是OK。</p>
<p>第二种情况也是通话成功，但没有笔记本电脑ID。我希望服务器为我们生成一个随机 ID。所以在这里我们生成一个示例笔记本电脑，并将其 ID 设置为空字符串。</p>
<p>第三种情况是由于 UUID 无效而导致调用失败。因此，我们生成了一个示例笔记本电脑并将其 ID 设置为invalid-uuid。对于这种情况，我们希望状态码为InvalidArgument.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLaptopServer_CreateLaptop</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Parallel()</span><br><span class="line"></span><br><span class="line">	laptopNoID := sample.NewLaptop()</span><br><span class="line">	laptopNoID.Id = <span class="string">&quot;&quot;</span></span><br><span class="line">	laptopInvalidID := sample.NewLaptop()</span><br><span class="line">	laptopInvalidID.Id = <span class="string">&quot;invalid-uuid&quot;</span></span><br><span class="line">	laptopDuplicateID := sample.NewLaptop()</span><br><span class="line">	storeDuplicateID := service.NewInMemoryLaptopStore()</span><br><span class="line">	err := storeDuplicateID.Save(laptopDuplicateID)</span><br><span class="line">	require.Nil(t, err)</span><br><span class="line"></span><br><span class="line">	testCases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		name   <span class="keyword">string</span></span><br><span class="line">		laptop *pb.Laptop</span><br><span class="line">		store  service.LaptopStore</span><br><span class="line">		code   codes.Code</span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;</span><br><span class="line">			name:   <span class="string">&quot;success_with_id&quot;</span>,</span><br><span class="line">			laptop: sample.NewLaptop(),</span><br><span class="line">			store:  service.NewInMemoryLaptopStore(),</span><br><span class="line">			code:   codes.OK,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			name:   <span class="string">&quot;success_no_id&quot;</span>,</span><br><span class="line">			laptop: laptopNoID,</span><br><span class="line">			store:  service.NewInMemoryLaptopStore(),</span><br><span class="line">			code:   codes.OK,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			name:   <span class="string">&quot;failure_invalid_id&quot;</span>,</span><br><span class="line">			laptop: laptopInvalidID,</span><br><span class="line">			store:  service.NewInMemoryLaptopStore(),</span><br><span class="line">			code:   codes.InvalidArgument,</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			name:   <span class="string">&quot;failure_duplicate_id&quot;</span>,</span><br><span class="line">			laptop: laptopDuplicateID,</span><br><span class="line">			store:  storeDuplicateID,</span><br><span class="line">			code:   codes.AlreadyExists,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，所有的测试用例都准备好了。现在我们用一个简单的 for 循环遍历它们。</p>
<p>我们必须将当前的测试用例保存到一个局部变量中。这对于避免并发问题非常重要，因为我们要创建多个并行子测试。</p>
<p>要创建子测试，我们调用t.Run()并使用tc.name子测试的名称。我们呼吁t.Parallel()使其与其他测试并行运行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> testCases &#123;</span><br><span class="line">    tc := testCases[i]</span><br><span class="line"></span><br><span class="line">    t.Run(tc.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">        t.Parallel()</span><br><span class="line"></span><br><span class="line">        req := &amp;pb.CreateLaptopRequest&#123;</span><br><span class="line">            Laptop: tc.laptop,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server := service.NewLaptopServer(tc.store)</span><br><span class="line">        res, err := server.CreateLaptop(context.Background(), req)</span><br><span class="line">        ...</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们用输入构建一个新CreateLaptopRequest对象tc.laptop。我们使用内存中的笔记本电脑商店创建一个新LaptopServer的。</p>
<p>然后只需调用server.CreateLaptop()带有背景上下文和请求对象的函数。</p>
<p>现在有2种情况：</p>
<p>成功的案例，或者tc.code是什么时候OK。在这种情况下，我们应该检查没有错误。响应不应该nil。返回的 ID 不能为空。如果输入的笔记本电脑已经有 ID，那么返回的 ID 应该等于它。</p>
<p>失败案例，when tc.codeis not OK。我们检查应该有错误并且响应应该是nil。</p>
<p>要检查状态码，我们调用status.FromError()以获取状态对象。检查ok应该是真的并且st.Code()应该等于tc.code。然后就完成了。</p>
<p>但是，我们编写的测试还没有使用任何类型的网络调用。它们基本上只是服务器端的直接调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">res, err := server.CreateLaptop(context.Background(), req)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> tc.code == codes.OK &#123;</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    require.NotNil(t, res)</span><br><span class="line">    require.NotEmpty(t, res.Id)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tc.laptop.Id) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        require.Equal(t, tc.laptop.Id, res.Id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    require.Error(t, err)</span><br><span class="line">    require.Nil(t, res)</span><br><span class="line">    st, ok := status.FromError(err)</span><br><span class="line">    require.True(t, ok)</span><br><span class="line">    require.Equal(t, tc.code, st.Code())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用真实连接测试一元-RPC">用真实连接测试一元 RPC</h3>
<p>现在我将向您展示如何使用真实连接测试来自客户端的 RPC 请求。</p>
<p>让我们创建laptop_client_test.go文件。包名仍然是service_test，但函数名是 now TestClientCreateLaptop()。</p>
<p>首先我们需要编写一个函数来启动 gRPC 服务器。它将 atesting.T作为参数，并返回服务器的网络地址字符串。</p>
<p>在这个函数中，我们创建了一个新的笔记本电脑服务器，其中包含一个内存笔记本电脑存储。我们通过调用grpc.NewServer()函数创建 gRPC 服务器，然后在该 gRPC 服务器上注册笔记本电脑服务服务器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTestLaptopServer</span><span class="params">(t *testing.T, laptopStore service.LaptopStore)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    laptopServer := service.NewLaptopServer(laptopStore)</span><br><span class="line"></span><br><span class="line">    grpcServer := grpc.NewServer()</span><br><span class="line">    pb.RegisterLaptopServiceServer(grpcServer, laptopServer)</span><br><span class="line"></span><br><span class="line">    listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:0&quot;</span>) <span class="comment">// random available port</span></span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> grpcServer.Serve(listener)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> listener.Addr().String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建一个新的监听器来监听 tcp 连接。这里的数字 0 表示我们希望为它分配任何随机可用端口。</p>
<p>然后我们就调用grpcServer.Serve()开始监听请求。这是一个阻塞调用，所以我们必须在一个单独的 go-routine 中运行它，因为我们想在那之后向这个服务器发送请求。</p>
<p>最后我们只返回监听器的地址字符串。</p>
<p>接下来我们将创建另一个函数来返回一个新的笔记本电脑客户端。此函数将testing.T对象和服务器地址作为其参数，然后返回一个pb.LaptopServiceClient.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestClientCreateLaptop</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Parallel()</span><br><span class="line"></span><br><span class="line">    laptopStore := service.NewInMemoryLaptopStore()</span><br><span class="line">    serverAddress := startTestLaptopServer(t, laptopStore)</span><br><span class="line">    laptopClient := newTestLaptopClient(t, serverAddress)</span><br><span class="line"></span><br><span class="line">    laptop := sample.NewLaptop()</span><br><span class="line">    expectedID := laptop.Id</span><br><span class="line">    req := &amp;pb.CreateLaptopRequest&#123;</span><br><span class="line">        Laptop: laptop,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们创建了一个新的示例笔记本电脑，将其 ID 保存到一个变量中以供以后比较。我们用笔记本电脑创建一个新的请求对象。</p>
<p>然后我们使用laptopClient对象来调用CreateLaptop()函数。我们检查是否没有返回错误并且响应应该是 not nil。返回的 ID 也应该与我们之前保存的预期 ID 匹配。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestClientCreateLaptop</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    res, err := laptopClient.CreateLaptop(context.Background(), req)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    require.NotNil(t, res)</span><br><span class="line">    require.Equal(t, expectedID, res.Id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们要确保笔记本电脑确实存储在服务器上。为此，我们需要向笔记本电脑商店再添加 1 个功能。</p>
<p>这是Find()通过 ID 搜索笔记本电脑的功能。它将stringID 作为输入，并返回带有错误的笔记本电脑对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LaptopStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Save saves the laptop to the store</span></span><br><span class="line">    Save(laptop *pb.Laptop) error</span><br><span class="line">    <span class="comment">// Find finds a laptop by ID</span></span><br><span class="line">    Find(id <span class="keyword">string</span>) (*pb.Laptop, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find finds a laptop by ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *InMemoryLaptopStore)</span> <span class="title">Find</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="params">(*pb.Laptop, error)</span></span> &#123;</span><br><span class="line">    store.mutex.RLock()</span><br><span class="line">    <span class="keyword">defer</span> store.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line">    laptop := store.data[id]</span><br><span class="line">    <span class="keyword">if</span> laptop == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> deepCopy(laptop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，我们首先调用mutex.RLock()获取读锁。</p>
<p>然后我们store.data通过它的 id 从地图中获取笔记本电脑。如果没有找到，就返回nil。否则，我们应该返回找到的笔记本电脑的深层副本。</p>
<p>现在回到我们的客户端测试。我们调用laptopServer.Store.Find() 通过ID 查找笔记本电脑。检查没有错误，笔记本电脑不应该是零。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestClientCreateLaptop</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check that the laptop is saved to the store</span></span><br><span class="line">    other, err := laptopStore.Find(res.Id)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    require.NotNil(t, other)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check that the saved laptop is the same as the one we send</span></span><br><span class="line">    requireSameLaptop(t, laptop, other)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们要检查保存的笔记本电脑是否与我们发送的笔记本电脑相同。让我们为此编写一个单独的函数。</p>
<p>它将有 3 个输入：testing.T对象和 2 个笔记本电脑对象。</p>
<p>现在如果我们只使用require.Equal()函数来比较这两个对象，测试将失败。</p>
<p>这是因为在 Laptop 结构中，gRPC 内部使用一些特殊字段来序列化对象。因此，要正确比较 2 台笔记本电脑，我们必须忽略这些特殊字段。</p>
<p>一种简单的方法是将对象序列化为 JSON，然后比较 2 个输出 JSON 字符串：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requireSameLaptop</span><span class="params">(t *testing.T, laptop1 *pb.Laptop, laptop2 *pb.Laptop)</span></span> &#123;</span><br><span class="line">    json1, err := serializer.ProtobufToJSON(laptop1)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    json2, err := serializer.ProtobufToJSON(laptop2)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    require.Equal(t, json1, json2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编写主服务器和客户端">编写主服务器和客户端</h3>
<p>接下来，我们将实现main.gogRPC 服务器和客户端的入口点。</p>
<p>让我们创建一个新cmd文件夹，然后在这个文件夹中，server为client. 每个都有自己的main.go文件。</p>
<p>然后还更新Makefile为服务器和客户端二进制文件有 2 个运行命令：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server:</span></span><br><span class="line">    go run cmd/server/main.go -port 8080</span><br><span class="line"></span><br><span class="line"><span class="section">client:</span></span><br><span class="line">    go run cmd/client/main.go -address 0.0.0.0:8080</span><br></pre></td></tr></table></figure>
<p>现在让我们实现server/main.go.</p>
<p>我们需要一个服务器端口，所以我使用该flag.Int()函数从命令行参数中获取它。</p>
<p>与我们在单元测试中编写的类似，我们创建了一个带有内存存储的新笔记本电脑服务器对象。然后我们创建一个新的 gRPC 服务器并向其注册笔记本电脑服务器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    port := flag.Int(<span class="string">&quot;port&quot;</span>, <span class="number">0</span>, <span class="string">&quot;the server port&quot;</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    log.Printf(<span class="string">&quot;start server on port %d&quot;</span>, *port)</span><br><span class="line"></span><br><span class="line">    laptopStore := service.NewInMemoryLaptopStore()</span><br><span class="line">    laptopServer := service.NewLaptopServer(laptopStore)</span><br><span class="line">    pb.RegisterLaptopServiceServer(grpcServer, laptopServer)</span><br><span class="line"></span><br><span class="line">    address := fmt.Sprintf(<span class="string">&quot;0.0.0.0:%d&quot;</span>, *port)</span><br><span class="line">    listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, address)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot start server: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = grpcServer.Serve(listener)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot start server: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用之前获得的端口创建一个地址字符串，然后在该服务器地址上侦听 TCP 连接。</p>
<p>最后我们调用grpcServer.Serve()启动服务器。如果发生任何错误，只需写一个致命日志并退出。这就是服务器代码。</p>
<p>现在是客户。首先，我们从命令行参数中获取服务器地址。</p>
<p>我们grpc.Dial()用输入地址调用函数，现在只是创建一个不安全的连接。</p>
<p>如果发生错误，我们会写一个致命日志并退出。否则，我们使用连接创建一个新的笔记本电脑客户端对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    serverAddress := flag.String(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;the server address&quot;</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    log.Printf(<span class="string">&quot;dial server %s&quot;</span>, *serverAddress)</span><br><span class="line"></span><br><span class="line">    conn, err := grpc.Dial(*serverAddress, grpc.WithInsecure())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot dial server: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laptopClient := pb.NewLaptopServiceClient(conn)</span><br><span class="line"></span><br><span class="line">    laptop := sample.NewLaptop()</span><br><span class="line">    req := &amp;pb.CreateLaptopRequest&#123;</span><br><span class="line">        Laptop: laptop,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set timeout</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    res, err := laptopClient.CreateLaptop(ctx, req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        st, ok := status.FromError(err)</span><br><span class="line">        <span class="keyword">if</span> ok &amp;&amp; st.Code() == codes.AlreadyExists &#123;</span><br><span class="line">            <span class="comment">// not a big deal</span></span><br><span class="line">            log.Print(<span class="string">&quot;laptop already exists&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.Fatal(<span class="string">&quot;cannot create laptop: &quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;created laptop with id: %s&quot;</span>, res.Id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们生成一个新的笔记本电脑，创建一个新的请求对象，然后laptopClient.Createlaptop()使用请求和上下文调用函数。这里我们context.WithTimeout()用来设置这个请求的超时时间为 5 秒。</p>
<p>如果错误不是nil，我们将其转换为状态对象。如果状态码是AlreadyExists那么没什么大不了的，写个普通的log就行了。否则，我们会写一个致命的日志。</p>
<p>如果一切正常，我们只需写一个日志，说明笔记本电脑是使用此 ID 创建的。对客户来说就是这样。</p>
<h2 id="在-Go-中实现服务器流式-gRPC">在 Go 中实现服务器流式 gRPC</h2>
<h3 id="将服务器流式-RPC-定义添加到-Protobuf">将服务器流式 RPC 定义添加到 Protobuf</h3>
<p>我们的 RPC 将允许我们搜索满足某些配置要求的笔记本电脑。所以我会创建一个filter_message.proto文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package techschool.pcbook;</span><br><span class="line"></span><br><span class="line">option go_package = &quot;pb&quot;;</span><br><span class="line">option java_package = &quot;com.gitlab.techschool.pcbook.pb&quot;;</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line"></span><br><span class="line">import &quot;memory_message.proto&quot;;</span><br><span class="line"></span><br><span class="line">message Filter &#123;</span><br><span class="line">  double max_price_usd = 1;</span><br><span class="line">  uint32 min_cpu_cores = 2;</span><br><span class="line">  double min_cpu_ghz = 3;</span><br><span class="line">  Memory min_ram = 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此消息将定义我们要查找的笔记本电脑类型，例如：</p>
<p>我们愿意为笔记本电脑支付的最高价格。<br>
笔记本电脑 CPU 应具有的最小内核数。<br>
CPU 的最低频率。<br>
以及 RAM 的最小大小。<br>
然后我们将在文件中定义新的服务器流式 RPC laptop_service.proto。</p>
<p>我们定义SearchLaptopRequest仅包含 1 个Filter字段的 和SearchLaptopResponse仅包含 1 个Laptop字段的 a。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message SearchLaptopRequest &#123; </span><br><span class="line">    Filter filter = 1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SearchLaptopResponse &#123; </span><br><span class="line">    Laptop laptop = 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器流式 RPC 的定义方式与一元 RPC 类似。以 rpc 关键字开头，然后 RPC 名称为SearchLaptop。输入为SearchLaptopRequest，输出为SearchLaptopResponse.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service LaptopService &#123;</span><br><span class="line">  rpc CreateLaptop(CreateLaptopRequest) returns (CreateLaptopResponse) &#123;&#125;;</span><br><span class="line">  rpc SearchLaptop(SearchLaptopRequest) returns (stream SearchLaptopResponse) &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将搜索功能添加到内存存储中">将搜索功能添加到内存存储中</h3>
<p>在实现服务器之前，让我们在接口中添加一个新Search()功能LaptopStore。</p>
<p>它需要一个过滤器作为输入，以及一个回调函数，以便在找到笔记本电脑时进行报告。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LaptopStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    Save(laptop *pb.Laptop) error</span><br><span class="line">    Find(id <span class="keyword">string</span>) (*pb.Laptop, error)</span><br><span class="line">    Search(ctx context.Context, filter *pb.Filter, found <span class="function"><span class="keyword">func</span><span class="params">(laptop *pb.Laptop)</span> <span class="title">error</span>) <span class="title">error</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上下文用于控制请求的期限/超时。我们稍后会看到它是如何工作的。</p>
<p>现在我们应该Search()为InMemoryLaptopStore.</p>
<p>由于我们正在读取数据，我们必须获得一个读取锁，然后再解锁它。我们遍历商店中的所有笔记本电脑，并检查哪一台符合过滤条件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Search searches for laptops with filter, returns one by one via the found function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *InMemoryLaptopStore)</span> <span class="title">Search</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ctx context.Context,</span></span></span><br><span class="line"><span class="params"><span class="function">    filter *pb.Filter,</span></span></span><br><span class="line"><span class="params"><span class="function">    found <span class="keyword">func</span>(laptop *pb.Laptop)</span> <span class="title">error</span>,</span></span><br><span class="line">) error &#123;</span><br><span class="line">    store.mutex.RLock()</span><br><span class="line">    <span class="keyword">defer</span> store.mutex.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, laptop := <span class="keyword">range</span> store.data &#123;</span><br><span class="line">        <span class="keyword">if</span> ctx.Err() == context.Canceled || ctx.Err() == context.DeadlineExceeded &#123;</span><br><span class="line">            log.Print(<span class="string">&quot;context is cancelled&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isQualified(filter, laptop) &#123;</span><br><span class="line">            other, err := deepCopy(laptop)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            err = found(other)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 for 循环中，在检查笔记本电脑是否合格之前，我们会检查上下文错误是否Cancelled存在DeadlineExceeded。如果是，我们应该立即返回，因为请求要么已经超时，要么被客户端取消，所以继续搜索只是浪费时间。</p>
<p>当笔记本电脑合格后，我们必须在通过回调函数将其发送给调用者之前对其进行深度复制found()。</p>
<p>该isQualified()函数将过滤器和笔记本电脑作为输入，如果笔记本电脑满足过滤器，则返回 true。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isQualified</span><span class="params">(filter *pb.Filter, laptop *pb.Laptop)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> laptop.GetPriceUsd() &gt; filter.GetMaxPriceUsd() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> laptop.GetCpu().GetNumberCores() &lt; filter.GetMinCpuCores() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> laptop.GetCpu().GetMinGhz() &lt; filter.GetMinCpuGhz() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> toBit(laptop.GetRam()) &lt; toBit(filter.GetMinRam()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于存在不同类型的内存单元，为了比较 RAM，我们必须编写一个函数将其值转换为最小单位：BIT。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toBit</span><span class="params">(memory *pb.Memory)</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">    value := memory.GetValue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> memory.GetUnit() &#123;</span><br><span class="line">    <span class="keyword">case</span> pb.Memory_BIT:</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">case</span> pb.Memory_BYTE:</span><br><span class="line">        <span class="keyword">return</span> value &lt;&lt; <span class="number">3</span> <span class="comment">// 8 = 2^3</span></span><br><span class="line">    <span class="keyword">case</span> pb.Memory_KILOBYTE:</span><br><span class="line">        <span class="keyword">return</span> value &lt;&lt; <span class="number">13</span> <span class="comment">// 1024 * 8 = 2^10 * 2^3 = 2^13</span></span><br><span class="line">    <span class="keyword">case</span> pb.Memory_MEGABYTE:</span><br><span class="line">        <span class="keyword">return</span> value &lt;&lt; <span class="number">23</span></span><br><span class="line">    <span class="keyword">case</span> pb.Memory_GIGABYTE:</span><br><span class="line">        <span class="keyword">return</span> value &lt;&lt; <span class="number">33</span></span><br><span class="line">    <span class="keyword">case</span> pb.Memory_TERABYTE:</span><br><span class="line">        <span class="keyword">return</span> value &lt;&lt; <span class="number">43</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现服务器">实现服务器</h3>
<p>我们将不得不实现接口的SearchLaptop()功能LaptopServiceServer。它有 2 个参数：输入请求和输出流响应。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SearchLaptop is a server-streaming RPC to search for laptops</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *LaptopServer)</span> <span class="title">SearchLaptop</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    req *pb.SearchLaptopRequest,</span></span></span><br><span class="line"><span class="params"><span class="function">    stream pb.LaptopService_SearchLaptopServer,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    filter := req.GetFilter()</span><br><span class="line">    log.Printf(<span class="string">&quot;receive a search-laptop request with filter: %v&quot;</span>, filter)</span><br><span class="line"></span><br><span class="line">    err := server.laptopStore.Search(</span><br><span class="line">        stream.Context(),</span><br><span class="line">        filter,</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(laptop *pb.Laptop)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            res := &amp;pb.SearchLaptopResponse&#123;Laptop: laptop&#125;</span><br><span class="line">            err := stream.Send(res)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.Printf(<span class="string">&quot;sent laptop with id: %s&quot;</span>, laptop.GetId())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status.Errorf(codes.Internal, <span class="string">&quot;unexpected error: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们要做的第一件事是从请求中获取过滤器。然后我们调用server.Store.Search()，传入流上下文、过滤器和回调函数。</p>
<p>如果发生错误，我们将其与Internal状态码一起返回，否则我们返回 nil。</p>
<p>在回调函数中，当我们找到一台笔记本电脑时，我们用该笔记本电脑创建一个新的响应对象，并通过调用stream.Send().</p>
<p>如果发生错误，只需返回它。否则，我们会写一个简单的日志，说明我们已经用这个 ID 发送了笔记本电脑，然后返回 nil。</p>
<p>我们已经完成了服务器。现在让我们实现客户端！</p>
<h3 id="实现客户端">实现客户端</h3>
<p>首先，我将拆分代码以创建我们在上一课中编写的随机笔记本电脑到一个单独的函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createLaptop</span><span class="params">(laptopClient pb.LaptopServiceClient)</span></span> &#123;</span><br><span class="line">    laptop := sample.NewLaptop()</span><br><span class="line">    laptop.Id = <span class="string">&quot;&quot;</span></span><br><span class="line">    req := &amp;pb.CreateLaptopRequest&#123;</span><br><span class="line">        Laptop: laptop,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set timeout</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    res, err := laptopClient.CreateLaptop(ctx, req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        st, ok := status.FromError(err)</span><br><span class="line">        <span class="keyword">if</span> ok &amp;&amp; st.Code() == codes.AlreadyExists &#123;</span><br><span class="line">            <span class="comment">// not a big deal</span></span><br><span class="line">            log.Print(<span class="string">&quot;laptop already exists&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.Fatal(<span class="string">&quot;cannot create laptop: &quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.Printf(<span class="string">&quot;created laptop with id: %s&quot;</span>, res.Id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 main 函数中，我们将使用一个 for 循环来创建 10 台随机笔记本电脑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    serverAddress := flag.String(<span class="string">&quot;address&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;the server address&quot;</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line">    log.Printf(<span class="string">&quot;dial server %s&quot;</span>, *serverAddress)</span><br><span class="line"></span><br><span class="line">    conn, err := grpc.Dial(*serverAddress, grpc.WithInsecure())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot dial server: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    laptopClient := pb.NewLaptopServiceClient(conn)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        createLaptop(laptopClient)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    filter := &amp;pb.Filter&#123;</span><br><span class="line">        MaxPriceUsd: <span class="number">3000</span>,</span><br><span class="line">        MinCpuCores: <span class="number">4</span>,</span><br><span class="line">        MinCpuGhz:   <span class="number">2.5</span>,</span><br><span class="line">        MinRam:      &amp;pb.Memory&#123;Value: <span class="number">8</span>, Unit: pb.Memory_GIGABYTE&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    searchLaptop(laptopClient, filter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们创建一个新的搜索过滤器。假设我想搜索笔记本电脑：</p>
<ul>
<li>最高价3000</li>
<li>至少 4 个 CPU 内核</li>
<li>最低频率为 2.5 Ghz</li>
<li>以及至少 8 GB 的 RAM<br>
之后，我们searchLaptop()使用 this 过滤器调用。让我们实现这个功能！</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchLaptop</span><span class="params">(laptopClient pb.LaptopServiceClient, filter *pb.Filter)</span></span> &#123;</span><br><span class="line">    log.Print(<span class="string">&quot;search filter: &quot;</span>, filter)</span><br><span class="line"></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    req := &amp;pb.SearchLaptopRequest&#123;Filter: filter&#125;</span><br><span class="line">    stream, err := laptopClient.SearchLaptop(ctx, req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot search laptop: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        res, err := stream.Recv()</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(<span class="string">&quot;cannot receive response: &quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        laptop := res.GetLaptop()</span><br><span class="line">        log.Print(<span class="string">&quot;- found: &quot;</span>, laptop.GetId())</span><br><span class="line">        log.Print(<span class="string">&quot;  + brand: &quot;</span>, laptop.GetBrand())</span><br><span class="line">        log.Print(<span class="string">&quot;  + name: &quot;</span>, laptop.GetName())</span><br><span class="line">        log.Print(<span class="string">&quot;  + cpu cores: &quot;</span>, laptop.GetCpu().GetNumberCores())</span><br><span class="line">        log.Print(<span class="string">&quot;  + cpu min ghz: &quot;</span>, laptop.GetCpu().GetMinGhz())</span><br><span class="line">        log.Print(<span class="string">&quot;  + ram: &quot;</span>, laptop.GetRam())</span><br><span class="line">        log.Print(<span class="string">&quot;  + price: &quot;</span>, laptop.GetPriceUsd())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先创建一个超时时间为 5 秒的上下文。我们SearchLaptopRequest用输入过滤器制作一个对象。然后我们调用laptopClient.SearchLaptop()获取流。</p>
<p>如果有错误，写一个致命日志。否则，我们使用 for 循环从流中接收多个响应。</p>
<p>如果stream.Recv()函数调用返回一个文件结束 (EOF) 错误，这意味着它是流的结尾，所以我们只是返回。否则，如果 error 不为零，我们会写一个致命日志。</p>
<p>如果一切顺利，我们可以从流中获取笔记本电脑。这里我只打印了笔记本电脑的一些属性，以便于阅读。</p>
<h2 id="使用客户端流式-gRPC-分块上传文件-Go">使用客户端流式 gRPC 分块上传文件 - Go</h2>
<h3 id="在proto文件中定义client-streaming-RPC">在proto文件中定义client-streaming RPC</h3>
<p>laptop_service.proto让我们在文件中定义新的 RPC 。</p>
<p>首先，我们需要一条UploadImageRequest消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message UploadImageRequest &#123;</span><br><span class="line">  oneof data &#123;</span><br><span class="line">    ImageInfo info = 1;</span><br><span class="line">    bytes chunk_data = 2;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路是将图像文件分成多个块，在每个请求消息中一个一个地发送给服务器。我oneof在这里使用一个字段，因为第一个请求将只包含元数据，或者图像的一些基本信息。然后以下请求将包含图像数据块。</p>
<p>该ImageInfo消息将包含 2 个字符串字段：笔记本电脑 ID 和图像类型，例如“.jpg”或“.png”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message ImageInfo &#123;</span><br><span class="line">  string laptop_id = 1;</span><br><span class="line">  string image_type = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们定义一条UploadImageResponse消息，一旦服务器接收到所有图像块，该消息将返回给客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message UploadImageResponse &#123;</span><br><span class="line">  string id = 1;</span><br><span class="line">  uint32 size = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，现在我们定义UploadImageRPC。这是一个客户端流式 RPC，因此它需要一个流UploadImageRequest作为输入并返回 1 个 single UploadImageResponse。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service LaptopService &#123;</span><br><span class="line">  ...</span><br><span class="line">  rpc UploadImage(stream UploadImageRequest) returns (UploadImageResponse) &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的，现在让我们运行makegen 来生成代码。</p>
<p>成功生成代码后，我们会看到代码中有一些错误，因为笔记本服务器没有实现接口UploadImage()所需的方法LaptopServiceServer。</p>
<h3 id="实现服务器-2">实现服务器</h3>
<p>让我们打开laptop_server.go文件并将UploadImage()函数添加到LaptopServer结构中。laptop_service.pb.go我们可以很容易地在生成的文件中找到它的签名。只需将其复制并粘贴到laptop_server.go文件中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *LaptopServer)</span> <span class="title">UploadImage</span><span class="params">(stream pb.LaptopService_UploadImageServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们暂时返回nil。我们稍后会在实现图像存储后回到这个功能。</p>
<h4 id="实现图片存储">实现图片存储</h4>
<p>store的作用是将上传的图片文件保存在服务器或云端的某处。为了使其更通用和更容易更改为不同类型的存储，我们将其定义ImageStore为接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ImageStore <span class="keyword">interface</span> &#123;</span><br><span class="line">    Save(laptopID <span class="keyword">string</span>, imageType <span class="keyword">string</span>, imageData bytes.Buffer) (<span class="keyword">string</span>, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它有 1 个函数来保存笔记本电脑图像，它需要 3 个输入参数：笔记本电脑 ID、图像类型和字节缓冲区给出的图像数据。它会返回已保存图像的 ID，否则会出错。</p>
<p>接下来我们将使用 实现这个接口DiskImageStore，它将图像文件保存到磁盘，并将其信息存储在内存中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DiskImageStore <span class="keyword">struct</span> &#123;</span><br><span class="line">    mutex       sync.RWMutex</span><br><span class="line">    imageFolder <span class="keyword">string</span></span><br><span class="line">    images      <span class="keyword">map</span>[<span class="keyword">string</span>]*ImageInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与笔记本电脑商店类似，我们需要一个互斥锁来处理并发。然后我们需要文件夹的路径来保存笔记本电脑图像。最后一张map，key是图片ID，value是图片的一些信息。</p>
<p>ImageInfo 包含 3 个字段：笔记本电脑的 ID、图像的类型（或其文件扩展名：jpg/png）和图像文件在磁盘上的路径。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ImageInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    LaptopID <span class="keyword">string</span></span><br><span class="line">    Type     <span class="keyword">string</span></span><br><span class="line">    Path     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们编写一个函数来创建一个新的DiskImageStore. 它只有 1 个输入，即图像文件夹。在里面，我们只需要初始化images地图：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDiskImageStore</span><span class="params">(imageFolder <span class="keyword">string</span>)</span> *<span class="title">DiskImageStore</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;DiskImageStore&#123;</span><br><span class="line">        imageFolder: imageFolder,</span><br><span class="line">        images:      <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*ImageInfo),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们必须实现接口Save()所需的ImageStore功能。</p>
<p>首先，我们必须为图像生成一个新的随机 UUID。我们通过加入图像文件夹、图像 ID 和图像类型来创建存储图像的路径。</p>
<p>然后我们调用os.Create()创建文件。我们调用imageData.WriteTo()将图像数据写入创建的文件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *DiskImageStore)</span> <span class="title">Save</span><span class="params">(laptopID <span class="keyword">string</span>, imageType <span class="keyword">string</span>, imageData bytes.Buffer)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    imageID, err := uuid.NewRandom()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;cannot generate image id: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    imagePath := fmt.Sprintf(<span class="string">&quot;%s/%s%s&quot;</span>, store.imageFolder, imageID, imageType)</span><br><span class="line"></span><br><span class="line">    file, err := os.Create(imagePath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;cannot create image file: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _, err = imageData.WriteTo(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;cannot write image to file: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    store.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> store.mutex.Unlock()</span><br><span class="line"></span><br><span class="line">    store.images[imageID.String()] = &amp;ImageInfo&#123;</span><br><span class="line">        LaptopID: laptopID,</span><br><span class="line">        Type:     imageType,</span><br><span class="line">        Path:     imagePath,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imageID.String(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果文件写入成功，我们需要将其信息保存到内存映射中。所以我们要获取store的写锁。</p>
<p>然后我们将图片信息保存到map中，key为图片的ID，value包含笔记本ID、图片类型、图片文件路径。</p>
<p>最后，我们将图像 ID 返回给调用者。就是这样，我们完成了图像存储。现在让我们回到服务器。</p>
<h4 id="实现-UploadImage-RPC">实现 UploadImage RPC</h4>
<p>我们需要将新的图像存储添加到LaptopServer结构中，并添加imageStore作为函数的第二个参数NewLaptopServer()：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LaptopServer <span class="keyword">struct</span> &#123;</span><br><span class="line">    laptopStore LaptopStore</span><br><span class="line">    imageStore  ImageStore</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLaptopServer</span><span class="params">(laptopStore LaptopStore, imageStore ImageStore)</span> *<span class="title">LaptopServer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;LaptopServer&#123;laptopStore, imageStore&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UploadImage upload images</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *LaptopServer)</span> <span class="title">UploadImage</span><span class="params">(stream pb.LaptopService_UploadImageServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	req, err := stream.Recv()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> logError(status.Errorf(codes.Unknown, <span class="string">&quot;cannot receive image info&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	laptopID := req.GetInfo().GetLaptopId()</span><br><span class="line">	imageType := req.GetInfo().GetImageType()</span><br><span class="line">	log.Printf(<span class="string">&quot;receive an upload-image request for laptop %s with image type %s&quot;</span>, laptopID, imageType)</span><br><span class="line"></span><br><span class="line">	laptop, err := server.laptopStore.Find(laptopID)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> logError(status.Errorf(codes.Internal, <span class="string">&quot;cannot find laptop:%v&quot;</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> laptop == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> logError(status.Errorf(codes.InvalidArgument, <span class="string">&quot;laptop id %s doesn&#x27;t exist&quot;</span>, laptopID))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imageData := bytes.Buffer&#123;&#125;</span><br><span class="line">	imageSize := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		log.Print(<span class="string">&quot;waiting to receive more data...&quot;</span>)</span><br><span class="line"></span><br><span class="line">		req, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			log.Print(<span class="string">&quot;no more data&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> logError(status.Errorf(codes.Unknown, <span class="string">&quot;cannot receive chunk data:%v&quot;</span>, err))</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		chunk:=req.GetChunkData()</span><br><span class="line">		size:=<span class="built_in">len</span>(chunk)</span><br><span class="line">		</span><br><span class="line">		log.Printf(<span class="string">&quot;received a chunk with size:%d&quot;</span>,size)</span><br><span class="line">		</span><br><span class="line">		imageSize+=size</span><br><span class="line">		<span class="keyword">if</span> imageSize&gt;maxImageSize&#123;</span><br><span class="line">			<span class="keyword">return</span> logError(status.Errorf(codes.InvalidArgument,<span class="string">&quot;cannot write chunk data:%v&quot;</span>,err))</span><br><span class="line">		&#125;</span><br><span class="line">		_,err=imageData.Write(chunk)</span><br><span class="line">		<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> logError(status.Errorf(codes.Internal,<span class="string">&quot;cannot write chunk data:%v&quot;</span>,err))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	imageID,err:=server.imageStore.Save(laptopID,imageType,imageData)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> logError(status.Errorf(codes.Internal,<span class="string">&quot;cannot save image to the store:%v&quot;</span>,err))</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	res:=&amp;pb.UploadImageResponse&#123;</span><br><span class="line">		Id: imageID,</span><br><span class="line">		Size: <span class="keyword">uint32</span>(imageSize),</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	err=stream.SendAndClose(res)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> logError(status.Errorf(codes.Unknown,<span class="string">&quot;cannot send response:%v&quot;</span>,err))</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	log.Printf(<span class="string">&quot;saved image with id:%s,size:%d&quot;</span>,imageID,imageSize)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logError</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Print(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/RPC%E6%A1%86%E6%9E%B6/" rel="tag"># RPC框架</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/04/22/Know-GNN-An-Explainable-Knowledge-Guided-Graph-Neural-Network-for-Fraud-Detection/" rel="prev" title="Know-GNN: An Explainable Knowledge-Guided Graph Neural Network for Fraud Detection">
                  <i class="fa fa-chevron-left"></i> Know-GNN: An Explainable Knowledge-Guided Graph Neural Network for Fraud Detection
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/04/28/ubuntu%E4%B8%8B%E6%9F%90%E4%B8%AAapt%E7%9A%84%E5%8C%85%E6%89%80%E5%9C%A8%E8%B7%AF%E5%BE%84/" rel="next" title="ubuntu下某个apt的包所在路径">
                  ubuntu下某个apt的包所在路径 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weirdo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"weirdoblog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
