<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="-jCet6qPD7nML4-W6IY2HZwfSblJyWta_Jx7_AGHgIk">
  <meta name="baidu-site-verification" content="f349dc627a72ee616d62ed513574025d">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/orange/pace-theme-center-circle.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"weirdozz.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="课程官方文档地址 docker的下载 ubuntu的docker下载地址 照着上述地址的步骤进行下载安装docker 为了不用每次都要sudo权限运行docker，进行以下步骤使我们当前用户具有启用docker权限 1234sudo groupadd docker &#x2F;&#x2F;创建docker组 通常来说安装万docker就已经自动创建好了sudo usermod -aG docker $USER &#x2F;&#x2F;将">
<meta property="og:type" content="article">
<meta property="og:title" content="使用golang+postgres+docker进行开发">
<meta property="og:url" content="https://weirdozz.github.io/2022/01/28/%E4%BD%BF%E7%94%A8golang+postgres+docker%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/index.html">
<meta property="og:site_name" content="Weirdo">
<meta property="og:description" content="课程官方文档地址 docker的下载 ubuntu的docker下载地址 照着上述地址的步骤进行下载安装docker 为了不用每次都要sudo权限运行docker，进行以下步骤使我们当前用户具有启用docker权限 1234sudo groupadd docker &#x2F;&#x2F;创建docker组 通常来说安装万docker就已经自动创建好了sudo usermod -aG docker $USER &#x2F;&#x2F;将">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.imgur.com/Ai2hmEK.png">
<meta property="og:image" content="https://i.imgur.com/HNe1dBh.png">
<meta property="article:published_time" content="2022-01-28T14:47:22.000Z">
<meta property="article:modified_time" content="2022-03-16T14:38:03.594Z">
<meta property="article:author" content="Weirdo">
<meta property="article:tag" content="sql,docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.imgur.com/Ai2hmEK.png">


<link rel="canonical" href="https://weirdozz.github.io/2022/01/28/%E4%BD%BF%E7%94%A8golang+postgres+docker%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://weirdozz.github.io/2022/01/28/%E4%BD%BF%E7%94%A8golang+postgres+docker%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/","path":"2022/01/28/使用golang+postgres+docker进行开发/","title":"使用golang+postgres+docker进行开发"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>使用golang+postgres+docker进行开发 | Weirdo</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Weirdo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-film fa-fw"></i>电影</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书籍</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#docker%E7%9A%84%E4%B8%8B%E8%BD%BD"><span class="nav-number">1.</span> <span class="nav-text">docker的下载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#docker%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%98%A0%E5%B0%84"><span class="nav-number">1.1.</span> <span class="nav-text">docker端口的映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#postgres%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85"><span class="nav-number">1.2.</span> <span class="nav-text">postgres的下载安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C"><span class="nav-number">1.3.</span> <span class="nav-text">进入容器的命令行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E7%9A%84%E6%97%A5%E5%BF%97"><span class="nav-number">1.4.</span> <span class="nav-text">查看容器的日志</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dbdiagram%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.</span> <span class="nav-text">dbdiagram的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tableplus%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88GUI%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">tableplus的使用（GUI）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%81%E7%A7%BB"><span class="nav-number">4.</span> <span class="nav-text">数据库的迁移</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8golang%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="nav-number">5.</span> <span class="nav-text">使用golang对数据库进行增删改查</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-2"><span class="nav-number">5.1.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sqlc"><span class="nav-number">5.2.</span> <span class="nav-text">sqlc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E5%8D%95%E5%85%83"><span class="nav-number">6.</span> <span class="nav-text">测试单元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1"><span class="nav-number">7.</span> <span class="nav-text">数据库事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8go%E5%AE%9E%E7%8E%B0DB%E4%BA%8B%E5%8A%A1"><span class="nav-number">7.1.</span> <span class="nav-text">用go实现DB事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88%E6%9D%A5%E6%89%A9%E5%B1%95Queries%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">7.1.1.</span> <span class="nav-text">使用组合来扩展Queries的功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84Store%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.1.2.</span> <span class="nav-text">创建一个新的Store对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1"><span class="nav-number">7.1.3.</span> <span class="nav-text">执行一个通用数据库事务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%BD%AC%E8%B4%A6%E4%BA%8B%E5%8A%A1"><span class="nav-number">7.2.</span> <span class="nav-text">实现转账事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E8%BD%AC%E8%B4%A6%E4%BA%8B%E5%8A%A1"><span class="nav-number">7.3.</span> <span class="nav-text">测试转账事务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E9%94%81%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81"><span class="nav-number">8.</span> <span class="nav-text">事务锁以及如何解决死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%BC%80%E5%8F%91"><span class="nav-number">8.1.</span> <span class="nav-text">测试驱动的开发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E8%B4%A6%E6%88%B7%E4%BD%99%E9%A2%9D"><span class="nav-number">8.2.</span> <span class="nav-text">更新账户余额</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">9.</span> <span class="nav-text">如何避免死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Gin%E6%A1%86%E6%9E%B6%E5%9C%A8go%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%AE%9E%E7%8E%B0HTTP-API"><span class="nav-number">10.</span> <span class="nav-text">使用Gin框架在go语言中实现HTTP API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">10.1.</span> <span class="nav-text">定义服务器结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%88%9B%E5%BB%BA%E8%B4%A6%E6%88%B7API"><span class="nav-number">10.2.</span> <span class="nav-text">实现创建账户API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%90%AFHTTP%E6%9C%8D%E5%8A%A1"><span class="nav-number">10.3.</span> <span class="nav-text">开启HTTP服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95API%E6%8E%A5%E5%8F%A3"><span class="nav-number">10.4.</span> <span class="nav-text">测试API接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0get-account-API%E6%8E%A5%E5%8F%A3"><span class="nav-number">10.5.</span> <span class="nav-text">实现get account API接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Viper%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">11.</span> <span class="nav-text">使用Viper从文件中加载配置和环境变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">11.1.</span> <span class="nav-text">创建配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">11.2.</span> <span class="nav-text">加载配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%B8%BB%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%BF%E7%94%A8LoadConfig"><span class="nav-number">11.3.</span> <span class="nav-text">在主函数中使用LoadConfig</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E6%B5%8B%E8%AF%95HTTP-API%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">12.</span> <span class="nav-text">为测试HTTP API模拟一个数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">12.1.</span> <span class="nav-text">模拟数据库的两种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85gomock"><span class="nav-number">12.2.</span> <span class="nav-text">安装gomock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89Store%E6%8E%A5%E5%8F%A3"><span class="nav-number">12.3.</span> <span class="nav-text">定义Store接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">12.4.</span> <span class="nav-text">生成模拟数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9API%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">12.5.</span> <span class="nav-text">对API进行单元测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96100-%E7%9A%84%E8%A6%86%E7%9B%96%E7%8E%87"><span class="nav-number">12.6.</span> <span class="nav-text">获取100%的覆盖率</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%82%E6%95%B0%E9%AA%8C%E8%AF%81%E5%99%A8%E5%AE%9E%E7%8E%B0%E8%BD%AC%E8%B4%A6"><span class="nav-number">13.</span> <span class="nav-text">使用自定义参数验证器实现转账</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%BD%AC%E8%B4%A6API%E7%9A%84handler"><span class="nav-number">13.1.</span> <span class="nav-text">实现转账API的handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%99%BB%E8%AE%B0%E8%BD%AC%E8%B4%A6API%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">13.2.</span> <span class="nav-text">登记转账API的路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B4%A7%E5%B8%81%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%9D%97"><span class="nav-number">13.3.</span> <span class="nav-text">实现自定义货币验证模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%99%BB%E8%AE%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E8%B4%A7%E5%B8%81%E9%AA%8C%E8%AF%81%E5%99%A8"><span class="nav-number">13.4.</span> <span class="nav-text">登记自定义的货币验证器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E9%AA%8C%E8%AF%81%E6%A8%A1%E5%9D%97"><span class="nav-number">13.5.</span> <span class="nav-text">使用自定义验证模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%89%B9%E6%AE%8A%E7%9A%84%E5%A4%96%E9%94%AE%E9%99%90%E5%88%B6%E5%9C%A8pgSQL%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E8%A1%A8"><span class="nav-number">14.</span> <span class="nav-text">通过特殊的外键限制在pgSQL中添加用户表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0user%E8%A1%A8"><span class="nav-number">14.1.</span> <span class="nav-text">增加user表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F"><span class="nav-number">14.2.</span> <span class="nav-text">增加外键约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E7%89%B9%E6%AE%8A%E7%BA%A6%E6%9D%9F"><span class="nav-number">14.3.</span> <span class="nav-text">增加特殊约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E6%96%B0%E7%9A%84schema%E6%B7%BB%E5%8A%A0%E5%88%B0%E9%A1%B9%E7%9B%AE%E4%B8%AD"><span class="nav-number">14.4.</span> <span class="nav-text">将新的schema添加到项目中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0up-migration"><span class="nav-number">14.5.</span> <span class="nav-text">实现up migration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8Cmiagrate-up"><span class="nav-number">14.6.</span> <span class="nav-text">执行miagrate up</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0migration-down"><span class="nav-number">14.7.</span> <span class="nav-text">实现migration down</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95up%E5%92%8Cdown%E7%9A%84migration"><span class="nav-number">14.8.</span> <span class="nav-text">测试up和down的migration</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86DB%E9%94%99%E8%AF%AF"><span class="nav-number">15.</span> <span class="nav-text">如何正确处理DB错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%92%8C%E8%8E%B7%E5%8F%96user"><span class="nav-number">15.1.</span> <span class="nav-text">生成代码来创建和获取user</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5%E9%9C%80%E8%A6%81%E7%BB%99%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95"><span class="nav-number">15.2.</span> <span class="nav-text">接下来需要给生成的代码编写测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E5%A4%8D%E5%A4%B1%E8%B4%A5%E4%BA%86%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-number">15.3.</span> <span class="nav-text">修复失败了的测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84DB%E9%94%99%E8%AF%AF"><span class="nav-number">15.4.</span> <span class="nav-text">处理不同类型的DB错误</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%9C%B0%E5%AD%98%E5%82%A8%E5%AF%86%E7%A0%81"><span class="nav-number">16.</span> <span class="nav-text">如何安全地存储密码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0hash%E5%92%8C%E6%AF%94%E8%BE%83%E5%AF%86%E7%A0%81"><span class="nav-number">16.1.</span> <span class="nav-text">实现hash和比较密码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%87%BD%E6%95%B0%E5%86%99%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">16.2.</span> <span class="nav-text">为这两个函数写单元测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E7%8E%B0%E6%9C%89%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">16.3.</span> <span class="nav-text">更新现有的代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E4%BF%9D%E6%89%80%E6%9C%89%E7%9A%84hashedpassword%E9%83%BD%E6%98%AF%E4%B8%8D%E5%90%8C%E7%9A%84"><span class="nav-number">16.4.</span> <span class="nav-text">确保所有的hashedpassword都是不同的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%88%9B%E5%BB%BAuser%E7%9A%84API"><span class="nav-number">16.5.</span> <span class="nav-text">实现创建user的API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#API%E4%B8%8D%E8%83%BD%E6%9A%B4%E9%9C%B2hash%E6%98%A0%E5%B0%84%E5%90%8E%E7%9A%84%E5%AF%86%E7%A0%81"><span class="nav-number">16.6.</span> <span class="nav-text">API不能暴露hash映射后的密码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84go-mock%E5%8C%B9%E9%85%8D%E5%99%A8%E5%86%99%E9%AB%98%E6%95%88%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">16.7.</span> <span class="nav-text">用自定义的go-mock匹配器写高效的单元测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8gomock-Eq"><span class="nav-number">16.8.</span> <span class="nav-text">尝试使用gomock.Eq</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89gomock%E5%8C%B9%E9%85%8D%E5%99%A8"><span class="nav-number">16.9.</span> <span class="nav-text">实现自定义gomock匹配器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%9F%BA%E4%BA%8E%E4%BB%A4%E7%89%8C%E7%9A%84%E9%AA%8C%E8%AF%81%E4%B8%8A%E4%B8%BA%E4%BB%80%E4%B9%88PASETO%E6%AF%94JWT%E5%A5%BD"><span class="nav-number">17.</span> <span class="nav-text">在基于令牌的验证上为什么PASETO比JWT好</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E4%BB%A4%E7%89%8C%E7%9A%84%E9%AA%8C%E8%AF%81"><span class="nav-number">17.1.</span> <span class="nav-text">基于令牌的验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON-Web-Tkoen-JWT"><span class="nav-number">17.2.</span> <span class="nav-text">JSON Web Tkoen(JWT)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E7%AE%97%E6%B3%95"><span class="nav-number">17.2.1.</span> <span class="nav-text">对称密钥算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E7%AE%97%E6%B3%95"><span class="nav-number">17.2.2.</span> <span class="nav-text">非对称密钥算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JWT%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">17.2.3.</span> <span class="nav-text">JWT存在的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PASETO-Platform-Agnostic-Security-Token"><span class="nav-number">17.3.</span> <span class="nav-text">PASETO-Platform Agnostic Security Token</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%8A%9B%E7%AE%97%E6%B3%95"><span class="nav-number">17.3.1.</span> <span class="nav-text">强力算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8go%E5%88%9B%E5%BB%BA%E5%92%8C%E9%AA%8C%E8%AF%81JWT%E5%92%8CPASETO"><span class="nav-number">18.</span> <span class="nav-text">如何用go创建和验证JWT和PASETO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%88%B6%E4%BD%9C%E4%BB%A4%E7%89%8C%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">18.1.</span> <span class="nav-text">声明制作令牌的接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8Etoken%E7%9A%84Payload%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">18.2.</span> <span class="nav-text">声明token的Payload结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0JWT-Maker"><span class="nav-number">18.3.</span> <span class="nav-text">实现JWT Maker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0JWT-CreateToken%E6%96%B9%E6%B3%95"><span class="nav-number">18.4.</span> <span class="nav-text">实现JWT CreateToken方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0JWT-VerifyToken%E6%96%B9%E6%B3%95"><span class="nav-number">18.5.</span> <span class="nav-text">实现JWT VerifyToken方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95JWT-Maker"><span class="nav-number">18.6.</span> <span class="nav-text">测试JWT Maker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0PASETO-Maker"><span class="nav-number">18.7.</span> <span class="nav-text">实现PASETO Maker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0paseto-CreateToken%E6%96%B9%E6%B3%95"><span class="nav-number">18.8.</span> <span class="nav-text">实现paseto CreateToken方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0paseto-VerifyToken-%E6%96%B9%E6%B3%95"><span class="nav-number">18.9.</span> <span class="nav-text">实现paseto VerifyToken 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95API%EF%BC%8C%E8%BF%94%E5%9B%9EPASETO%E6%88%96%E8%80%85JWT%E9%80%9A%E8%A1%8C%E8%AF%81"><span class="nav-number">19.</span> <span class="nav-text">实现用户登录API，返回PASETO或者JWT通行证</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86token-maker%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">19.1.</span> <span class="nav-text">将token maker添加到服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E5%A4%8D%E5%8F%97%E5%BD%B1%E5%93%8D%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">19.2.</span> <span class="nav-text">修复受影响的单元测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0login-user%E7%9A%84handler"><span class="nav-number">19.3.</span> <span class="nav-text">实现login user的handler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86login-api%E7%9A%84route%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A"><span class="nav-number">19.4.</span> <span class="nav-text">将login api的route添加到服务器上</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E9%AA%8C%E8%AF%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E6%8E%88%E6%9D%83%E8%A7%84%E5%88%99"><span class="nav-number">20.</span> <span class="nav-text">实现验证中间件和授权规则</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Weirdo"
      src="/images/weirdo.jpg">
  <p class="site-author-name" itemprop="name">Weirdo</p>
  <div class="site-description" itemprop="description">怕什么真理无穷，进一步有进一步的欢喜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weirdozz.github.io/2022/01/28/%E4%BD%BF%E7%94%A8golang+postgres+docker%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/weirdo.jpg">
      <meta itemprop="name" content="Weirdo">
      <meta itemprop="description" content="怕什么真理无穷，进一步有进一步的欢喜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weirdo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          使用golang+postgres+docker进行开发
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-01-28 22:47:22" itemprop="dateCreated datePublished" datetime="2022-01-28T22:47:22+08:00">2022-01-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-16 22:38:03" itemprop="dateModified" datetime="2022-03-16T22:38:03+08:00">2022-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">后端</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/01/28/%E4%BD%BF%E7%94%A8golang+postgres+docker%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/01/28/使用golang+postgres+docker进行开发/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><a target="_blank" rel="noopener" href="https://dev.to/techschoolguru/design-db-schema-and-generate-sql-code-with-dbdiagram-io-4ko5">课程官方文档地址</a></p>
<h2 id="docker的下载">docker的下载</h2>
<p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/ubuntu/">ubuntu的docker下载地址</a></p>
<p>照着上述地址的步骤进行下载安装docker</p>
<p>为了不用每次都要sudo权限运行docker，进行以下步骤使我们当前用户具有启用docker权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker //创建docker组 通常来说安装万docker就已经自动创建好了</span><br><span class="line">sudo usermod -aG docker $USER //将当前用户添加到组中</span><br><span class="line">newgrp docker  //刷新一下对group的更改</span><br><span class="line">docker run hello-world //测试不用sudo是否可以进行使用docker</span><br></pre></td></tr></table></figure>
<p><code>image</code>和<code>container</code>的区别在于，container是image的一个实例，通过<code>docker run</code>来启动，我们可以根据一个镜像启动多个container。</p>
<span id="more"></span>
<h3 id="docker端口的映射">docker端口的映射</h3>
<p>docker容器是在一个虚拟网络上运行的，因此我们不能简单地连接5432端口上的postgres服务器，我们需要让docker创建一个本地和容器网路的映射。</p>
<p>可以在容器启动的时候指定<code>-p 主机端口：容器端口</code></p>
<h3 id="postgres的下载安装">postgres的下载安装</h3>
<p>接着去下面的地址找到postgres的镜像文件进行下载安装，推荐使用官方镜像。或者直接使用<code>docker pull postgres</code>也是可以的。</p>
<p><a target="_blank" rel="noopener" href="https://hub.docker.com/_/postgres">postgres镜像地址</a></p>
<p>通过下列命令可以创建一个postgres镜像的实例，也就是数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name 实例名称 -p 5432:5432 -e POSTGRES_PASSWORD=密码 -d postgres:version //-p后面的是docker的端口与主机端口的映射</span><br></pre></td></tr></table></figure>
<h3 id="进入容器的命令行">进入容器的命令行</h3>
<p>使用<code>docker exec</code>命令可以让我们在容器中执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器名 psql -U 用户名</span><br></pre></td></tr></table></figure>
<p><code>it</code>是高速docker以交互式模式启动命令行，然后指定容器名。由于我们想要运行的是postgresql的命令，所以我们使用<code>psql</code>,最后指定用户名。</p>
<h3 id="查看容器的日志">查看容器的日志</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs 容器名（或者id）</span><br></pre></td></tr></table></figure>
<h2 id="dbdiagram的使用">dbdiagram的使用</h2>
<p><a target="_blank" rel="noopener" href="https://dbdiagram.io/">dbdiagram网址</a></p>
<p>进去后按照自己的需要设计数据库，并且可以导出为sql文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Table accounts as A &#123;</span><br><span class="line">  id bigserial [pk]</span><br><span class="line">  owner varchar</span><br><span class="line">  balance bigint</span><br><span class="line">  currency varchar</span><br><span class="line">  created_at timestamptz [default: `now()`]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>bigserial</code>类型可以自增，是八个字节的，余额使用的是<code>bigint</code>这历史为了方便，实际上应该是<code>decimal</code>类型的。时间戳的格式我们不用<code>timestamp</code>而是<code>timestamptz</code>是因为后者包含了时区信息，并且我们需要给他设置默认值为当时的时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Table entries &#123;</span><br><span class="line">  id bigserial [pk]</span><br><span class="line">  account_id bigint [ref: &gt; A.id]</span><br><span class="line">  amount bigint</span><br><span class="line">  created_at timestamptz [default: `now()`]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>entry表记录了某个账户所有的出入帐，其中账户id必须是accounts表中有的，所以需要设置一个<code>ref</code>关系来与accounts表建立联系，属于外键。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Table transfers &#123;</span><br><span class="line">  id bigserial [pk]</span><br><span class="line">  from_account_id bigint [ref: &gt; A.id]</span><br><span class="line">  to_account_id bigint [ref: &gt; A.id]</span><br><span class="line">  amount bigint</span><br><span class="line">  created_at timestamptz [default: `now()`]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外我们还可以对每个字段增加一些限制，由于其他的字段并没什么好限制的，所以都只需要加上<code>not null</code>限制，此外，对于entries表，出入账可以为正负，正表示入，负表示出，但是对于transfers表，出入关系在其他字段给出了，所以数额字段只能是正。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Table accounts as A &#123;</span><br><span class="line">  id bigserial [pk]</span><br><span class="line">  owner varchar [not null]</span><br><span class="line">  balance bigint [not null]</span><br><span class="line">  currency varchar [not null]</span><br><span class="line">  created_at timestamptz [not null, default: `now()`]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Table entries &#123;</span><br><span class="line">  id bigserial [pk]</span><br><span class="line">  account_id bigint [ref: &gt; A.id, not null]</span><br><span class="line">  amount bigint [not null, note: &#x27;can be negative or positive&#x27;]</span><br><span class="line">  created_at timestamptz [not null, default: `now()`]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Table transfers &#123;</span><br><span class="line">  id bigserial [pk]</span><br><span class="line">  from_account_id bigint [ref: &gt; A.id, not null]</span><br><span class="line">  to_account_id bigint [ref: &gt; A.id, not null]</span><br><span class="line">  amount bigint [not null, note: &#x27;must be positive&#x27;]</span><br><span class="line">  created_at timestamptz [not null, default: `now()`]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外我们还可以定义自己的枚举类型，比如说对于货币的种类我们只设置两种<code>USD</code>和<code>EUR</code>,那我们就可以设置字段的类型为自己的自定义类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum Currency &#123;</span><br><span class="line">    USD</span><br><span class="line">    EUR</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Table accounts as A &#123;</span><br><span class="line">  ...</span><br><span class="line">  currency Currency [not null]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>transfers表记录了每一笔账户之间的转账，我们在这里只考虑本simple bank中的账户之间的转账行为。</p>
<p>接下来我们可以给表添加索引，在accounts表中我们想要能够通过onwer的名字来查询账户，所以我们将owner增加到indexes列表中。</p>
<p>在entries表中，我们可能会需要列出一个账户的所有出入账，所以我们需要将<code>account_id</code>添加到索引中</p>
<p>在transfers表中我们可能需要搜索一个账户全部的出账，或者一个账户全部的入账，甚至两个账户之间的所有交易记录，所以我们要将这两个字段和<strong>两个字段的组合</strong>添加到索引中</p>
<p>接下来我们就可以生成sql代码了，当然也可以生成其他各种形式的如pdf、图片或者是mysql的代码。</p>
<h2 id="tableplus的使用（GUI）">tableplus的使用（GUI）</h2>
<p><a target="_blank" rel="noopener" href="https://tableplus.com/">tableplus官网</a></p>
<p>去到tableplus官网按照官网教程下载安装，之后就可以用这个的可视化界面管理数据库</p>
<h2 id="数据库的迁移">数据库的迁移</h2>
<p>首先需要下载安装migrate库<a target="_blank" rel="noopener" href="https://github.com/golang-migrate/migrate">migrate的github地址</a>。进入cmd/migrate目录下按照提示操作安装migrate</p>
<p>在需要迁移的项目下创建db目录，进入目录后输入<code>migrate create -ext sql -dir db/migration -seq init_schema</code>，然后将初始化db的query语句复制粘贴到其中的up文件中，删除操作放入到down文件中。<strong>写删除操作的时候需要注意，要先删除依赖别的表的表，否则无法删除</strong></p>
<p>接着创建一个Makefile脚本，其基本格式可以如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">postgres:</span></span><br><span class="line">  docker run --name postgres14 -p 5432:5432 -e POSTGRES_USER=root -e POSTGRES_PASSWORD=123 -d postgres</span><br><span class="line"><span class="section">createdb:</span></span><br><span class="line">  docker exec -it postgres14 createdb --username=root --owner=root simplebank</span><br><span class="line"><span class="section">dropdb:</span></span><br><span class="line">  docker exec -it postgres14 dropdb simplebank</span><br><span class="line"><span class="section">migrateup:</span></span><br><span class="line">  migrate -path db -database <span class="string">&quot;postgresql://root:123@localhost:5432/simplebank?sslmode=disable&quot;</span> -verbose up</span><br><span class="line"><span class="section">migratedown:</span></span><br><span class="line">  migrate -path db -database <span class="string">&quot;postgresql://root:123@localhost:5432/simplebank?sslmode=disable&quot;</span> -verbose down</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:postgres createdb dropdb migrateup migratedown</span></span><br></pre></td></tr></table></figure>
<p>是为了方便整个项目在别的地方使用。</p>
<h2 id="使用golang对数据库进行增删改查">使用golang对数据库进行增删改查</h2>
<h3 id="方法-2">方法</h3>
<ul>
<li>使用DATABASE/SQL库
<ul>
<li>优点：快且直接</li>
<li>缺点：需要手动将sql字段映射到变量，容易出错</li>
</ul>
</li>
<li>GORM库
<ul>
<li>优点：生产代码短</li>
<li>缺点：流量很高时运行速度较慢</li>
</ul>
</li>
<li>SQLX库
<ul>
<li>优点：相当快并且易于使用</li>
<li>缺点：执行时才会出现错误</li>
</ul>
</li>
<li>SQLC库：
<ul>
<li>优点：运行快，只需要编写query就可以让golang自动生成代码，错误可以被立即发现</li>
<li>缺点：只支持postgres</li>
</ul>
</li>
</ul>
<h3 id="sqlc">sqlc</h3>
<p>首先去sqlc的官方文档，并且根据自己的系统安装sqlc</p>
<p>然后进入项目目录下运行<code>sqlc init</code>,会自动生成一个yaml文件，我们将这个文件进行填充修改如下，其中参数可以自己设定</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="attr">packages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;db&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;./db/sqlc&quot;</span></span><br><span class="line">    <span class="attr">queries:</span> <span class="string">&quot;./db/query/&quot;</span></span><br><span class="line">    <span class="attr">schema:</span> <span class="string">&quot;./db/migration/&quot;</span></span><br><span class="line">    <span class="attr">engine:</span> <span class="string">&quot;postgresql&quot;</span></span><br><span class="line">    <span class="attr">emit_json_tags:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">emit_prepared_queries:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">emit_interface:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">emit_exact_table_names:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">emit_empty_slices:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>然后在db目录下创建一个query目录，其中存放我们对于数据库中表的CRUD操作的语句，语句开头用<code>--name:函数名:返回条目数量</code>来控制我们稍后自动生成的golang代码的函数。其形式大概是这样的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- name: CreateAccount :one</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> accounts (</span><br><span class="line">    owner,</span><br><span class="line">    balance,</span><br><span class="line">    currency</span><br><span class="line">) <span class="keyword">VALUES</span> (</span><br><span class="line">$<span class="number">1</span>, $<span class="number">2</span>,$<span class="number">3</span></span><br><span class="line">)</span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- name: GetAccount :one</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> $<span class="number">1</span> LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- name: ListAccount :many</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id</span><br><span class="line">LIMIT $<span class="number">1</span></span><br><span class="line"><span class="keyword">OFFSET</span> $<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- name: UpdateAccount :one</span></span><br><span class="line">UPDATE accounts</span><br><span class="line"><span class="keyword">SET</span> balance <span class="operator">=</span> $<span class="number">2</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> $<span class="number">1</span></span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- name: DeleteAuthor :exec</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> accounts <span class="keyword">WHERE</span> id <span class="operator">=</span> $<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>同样在db目录下创建一个sqlc目录，存放由sqlc生成的.go文件，命令行使用<code>sql generate</code>语句就可以自动生成对应的go文件。</p>
<p>对于这些生成的文件我们不要去对它作修改改动，因为下次生成时会覆盖掉，如果我们需要自定义功能，就自己写一个文件。</p>
<h2 id="测试单元">测试单元</h2>
<p>对于生成的文件，我们需要测试其提供给我们的函数是否是正确有用的，首先需要在sqlc目录下创建一个main_test.go文件，其测试是否能连接到创建的数据库.其中的TestMain函数是所有测试单元的主入口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> db</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;database/sql&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line">_ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">dbDriver = <span class="string">&quot;postgres&quot;</span></span><br><span class="line">dbSource = <span class="string">&quot;postgresql://root:123@localhost:5432/simplebank?sslmode=disable&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testQueries *Queries</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">conn, err := sql.Open(dbDriver, dbSource)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  log.Fatal(<span class="string">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testQueries = New(conn)</span><br><span class="line">os.Exit(m.Run())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以在其他的各种不同的单元测试中进行各种不同函数的测试，需要检查测试结果的话，推荐使用github上的<code>testify</code>包中require子包，具体用法如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">require.NoError(t, err)<span class="comment">//判断没有产生err</span></span><br><span class="line">require.NotEmpty(t, account)</span><br><span class="line"></span><br><span class="line">require.Equal(t, arg.Owner, account.Owner)<span class="comment">//判断写入数据库的和返回的是同一份数据</span></span><br><span class="line">require.Equal(t, arg.Balance, account.Balance)</span><br><span class="line">require.Equal(t, arg.Currency, account.Currency)</span><br><span class="line"></span><br><span class="line">require.NotZero(t, account.ID)<span class="comment">//判断返回的不是零值</span></span><br><span class="line">require.NotZero(t, account.CreatedAt)</span><br></pre></td></tr></table></figure>
<p>为了更好地测试db，我们可以在工程目录下创建util目录，其中存放我们需要的一些工具函数。比如数据库表中的每个条目我们可以通过随机生成并放入，这时就需要随机生成数据的函数，可以放在这个目录下面。</p>
<h2 id="数据库事务">数据库事务</h2>
<p>之前写到的都是对数据库的增删改查操作，但是在实际操作中，一个事务往往需要结合多个数据库的CRUD操作</p>
<p>假设我们要开始一个从account1转10元到account2上，那么这个事务包含5个CRUD操作：</p>
<ol>
<li>创建一个transfer=10的记录</li>
<li>创建一个金额等于-10的记录，account1-10</li>
<li>创建另一条entry记录account2，金额为10</li>
<li>通过减去它来更新account1的banlance</li>
<li>增加它来更新account2的balance</li>
</ol>
<h3 id="用go实现DB事务">用go实现DB事务</h3>
<h4 id="使用组合来扩展Queries的功能">使用组合来扩展Queries的功能</h4>
<p>首先在<code>db/sqlc</code>下创建一个<code>store.go</code>文件，我们在其中定义一个新的<code>Store</code>结构体，该结构体会绑定其需要的函数来独立运行数据库查询语句。</p>
<p>之前已经由sqlc生成过对应的Quriers结构体了，但是一个query只能在一个表上执行一个特定的操作，所以Queries结构体并不支持事务。因此我们需要把它迁入到Store结构体中来扩展它的功能。将Queries迁入到Store后，Queries的函数将会对Store可用。</p>
<p>此外，还需要在Store结构体中加入sql.DB对象，因为它需要创建一个数据库事务</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Store <span class="keyword">struct</span> &#123;</span><br><span class="line">    *Queries</span><br><span class="line">    db *sql.DB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建一个新的Store对象">创建一个新的Store对象</h4>
<p>NewStore函数以一个<code>sql.DB</code>作为输入并且返回一个Store对象。Store.db就等于我们的输入，New()函数由sqlc生成，创建并返回一个Queries对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStore</span><span class="params">(db *sql.DB)</span> *<span class="title">Store</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Store&#123;</span><br><span class="line">        db:      db,</span><br><span class="line">        Queries: New(db),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行一个通用数据库事务">执行一个通用数据库事务</h4>
<p>思路很简单：该函数以上下文环境和回调函数作为输入，之后以一个新的数据库事务作为开始，通过该事务创建一个新的Queries对象，通过这个新的Queries调用回调函数，最终根据函数返回的error来确定提交还是回滚事务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *Store)</span> <span class="title">execTx</span><span class="params">(ctx context.Context, fn <span class="keyword">func</span>(*Queries)</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，调用<code>store.db.BeginTx()</code>来开启一个新的事务，将环境和一个可选的参数<code>sql.TxOptions</code>传入,该参数允许我们对该事务设置一个通用的隔离等级。如果我们设为nil则会用数据库默认的隔离等级，在postgres中就是读提交。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tx, err := store.db.BeginTx(ctx, &amp;sql.TxOptions&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p><code>BeginTx</code>函数会返回一个事务对象或一个错误，如果存在错误则直接返回，否则的话通过新构建的事务tx调用<code>New()</code>得到一个新的返回的Queries对象。这里的<code>New()</code>函数和上面的<code>NewStore()</code>中的是一样的。唯一的差别在于，我们传入一个<code>sql.Tx</code>而非<code>sql.DB</code>。因为<code>New()</code>函数接受的是一个DBTX接口。</p>
<p>现在有了能够在事务内部运行的queries，我们可以调用传入的函数并且获取返回的错误。如果存在错误的话，就调用<code>tx.Rollback()</code>回滚。同时会返回一个rollback错误。如果存在rollback错误，我们就需要报告两个错误。因此我们应该把他们合二为一，在返回之前使用<code>fmt.Errorf()</code>即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *Store)</span> <span class="title">execTx</span><span class="params">(ctx context.Context, fn <span class="keyword">func</span>(*Queries)</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">    tx, err := store.db.BeginTx(ctx, &amp;sql.TxOptions)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q := New(tx)</span><br><span class="line">    err = fn(q)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> rbErr := tx.Rollback(); rbErr != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;tx err: %v, rb err: %v&quot;</span>, err, rbErr)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tx.Commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果回滚成功的话我们只需要返回最初的事务错误。如果所有的操作都是成功的，我们只需要提交事务<code>tx.Commit()</code>就可以了，并且返回它的错误。</p>
<p>到此我们就已经完成<code>execTx()</code>函数了。需要注意的是这个函数是不导出的，我们不希望在包外部可以直接调用它，作为代替，我们对每个具体的事务提供一个导出的函数。</p>
<h3 id="实现转账事务">实现转账事务</h3>
<p>先回忆一下，这个事务需要创造一个新的转账记录，两条新的entry信息并且更新两个账户的余额。函数的输入应当是一个上下文变量和一个对应的<code>TransferTxParam</code>类型的参数。该函数需要返回一个<code>TransferTxResult</code>对象或者一个错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func (store *Store) TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TransferTxParams</code>结构体包含所有必要的在账户间转账的参数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TransferTxParams <span class="keyword">struct</span> &#123;</span><br><span class="line">    FromAccountID <span class="keyword">int64</span> <span class="string">`json:&quot;from_account_id&quot;`</span></span><br><span class="line">    ToAccountID   <span class="keyword">int64</span> <span class="string">`json:&quot;to_account_id&quot;`</span></span><br><span class="line">    Amount        <span class="keyword">int64</span> <span class="string">`json:&quot;amount&quot;`</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>TransferTxResult</code>包含转账事务的结果</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TransferTxResult <span class="keyword">struct</span> &#123;</span><br><span class="line">    Transfer    Transfer <span class="string">`json:&quot;transfer&quot;`</span></span><br><span class="line">    FromAccount Account  <span class="string">`json:&quot;from_account&quot;`</span></span><br><span class="line">    ToAccount   Account  <span class="string">`json:&quot;to_account&quot;`</span></span><br><span class="line">    FromEntry   Entry    <span class="string">`json:&quot;from_entry&quot;`</span></span><br><span class="line">    ToEntry     Entry    <span class="string">`json:&quot;to_entry&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在开始实现转账事务。首先创建一个空的结果，然后调用<code>store.execTX()</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *Store)</span> <span class="title">TransferTx</span><span class="params">(ctx context.Context, arg TransferTxParams)</span> <span class="params">(TransferTxResult, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result TransferTxResult</span><br><span class="line"></span><br><span class="line">    err := store.execTx(ctx, <span class="function"><span class="keyword">func</span><span class="params">(q *Queries)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，我们可以使用Queries对象q调用任何单独的CRUD操作。要记住这个q是在一个单独的数据库事务中创建的，所以它提供的所有方法都只在这个事务中运行。</p>
<p>接下来通过调用<code>q.CreateTransfer()</code>来创造我们的result中需要的transfer记录，该函数需要传入上下文变量和对应的<code>CreateTransferParams</code>变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *Store)</span> <span class="title">TransferTx</span><span class="params">(ctx context.Context, arg TransferTxParams)</span> <span class="params">(TransferTxResult, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    err := store.execTx(ctx, <span class="function"><span class="keyword">func</span><span class="params">(q *Queries)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">        result.Transfer, err = q.CreateTransfer(ctx, CreateTransferParams&#123;</span><br><span class="line">            FromAccountID: arg.FromAccountID,</span><br><span class="line">            ToAccountID:   arg.ToAccountID,</span><br><span class="line">            Amount:        arg.Amount,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们在回调函数中就能够接触到result和前面传入的arg变量，这使得回调函数形成一个闭包。go语言中由于缺乏泛型的概念，所以通常是使用这个方法来从回调函数中获取返回。</p>
<p>接着对result中剩下4个条目的方法的操作是一样的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *Store)</span> <span class="title">TransferTx</span><span class="params">(ctx context.Context, arg TransferTxParams)</span> <span class="params">(TransferTxResult, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    err := store.execTx(ctx, <span class="function"><span class="keyword">func</span><span class="params">(q *Queries)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">        result.Transfer, err = q.CreateTransfer(ctx, CreateTransferParams&#123;</span><br><span class="line">            FromAccountID: arg.FromAccountID,</span><br><span class="line">            ToAccountID:   arg.ToAccountID,</span><br><span class="line">            Amount:        arg.Amount,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.FromEntry, err = q.CreateEntry(ctx, CreateEntryParams&#123;</span><br><span class="line">            AccountID: arg.FromAccountID,</span><br><span class="line">            Amount:    -arg.Amount,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.ToEntry, err = q.CreateEntry(ctx, CreateEntryParams&#123;</span><br><span class="line">            AccountID: arg.ToAccountID,</span><br><span class="line">            Amount:    arg.Amount,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们现在完成了3个条目，剩下来的两个修改两个账户余额的操作比较复杂，涉及到死锁的问题，这一问题会在后面进行补充。</p>
<h3 id="测试转账事务">测试转账事务</h3>
<p>首先创建一个store_test.go文件和store.go处在同一个目录下，然后对<code>TransferTx()</code>定义一个单元测试。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTransferTx</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们需要先有一个Store对象，而<code>NewStore()</code>又需要有一个<code>sql.DB</code>对象，之前其实已经在<code>main_test.go</code>中创建了一个<code>sql.DB</code>对象，所以为了能够复用我们声明两个全局变量<code>testDB</code>和<code>testQueries</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testQueries *Queries</span><br><span class="line"><span class="keyword">var</span> testDB *sql.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> err error</span><br><span class="line">    testDB, err = sql.Open(dbDriver, dbSource)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    testQueries = New(testDB)</span><br><span class="line"></span><br><span class="line">    os.Exit(m.Run())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以回到我们的单元测试中，并且通过将这个全局变量传给<code>NewStore()</code>来创建一个新的store。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTransferTx</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    store := NewStore(testDB)</span><br><span class="line"></span><br><span class="line">    account1 := createRandomAccount(t)</span><br><span class="line">    account2 := createRandomAccount(t)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着创建两个随机账户，会在这两个账户之间进行转账。为了保证该事务能够很好的运行，我们测试时需要并行多个进程。我们可以并行5个进程来将账户1的钱转10元到账户2，可以用一个for循环来实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTransferTx</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    store := NewStore(testDB)</span><br><span class="line"></span><br><span class="line">    account1 := createRandomAccount(t)</span><br><span class="line">    account2 := createRandomAccount(t)</span><br><span class="line"></span><br><span class="line">    n := <span class="number">5</span></span><br><span class="line">    amount := <span class="keyword">int64</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run n concurrent transfer transaction</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            result, err := store.TransferTx(context.Background(), TransferTxParams&#123;</span><br><span class="line">                FromAccountID: account1.ID,</span><br><span class="line">                ToAccountID:   account2.ID,</span><br><span class="line">                Amount:        amount,</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在循环中我们不能立即使用<code>require</code>包来检查，因为这个函数运行在一个和我们的测试函数正在运行的进程所不相同的进程上，因此不能保证在某个条件不满足的情况下它会停止整个测试。</p>
<p>正确的做法是将result和err送到测试单元所在的主进程上。为了做到这一点，我们使用channel，在此处我们需要两个channel来分别传输result和err。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTransferTx</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run n concurrent transfer transaction</span></span><br><span class="line">    errs := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line">    results := <span class="built_in">make</span>(<span class="keyword">chan</span> TransferTxResult)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            result, err := store.TransferTx(context.Background(), TransferTxParams&#123;</span><br><span class="line">                FromAccountID: account1.ID,</span><br><span class="line">                ToAccountID:   account2.ID,</span><br><span class="line">                Amount:        amount,</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            errs &lt;- err</span><br><span class="line">            results &lt;- result</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样用一个for循环来获取channel中的值，并且对他们做检测</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTransferTx</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run n concurrent transfer transaction</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check results</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        err := &lt;-errs</span><br><span class="line">        require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">        result := &lt;-results</span><br><span class="line">        require.NotEmpty(t, result)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于result中包含了太多的参数，所以我们一个一个来验证他们</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTransferTx</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check results</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        err := &lt;-errs</span><br><span class="line">        require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">        result := &lt;-results</span><br><span class="line">        require.NotEmpty(t, result)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check transfer</span></span><br><span class="line">        transfer := result.Transfer</span><br><span class="line">        require.NotEmpty(t, transfer)</span><br><span class="line">        require.Equal(t, account1.ID, transfer.FromAccountID)</span><br><span class="line">        require.Equal(t, account2.ID, transfer.ToAccountID)</span><br><span class="line">        require.Equal(t, amount, transfer.Amount)</span><br><span class="line">        require.NotZero(t, transfer.ID)</span><br><span class="line">        require.NotZero(t, transfer.CreatedAt)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着为了确保transfer记录真的在数据库中创建了，我们应该调用<code>store.GetTransfer()</code>来找到一个相同ID的记录。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTransferTx</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check results</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="comment">// check transfer</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        _, err = store.GetTransfer(context.Background(), transfer.ID)</span><br><span class="line">        require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接着对于两个entry的检测也是同样的步骤，这里就不多赘述。</p>
<h2 id="事务锁以及如何解决死锁">事务锁以及如何解决死锁</h2>
<h3 id="测试驱动的开发">测试驱动的开发</h3>
<p>前面已经测试了三个部分了，剩下的余额部分还没有进行测试和开发，我们先写好测试程序，通过测试报错，不断完善开发程序直到测试程序能够通过。</p>
<p>首先判断两个账户不为空以及result中两个账户的ID和对应的账户ID是相同的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTransferTx</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check results</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check accounts</span></span><br><span class="line">        fromAccount := result.FromAccount</span><br><span class="line">        require.NotEmpty(t, fromAccount)</span><br><span class="line">        require.Equal(t, account1.ID, fromAccount.ID)</span><br><span class="line"></span><br><span class="line">        toAccount := result.ToAccount</span><br><span class="line">        require.NotEmpty(t, toAccount)</span><br><span class="line">        require.Equal(t, account2.ID, toAccount.ID)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> check accounts&#x27; balance</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们需要检查账户余额，将账户进行转账事务前的余额和进行事务后的余额做差，两个账户得到的差值应该是相同的，并且差值应该能够整除每一次的转账金额，因为转账次数为5次。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTransferTx</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check results</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check accounts&#x27; balance</span></span><br><span class="line">        diff1 := account1.Balance - fromAccount.Balance</span><br><span class="line">        diff2 := toAccount.Balance - account2.Balance</span><br><span class="line">        require.Equal(t, diff1, diff2)</span><br><span class="line">        require.True(t, diff1 &gt; <span class="number">0</span>)</span><br><span class="line">        require.True(t, diff1%amount == <span class="number">0</span>) <span class="comment">// 1 * amount, 2 * amount, 3 * amount, ..., n * amount</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，若我们计算出差值除以转账金额，就能够得到转账次数k，而且这个次数对于每次交易是唯一的，第一次就是1，第二次就是2。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTransferTx</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check results</span></span><br><span class="line">    existed := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check accounts&#x27; balance</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        k := <span class="keyword">int</span>(diff1 / amount)</span><br><span class="line">        require.True(t, k &gt;= <span class="number">1</span> &amp;&amp; k &lt;= n)</span><br><span class="line"></span><br><span class="line">        require.NotContains(t, existed, k)</span><br><span class="line">        existed[k] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们还需要确定所有转账完成后是否真的对数据库中的数据进行了改动，我们用<code>store.GetAccount()</code>从数据库中获取对应的账户，并且将它的余额与应当变成的余额做相等比较，此处应该是相等的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTransferTx</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check results</span></span><br><span class="line">    existed := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check the final updated balance</span></span><br><span class="line">    updatedAccount1, err := store.GetAccount(context.Background(), account1.ID)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    updatedAccount2, err := store.GetAccount(context.Background(), account2.ID)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    require.Equal(t, account1.Balance-<span class="keyword">int64</span>(n)*amount, updatedAccount1.Balance)</span><br><span class="line">    require.Equal(t, account2.Balance+<span class="keyword">int64</span>(n)*amount, updatedAccount2.Balance)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着就可以运行这个测试，当然测试失败了，因为我们的转账事务中的修改两方余额的部分还没有写呢！</p>
<h3 id="更新账户余额">更新账户余额</h3>
<p>通常我们一个直觉的想法就是通过<code>q.GetAccount()</code>获取账户然后通过<code>q.updateAccount()</code>来更新账户的余额，但是这样的做法是错误的，它没有考虑到锁的问题。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- name: GetAccount :one</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> $<span class="number">1</span> LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>从getAccount的数据库定义中我们可以发现它仅仅使用了一个SELECT语句，并没由阻止其他的事务来读取相同的账户记录，因此两个并行的记录可能会得到账户1的相同的值，并对这个值进行修改后提交。</p>
<p>这种情况可以在语句后面加上<code>FOR UPDATE</code>来创造一个锁，这样只有在前一个占用该数据的事务commit之后，后一个事务才能获取该条数据并且进行修改。</p>
<p>因此，我们可以在<code>account.sql</code>文件中增加一组操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- name: GetAccountForUpdate :one</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> $<span class="number">1</span> LIMIT <span class="number">1</span></span><br><span class="line"><span class="keyword">FOR</span> UPDATE;</span><br></pre></td></tr></table></figure>
<p>然后通过<code>make sqlc</code>来生成<code>account.sql.go</code>文件，这样我们需要的带锁的<code>GetAccountForUpdate()</code>函数就生成了。接着我们在事务中使用这个函数代替原本的<code>GetAccount()</code>函数，然而这一次又报错了，这次报的错是<strong>检查到死锁</strong>。</p>
<p>为了能够debug出错误出在那里，我们为每个事务都加上一个名字，使用<code>fmt.Sprintf()</code>来创造不同的事务名称</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTransferTx</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// run n concurrent transfer transaction</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        txName := fmt.Sprintf(<span class="string">&quot;tx %d&quot;</span>, i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            ctx := context.WithValue(context.Background(), txKey, txName)</span><br><span class="line"></span><br><span class="line">            result, err := store.TransferTx(ctx, TransferTxParams&#123;</span><br><span class="line">                FromAccountID: account1.ID,</span><br><span class="line">                ToAccountID:   account2.ID,</span><br><span class="line">                Amount:        amount,</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            errs &lt;- err</span><br><span class="line">            results &lt;- result</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check results</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了能够将事务额的名称加到环境中，我们调用<code>context.WithValue()</code>传入一个background上下文和一对键值对，其中值就是对应的事务名称。文档中有说明上下文环境的key不应当是string类型或者任何其他内置的类型，这是为了避免键冲突。通常来说我们应当定义一个struct类型的变量来作为key。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> txKey = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *Store)</span> <span class="title">TransferTx</span><span class="params">(ctx context.Context, arg TransferTxParams)</span> <span class="params">(TransferTxResult, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在<code>TransferTx()</code>中,上下文环境会拥有事务名称，我们可以通过调用<code>ctx.Value()</code>来获取<code>txKey</code>的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *Store)</span> <span class="title">TransferTx</span><span class="params">(ctx context.Context, arg TransferTxParams)</span> <span class="params">(TransferTxResult, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result TransferTxResult</span><br><span class="line"></span><br><span class="line">    err := store.execTx(ctx, <span class="function"><span class="keyword">func</span><span class="params">(q *Queries)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">        txName := ctx.Value(txKey)</span><br><span class="line"></span><br><span class="line">        fmt.Println(txName, <span class="string">&quot;create transfer&quot;</span>)</span><br><span class="line">        result.Transfer, err = q.CreateTransfer(ctx, CreateTransferParams&#123;</span><br><span class="line">            FromAccountID: arg.FromAccountID,</span><br><span class="line">            ToAccountID:   arg.ToAccountID,</span><br><span class="line">            Amount:        arg.Amount,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Println(txName, <span class="string">&quot;create entry 1&quot;</span>)</span><br><span class="line">        result.FromEntry, err = q.CreateEntry(ctx, CreateEntryParams&#123;</span><br><span class="line">            AccountID: arg.FromAccountID,</span><br><span class="line">            Amount:    -arg.Amount,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Println(txName, <span class="string">&quot;create entry 2&quot;</span>)</span><br><span class="line">        result.ToEntry, err = q.CreateEntry(ctx, CreateEntryParams&#123;</span><br><span class="line">            AccountID: arg.ToAccountID,</span><br><span class="line">            Amount:    arg.Amount,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// move money out of account1</span></span><br><span class="line">        fmt.Println(txName, <span class="string">&quot;get account 1&quot;</span>)</span><br><span class="line">        account1, err := q.GetAccountForUpdate(ctx, arg.FromAccountID)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Println(txName, <span class="string">&quot;update account 1&quot;</span>)</span><br><span class="line">        result.FromAccount, err = q.UpdateAccount(ctx, UpdateAccountParams&#123;</span><br><span class="line">            ID:      arg.FromAccountID,</span><br><span class="line">            Balance: account1.Balance - arg.Amount,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// move money into account2</span></span><br><span class="line">        fmt.Println(txName, <span class="string">&quot;get account 2&quot;</span>)</span><br><span class="line">        account2, err := q.GetAccountForUpdate(ctx, arg.ToAccountID)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fmt.Println(txName, <span class="string">&quot;update account 2&quot;</span>)</span><br><span class="line">        result.ToAccount, err = q.UpdateAccount(ctx, UpdateAccountParams&#123;</span><br><span class="line">            ID:      arg.ToAccountID,</span><br><span class="line">            Balance: account2.Balance + arg.Amount,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们已经把输出log功能添加到程序中了，接下来我们只并行运行两个进程来进行debug。最终遭到出现死锁的原因是更新操作需要对账户进行上锁，而Select操作的表中有来自账户表中的外键，这时事务2等待事务1，事务1等待事务2，形成了死锁。</p>
<p>此时我们已经知道，出现死锁的原因在于数据库担心事务1会对<code>accountID</code>进行更新从而影响到<code>transfer</code>表的外键约束，但是实际上我们并不会改动id，因此在数据库文件中我们要描述的更加具体:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- name: GetAccountForUpdate :one</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> accounts</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> $<span class="number">1</span> LIMIT <span class="number">1</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">NO</span> KEY UPDATE;</span><br></pre></td></tr></table></figure>
<p>接着<code>make sqlc</code>生成文件，并且运行测试发现能够通过了！</p>
<p>但是我们还有更好的方法来完成转账事务，之前我们是使用两条qeuries语句来完成对账户的更新，而我们现在可以只用一条query语句来实现这个功能，我们直接在账户的余额上进行增加或者减少。因此我们需要添加一条新sql语句到<code>account.sql</code>中</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- name: AddAccountBalance :one</span></span><br><span class="line">UPDATE accounts</span><br><span class="line"><span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> $<span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> $<span class="number">2</span></span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br></pre></td></tr></table></figure>
<p>但是这样生成的参数中增加的金额的参数名为balance而按照我们的思维，应当是amount，所以我们对该sql语句进行修改</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- name: AddAccountBalance :one</span></span><br><span class="line">UPDATE accounts</span><br><span class="line"><span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> sqlc.arg(amount)</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> sqlc.arg(id)</span><br><span class="line">RETURNING <span class="operator">*</span>;</span><br></pre></td></tr></table></figure>
<p>这样自动生成的语句中就能够自动将参数名改称amount了。然后回到<code>TransferTx()</code>中将<code>GetAccountForUpdate()</code>去掉，并且将<code>UpdateAccount()</code>替换为<code>AddAccountBalance()</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *Store)</span> <span class="title">TransferTx</span><span class="params">(ctx context.Context, arg TransferTxParams)</span> <span class="params">(TransferTxResult, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result TransferTxResult</span><br><span class="line"></span><br><span class="line">    err := store.execTx(ctx, <span class="function"><span class="keyword">func</span><span class="params">(q *Queries)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// move money out of account1</span></span><br><span class="line">        result.FromAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class="line">            ID:     arg.FromAccountID,</span><br><span class="line">            Amount: -arg.Amount,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// move money into account2</span></span><br><span class="line">        result.ToAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class="line">            ID:     arg.ToAccountID,</span><br><span class="line">            Amount: arg.Amount,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result, err</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何避免死锁">如何避免死锁</h2>
<p>前面我们已经解决了死锁的问题，但是如果我们呢仔细看的话我们能发现它仍然存在潜在的死锁问题。在事务中我们更新两个账户的余额，这两个操作都需要排他锁，因此如果存在两个事务同时对这两个账户进行操作就会存在一个潜在的死锁可能性。</p>
<p>虽然我们已经确定了并行5个从账户1向账户2转账的并行事务是不会再产生死锁了，但是如果再并行5个从账户2向账户1转账的事务呢。结果我们会发现仍然会发生死锁的现象。</p>
<p>原因是事务1可能完成了对1账户的更改，在申请对账户2的更改，而事务2完成了对账户2的更改，在申请对账户1的更改，但是两个事务都没有完成没法commit，所以就死锁了。</p>
<p>我们可以做一个测试程序专门测试死锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTransferTxDeadlock</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    store := NewStore(testDB)</span><br><span class="line"></span><br><span class="line">    account1 := createRandomAccount(t)</span><br><span class="line">    account2 := createRandomAccount(t)</span><br><span class="line">    fmt.Println(<span class="string">&quot;&gt;&gt; before:&quot;</span>, account1.Balance, account2.Balance)</span><br><span class="line"></span><br><span class="line">    n := <span class="number">10</span></span><br><span class="line">    amount := <span class="keyword">int64</span>(<span class="number">10</span>)</span><br><span class="line">    errs := <span class="built_in">make</span>(<span class="keyword">chan</span> error)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再根据当前的循环次数的不同对<code>fromAccount</code>和<code>toAccount</code>进行不同的赋值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTransferTxDeadlock</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        fromAccountID := account1.ID</span><br><span class="line">        toAccountID := account2.ID</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">            fromAccountID = account2.ID</span><br><span class="line">            toAccountID = account1.ID</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            _, err := store.TransferTx(context.Background(), TransferTxParams&#123;</span><br><span class="line">                FromAccountID: fromAccountID,</span><br><span class="line">                ToAccountID:   toAccountID,</span><br><span class="line">                Amount:        amount,</span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line">            errs &lt;- err</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后对错误和结果进行检查，这里因为我们只要检查结果，对于过程中的对错我们就不检查了，只要能有结果出来就说明不存在死锁了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTransferTxDeadlock</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        err := &lt;-errs</span><br><span class="line">        require.NoError(t, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *Store)</span> <span class="title">TransferTx</span><span class="params">(ctx context.Context, arg TransferTxParams)</span> <span class="params">(TransferTxResult, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result TransferTxResult</span><br><span class="line"></span><br><span class="line">    err := store.execTx(ctx, <span class="function"><span class="keyword">func</span><span class="params">(q *Queries)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> arg.FromAccountID &lt; arg.ToAccountID &#123;</span><br><span class="line">            result.FromAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class="line">                ID:     arg.FromAccountID,</span><br><span class="line">                Amount: -arg.Amount,</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.ToAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class="line">                ID:     arg.ToAccountID,</span><br><span class="line">                Amount: arg.Amount,</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.ToAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class="line">                ID:     arg.ToAccountID,</span><br><span class="line">                Amount: arg.Amount,</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.FromAccount, err = q.AddAccountBalance(ctx, AddAccountBalanceParams&#123;</span><br><span class="line">                ID:     arg.FromAccountID,</span><br><span class="line">                Amount: -arg.Amount,</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Gin框架在go语言中实现HTTP-API">使用Gin框架在go语言中实现HTTP API</h2>
<p>首先我们安装gin框架</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>
<h3 id="定义服务器结构体">定义服务器结构体</h3>
<p>创建一个新的目录<code>api</code>并且在其中创建一个新的文件<code>server.go</code>，这里是我们实现HTTP API服务器的地方。</p>
<p>首先我们定义一个Server结构体，它会提供所有的HTTP请求，它有两个字段：</p>
<ul>
<li><code>db.Store</code>，它使得我们处理来自客户端的请求的时候能够和数据库互动</li>
<li><code>gin.Engine</code>，它是一个router，帮我们将每一个API请求送到正确的handler上</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    store  *db.Store</span><br><span class="line">    router *gin.Engine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着增加一个函数<code>NewServer</code>，它以<code>db.Store</code>为输入，返回一个<code>Server</code>。这个函数创造一个Server实例，并且为我们的服务在服务器上创建所有的HTTP API route。</p>
<p>首先创建一个Server对象，然后创建一个router，我们会将routes添加到这个router中，在这之后我们将这个router分配给server并且返回server。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(store *db.Store)</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;store: store&#125;</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add routes to router</span></span><br><span class="line"></span><br><span class="line">    server.router = router</span><br><span class="line">    <span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以将第一个用于创建新账户的API以POST方式挂到该router上了，需要传入router的路径以及一个handler函数，如果传入多个函数的话，最后一个函数是真正的handler，其他的函数都应当是中间件</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(store *db.Store)</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;store: store&#125;</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    router.POST(<span class="string">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class="line"></span><br><span class="line">    server.router = router</span><br><span class="line">    <span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现创建账户API">实现创建账户API</h3>
<p>在当前<code>api</code>目录下创建一个新的<code>account.go</code>文件来实现跟account相关的api。其中我们声明一个<code>creatAccount()</code>函数，<strong>它必须只以一个<code>gin.Context</code>对象为输入</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">createAccount</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着需要定义一个结构体去存储创建账户请求，它的字段和<code>createAccountParams</code>相近，但是不需要设置balance，因为创建账户时余额应当为0不能让客户端自己指定。<br>
由于我们需要从HTTP请求主体中获取参数，所以字段的json标签仍然是需要的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> createAccountRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    Owner    <span class="keyword">string</span> <span class="string">`json:&quot;owner&quot;`</span></span><br><span class="line">    Currency <span class="keyword">string</span> <span class="string">`json:&quot;currency&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">createAccount</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，无论何时我们获取到客户端传过来的输入数据时都要进行验证，因为可能会有非法的数据传过来。Gin在内部使用了一个验证包来自动执行验证。我们对两个字段增加binding的<code>required</code>标签，同时我们的银行只支持两种货币<code>USD</code>和<code>EUR</code>则我们在binding标签中还需要增加一个oneof参数用于指定值一定是在哪个范围</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> createAccountRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    Owner    <span class="keyword">string</span> <span class="string">`json:&quot;owner&quot; binding:&quot;required&quot;`</span></span><br><span class="line">    Currency <span class="keyword">string</span> <span class="string">`json:&quot;currency&quot; binding:&quot;required,oneof=USD EUR&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>createAccount()</code>函数主体中我们生命一个该类型的实例<code>req</code>并且通过<code>ctx.shouldBindJSON()</code>来解析传过来的请求并且赋值给该<code>req</code>。这个函数会返回一个错误，如果存在错误的话就说明传过来的数据有问题我们返回一个badRequest错误，用<code>ctx.JSON()</code>实现。其中的第一个参数是HTTP状态码<code>http.StatusBadRequest</code>，第二个参数是我们希望返回给客户端的JSON对象。由于我们想返回的是个错误，所以我们需要将错误转变为一个键值对，这样Gin框架能够将他转成JSON并且返回给客户端。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">createAccount</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> req createAccountRequest</span><br><span class="line">    <span class="keyword">if</span> err := ctx.ShouldBindJSON(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>errorResponse()</code>是我们自定义的函数，由于我们后面会经常用到它，所以我们将它在<code>server.go</code>里面实现，我们使用<code>gin.H()</code>将错误转换为一个键值对，该函数本质上就是一个<code>map[string]interface&#123;&#125;</code>的别称。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">errorResponse</span><span class="params">(err error)</span> <span class="title">gin</span>.<span class="title">H</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们准备好对数据库进行CreatAccount的参数，然后调用该操作就可以了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">createAccount</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> req createAccountRequest</span><br><span class="line">    <span class="keyword">if</span> err := ctx.ShouldBindJSON(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arg := db.CreateAccountParams&#123;</span><br><span class="line">        Owner:    req.Owner,</span><br><span class="line">        Currency: req.Currency,</span><br><span class="line">        Balance:  <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    account, err := server.store.CreateAccount(ctx, arg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.JSON(http.StatusOK, account)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="开启HTTP服务">开启HTTP服务</h3>
<p>我们对Server创建一个<code>Start</code>函数，它以一个地址作为输入，作用是在这个地址上运行我们的HTTP服务以监听传过来的API请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">Start</span><span class="params">(address <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> server.router.Run(address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们创建server的入口，<code>main.go</code>在项目根目录下面，其具体内容和<code>main_test.go</code>相近，我们通过调用<code>db.NewStore()</code>创建一个<code>store</code>，再调用<code>api.NewServer()</code>来创建一个新的server。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    dbDriver      = <span class="string">&quot;postgres&quot;</span></span><br><span class="line">    dbSource      = <span class="string">&quot;postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := sql.Open(dbDriver, dbSource)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    store := db.NewStore(conn)</span><br><span class="line">    server := api.NewServer(store)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外我们还需要设置服务器监听的地址以及导入一个间接引用的包否则我们无法和数据库进行对话</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">    _ <span class="string">&quot;github.com/lib/pq&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/techschool/simplebank/api&quot;</span></span><br><span class="line">    db <span class="string">&quot;github.com/techschool/simplebank/db/sqlc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    dbDriver      = <span class="string">&quot;postgres&quot;</span></span><br><span class="line">    dbSource      = <span class="string">&quot;postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable&quot;</span></span><br><span class="line">    serverAddress = <span class="string">&quot;0.0.0.0:8080&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    conn, err := sql.Open(dbDriver, dbSource)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    store := db.NewStore(conn)</span><br><span class="line">    server := api.NewServer(store)</span><br><span class="line"></span><br><span class="line">    err = server.Start(serverAddress)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot start server:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在主函数入口完成了，我们可以去<code>Makefile</code>中再加入一个server指令，内容为<code>go run main.go</code></p>
<h3 id="测试API接口">测试API接口</h3>
<p>这里我们可以用postman来模拟对接口的访问，注意下载postman的时候不要科学上网，不然会很慢。</p>
<h3 id="实现get-account-API接口">实现get account API接口</h3>
<p>与上面不同的是，这里用GET请求显示地给出要查询的account的id。我们在<code>NewServer()</code>函数中使用GET方法向路径中添加一个功能。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(store *db.Store)</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    router.POST(<span class="string">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class="line">    router.GET(<span class="string">&quot;/accounts/:id&quot;</span>, server.getAccount)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们需要实现<code>getAccount</code>handler。我们去到<code>account.go</code>中进行实现，我们首先需要一个结构体来作为请求的参数，这里由于ID是通过URI参数的方式获取到的，我们就不能用json标签了而是应该使用uri标签。同样的，在实现的过程中还需要将<code>shouldBindJSON</code>改为<code>shouldBindUri</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">getAccount</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> req getAccountRequest</span><br><span class="line">    <span class="keyword">if</span> err := ctx.ShouldBindUri(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    account, err := server.store.GetAccount(ctx, req.ID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err == sql.ErrNoRows &#123;</span><br><span class="line">            ctx.JSON(http.StatusNotFound, errorResponse(err))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.JSON(http.StatusOK, account)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于list account的方法也是大同小异，其主要在于它的两个参数应该用<code>shouldBindQuery</code>来获取，它是通过query string传递参数的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> listAccountRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    PageID   <span class="keyword">int32</span> <span class="string">`form:&quot;page_id&quot; binding:&quot;required,min=1&quot;`</span></span><br><span class="line">    PageSize <span class="keyword">int32</span> <span class="string">`form:&quot;page_size&quot; binding:&quot;required,min=5,max=10&quot;`</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">listAccount</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> req listAccountRequest</span><br><span class="line">    <span class="keyword">if</span> err := ctx.ShouldBindQuery(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arg := db.ListAccountsParams&#123;</span><br><span class="line">        Limit:  req.PageSize,</span><br><span class="line">        Offset: (req.PageID - <span class="number">1</span>) * req.PageSize,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    accounts, err := server.store.ListAccounts(ctx, arg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.JSON(http.StatusOK, accounts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Viper从文件中加载配置和环境变量">使用Viper从文件中加载配置和环境变量</h2>
<p>开发和部署后端的时候我们需要对不同的环境使用不同的配置。</p>
<p>在我们目前的代码中，我们有一些以constant形式的变量配置在<code>main_test.go</code>中，接下来我们就要用viper来从文件和环境变量中读取这些配置信息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    dbDriver      = <span class="string">&quot;postgres&quot;</span></span><br><span class="line">    dbSource      = <span class="string">&quot;postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable&quot;</span></span><br><span class="line">    serverAddress = <span class="string">&quot;0.0.0.0:8080&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>首先是安装Viper，进入<a target="_blank" rel="noopener" href="https://github.com/spf13/viper">Viper的github主页</a>下载安装viper。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/spf13/viper</span><br></pre></td></tr></table></figure>
<h3 id="创建配置文件">创建配置文件</h3>
<p>我们需要创建一个新的文件<code>app.env</code>来保存我们的配置信息，接着我们将上面的变量复制到这里，但是由于我们使用的是.env格式的文件，所以我们需要更改一下格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DB_DRIVER=postgres</span><br><span class="line">DB_SOURCE=postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable</span><br><span class="line">SERVER_ADDRESS=0.0.0.0:8080</span><br></pre></td></tr></table></figure>
<h3 id="加载配置文件">加载配置文件</h3>
<p>我们在util目录下创建一个config包，然后我们声明一个新的<code>Config</code>结构体变量，这个结构体中将会包含所有的配置变量信息，目前，我们有3个变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    DBDriver      <span class="keyword">string</span> <span class="string">`mapstructure:&quot;DB_DRIVER&quot;`</span></span><br><span class="line">    DBSource      <span class="keyword">string</span> <span class="string">`mapstructure:&quot;DB_SOURCE&quot;`</span></span><br><span class="line">    ServerAddress <span class="keyword">string</span> <span class="string">`mapstructure:&quot;SERVER_ADDRESS&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了能够获取到变量的值并且将他们保存到结构体中，我们需要用到Vpier的unmarshaling特征，viper使用<a target="_blank" rel="noopener" href="https://github.com/mitchellh/mapstructure">mapstructure</a>包在底层解析数据，因此我们需要使用mapstructure标签来制定每一个配置字段的名称</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    DBDriver      <span class="keyword">string</span> <span class="string">`mapstructure:&quot;DB_DRIVER&quot;`</span></span><br><span class="line">    DBSource      <span class="keyword">string</span> <span class="string">`mapstructure:&quot;DB_SOURCE&quot;`</span></span><br><span class="line">    ServerAddress <span class="keyword">string</span> <span class="string">`mapstructure:&quot;SERVER_ADDRESS&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们需要定义一个新的函数<code>LoadConfig()</code>，它以一个路径为输入，并且返回一个Config对象或者一个错误。这个函数会从路径中存在的配置文件中读取配置信息，或者重写这些配置的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadConfig</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(config Config, err error)</span></span> &#123;</span><br><span class="line">    viper.AddConfigPath(path)</span><br><span class="line">    viper.SetConfigName(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">    viper.SetConfigType(<span class="string">&quot;env&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了从文件中读取配置，我们还希望viper能够从环境变量中读取值，所以我们调用<code>viper.AutomaticEnv()</code>来让viper自动覆盖它已经从配置文件中读取到的相关的环境变量的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LoadConfig reads configuration from file or environment variables.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadConfig</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(config Config, err error)</span></span> &#123;</span><br><span class="line">    viper.AddConfigPath(path)</span><br><span class="line">    viper.SetConfigName(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">    viper.SetConfigType(<span class="string">&quot;env&quot;</span>)</span><br><span class="line"></span><br><span class="line">    viper.AutomaticEnv()</span><br><span class="line"></span><br><span class="line">    err = viper.ReadInConfig()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = viper.Unmarshal(&amp;config)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后我们调用<code>viper.ReadInConfig()</code>来开始读取配置值。</p>
<p>最后我们调用<code>viper.Unmarshal()</code>来将值解析到<code>config</code>变量中，最后返回。</p>
<h3 id="在主函数中使用LoadConfig">在主函数中使用LoadConfig</h3>
<p>我们将之前手动配置的值全部删除，然后在主函数中我们调用刚才写的<code>util.LoadConfig()</code>并且传入<code>.</code>，意思是用当前的目录作为路径，因为我们的配置文件<code>app.env</code>是在<code>main.go</code>的统一目录下的。</p>
<p>如果存在错误的话我么写一个fatal log来记录无法加载配置文件。否则，就成功，我们的原先的配置值就成为了结构体中的字段值，调用就可以了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    config, err := util.LoadConfig(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot load config:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conn, err := sql.Open(config.DBDriver, config.DBSource)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    store := db.NewStore(conn)</span><br><span class="line">    server := api.NewServer(store)</span><br><span class="line"></span><br><span class="line">    err = server.Start(config.ServerAddress)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot start server:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，在测试函数的主函数中我们也可以使用同样的方法加载这些配置信息。</p>
<h2 id="为测试HTTP-API模拟一个数据库">为测试HTTP API模拟一个数据库</h2>
<p>如果我们无法隔离单元测试的数据来避免冲突，可以尝试模拟数据库。我们使用<a target="_blank" rel="noopener" href="https://github.com/golang/mock">Gomock</a>来为数据库结构生成存根。</p>
<h3 id="模拟数据库的两种方式">模拟数据库的两种方式</h3>
<p>第一种方式是生成一个虚拟数据库，它将信息保存在内存之中。比如我们有一个Store接口定义了一系列的对于真实数据库的操作，那么我们就可以定义一个虚拟数据库的<code>MemStore</code>结构体来实现<code>Store</code>接口的所有功能，但只用一个映射去读取和写入数据。这个方法简单且易于实现，但是它需要我们去写更多只能用于测试的代码，这非常耗时。</p>
<p>所以接下来我们将会用一个更好的方法来模拟数据库，<strong>使用存根来替代虚假的数据库</strong>。基本思路是使用<code>gomock</code>包来生成和构建存根，它会返回我们想要测试的场景的硬编码。</p>
<p>在我们这个例子中，gomock会生成一个<code>MockStore</code>，我们需要做的是调用它的<code>EXPECT()</code>函数来生成一个存根，它会告诉gomock：<code>GetAccount()</code>函数通过输入的<code>AccountID</code>只能被调用一次，并且返回账户对象作为输出。这之后，我们只需要使用这个虚拟的store就可以测试API了。</p>
<h3 id="安装gomock">安装gomock</h3>
<p>首先我们去gomock的github主页按照其中的命令安装gomock</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/golang/mock/mockgen@v1.4.4</span><br></pre></td></tr></table></figure>
<p>接着可以发现，一个<code>mockgen</code>的二进制文件出现在go/bin的文件夹下。</p>
<p>我们会使用这个工具来生成模拟数据库，所以我们要确认该命令能够在任何地方执行。我们可以通过以下命令检查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ which mockgen</span><br><span class="line">mockgen not found</span><br></pre></td></tr></table></figure>
<p>如果出现如上的情况所名go/bin目录没有被添加到环境变量中，我们可以将它添加到环境变量中。</p>
<h3 id="定义Store接口">定义Store接口</h3>
<p>为了能够使用mockgen来生成虚拟数据库，我们需要先稍微修改一下我们的代码。</p>
<p>目前，在<code>api/server.go</code>文件中，<code>NewServer()</code>函数接收一个<code>db.Store</code>对象</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    store  *db.Store</span><br><span class="line">    router *gin.Engine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(store *db.Store)</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>db.Store</code>是在<code>db/sqlc/store.go</code>中定义的，这是我们连接真实数据库的结构体</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Store <span class="keyword">struct</span> &#123;</span><br><span class="line">    db *sql.DB</span><br><span class="line">    *Queries</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了能在API测试中使用虚拟数据库，我们需要用一个接口替代store对象。我们会赋值<code>Store</code>结构体的定义并且将它的类型改成接口。然后将原本的定义重命名为<code>SQLStore</code>，这是<code>Store</code>接口的真实实现，能够与SQL数据库交互。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> add functions to this interface</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SQLStore <span class="keyword">struct</span> &#123;</span><br><span class="line">    db *sql.DB</span><br><span class="line">    *Queries</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接着，<code>NewStore()</code>函数不应该再返回一个指针，而是直接返回一个接口，并且在内部它应当返回真实的数据库接口实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStore</span><span class="params">(db *sql.DB)</span> <span class="title">Store</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;SQLStore&#123;</span><br><span class="line">        db:      db,</span><br><span class="line">        Queries: New(db),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们同样需要改变<code>execTx()</code>和<code>TransferTx()</code>函数的<code>store</code>接收器类型改为<code>*SQLStore</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *SQLStore)</span> <span class="title">execTx</span><span class="params">(ctx context.Context, fn <span class="keyword">func</span>(*Queries)</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *SQLStore)</span> <span class="title">TransferTx</span><span class="params">(ctx context.Context, arg TransferTxParams)</span> <span class="params">(TransferTxResult, error)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们需要定义一系列<code>Store</code>接口能够执行的操作。首先，它应该拥有所有的<code>Queries</code>结构体的函数，并且还多处一个执行转账交易的函数。所以我们首先将<code>TransferTx()</code>的定义复制到<code>Store</code>接口中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">    TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>Queries</code>结构体的函数，我们可以同样赋值粘贴，但是这样太耗时了。所幸，sqlc包中有一个选项是发散包含<code>Queries</code>结构体包含的所有函数的接口。我们所要做的就是将它的值这是为true</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="attr">packages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;db&quot;</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">&quot;./db/sqlc&quot;</span></span><br><span class="line">    <span class="attr">queries:</span> <span class="string">&quot;./db/query/&quot;</span></span><br><span class="line">    <span class="attr">schema:</span> <span class="string">&quot;./db/migration/&quot;</span></span><br><span class="line">    <span class="attr">engine:</span> <span class="string">&quot;postgresql&quot;</span></span><br><span class="line">    <span class="attr">emit_json_tags:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">emit_prepared_queries:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">emit_interface:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">emit_exact_table_names:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">emit_empty_slices:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>然后再执行一次make sqlc</p>
<p>之后在<code>db/sqlc</code>中我们可以看到一个新的文件<code>querier.go</code>，它包含了生成的<code>Querier</code>接口其中包含所有的对数据库进行交互操作的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Querier <span class="keyword">interface</span> &#123;</span><br><span class="line">    AddAccountBalance(ctx context.Context, arg AddAccountBalanceParams) (Account, error)</span><br><span class="line">    CreateAccount(ctx context.Context, arg CreateAccountParams) (Account, error)</span><br><span class="line">    CreateEntry(ctx context.Context, arg CreateEntryParams) (Entry, error)</span><br><span class="line">    CreateTransfer(ctx context.Context, arg CreateTransferParams) (Transfer, error)</span><br><span class="line">    DeleteAccount(ctx context.Context, id <span class="keyword">int64</span>) error</span><br><span class="line">    GetAccount(ctx context.Context, id <span class="keyword">int64</span>) (Account, error)</span><br><span class="line">    GetAccountForUpdate(ctx context.Context, id <span class="keyword">int64</span>) (Account, error)</span><br><span class="line">    GetEntry(ctx context.Context, id <span class="keyword">int64</span>) (Entry, error)</span><br><span class="line">    GetTransfer(ctx context.Context, id <span class="keyword">int64</span>) (Transfer, error)</span><br><span class="line">    ListAccounts(ctx context.Context, arg ListAccountsParams) ([]Account, error)</span><br><span class="line">    ListEntries(ctx context.Context, arg ListEntriesParams) ([]Entry, error)</span><br><span class="line">    ListTransfers(ctx context.Context, arg ListTransfersParams) ([]Transfer, error)</span><br><span class="line">    UpdateAccount(ctx context.Context, arg UpdateAccountParams) (Account, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ Querier = (*Queries)(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>接着我们只需要将这个接口的定义迁入到<code>Store</code>接口中就可以了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Store <span class="keyword">interface</span> &#123;</span><br><span class="line">    Querier</span><br><span class="line">    TransferTx(ctx context.Context, arg TransferTxParams) (TransferTxResult, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们回到<code>api/server.go</code>文件中将<code>*db.Store</code>类型因为它不再是一个结构体指针了而是一个接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(store db.Store)</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且由于我们更改了<code>db.NewStore</code>的返回值所以我们在<code>main.go</code>中不需要对函数主体进行任何的修改</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    config, err := util.LoadConfig(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot load config:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conn, err := sql.Open(config.DBDriver, config.DBSource)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    store := db.NewStore(conn)</span><br><span class="line">    server := api.NewServer(store)</span><br><span class="line"></span><br><span class="line">    err = server.Start(config.ServerAddress)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot start server:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成模拟数据库">生成模拟数据库</h3>
<p>目前我们已经有了<code>db.Store</code>接口，我们能够使用gomock去生成一个虚拟实现。</p>
<p>首先我们创造一个新的<code>mock</code>目录在<code>db</code>目录下，然后我们打开终端运行<code>mockgen -help</code>。mockgen给我们两种方式去生成模拟，<code>source mode</code>会从单个源文件生成模拟接口，这在该文件导入了别的包的情况下会比较复杂。</p>
<p>在本例子中，我们最好使用<code>reflect mode</code>，我们只需要提供包的名字和接口，mockgen就会利用反射去自动决定怎么做</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockgen github.com/techschool/simplebank/db/sqlc Store</span><br></pre></td></tr></table></figure>
<p>第一个参数是导入的<code>Store</code>的路径即该接口定义的路径，第二个参数是接口的名称。我们还应该制定生成文件的路径。否则，mockgen会默认生成代码到标准输出上。所以我们用<code>-destination</code>来指定代码生成的位置。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockgen -destination db/mock/store.go github.com/techschool/simplebank/db/sqlc Store</span><br></pre></td></tr></table></figure>
<p>在生成文件中有两个重要的结构体<code>MockStore</code>和<code>MockStoreRecorder</code></p>
<p><code>MockStore</code>是执行所有<code>Store</code>接口的必要函数的结构体，<code>MockStoreRecorder</code>同样有这些相同名字的函数，只不过他们的参数是普通的接口类型。</p>
<p>此外，由mockgen生成的代码的包的名字是<code>mock_sqlc</code>这不太好，我们可以在刚才的命令中加入一个参数来指定包名。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockgen -package mockdb -destination db/mock/store.go github.com/techschool/simplebank/db/sqlc Store</span><br></pre></td></tr></table></figure>
<p>接下来我们先在MakeFile中将mock命令添加进区，之后就可以测试API了</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="section">mock:</span></span><br><span class="line">    mockgen -package mockdb -destination db/mock/store.go github.com/techschool/simplebank/db/sqlc Store</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: postgres createdb dropdb migrateup migratedown sqlc test </span></span><br></pre></td></tr></table></figure>
<h3 id="对API进行单元测试">对API进行单元测试</h3>
<p>在api目录下创建一个新的文件<code>account_test.go</code>。在其中我们定义一个新的函数<code>TestGetAccountAPI(t *testing.T)</code>。为了能够测试，我们需要账户，所以我们先写一个函数来生成随机的账户</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomAccount</span><span class="params">()</span> <span class="title">db</span>.<span class="title">Account</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> db.Account&#123;</span><br><span class="line">        ID:       util.RandomInt(<span class="number">1</span>, <span class="number">1000</span>),</span><br><span class="line">        Owner:    util.RandomOwner(),</span><br><span class="line">        Balance:  util.RandomMoney(),</span><br><span class="line">        Currency: util.RandomCurrency(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们返回测试，在函数中调用上面这个函数来创建一个新的用户</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetAccountAPI</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    account := randomAccount()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们需要用<code>mockdb.NewMockStore()</code>创建一个新的mock store，它以一个gomock.Controller对象为输入，所以我们需要调用一个<code>gomock.NewController</code>来创建一个controller。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetAccountAPI</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    account := randomAccount()</span><br><span class="line"></span><br><span class="line">    ctrl := gomock.NewController(t)</span><br><span class="line">    <span class="keyword">defer</span> ctrl.Finish()</span><br><span class="line"></span><br><span class="line">    store := mockdb.NewMockStore(ctrl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>defer调用finish非常重要，因为它会检查是否所有我们希望调用的函数都被调用到了。</p>
<p>接下来是为虚拟store创建存根，在这个案例中我们值关心<code>GetAccount()</code>方法，因为它是唯一一个需要被GetAccount API调用的方法。所以接下来我们调用<code>store.EXPECT().GetAccount()</code>方法来创建存根。而<code>GetAccount()</code>方法需要两个参数作为输入，因此我们需要给出这两个参数。</p>
<p>对于第一个参数，是上下文环境参数，它可以是任意值，所以我们使用<code>gomock.Any()</code>来匹配它，第二个参数应该等于我们创造的随机账户的ID，所以我们使用<code>gomock.Eq()</code>来匹配<code>account.ID</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetAccountAPI</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    account := randomAccount()</span><br><span class="line"></span><br><span class="line">    ctrl := gomock.NewController(t)</span><br><span class="line">    <span class="keyword">defer</span> ctrl.Finish()</span><br><span class="line"></span><br><span class="line">    store := mockdb.NewMockStore(ctrl)</span><br><span class="line">    store.EXPECT().</span><br><span class="line">        GetAccount(gomock.Any(), gomock.Eq(account.ID)).</span><br><span class="line">        Times(<span class="number">1</span>).</span><br><span class="line">        Return(account, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样这个存根的意思就可以翻译为我希望GetAccount()函数被调用并且其参数是一个随意的上下文和指定的账户ID</p>
<p>我们同样还可以指定函数应当被调用的次数，<code>Time(1)</code>表示我们希望这个函数被调用一次。此外我们还可以用<code>Return()</code>函数来告诉gomock返回指定的值。比如，在这个例子中，我们希望他能够返回账户对象和nil错误。需要注意的是，这里的Return函数的返回应当和GetAccount函数的返回值是相同的。</p>
<p>现在存根已经设置完毕了，我们开始创建一个服务器</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetAccountAPI</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    server := NewServer(store)</span><br><span class="line">    recorder := httptest.NewRecorder()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了测试API我们不需要真的开启一个服务器，我们只需要使用httptest包的recording特征来记录API请求的返回值。所以我们调用<code>httptest.Recorder()</code>来创建一个新的<code>ResponseRecorder</code>。</p>
<p>接着我们声明我们希望调用的API的url路径，在这里就是<code>/accounts/&#123;ID of the account we want to get&#125;</code>。然后我们用GET方法创建一个新的HTTP请求，因为用的是GET，我们可以对request body使用nil。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetAccountAPI</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    server := NewServer(store)</span><br><span class="line">    recorder := httptest.NewRecorder()</span><br><span class="line"></span><br><span class="line">    url := fmt.Sprintf(<span class="string">&quot;/accounts/%d&quot;</span>, tc.accountID)</span><br><span class="line">    request, err := http.NewRequest(http.MethodGet, url, <span class="literal">nil</span>)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们用创建的recorder和request对象调用<code>server.router.ServeHTTP()</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetAccountAPI</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    account := randomAccount()</span><br><span class="line"></span><br><span class="line">    ctrl := gomock.NewController(t)</span><br><span class="line">    <span class="keyword">defer</span> ctrl.Finish()</span><br><span class="line"></span><br><span class="line">    store := mockdb.NewMockStore(ctrl)</span><br><span class="line">    store.EXPECT().</span><br><span class="line">        GetAccount(gomock.Any(), gomock.Eq(account.ID)).</span><br><span class="line">        Times(<span class="number">1</span>).</span><br><span class="line">        Return(account, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    server := NewServer(store)</span><br><span class="line">    recorder := httptest.NewRecorder()</span><br><span class="line"></span><br><span class="line">    url := fmt.Sprintf(<span class="string">&quot;/accounts/%d&quot;</span>, tc.accountID)</span><br><span class="line">    request, err := http.NewRequest(http.MethodGet, url, <span class="literal">nil</span>)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    server.router.ServeHTTP(recorder, request)</span><br><span class="line">    require.Equal(t, http.StatusOK, recorder.Code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面我们只是简单地检查了返回的http状态码是否正确，这是一种比较简陋的方法。</p>
<p>那如果我们想要检查返回的主体呢，我们可以调用<code>requireBodyMatchAccount()</code>，它有三个参数：<code>testing.T</code>,<code>byte.Buffer</code>指针类型的返回主体和去比较的账户对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requireBodyMatchAccount</span><span class="params">(t *testing.T, body *bytes.Buffer, account db.Account)</span></span> &#123;</span><br><span class="line">    data, err := ioutil.ReadAll(body)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> gotAccount db.Account</span><br><span class="line">    err = json.Unmarshal(data, &amp;gotAccount)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    require.Equal(t, account, gotAccount)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取100-的覆盖率">获取100%的覆盖率</h3>
<p>首先我们需要定义一组测试用例，每一个测试用例会有一个独特的名字与其他用例区别开，并且会有一个accountID字段用来指定用于测试的id，此外由于每个测试所用到的存根时不一样的，所以要用一个对应的字段作为存根的设置，检查返回字段也是一样的道理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetAccountAPI</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    account := randomAccount()</span><br><span class="line"></span><br><span class="line">    testCases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        name          <span class="keyword">string</span></span><br><span class="line">        accountID     <span class="keyword">int64</span></span><br><span class="line">        buildStubs    <span class="function"><span class="keyword">func</span><span class="params">(store *mockdb.MockStore)</span></span></span><br><span class="line">        checkResponse <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, recoder *httptest.ResponseRecorder)</span></span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> add test data</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以增加一些不同的场景到我们的测试用例里面了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetAccountAPI</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    account := randomAccount()</span><br><span class="line"></span><br><span class="line">    testCases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        name          <span class="keyword">string</span></span><br><span class="line">        accountID     <span class="keyword">int64</span></span><br><span class="line">        buildStubs    <span class="function"><span class="keyword">func</span><span class="params">(store *mockdb.MockStore)</span></span></span><br><span class="line">        checkResponse <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, recoder *httptest.ResponseRecorder)</span></span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            name:      <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">            accountID: account.ID,</span><br><span class="line">            buildStubs: <span class="function"><span class="keyword">func</span><span class="params">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class="line">                store.EXPECT().</span><br><span class="line">                    GetAccount(gomock.Any(), gomock.Eq(account.ID)).</span><br><span class="line">                    Times(<span class="number">1</span>).</span><br><span class="line">                    Return(account, <span class="literal">nil</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            checkResponse: <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T, recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class="line">                require.Equal(t, http.StatusOK, recorder.Code)</span><br><span class="line">                requireBodyMatchAccount(t, recorder.Body, account)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后我们会在里面添加一些不同的案例场景，所以在测试函数中我们使用一个for loop来进行测试，我们将每个测试用例作为一个独立的测试，所以在for loop中我们呢使用<code>t.Run()</code>，传入用例名称和一个函数，然后将之前写的测试函数内部的操作都放到这个函数里面去。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetAccountAPI</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> testCases &#123;</span><br><span class="line">        tc := testCases[i]</span><br><span class="line"></span><br><span class="line">        t.Run(tc.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            ctrl := gomock.NewController(t)</span><br><span class="line">            <span class="keyword">defer</span> ctrl.Finish()</span><br><span class="line"></span><br><span class="line">            store := mockdb.NewMockStore(ctrl)</span><br><span class="line">            tc.buildStubs(store)</span><br><span class="line"></span><br><span class="line">            server := NewServer(store)</span><br><span class="line">            recorder := httptest.NewRecorder()</span><br><span class="line"></span><br><span class="line">            url := fmt.Sprintf(<span class="string">&quot;/accounts/%d&quot;</span>, tc.accountID)</span><br><span class="line">            request, err := http.NewRequest(http.MethodGet, url, <span class="literal">nil</span>)</span><br><span class="line">            require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">            server.router.ServeHTTP(recorder, request)</span><br><span class="line">            tc.checkResponse(t, recorder)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后可以按照我们自己的想法向其中添加不同的测试用例，但是之后运行测试的时候会发现控制台中的输出太多了，干扰到我们观察我们需要观察的数据，这是因为Gin默认是在Debug模式下运行的。我们可以在api目录下创建一个<code>main_test.go</code>函数来将Gin的模式设置为Test模式。这个文件的内容和db包下的<code>main_test.go</code>文件是类似的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">    gin.SetMode(gin.TestMode)</span><br><span class="line">    os.Exit(m.Run())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用自定义参数验证器实现转账">使用自定义参数验证器实现转账</h2>
<p>这一节将会实现对于银行来说最重要的API：转账。并且还会实现一个自定义验证器来验证传给API的输入参数。</p>
<h3 id="实现转账API的handler">实现转账API的handler</h3>
<p>我们首先在api包中创建一个transfer.go文件，转账api的实现和创建账户api的实现是相似的。</p>
<p>我们用<code>transferRequest</code>结构体来保存api的输入参数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> transferRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    FromAccountID <span class="keyword">int64</span>  <span class="string">`json:&quot;from_account_id&quot; binding:&quot;required,min=1&quot;`</span></span><br><span class="line">    ToAccountID   <span class="keyword">int64</span>  <span class="string">`json:&quot;to_account_id&quot; binding:&quot;required,min=1&quot;`</span></span><br><span class="line">    Amount        <span class="keyword">int64</span>  <span class="string">`json:&quot;amount&quot; binding:&quot;required,gt=0&quot;`</span></span><br><span class="line">    Currency      <span class="keyword">string</span> <span class="string">`json:&quot;currency&quot; binding:&quot;required,oneof=USD EUR CAD&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在hadler函数<code>creatTransfer()</code>中将参数和请求进行绑定，并且如果出现错误的话就返回<code>http.StatusBadRequest</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">createTransfer</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> req transferRequest</span><br><span class="line">    <span class="keyword">if</span> err := ctx.ShouldBindJSON(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arg := db.TransferTxParams&#123;</span><br><span class="line">        FromAccountID: req.FromAccountID,</span><br><span class="line">        ToAccountID:   req.ToAccountID,</span><br><span class="line">        Amount:        req.Amount,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result, err := server.store.TransferTx(ctx, arg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.JSON(http.StatusOK, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数中我们已经创建好了一个handler函数了，但是我们req参数中的<code>request.Currency</code>其实是没有用到的，我们需要做的是比较转出账户和转入账户中这个参数是否是相同的。因此我们需要为<code>Server</code>结构体定义一个新的函数<code>validAccount()</code>。</p>
<p>这个函数会检查带有指定ID的账户是否真实存在并且它的货币是否跟输入的货币相匹配。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">validAccount</span><span class="params">(ctx *gin.Context, accountID <span class="keyword">int64</span>, currency <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    account, err := server.store.GetAccount(ctx, accountID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err == sql.ErrNoRows &#123;</span><br><span class="line">            ctx.JSON(http.StatusNotFound, errorResponse(err))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> account.Currency != currency &#123;</span><br><span class="line">        err := fmt.Errorf(<span class="string">&quot;account [%d] currency mismatch: %s vs %s&quot;</span>, account.ID, account.Currency, currency)</span><br><span class="line">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们要回到刚才的handler函数中，将这个valid模块插入进去。</p>
<h3 id="登记转账API的路径">登记转账API的路径</h3>
<p>我们打开<code>api/server.go</code>文件，在其中添加一个路径，同样使用post方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(store db.Store)</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;store: store&#125;</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    router.POST(<span class="string">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class="line">    router.GET(<span class="string">&quot;/accounts/:id&quot;</span>, server.getAccount)</span><br><span class="line">    router.GET(<span class="string">&quot;/accounts&quot;</span>, server.listAccounts)</span><br><span class="line">    router.POST(<span class="string">&quot;/transfers&quot;</span>, server.createTransfer)</span><br><span class="line"></span><br><span class="line">    server.router = router</span><br><span class="line">    <span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在终端中输入并且执行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make server</span><br></pre></td></tr></table></figure>
<p>然后就可以验证我们的api了，同样使用postman进行测试验证，这里就不多做赘述了。需要注意的是，这里我们并没有使用虚拟数据库进行验证，而是使用了真实的数据库交互。</p>
<h3 id="实现自定义货币验证模块">实现自定义货币验证模块</h3>
<p>在我们之前的定义中我们只硬编码了三种货币，加入之后我们需要增加货币种类，使它能够支持更多的货币类型呢？那我们如果仍然使用oneof的方式一个一个放入的话就很容易出错。而且对以货币的定义出现在很多的结构体中，一个一个修改他们并不现实。</p>
<p>我们可以在api包下创建一个新的文件<code>validator.go</code>，然后声明一个新的<code>validator.Func</code>类型的变量<code>validCurrency</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> api</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/go-playground/validator/v10&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/techschool/simplebank/util&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> validCurrency validator.Func = <span class="function"><span class="keyword">func</span><span class="params">(fieldLevel validator.FieldLevel)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> currency, ok := fieldLevel.Field().Interface().(<span class="keyword">string</span>); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> util.IsSupportedCurrency(currency)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总体上来说，<code>validator.Func</code>是一个函数，它以<code>validator.FieldLevel</code>接口作为输入并且返回true如果验证成功的话。这个接口包含了所有的信息来帮助函数进行字段的验证。</p>
<p>我们需要做的就是通过<code>fieldLevel.Field()</code>获取到字段的值，需要注意的是这是一个反射值，所以我们需要调用<code>.interface()</code>来将值转为<code>interface&#123;&#125;</code>。然后我们将这个值转为string类型。该函数会返回一个货币字符串和一个bool类型的值，在我们这个案例中我们还需要对货币进行检查，看是否是我们支持的货币类型，因此我们需要在util中再创建一个工具函数来实现这个功能。</p>
<p>我们首先用常量的形式将支持的货币写下，然后再用函数判断货币是否在这些常量中，如果在的话就能够支持，否则的话不能够支持。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> util</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants for all supported currencies</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    USD = <span class="string">&quot;USD&quot;</span></span><br><span class="line">    EUR = <span class="string">&quot;EUR&quot;</span></span><br><span class="line">CAD = <span class="string">&quot;CAD&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// IsSupportedCurrency returns true if the currency is supported</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsSupportedCurrency</span><span class="params">(currency <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> currency &#123;</span><br><span class="line">    <span class="keyword">case</span> USD, EUR, CAD:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="登记自定义的货币验证器">登记自定义的货币验证器</h3>
<p>我们先打开<code>server.go</code>文件，在我们创建了Gin <code>router</code>之后我们需要调用<code>binding.Validator.Engine()</code>来得到目前Gin框架正在使用的验证器引擎。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> api</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin/binding&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/go-playground/validator/v10&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(store db.Store)</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;store: store&#125;</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class="line">        v.RegisterValidation(<span class="string">&quot;currency&quot;</span>, validCurrency)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    router.POST(<span class="string">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class="line">    router.GET(<span class="string">&quot;/accounts/:id&quot;</span>, server.getAccount)</span><br><span class="line">    router.GET(<span class="string">&quot;/accounts&quot;</span>, server.listAccounts)</span><br><span class="line"></span><br><span class="line">    router.POST(<span class="string">&quot;/transfers&quot;</span>, server.createTransfer)</span><br><span class="line"></span><br><span class="line">    server.router = router</span><br><span class="line">    <span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这个函数返回的是一个<code>validator</code>对象，因此我们需要将他转换为<code>validator.Validate</code>对象指针，如果一切成功的话我们就可以调用<code>v.RegisterValidation()</code>来登记我们的自定义的验证函数。其中第一个参数是我们的验证标签，第二个参数是我们之前实现的<code>validCurrency()</code>函数。</p>
<h3 id="使用自定义验证模块">使用自定义验证模块</h3>
<p>接下来在request参数结构体中有货币字段的，将货币字段的binding部分的oneof去掉改成currency</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> createAccountRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    Owner    <span class="keyword">string</span> <span class="string">`json:&quot;owner&quot; binding:&quot;required&quot;`</span></span><br><span class="line">    Currency <span class="keyword">string</span> <span class="string">`json:&quot;currency&quot; binding:&quot;required,currency&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> transferRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    FromAccountID <span class="keyword">int64</span>  <span class="string">`json:&quot;from_account_id&quot; binding:&quot;required,min=1&quot;`</span></span><br><span class="line">    ToAccountID   <span class="keyword">int64</span>  <span class="string">`json:&quot;to_account_id&quot; binding:&quot;required,min=1&quot;`</span></span><br><span class="line">    Amount        <span class="keyword">int64</span>  <span class="string">`json:&quot;amount&quot; binding:&quot;required,gt=0&quot;`</span></span><br><span class="line">    Currency      <span class="keyword">string</span> <span class="string">`json:&quot;currency&quot; binding:&quot;required,currency&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，我们运行<code>make server</code>并且进行测试。</p>
<h2 id="通过特殊的外键限制在pgSQL中添加用户表">通过特殊的外键限制在pgSQL中添加用户表</h2>
<p>我们的银行系统到目前为止还缺少一个关键的表：用户认证和授权。接下来我们九江通过连接到已经存在的account表来创建一个user表。</p>
<h3 id="增加user表">增加user表</h3>
<p>我们去到<code>diagram.io</code>添加我们的user表。</p>
<p>表中第一个字段是用户名，它应当是一个varchar类型的变量，每一个用户名都应当是不同的，所以它应当是个主键[pk]</p>
<p>第二个字段是<code>hashed_password</code>字段来存储用户的密码值，它的类型同样是<code>varchar</code>并且不应当为NULL。为什么是hashed呢？因为我们基本上不会在数据库存储一个未经任何修饰的密码，因为如果我们这样做了那么任何能够访问数据库的人都会看到所有人的密码，这是一个非常重要的安全问题。</p>
<p>接下来的字段是用户的全名，它也是varchar，并且不能为null，然后是有向，每个用户的邮箱应该不同。</p>
<p>然后我们有一个创建时间字段，记录创建该用户的时间并且默认值为当前时间。</p>
<p>最后，为了安全考虑，通常会定期提醒用户去修改密码，所以我们设置一个<code>password_changed_at</code>来获取用户上一次修改密码是什么时候。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Table</span> users <span class="keyword">as</span> U &#123;</span><br><span class="line">  username <span class="type">varchar</span> [pk]</span><br><span class="line">  hashed_password <span class="type">varchar</span> [<span class="keyword">not</span> <span class="keyword">null</span>]</span><br><span class="line">  full_name <span class="type">varchar</span> [<span class="keyword">not</span> <span class="keyword">null</span>]</span><br><span class="line">  email <span class="type">varchar</span> [<span class="keyword">unique</span>, <span class="keyword">not</span> <span class="keyword">null</span>]</span><br><span class="line">  password_changed_at timestamptz [<span class="keyword">not</span> <span class="keyword">null</span>, <span class="keyword">default</span>: <span class="string">&#x27;0001-01-01 00:00:00Z&#x27;</span>]</span><br><span class="line">  created_at timestamptz [<span class="keyword">not</span> <span class="keyword">null</span>, <span class="keyword">default</span>: `now()`]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们设置每个字段都不为null的目的非常简单，因为我们在程序中不希望单独处理为null的情况。如果密码一直没有改变过的话，我们会用默认的一个过去时间作为它的值。在go语言中，就是<code>0001-01-01 00:00:00Z</code>，Z的意思是0时区。</p>
<h3 id="增加外键约束">增加外键约束</h3>
<p>现在，我们需要让一个用户能够有多个不同货币的账号，所以我们需要将<code>accounts</code>表的<code>owner</code>字段连接到<code>users</code>表的<code>username</code>字段，这会使得<code>owner</code>字段成为一个外键。</p>
<p>我们会在定义<code>owner</code>的地方增加一个索引标签到username上。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Table</span> accounts <span class="keyword">as</span> A &#123;</span><br><span class="line">  id bigserial [pk]</span><br><span class="line">  owner <span class="type">varchar</span> [<span class="keyword">ref</span>: <span class="operator">&gt;</span> U.username, <span class="keyword">not</span> <span class="keyword">null</span>]</span><br><span class="line">  balance <span class="type">bigint</span> [<span class="keyword">not</span> <span class="keyword">null</span>]</span><br><span class="line">  currency <span class="type">varchar</span> [<span class="keyword">not</span> <span class="keyword">null</span>]</span><br><span class="line">  created_at timestamptz [<span class="keyword">not</span> <span class="keyword">null</span>, <span class="keyword">default</span>: `now()`]</span><br><span class="line"></span><br><span class="line">  Indexes &#123;</span><br><span class="line">    owner</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="增加特殊约束">增加特殊约束</h3>
<p>还有一件事我们需要注意，一个用户可以有多个账户，但是那些账户应当有不同的货币类型。一个将这个限制在数据库级别实现的方法是增加一个<code>composite unique index</code>到account表中。这个索引由两个字段构成：owner和currency。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Table</span> accounts <span class="keyword">as</span> A &#123;</span><br><span class="line">  id bigserial [pk]</span><br><span class="line">  owner <span class="type">varchar</span> [<span class="keyword">ref</span>: <span class="operator">&gt;</span> U.username, <span class="keyword">not</span> <span class="keyword">null</span>]</span><br><span class="line">  balance <span class="type">bigint</span> [<span class="keyword">not</span> <span class="keyword">null</span>]</span><br><span class="line">  currency <span class="type">varchar</span> [<span class="keyword">not</span> <span class="keyword">null</span>]</span><br><span class="line">  created_at timestamptz [<span class="keyword">not</span> <span class="keyword">null</span>, <span class="keyword">default</span>: `now()`]</span><br><span class="line"></span><br><span class="line">  Indexes &#123;</span><br><span class="line">    owner</span><br><span class="line">    (owner, currency) [<span class="keyword">unique</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以将文件导出为SQL文件了。</p>
<h3 id="将新的schema添加到项目中">将新的schema添加到项目中</h3>
<p>为了能够将变化更改到项目中去，一个方法是将<code>init_schema_migration</code>的全部内容都换成新的，然后重置数据库并且再次执行<code>migrate up</code>。但是，这么干在实际项目中显然是不可能的。因为需求一直在改，可能我们需要增加新表的时候，数据库已经投入到产品中了，不可能删库的。</p>
<p>所以正确的合并变化的方式是创建一个新的migration版本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">migrate create -ext sql -dir db/migration -seq add_users</span><br></pre></td></tr></table></figure>
<p>我们用一些参数来告诉migrate输出的file要以sql作为文件扩展名，并且输出到<code>db/migration</code>，并且用一个序列数字作为文件的前缀，生成的文件名是<code>add_user</code></p>
<h3 id="实现up-migration">实现up migration</h3>
<p>首先我们需要创建user表，所以我们将之前生成的SQL查询语句复制到新生成的up文件中，接着我们复制一个添加外键限制的查询语句到<code>account</code>表的<code>owner</code>字段中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE <span class="string">&quot;users&quot;</span> (</span><br><span class="line">  <span class="string">&quot;username&quot;</span> varchar PRIMARY KEY,</span><br><span class="line">  <span class="string">&quot;hashed_password&quot;</span> varchar NOT NULL,</span><br><span class="line">  <span class="string">&quot;full_name&quot;</span> varchar NOT NULL,</span><br><span class="line">  <span class="string">&quot;email&quot;</span> varchar UNIQUE NOT NULL,</span><br><span class="line">  <span class="string">&quot;password_changed_at&quot;</span> timestamptz NOT NULL DEFAULT(<span class="string">&#x27;0001-01-01 00:00:00Z&#x27;</span>),  </span><br><span class="line">  <span class="string">&quot;created_at&quot;</span> timestamptz NOT NULL DEFAULT (now())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALTER TABLE <span class="string">&quot;accounts&quot;</span> ADD FOREIGN KEY (<span class="string">&quot;owner&quot;</span>) REFERENCES <span class="string">&quot;users&quot;</span> (<span class="string">&quot;username&quot;</span>);</span><br><span class="line"></span><br><span class="line">CREATE UNIQUE INDEX ON <span class="string">&quot;accounts&quot;</span> (<span class="string">&quot;owner&quot;</span>, <span class="string">&quot;currency&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这样看起来已经很好了，但是我们还能有另一种方法，让每一个用户对每一种货币最多能有一个账户。我们不是使用一个unique索引，而是添加一个unique限制对每一个<code>owner</code>和<code>currency</code>对。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- CREATE UNIQUE INDEX ON &quot;accounts&quot; (&quot;owner&quot;, &quot;currency&quot;);</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &quot;accounts&quot; <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> &quot;owner_currency_key&quot; <span class="keyword">UNIQUE</span> (&quot;owner&quot;, &quot;currency&quot;);</span><br></pre></td></tr></table></figure>
<p>这两种方法其实在底层是差不多的，都可以使用。</p>
<h3 id="执行miagrate-up">执行miagrate up</h3>
<p>我们使用make migrateup命令来更新我们的改动，但是报错了。这是因为我们在account表中已经存在数据了但是在user表中没有，导致两表之间没有建立连接。所以在这个例子中，我们不得不清除掉所有的已经存在的数据，在执行刚才的命令之前。这是可行的，因为我们目前的系统还没有准备好部署呢。</p>
<p>但是需要注意的是，由于刚才的操作失败了，它会将当前的schema改成版本2但是是以一个dirty状态。所以如果我们这时候运行down的话，我们会得到一个错误因为现在的版本是dirty的。我们可以手动去修改这个dirty标志为false，然后再运行<code>make migratedown</code>使它数据清空。然后我们再运行<code>make migrateup</code>来生成我们的数据库。</p>
<h3 id="实现migration-down">实现migration down</h3>
<p>刚才我们为我们新创建的up文件进行了实现，接下来我们要实现我们刚刚创建的down文件。首先我们要丢弃<code>owner</code>和<code>currency</code>的特殊约束。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> &quot;accounts&quot; <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> IF <span class="keyword">EXISTS</span> &quot;owner_currency_key&quot;;</span><br></pre></td></tr></table></figure>
<p>接着我们用相同的方法丢弃掉owner的外键约束，但是我们这个时候怎么能知道这个外键约束的名称呢？我们可以点击tableplus窗口下方的info按钮获取到当前表的定义，其中会给出外键约束的名称。在这里我们的名称是<code>accounts_owner_fkey</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> &quot;accounts&quot; <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> IF <span class="keyword">EXISTS</span> &quot;accounts_owner_fkey&quot;;</span><br></pre></td></tr></table></figure>
<p>最后一步我们要把user表删掉就可以了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> &quot;users&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="测试up和down的migration">测试up和down的migration</h3>
<p>由于目前我们makefile中已经有一个make migratedown所以为了能够执行这个第二版本的down我们新增一个down1，其内容和之前是一样的，只是最后需要增加一个参数1，它的意思是只rollback到最后一个migration。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">migratedown1:</span></span><br><span class="line">  migrate -path db/migration -database <span class="string">&quot;postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable&quot;</span> -verbose down 1</span><br></pre></td></tr></table></figure>
<p>对于up我们也是相同的做法，只向下up一层</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">migrateup1:</span></span><br><span class="line">  migrate -path db/migration -database <span class="string">&quot;postgresql://root:secret@localhost:5432/simple_bank?sslmode=disable&quot;</span> -verbose up 1</span><br></pre></td></tr></table></figure>
<p>然后把这两个添加到phony列表中。</p>
<h2 id="如何正确处理DB错误">如何正确处理DB错误</h2>
<p>上一节中我们已经添加了一个新的user表到我们的数据库中，接下来我们就需要更改我们的代码来使它能够在这个表上工作，而且还要处理pg返回的一些特殊错误。</p>
<h3 id="生成代码来创建和获取user">生成代码来创建和获取user</h3>
<p>首先我们需要创建一个新的<code>user.sql</code>文件，在这个文件中我们需要写两个SQL语句来创建和获取users。他们在结构上和我们之前对account的创建和获取应该是相似的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- name: CreateUser :one</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (</span><br><span class="line">  username,</span><br><span class="line">  hashed_password,</span><br><span class="line">  full_name,</span><br><span class="line">  email</span><br><span class="line">) <span class="keyword">VALUES</span> (</span><br><span class="line">  $<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>, $<span class="number">4</span></span><br><span class="line">) RETURNING <span class="operator">*</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- name: GetUser :one</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> $<span class="number">1</span> LIMIT <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>然后用sqlc自动生成对应的代码。我们现在可以去<code>db/sqlc/models.go</code>中观察到一个新的结构体User已经出现了。</p>
<h3 id="接下来需要给生成的代码编写测试">接下来需要给生成的代码编写测试</h3>
<p>我们可以使用之前对account做测试的文件中的一部分进行测试，其在本质上是差不多的。编写完成后发现对于单独的user的两个函数可以通过，但是要运行整个包通过就不可以了，因为我们的owner的外键约束还不存在呢！</p>
<h3 id="修复失败了的测试">修复失败了的测试</h3>
<p>我们能够注意到，account_test中其创建的随机账户的owner并没有关联到我们的user表中，为了解决这个问题我们需要在数据库中创建一个用户。然后，我们不再是随机创建一个owner而是用已经创建好的account owner。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createRandomAccount</span><span class="params">(t *testing.T)</span> <span class="title">Account</span></span> &#123;</span><br><span class="line">    user := createRandomUser(t)</span><br><span class="line"></span><br><span class="line">    arg := CreateAccountParams&#123;</span><br><span class="line">        Owner:    user.Username,</span><br><span class="line">        Balance:  util.RandomMoney(),</span><br><span class="line">        Currency: util.RandomCurrency(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们再运行整个包，发现全部通过。但是需要注意，这只是运行了所有db包中的测试，我们还没有运行api包中的测试呢。再命令行输入 make test来运行所有的测试。</p>
<p>我们会发现报错了，因为我们的mockstore没有实现db.Store接口。它缺失了一些函数的实现。这是因为我们运行sqlc生成代码的时候多出来两个函数<code>CreateUser</code>和<code>GetUser</code>被添加到了<code>Queries</code>接口中了，而<code>Queries</code>接口是<code>db.Store</code>接口的一部分。</p>
<p>为了解决这个问题，我们需要将mock代码再次生成一次 <code>make mock</code>,之后再进行测试就会发现没问题了。</p>
<h3 id="处理不同类型的DB错误">处理不同类型的DB错误</h3>
<p>接下来我们运行make server，然后打开postman来测试目前已经存在的api。</p>
<p>首先我们尝试为一个不存在数据库中的user创建一个账户。显而易见它会报错，但是它报的是内部服务器错误，这个状态码明显不是我们要的，因为这是客户端的错误，它不应该给一个不存在的用户创建账户。这里返回的最好应该是<code>403 forbidden</code>。</p>
<p>我们在<code>api/account.go</code>下面找到<code>creatAccount</code>函数，如果返回了一个错误的话，我们将会尝试将他转成<code>pg.Error</code>类型并且赋给一个<code>pgErr</code>变量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">createAccount</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    account, err := server.store.CreateAccount(ctx, arg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> pqErr, ok := err.(*pq.Error); ok &#123;</span><br><span class="line">            log.Println(pqErr.Code.Name())</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.JSON(http.StatusOK, account)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们重启服务器，发现这一次报的错误是我们想要的了。我们一会可以利用它对错误进行分类。</p>
<p>现在我们想要对一个已经存在的用户创建一个账户，这一次能够成功，但是要是我们再进行一次重复操作呢？即对这个用户再创建一个相同的账户。就会报一个owner_currency的键的错误了。这一次我们同样希望它报的错误是403而不是500，然后我们看log中的错误，发现是<code>unique_violation</code>，这样我们就可以回到代码中进行更新</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">createAccount</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    account, err := server.store.CreateAccount(ctx, arg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> pqErr, ok := err.(*pq.Error); ok &#123;</span><br><span class="line">            <span class="keyword">switch</span> pqErr.Code.Name() &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;foreign_key_violation&quot;</span>, <span class="string">&quot;unique_violation&quot;</span>:</span><br><span class="line">                ctx.JSON(http.StatusForbidden, errorResponse(err))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.JSON(http.StatusOK, account)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何安全地存储密码">如何安全地存储密码</h2>
<p>之前已经提到我们不可以直接存储密码到数据库中，所以我们可以先对他做hash变换然后只存储hash值。基本上使用<code>bcrypt</code>hashing函数来实现的。除了原本的密码，这个函数还需要一个<code>cost</code>参数，它将会决定算法的密钥扩展轮次或者迭代次数。</p>
<p><code>bcrypt</code>同样生成一个随机的<code>salt</code>用于这些迭代中，将会有助于抵抗<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rainbow_table">rainbow table attack</a>。因为存在随机的<code>salt</code>，所以算法每次都会给出一个完全不同的输出hash值，即便输入的密码是相同的。</p>
<p><img src="https://i.imgur.com/Ai2hmEK.png" alt="picture 1"></p>
<p><code>cost</code>和<code>salt</code>参数会被添加到hash中来生成最终的hash字符串。这个hash字符串包含4个部分：</p>
<ul>
<li>第一个部分是算法id，<code>2A</code>的意思是<code>bcrypt</code>算法</li>
<li>第二个部分是cost，在本例子中cost是10，意思是<code>2^10</code>次密钥扩展</li>
<li>第三个部分是长度为16byte的<code>salt</code>，它是使用<code>base64</code>格式化编码的，将会生成一个22个字符的字符串</li>
<li>最后是24个字节的hash值，被编码为31个字符</li>
</ul>
<p>所有这些部分会连接到一个单独的hash字符串中，并且这个字符串就是我们需要存储到数据库中的字符串。</p>
<p>那么当用户登陆的时候我们怎么验证这个密码呢？首先我们找到这个账户对应的密码，然后我们用密码中的<code>cost</code>和<code>salt</code>作为hash函数的参数，然后对用户输入的密码进行hash处理，如果结果和数据库中的密码结果是一样的，那么验证成功。</p>
<h3 id="实现hash和比较密码">实现hash和比较密码</h3>
<p>对于实现hash密码函数，我们先在<code>util</code>包下面创建一个<code>password.go</code>文件，其中我们定义一个新的函数<code>HashPassword()</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashPassword returns the bcrypt hash of the password</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HashPassword</span><span class="params">(password <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    hashedPassword, err := bcrypt.GenerateFromPassword([]<span class="keyword">byte</span>(password), bcrypt.DefaultCost)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;failed to hash password: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(hashedPassword), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中我们直接调用<code>bcrypt</code>包来生成我们的hash密码。</p>
<p>接下来我们需要进行密码的比较，由于我们已经在上面定义了hash转换。所以我们可以对用户输入的密码做转换然后和数据库中的密码进行比较</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CheckPassword checks if the provided password is correct or not</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckPassword</span><span class="params">(password <span class="keyword">string</span>, hashedPassword <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bcrypt.CompareHashAndPassword([]<span class="keyword">byte</span>(hashedPassword), []<span class="keyword">byte</span>(password))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为这两个函数写单元测试">为这两个函数写单元测试</h3>
<p>我们在<code>util</code>包下面创建一个新的文件<code>password_test.go</code>来对刚才的两个函数进行测试。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPassword</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    password := RandomString(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    hashedPassword, err := HashPassword(password)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    require.NotEmpty(t, hashedPassword)</span><br><span class="line"></span><br><span class="line">    err = CheckPassword(password, hashedPassword1)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就测试了密码正确时的情景，下面我们用一个错误密码进行测试</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPassword</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    password := RandomString(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    hashedPassword, err := HashPassword(password)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    require.NotEmpty(t, hashedPassword)</span><br><span class="line"></span><br><span class="line">    wrongPassword := RandomString(<span class="number">6</span>)</span><br><span class="line">    err = CheckPassword(wrongPassword, hashedPassword)</span><br><span class="line">    require.EqualError(t, err, bcrypt.ErrMismatchedHashAndPassword.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新现有的代码">更新现有的代码</h3>
<p>目前我们已经能够对密码进行hash，因此我们需要返回<code>user_test.go</code>中的<code>creatRandomUser()</code>函数，使用<code>hashedPassword</code>来替换原本的随机密码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createRandomUser</span><span class="params">(t *testing.T)</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    hashedPassword, err := util.HashPassword(util.RandomString(<span class="number">6</span>))</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    arg := CreateUserParams&#123;</span><br><span class="line">        Username:       util.RandomOwner(),</span><br><span class="line">        HashedPassword: hashedPassword,</span><br><span class="line">        FullName:       util.RandomOwner(),</span><br><span class="line">        Email:          util.RandomEmail(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们就可以对整个包进行测试，发现全部测试成功！并且我们能够在数据库中发现密码已经变成我们生成的hash值了。</p>
<h3 id="确保所有的hashedpassword都是不同的">确保所有的hashedpassword都是不同的</h3>
<p>我们需要保证即便输入两次相同的密码我们生成的hash密码应该是不一样的。所以我们回到<code>password_test.go</code>文件中，对其进行一定的修改然后进行测试。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPassword</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    password := RandomString(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    hashedPassword1, err := HashPassword(password)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    require.NotEmpty(t, hashedPassword1)</span><br><span class="line"></span><br><span class="line">    err = CheckPassword(password, hashedPassword1)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    wrongPassword := RandomString(<span class="number">6</span>)</span><br><span class="line">    err = CheckPassword(wrongPassword, hashedPassword1)</span><br><span class="line">    require.EqualError(t, err, bcrypt.ErrMismatchedHashAndPassword.Error())</span><br><span class="line"></span><br><span class="line">    hashedPassword2, err := HashPassword(password)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    require.NotEmpty(t, hashedPassword2)</span><br><span class="line">    require.NotEqual(t, hashedPassword1, hashedPassword2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试之后发现能够成功！</p>
<h3 id="实现创建user的API">实现创建user的API</h3>
<p>下一步我们需要使用<code>HashPassword()</code>函数来实现创建用户的API。我们先在api包下创建一个<code>user.go</code>的新文件。之前我们作为创建账户的api，创建用户的api和这个是非常相像的，所以我们可以直接赋值过来。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> createUserRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    Username <span class="keyword">string</span> <span class="string">`json:&quot;username&quot; binding:&quot;required,alphanum&quot;`</span></span><br><span class="line">    Password <span class="keyword">string</span> <span class="string">`json:&quot;password&quot; binding:&quot;required,min=6&quot;`</span></span><br><span class="line">    FullName <span class="keyword">string</span> <span class="string">`json:&quot;full_name&quot; binding:&quot;required&quot;`</span></span><br><span class="line">    Email    <span class="keyword">string</span> <span class="string">`json:&quot;email&quot; binding:&quot;required,email&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中比较重要的是最后一个email，因为我们需要确保email正确能够沟通，所以我们增加一个<code>email</code> tag来确保这个邮箱是正确的。其实在validator包中有很多好用的tag，我们可以在<a target="_blank" rel="noopener" href="https://pkg.go.dev/github.com/go-playground/validator/v10">官方文档</a>中查看他们。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">createUser</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> req createUserRequest</span><br><span class="line">    <span class="keyword">if</span> err := ctx.ShouldBindJSON(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hashedPassword, err := util.HashPassword(req.Password)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arg := db.CreateUserParams&#123;</span><br><span class="line">        Username:       req.Username,</span><br><span class="line">        HashedPassword: hashedPassword,</span><br><span class="line">        FullName:       req.FullName,</span><br><span class="line">        Email:          req.Email,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user, err := server.store.CreateUser(ctx, arg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> pqErr, ok := err.(*pq.Error); ok &#123;</span><br><span class="line">            <span class="keyword">switch</span> pqErr.Code.Name() &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;unique_violation&quot;</span>:</span><br><span class="line">                ctx.JSON(http.StatusForbidden, errorResponse(err))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.JSON(http.StatusOK, user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意，对于传过来的密码我们要通过哈希加密之后才能传入数据库。</p>
<p>正如在创建账户API中的一样，如果存在错误的话我们可能会有多个场景，需要记住，在用户表中我们有两个unique约束</p>
<ul>
<li>一个是用户名</li>
<li>一个是邮箱</li>
</ul>
<p>在这个表中我们没有外键，所以我们只需要保留<code>unique_violation</code>来返回403错误就可以了</p>
<p>接着我们需要在<code>NewServer()</code>函数中增加一个新的路径，我们使用POST方法，路径应当是<code>/users</code>，并且它的handler应当为<code>server.createUser</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewServer creates a new HTTP server and set up routing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(store db.Store)</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">    server := &amp;Server&#123;store: store&#125;</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class="line">        v.RegisterValidation(<span class="string">&quot;currency&quot;</span>, validCurrency)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    router.POST(<span class="string">&quot;/users&quot;</span>, server.createUser)</span><br><span class="line"></span><br><span class="line">    router.POST(<span class="string">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class="line">    router.GET(<span class="string">&quot;/accounts/:id&quot;</span>, server.getAccount)</span><br><span class="line">    router.GET(<span class="string">&quot;/accounts&quot;</span>, server.listAccounts)</span><br><span class="line"></span><br><span class="line">    router.POST(<span class="string">&quot;/transfers&quot;</span>, server.createTransfer)</span><br><span class="line"></span><br><span class="line">    server.router = router</span><br><span class="line">    <span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以在postman中测试我们创建的这个api是否成功拉！</p>
<h3 id="API不能暴露hash映射后的密码">API不能暴露hash映射后的密码</h3>
<p>在我们彻底完成之前，我们需要注意我们测试时服务器给我们返回的信息中包含了我们的密码哈希值，但是这显然是没必要的，因为客户端永远不会用到这个哈希值。并且这也会造成一些安全性的问题，我们最好从response中删除这一条信息。</p>
<p>因此我们创建一个结构体作为返回对象，其中不需要password这一字段，另外在最后的return之前我们将user的内容转移到这个结构体的实例上面就可以了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> createUserResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">    Username          <span class="keyword">string</span>    <span class="string">`json:&quot;username&quot;`</span></span><br><span class="line">    FullName          <span class="keyword">string</span>    <span class="string">`json:&quot;full_name&quot;`</span></span><br><span class="line">    Email             <span class="keyword">string</span>    <span class="string">`json:&quot;email&quot;`</span></span><br><span class="line">    PasswordChangedAt time.Time <span class="string">`json:&quot;password_changed_at&quot;`</span></span><br><span class="line">    CreatedAt         time.Time <span class="string">`json:&quot;created_at&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">createUser</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    user, err := server.store.CreateUser(ctx, arg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> pqErr, ok := err.(*pq.Error); ok &#123;</span><br><span class="line">            <span class="keyword">switch</span> pqErr.Code.Name() &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;unique_violation&quot;</span>:</span><br><span class="line">                ctx.JSON(http.StatusForbidden, errorResponse(err))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rsp := createUserResponse&#123;</span><br><span class="line">        Username:          user.Username,</span><br><span class="line">        FullName:          user.FullName,</span><br><span class="line">        Email:             user.Email,</span><br><span class="line">        PasswordChangedAt: user.PasswordChangedAt,</span><br><span class="line">        CreatedAt:         user.CreatedAt,</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.JSON(http.StatusOK, rsp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用自定义的go-mock匹配器写高效的单元测试">用自定义的go-mock匹配器写高效的单元测试</h3>
<p>通过go-mock我们可以很轻松的对我们刚才实现的API做单元测试，但是如果我们自己来写单元测试的话，我们会发现这会有点小插曲在里面。因为输入的密码参数在存入数据库之前经过了hash变换。</p>
<p>为了更好地理解威慑呢蜜，我们先看下面这个版本的测试</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCreateUserAPI</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    user, password := randomUser(t)</span><br><span class="line"></span><br><span class="line">    testCases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        name          <span class="keyword">string</span></span><br><span class="line">        body          gin.H</span><br><span class="line">        buildStubs    <span class="function"><span class="keyword">func</span><span class="params">(store *mockdb.MockStore)</span></span></span><br><span class="line">        checkResponse <span class="function"><span class="keyword">func</span><span class="params">(recoder *httptest.ResponseRecorder)</span></span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">            body: gin.H&#123;</span><br><span class="line">                <span class="string">&quot;username&quot;</span>:  user.Username,</span><br><span class="line">                <span class="string">&quot;password&quot;</span>:  password,</span><br><span class="line">                <span class="string">&quot;full_name&quot;</span>: user.FullName,</span><br><span class="line">                <span class="string">&quot;email&quot;</span>:     user.Email,</span><br><span class="line">            &#125;,</span><br><span class="line">            buildStubs: <span class="function"><span class="keyword">func</span><span class="params">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class="line">                store.EXPECT().</span><br><span class="line">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class="line">                    Times(<span class="number">1</span>).</span><br><span class="line">                    Return(user, <span class="literal">nil</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            checkResponse: <span class="function"><span class="keyword">func</span><span class="params">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class="line">                require.Equal(t, http.StatusOK, recorder.Code)</span><br><span class="line">                requireBodyMatchUser(t, recorder.Body, user)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">&quot;InternalError&quot;</span>,</span><br><span class="line">            body: gin.H&#123;</span><br><span class="line">                <span class="string">&quot;username&quot;</span>:  user.Username,</span><br><span class="line">                <span class="string">&quot;password&quot;</span>:  password,</span><br><span class="line">                <span class="string">&quot;full_name&quot;</span>: user.FullName,</span><br><span class="line">                <span class="string">&quot;email&quot;</span>:     user.Email,</span><br><span class="line">            &#125;,</span><br><span class="line">            buildStubs: <span class="function"><span class="keyword">func</span><span class="params">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class="line">                store.EXPECT().</span><br><span class="line">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class="line">                    Times(<span class="number">1</span>).</span><br><span class="line">                    Return(db.User&#123;&#125;, sql.ErrConnDone)</span><br><span class="line">            &#125;,</span><br><span class="line">            checkResponse: <span class="function"><span class="keyword">func</span><span class="params">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class="line">                require.Equal(t, http.StatusInternalServerError, recorder.Code)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">&quot;DuplicateUsername&quot;</span>,</span><br><span class="line">            body: gin.H&#123;</span><br><span class="line">                <span class="string">&quot;username&quot;</span>:  user.Username,</span><br><span class="line">                <span class="string">&quot;password&quot;</span>:  password,</span><br><span class="line">                <span class="string">&quot;full_name&quot;</span>: user.FullName,</span><br><span class="line">                <span class="string">&quot;email&quot;</span>:     user.Email,</span><br><span class="line">            &#125;,</span><br><span class="line">            buildStubs: <span class="function"><span class="keyword">func</span><span class="params">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class="line">                store.EXPECT().</span><br><span class="line">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class="line">                    Times(<span class="number">1</span>).</span><br><span class="line">                    Return(db.User&#123;&#125;, &amp;pq.Error&#123;Code: <span class="string">&quot;23505&quot;</span>&#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            checkResponse: <span class="function"><span class="keyword">func</span><span class="params">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class="line">                require.Equal(t, http.StatusForbidden, recorder.Code)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">&quot;InvalidUsername&quot;</span>,</span><br><span class="line">            body: gin.H&#123;</span><br><span class="line">                <span class="string">&quot;username&quot;</span>:  <span class="string">&quot;invalid-user#1&quot;</span>,</span><br><span class="line">                <span class="string">&quot;password&quot;</span>:  password,</span><br><span class="line">                <span class="string">&quot;full_name&quot;</span>: user.FullName,</span><br><span class="line">                <span class="string">&quot;email&quot;</span>:     user.Email,</span><br><span class="line">            &#125;,</span><br><span class="line">            buildStubs: <span class="function"><span class="keyword">func</span><span class="params">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class="line">                store.EXPECT().</span><br><span class="line">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class="line">                    Times(<span class="number">0</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            checkResponse: <span class="function"><span class="keyword">func</span><span class="params">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class="line">                require.Equal(t, http.StatusBadRequest, recorder.Code)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">&quot;InvalidEmail&quot;</span>,</span><br><span class="line">            body: gin.H&#123;</span><br><span class="line">                <span class="string">&quot;username&quot;</span>:  user.Username,</span><br><span class="line">                <span class="string">&quot;password&quot;</span>:  password,</span><br><span class="line">                <span class="string">&quot;full_name&quot;</span>: user.FullName,</span><br><span class="line">                <span class="string">&quot;email&quot;</span>:     <span class="string">&quot;invalid-email&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            buildStubs: <span class="function"><span class="keyword">func</span><span class="params">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class="line">                store.EXPECT().</span><br><span class="line">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class="line">                    Times(<span class="number">0</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            checkResponse: <span class="function"><span class="keyword">func</span><span class="params">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class="line">                require.Equal(t, http.StatusBadRequest, recorder.Code)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">&quot;TooShortPassword&quot;</span>,</span><br><span class="line">            body: gin.H&#123;</span><br><span class="line">                <span class="string">&quot;username&quot;</span>:  user.Username,</span><br><span class="line">                <span class="string">&quot;password&quot;</span>:  <span class="string">&quot;123&quot;</span>,</span><br><span class="line">                <span class="string">&quot;full_name&quot;</span>: user.FullName,</span><br><span class="line">                <span class="string">&quot;email&quot;</span>:     user.Email,</span><br><span class="line">            &#125;,</span><br><span class="line">            buildStubs: <span class="function"><span class="keyword">func</span><span class="params">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class="line">                store.EXPECT().</span><br><span class="line">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class="line">                    Times(<span class="number">0</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            checkResponse: <span class="function"><span class="keyword">func</span><span class="params">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class="line">                require.Equal(t, http.StatusBadRequest, recorder.Code)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和之前一样，我们可以创建一个随机的用户，然后我们声明一组测试用例，其中我们能够定义输入的请求主体，以及两个函数分别用于创建store存根和检查API的返回值。</p>
<p>我们可以测试一些不同的案例，比如：</p>
<ul>
<li>成功的案例</li>
<li>内部服务器错误案例</li>
<li>重复用户名</li>
<li>非法用户名、邮箱或者密码</li>
</ul>
<p>我们迭代所有这些例子并且为他们运行独立的子测试。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCreateUserAPI</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> testCases &#123;</span><br><span class="line">        tc := testCases[i]</span><br><span class="line"></span><br><span class="line">        t.Run(tc.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">            ctrl := gomock.NewController(t)</span><br><span class="line">            <span class="keyword">defer</span> ctrl.Finish()</span><br><span class="line"></span><br><span class="line">            store := mockdb.NewMockStore(ctrl)</span><br><span class="line">            tc.buildStubs(store)</span><br><span class="line"></span><br><span class="line">            server := NewServer(store)</span><br><span class="line">            recorder := httptest.NewRecorder()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Marshal body data to JSON</span></span><br><span class="line">            data, err := json.Marshal(tc.body)</span><br><span class="line">            require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">            url := <span class="string">&quot;/users&quot;</span></span><br><span class="line">            request, err := http.NewRequest(http.MethodPost, url, bytes.NewReader(data))</span><br><span class="line">            require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">            server.router.ServeHTTP(recorder, request)</span><br><span class="line">            tc.checkResponse(recorder)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每一个子测试中，我们创建一个新的gomock控制器，并且用它来创建一个新的DB store。然后我们调用<code>buildStubs()</code>来为store创建存根。之后，我们使用mock store创建一个新的服务器，并且创建一个新的HTTP返回<code>recorder</code>来记录API的返回值。接着我们解析输入的请求主体并且向API终端发送请求。我们调用<code>server.router.ServeHTTP()</code>，最后调用<code>tc.checkResponse()</code>来检查结果。</p>
<p>这相当简单，就和我们之前做的一样。而现在，对于这一章节我们只需要注重于成功的例子</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCreateUserAPI</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    user, password := randomUser(t)</span><br><span class="line"></span><br><span class="line">    testCases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        name          <span class="keyword">string</span></span><br><span class="line">        body          gin.H</span><br><span class="line">        buildStubs    <span class="function"><span class="keyword">func</span><span class="params">(store *mockdb.MockStore)</span></span></span><br><span class="line">        checkResponse <span class="function"><span class="keyword">func</span><span class="params">(recoder *httptest.ResponseRecorder)</span></span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">            body: gin.H&#123;</span><br><span class="line">                <span class="string">&quot;username&quot;</span>:  user.Username,</span><br><span class="line">                <span class="string">&quot;password&quot;</span>:  password,</span><br><span class="line">                <span class="string">&quot;full_name&quot;</span>: user.FullName,</span><br><span class="line">                <span class="string">&quot;email&quot;</span>:     user.Email,</span><br><span class="line">            &#125;,</span><br><span class="line">            buildStubs: <span class="function"><span class="keyword">func</span><span class="params">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class="line">                store.EXPECT().</span><br><span class="line">                    CreateUser(gomock.Any(), gomock.Any()).</span><br><span class="line">                    Times(<span class="number">1</span>).</span><br><span class="line">                    Return(user, <span class="literal">nil</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            checkResponse: <span class="function"><span class="keyword">func</span><span class="params">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class="line">                require.Equal(t, http.StatusOK, recorder.Code)</span><br><span class="line">                requireBodyMatchUser(t, recorder.Body, user)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里的<code>buildstubs</code>函数中，我们用两个<code>gomock.Any()</code>函数来匹配<code>CreateUser()</code>函数的两个参数，这对于第一个参数上下文环境是合理的，但是对于第二个参数我们就无法判断是否输入的是合理的参数了。但是我们先这样用。</p>
<p>我们输入一个成功案例并且进行测试，发现是可以的，但是如果我们将输入的参数设置为空，再运行测试发现还是可行的。这样的话就非常糟糕，因为我们的处理是错误的，但是测试竟然通过了！</p>
<p>此外我们加入忽视用户生成的密码，而改用一个常量<code>weirdo</code>作为密码并且做hash转换，发现仍然不会报错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">createUser</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    hashedPassword, err := util.HashPassword(<span class="string">&quot;xyz&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arg := db.CreateUserParams&#123;</span><br><span class="line">        Username:       req.Username,</span><br><span class="line">        HashedPassword: hashedPassword,</span><br><span class="line">        FullName:       req.FullName,</span><br><span class="line">        Email:          req.Email,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user, err := server.store.CreateUser(ctx, arg)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> pqErr, ok := err.(*pq.Error); ok &#123;</span><br><span class="line">            <span class="keyword">switch</span> pqErr.Code.Name() &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;unique_violation&quot;</span>:</span><br><span class="line">                ctx.JSON(http.StatusForbidden, errorResponse(err))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="尝试使用gomock-Eq">尝试使用<code>gomock.Eq</code></h3>
<p>我们可以想到如果不使用<code>gomock.Any()</code>来作为替代呢，我们用别的，比如<code>gomock.Eq()</code>.</p>
<p>首先我们声明一个新的arg变量是<code>db.CreateUserParams</code>，其中username是<code>user.Username</code>。对于<code>hashed_password</code>这一字段，我们需要映射输入的密码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCreateUserAPI</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    user, password := randomUser(t)</span><br><span class="line"></span><br><span class="line">    hashedPassword, err := util.HashPassword(password)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    testCases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        name          <span class="keyword">string</span></span><br><span class="line">        body          gin.H</span><br><span class="line">        buildStubs    <span class="function"><span class="keyword">func</span><span class="params">(store *mockdb.MockStore)</span></span></span><br><span class="line">        checkResponse <span class="function"><span class="keyword">func</span><span class="params">(recoder *httptest.ResponseRecorder)</span></span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            name: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">            body: gin.H&#123;</span><br><span class="line">                <span class="string">&quot;username&quot;</span>:  user.Username,</span><br><span class="line">                <span class="string">&quot;password&quot;</span>:  password,</span><br><span class="line">                <span class="string">&quot;full_name&quot;</span>: user.FullName,</span><br><span class="line">                <span class="string">&quot;email&quot;</span>:     user.Email,</span><br><span class="line">            &#125;,</span><br><span class="line">            buildStubs: <span class="function"><span class="keyword">func</span><span class="params">(store *mockdb.MockStore)</span></span> &#123;</span><br><span class="line">                arg := db.CreateUserParams&#123;</span><br><span class="line">                    Username: user.Username,</span><br><span class="line">                    HashedPassword: hashedPassword,</span><br><span class="line">                    FullName: user.FullName,</span><br><span class="line">                    Email: user.Email,</span><br><span class="line">                &#125;</span><br><span class="line">                store.EXPECT().</span><br><span class="line">                    CreateUser(gomock.Any(), gomock.Eq(arg)).</span><br><span class="line">                    Times(<span class="number">1</span>).</span><br><span class="line">                    Return(user, <span class="literal">nil</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            checkResponse: <span class="function"><span class="keyword">func</span><span class="params">(recorder *httptest.ResponseRecorder)</span></span> &#123;</span><br><span class="line">                require.Equal(t, http.StatusOK, recorder.Code)</span><br><span class="line">                requireBodyMatchUser(t, recorder.Body, user)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们用<code>gomock.Eq(arg)</code>来代替<code>gomock.Any()</code>。接下来我们测试如果传入的是空的值是否可以通过测试，发现确实不能通过了！这就对了，但是如果我们把这个传入的值设置为正确的值，结果发现不能通过。</p>
<p>这是因为传入的值和gomock期待的值是不一样的，我们在log中可以看到，只有hashedpassword字段没有通过。我们还记得上一节说提到过，同样的密码经过hash得到的值也会是不一样的，因此我们的匹配不会成功。</p>
<p>唯一能解决这个问题的办法似乎只能是我们自定义一个匹配器了。</p>
<h3 id="实现自定义gomock匹配器">实现自定义gomock匹配器</h3>
<p>首先我们移除掉<code>hashedPassword</code>因为这部是我们在自定义匹配器中所需要的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Eq</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Matcher</span></span> &#123; <span class="keyword">return</span> eqMatcher&#123;x&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Matcher <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Matches returns whether x is a match.</span></span><br><span class="line">    Matches(x <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// String describes what the matcher matches.</span></span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于我们自定义的匹配器而言，我们将写一个类似的实现，它只有两个方法：</p>
<ul>
<li><code>Matches()</code>，它应当返回输入<code>x</code>是否是一个匹配</li>
<li><code>String()</code>，它描述匹配器匹配了哪些内容，用于日志的记录</li>
</ul>
<p>这是我们正在使用的相等匹配器的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eqMatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e eqMatcher)</span> <span class="title">Matches</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reflect.DeepEqual(e.x, x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e eqMatcher)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;is equal to %v&quot;</span>, e.x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们自定义的匹配器应该和它非常相像所以我把它复制到<code>user_test.go</code>文件的最上方，然后对他进行修改.</p>
<p>首先我们把结构体的名字改成<code>eqCreateUserParamsMatcher</code>，并且为了正确比较输入的参数，我们需要两个字段</p>
<ul>
<li>首先是<code>arg</code>字段，它是<code>db.CreateUserParams</code>类型的</li>
<li>第二个是password字段，存储最原始的密码值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eqCreateUserParamsMatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">    arg      db.CreateUserParams</span><br><span class="line">    password <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在让我们实现<code>Matches()</code>函数，因为输入<code>x</code>是一个接口，我们应当把它转换为<code>db.CreateUserParams</code>对象。</p>
<p>如果转换不成功我们返回错误，如果转换成功，我们检测输入的密码是否和hash转换后的密码相同</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e eqCreateUserParamsMatcher)</span> <span class="title">Matches</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    arg, ok := x.(db.CreateUserParams)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err := util.CheckPassword(e.password, arg.HashedPassword)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e.arg.HashedPassword = arg.HashedPassword</span><br><span class="line">    <span class="keyword">return</span> reflect.DeepEqual(e.arg, arg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们再修改其他的函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e eqCreateUserParamsMatcher)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;matches arg %v and password %v&quot;</span>, e.arg, e.password)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EqCreateUserParams</span><span class="params">(arg db.CreateUserParams, password <span class="keyword">string</span>)</span> <span class="title">gomock</span>.<span class="title">Matcher</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> eqCreateUserParamsMatcher&#123;arg, password&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在基于令牌的验证上为什么PASETO比JWT好">在基于令牌的验证上为什么PASETO比JWT好</h2>
<h3 id="基于令牌的验证">基于令牌的验证</h3>
<p>我们先了解一下基于令牌的验证。大体来说，在验证机制中，客户端会发起第一个请求来登陆账户，它会向客户端提供用户名和密码。然后服务器会检查用户名是否是正确的，如果是的话服务器会创建并且登记一个token，然后返回一个<code>200 ok</code>和产生的这个token一块到客户端。</p>
<p>之所以这个token会被称为通行token是因为稍后客户端会通过它来获取服务器上面的资源。比如说客户端想要获取到当前user名下的所有银行账户，他需要发送一个<code>GET/accounts</code>请求到服务器，通行token会被嵌入在请求的头部。受到请求的时候，服务器会验证这个令牌是否是有效的，如果请求是被允许的话，就会返回<code>200 ok</code>和该user的银行账户列表。</p>
<p>需要注意通行token通常是有生命周期的，在这个期间，客户端可以用相同的令牌向服务器发送多个请求。</p>
<h3 id="JSON-Web-Tkoen-JWT">JSON Web Tkoen(JWT)</h3>
<p><img src="https://i.imgur.com/HNe1dBh.png" alt="picture 1"></p>
<p>上图是一个JSON Web Token的例子，它基于64位字符串编码，由3个主要部分组成，中间由点分割开：</p>
<ul>
<li>第一部分是红色的部分，是令牌的头部，当我们解码这一部分的时候，我们将会获得一个JSON对象，其中包含令牌的类型<code>JWT</code>，和用于登记令牌的算法<code>HS256</code></li>
<li>第二部分是紫色的部分，这一部分是我们保存当前登陆用户的信息的部分，比如用户名和该令牌的生命截止的时间戳。</li>
</ul>
<p>我们可以自定义这个JSON来存储一些别的信息，在这个例子中我们有一个ID字段来标识令牌。当令牌泄漏我们需要撤销令牌的权限的时候会派上用场。存储在JWT中的数据只是基于64位的编码，而不是加密，我们不需要用服务器的密钥来对它进行解密内容。这意味着我们可以很轻松地对头部和有效信息部分进行编码。那么服务器如何验证这个令牌的权限呢？</p>
<p>这就是第三部分需要做的了</p>
<ul>
<li>数字签名，这个思路很简单，只有服务器拥有密钥来注册令牌，所以如果有黑客再没有正确密钥情况下尝试去创建一个虚假的令牌，服务器会很容易发现这一行为。</li>
</ul>
<p>JWT标准提供了许多不同种类的数字签名算法，但是总体上能够概括为两个主要类别</p>
<h4 id="对称密钥算法">对称密钥算法</h4>
<p>在注册和验证密钥期间使用相同的密钥，因为只有一个密钥，它必须要保密。所以这个算法只适合本地用户，换句话说就是内部服务器。这个算法在大部分应用的情况下都是有效并且合适的。</p>
<p>但是我们不能在存在第三方服务需要验证令牌的时候使用它，因为这意味着我们必须把密钥交给第三方。</p>
<h4 id="非对称密钥算法">非对称密钥算法</h4>
<p>私有密钥用于注册令牌，公共密钥用于验证。</p>
<h4 id="JWT存在的问题">JWT存在的问题</h4>
<ul>
<li>算法太弱：JWT提供的算法中有很多已知比较脆弱的算法，对于开发新手来说，很难知道哪一个算法是最合适的。</li>
<li>简单的令牌伪造：如果选了一个不恰当的库，我们的系统会成为极易攻破的目标。JWT将注册算法放在了令牌的头部，因此攻击者可以向令牌中这个位置设置none来绕过签名验证过程。虽然这个问题在大部分库中被解决了，但是我们在选择的时候仍然需要小心。</li>
</ul>
<h3 id="PASETO-Platform-Agnostic-Security-Token">PASETO-Platform Agnostic Security Token</h3>
<h4 id="强力算法">强力算法</h4>
<p>它解决了所有JSON Web Token中存在的问题，并且开发者不再需要选择算法，而是只需要选择PASETO的版本。同一时刻只有两个PASETO版本是可用的。</p>
<p>版本1比较老旧并且只能用于不能使用现代密码学的遗留系统。</p>
<p>和JWT类似，PASETO对于两种主要情况同样有两个算法总类，对于本地和内部服务器而言，可以使用对称密钥算法。但是和JWT不同的是，PASETO会在令牌中进行加密和验证所有的信息。对于公共服务器的情况，我们还是使用非对称密钥算法，可JWT一样不对令牌信息进行编码。</p>
<p>PASETO版本2的令牌字段主要分为4个部分，用点分割开</p>
<ul>
<li>第一部分是PASETO的版本</li>
<li>第二部分是令牌的目的，是用于本地还是公共场景</li>
<li>第三个部分是令牌承载的有效信息的主要内容，注意这是加密的，我们需要用密钥对它进行解密，这之后我们得到三个小部分
<ul>
<li>有效信息主体</li>
<li>用于加密和验证的随机数</li>
<li>信息验证标签，用于验证加密信息和与之相关的未加密信息</li>
</ul>
</li>
<li>最后一部分可以存储任何公共信息，因为它不会被加密，这一部分是可以选择的</li>
</ul>
<h2 id="如何用go创建和验证JWT和PASETO">如何用go创建和验证JWT和PASETO</h2>
<h3 id="声明制作令牌的接口">声明制作令牌的接口</h3>
<p>我们创建一个新的包<code>token</code>，然后在其中创建一个新的文件<code>make.go</code>。思路是声明一个总的<code>token.Maker</code>接口来管理令牌的创建和验证。然后我们会写一个<code>JWTMaker</code>和<code>PasetoMaker</code>结构体来实现这个接口。通过这样做，我们能够很轻松地在不同种类的令牌制造。</p>
<p>这个接口应当有两个方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Maker <span class="keyword">interface</span> &#123;</span><br><span class="line">    CreateToken(username <span class="keyword">string</span>, duration time.Duration) (<span class="keyword">string</span>, error)</span><br><span class="line">    VerifyToken(token <span class="keyword">string</span>) (*Payload, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CreateToken()</code>方法以<code>username</code>和<code>duration</code>作为输入，返回一个token和一个错误类型</p>
<p><code>VerifyToken()</code>方法接收一个token然后返回<code>Payload</code>对象和一个错误类型，这个payload对象存储token的主体。</p>
<h3 id="声明token的Payload结构体">声明token的Payload结构体</h3>
<p>我们需要创建一个<code>payload.go</code>文件，然后定义<code>Payload</code>结构体。其中最重要的是<code>Username</code>字段，用于识别token的拥有者。当使用基于验证的token的时候，一定要记住每一个token都有一个较短的验证时间，所以我们需要<code>ExpiredAt</code>字段来指明这个token什么时候会过期。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Payload <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID        uuid.UUID <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">    Username  <span class="keyword">string</span>    <span class="string">`json:&quot;username&quot;`</span></span><br><span class="line">    IssuedAt  time.Time <span class="string">`json:&quot;issued_at&quot;`</span></span><br><span class="line">    ExpiredAt time.Time <span class="string">`json:&quot;expired_at&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常来说我们只需要下面这三个字段就可以了，但是如果我们想要有一个机制来取消对某些泄漏的token的权限的话，我们需要增加一个<code>ID</code>字段来独立地标志每一个token。这里我们用到的是uuid，它在<a target="_blank" rel="noopener" href="https://github.com/google/uuid">uuid</a>包中定义，我们可以go get一下。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/google/uuid</span><br></pre></td></tr></table></figure>
<p>接下来我们定义一个<code>NewPayload()</code>函数，以一个<code>username</code>和<code>duration</code>作为输入参数并且返回一个<code>Payload</code>对象和一个错误。这个函数会创建一个新的带有username和duration的token payload。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPayload</span><span class="params">(username <span class="keyword">string</span>, duration time.Duration)</span> <span class="params">(*Payload, error)</span></span> &#123;</span><br><span class="line">    tokenID, err := uuid.NewRandom()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    payload := &amp;Payload&#123;</span><br><span class="line">        ID:        tokenID,</span><br><span class="line">        Username:  username,</span><br><span class="line">        IssuedAt:  time.Now(),</span><br><span class="line">        ExpiredAt: time.Now().Add(duration),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> payload, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先调用<code>uuid.Random()</code>来进行随机生成tokenID，然后我们定义一个payload变量，对其中字段进行赋值。</p>
<h3 id="实现JWT-Maker">实现JWT Maker</h3>
<p>我们需要JWT的包，包的种类很多但是我们选用最流行的<a target="_blank" rel="noopener" href="https://github.com/dgrijalva/jwt-go">https://github.com/dgrijalva/jwt-go</a>,我们go get一下这个包。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/dgrijalva/jwt-go</span><br></pre></td></tr></table></figure>
<p>接着我们创建一个<code>jwt_maker.go</code>文件，然后声明一个<code>JWTMaker</code>结构体，它是一个JWT maker，用于实现token.Maker接。</p>
<p>在我们的项目中，我们使用对称密钥算法来注册token，因此结构体中应当有一个字段来保存密钥。</p>
<p>然后我们需要增加一个<code>NewJWTMaker()</code>函数，以<code>secretKey</code>作为输入，并且返回一个token.Maker接口和一个错误类型。通过返回这个接口，我们将会保证我们的<code>JWTMaker</code>实现了<code>token.Maker</code>接口。</p>
<p>目前，景观我们将要使用的算法不需要获得密钥的长度，确保密钥不是太短仍然是一个不错的想法。因此我们声明一个常量<code>minSecrectKeySize</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> minSecretKeySize = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewJWTMaker</span><span class="params">(secretKey <span class="keyword">string</span>)</span> <span class="params">(Maker, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(secretKey) &lt; minSecretKeySize &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;invalid key size: must be at least %d characters&quot;</span>, minSecretKeySize)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;JWTMaker&#123;secretKey&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数中我们检查密钥的长度，如果不够长的话我们回报错，如果够长我们就将他的值赋给JWTMaker对应的字段。</p>
<p>到目前这一步我们发现我们的代码中还是有错误的，因为我们创建的<code>JWTMaker</code>对象没有实现<code>token.Maker</code>所要求的方法，因此我们需要解决这个问题就要实现这两个方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(maker *JWTMaker)</span> <span class="title">CreateToken</span><span class="params">(username <span class="keyword">string</span>, duration time.Duration)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(maker *JWTMaker)</span> <span class="title">VerifyToken</span><span class="params">(token <span class="keyword">string</span>)</span> <span class="params">(*Payload, error)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现JWT-CreateToken方法">实现JWT CreateToken方法</h3>
<p>首先我们调用<code>NewPayload()</code>方法，并且传入<code>username</code>和<code>duration</code>,然后创建一个<code>jwtToken</code>通过调用jwt-go的包里面的<code>jwt.NewWithClaims()</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(maker *JWTMaker)</span> <span class="title">CreateToken</span><span class="params">(username <span class="keyword">string</span>, duration time.Duration)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    payload, err := NewPayload(username, duration)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jwtToken := jwt.NewWithClaims(jwt.SigningMethodHS256, payload)</span><br><span class="line">    <span class="keyword">return</span> jwtToken.SignedString([]<span class="keyword">byte</span>(maker.secretKey))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是此时我们会遇到一个错误，我们的Payload结构体并没有实现jwt.Claims接口，它缺少一个<code>Valid()</code>方法。所以我们需要为它加上这个方法。它不需要仍和的输入参数，并且仅仅返回一个错误以防token是非法的。在jwt-go包中能够很轻易地找到这个方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrExpiredToken = errors.New(<span class="string">&quot;token has expired&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(payload *Payload)</span> <span class="title">Valid</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> time.Now().After(payload.ExpiredAt) &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrExpiredToken</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是用于判断当前token是否已经过期的函数，当现在时间迟于token的失效时间的时候，这个token就过期了，因此需要返回一个错误，我们应当把这个错误定义为一个公共的常量<code>ErrExpiredToken</code>，这样我们就可以从外部检查这个错误类型了。</p>
<p>接着我们回到<code>jwtmaker.go</code>文件中，我们发现刚才的红线报的错误消失了。由于我们添加了<code>jwt-go</code>包，我们需要<code>go mod tidy</code>来将他添加到<code>go.mod</code>文件中。</p>
<h3 id="实现JWT-VerifyToken方法">实现JWT VerifyToken方法</h3>
<p>首先我们需要解析token，调用<code>jwt.ParseWithClaims</code>并且传入token，一个空的payload和一个key函数。key函数接受一个解析后的但没验证的token，我们应该验证头部以确保注册算法和我们使用的是一致的。如果匹配的话，就返回key这样jwt-go能够用它来验证token。这一步对于预防攻击很重要。</p>
<p>下面这个就是key函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(maker *JWTMaker)</span> <span class="title">VerifyToken</span><span class="params">(token <span class="keyword">string</span>)</span> <span class="params">(*Payload, error)</span></span> &#123;</span><br><span class="line">    keyFunc := <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">        _, ok := token.Method.(*jwt.SigningMethodHMAC)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrInvalidToken</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">byte</span>(maker.secretKey), <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jwtToken, err := jwt.ParseWithClaims(token, &amp;Payload&#123;&#125;, keyFunc)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在key函数中我们能够通过<code>token.Method</code>获得它的注册算法。注意到它的类型是一个<code>SigningMethod</code>，是一个接口，所以我们需要将他转换为一个具体的实现。在我们的代码中将他转换成了<code>SigningMethodHMAC</code>，因为我们使用的是<code>HS256</code>，是属于他的实例。如果转换不成功说明他们的类型是不一致的，我们需要返回一个空key和一个<code>ErrInvalidToken</code>错误，我们一会会在<code>payload.go</code>文件中定义这个错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    ErrInvalidToken = errors.New(<span class="string">&quot;token is invalid&quot;</span>)</span><br><span class="line">    ErrExpiredToken = errors.New(<span class="string">&quot;token has expired&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>如果转换成功的话，我们将密钥转成[]byte切片并且返回。</p>
<p>现在key函数完成了，我们可以开始调用<code>ParseWithClaims</code>函数。如果它返回一个或者没有错误，可能存在2个不同的情况：要么token非法，要么token过期。但是我们需要区分这两种情况的时候问题变得复杂了，如果我们深入jwt-go包中的话我们发现它会自动调用<code>token.Claims.Valid()</code>函数，而在我们的函数实现中我们返回的是<code>ErrExpiredToken</code>，jwt-go中隐式地将最初的错误放在了<code>ValidationError</code>对象中了。</p>
<p>因此为了弄清真实的错误，我们需要转换<code>ParseWithClaims()</code>函数返回的错误，使它成为<code>jwt.ValidationError</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(maker *JWTMaker)</span> <span class="title">VerifyToken</span><span class="params">(token <span class="keyword">string</span>)</span> <span class="params">(*Payload, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    jwtToken, err := jwt.ParseWithClaims(token, &amp;Payload&#123;&#125;, keyFunc)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        verr, ok := err.(*jwt.ValidationError)</span><br><span class="line">        <span class="keyword">if</span> ok &amp;&amp; errors.Is(verr.Inner, ErrExpiredToken) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrExpiredToken</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrInvalidToken</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们这里将转换后的err赋值给<code>verr</code>变量，如果转换成功，<a target="_blank" rel="noopener" href="http://xn--errors-hz8ig3bo82im51b.Is">我们使用errors.Is</a>()函数来检查<code>verr.Inner</code>是否是<code>ErrExpiredToken</code>。如果是的话，我们返回一个空的payload和过期错误，否则我们返回token非法错误。</p>
<p>如果一切都是正常，并且token也成功解析和验证，我们会尝试获取它的payload信息，通过将<code>jwtToken.Claims</code>转换为一个payload对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(maker *JWTMaker)</span> <span class="title">VerifyToken</span><span class="params">(token <span class="keyword">string</span>)</span> <span class="params">(*Payload, error)</span></span> &#123;</span><br><span class="line">    keyFunc := <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">        _, ok := token.Method.(*jwt.SigningMethodHMAC)</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrInvalidToken</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">byte</span>(maker.secretKey), <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jwtToken, err := jwt.ParseWithClaims(token, &amp;Payload&#123;&#125;, keyFunc)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        verr, ok := err.(*jwt.ValidationError)</span><br><span class="line">        <span class="keyword">if</span> ok &amp;&amp; errors.Is(verr.Inner, ErrExpiredToken) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, ErrExpiredToken</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrInvalidToken</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    payload, ok := jwtToken.Claims.(*Payload)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrInvalidToken</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试JWT-Maker">测试JWT Maker</h3>
<p>在token包下面创建一个新的文件<code>jwt_maker_test.go</code>我们对这个maker进行测试。</p>
<p>首先我们调用<code>NewJWTMaker()</code>函数并且传入一个随机的密钥。我们require一个Noerror。接着我们用util.RandomOwner()生成一个username，并且将token的生命周期设置为1分钟。</p>
<p>我们声明两个变量来比较最后的结果：</p>
<ul>
<li><code>issueAt</code>时间应当是`time.Now(0</li>
<li>在这个基础上加上<code>duration</code>就可以得到我们的截止时间</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJWTMaker</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    maker, err := NewJWTMaker(util.RandomString(<span class="number">32</span>))</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    username := util.RandomOwner()</span><br><span class="line">    duration := time.Minute</span><br><span class="line"></span><br><span class="line">    issuedAt := time.Now()</span><br><span class="line">    expiredAt := issuedAt.Add(duration)</span><br><span class="line"></span><br><span class="line">    token, err := maker.CreateToken(username, duration)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    require.NotEmpty(t, token)</span><br><span class="line"></span><br><span class="line">    payload, err := maker.VerifyToken(token)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line">    require.NotEmpty(t, token)</span><br><span class="line"></span><br><span class="line">    require.NotZero(t, payload.ID)</span><br><span class="line">    require.Equal(t, username, payload.Username)</span><br><span class="line">    require.WithinDuration(t, issuedAt, payload.IssuedAt, time.Second)</span><br><span class="line">    require.WithinDuration(t, expiredAt, payload.ExpiredAt, time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在测试中我们先生成token，然后调用token验证来确保token合法并且返回payload信息。最后我们再一一检查payload中的各个字段。然后我们就可以运行这个单元测试了。</p>
<p>接下来我们需要增加一个测试用于过期token。和之前类似，我们首先创建一个新的JWTMaker，然后创建一个过期token，传入一个username和负的duration就可以了。</p>
<p>我们最后还需要验证一下非法的token，其中算法头部是None。这在上一节中说过，是一个著名的攻击技术。首先我们创建一个新的payload，然后我们创建一个新的token。然后我们要使用<code>SignedString()</code>注册token。但是这里我们不能再使用随机密钥了，因为jwt-go包中已经完全禁止使用<code>None</code>算法去注册token。我们只能在传入指定常量的时候对他做测试：<code>jwt.UnsafeAllowNoneSignatureType</code>。</p>
<p>如果你遵循这个值的实现，你可以看到通常不允许使用无符号方法，除非输入键是这个特殊的常量。这意味着你知道你在干什么。确保你只在测试的时候这样用！</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestInvalidJWTTokenAlgNone</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    payload, err := NewPayload(util.RandomOwner(), time.Minute)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    jwtToken := jwt.NewWithClaims(jwt.SigningMethodNone, payload)</span><br><span class="line">    token, err := jwtToken.SignedString(jwt.UnsafeAllowNoneSignatureType)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    maker, err := NewJWTMaker(util.RandomString(<span class="number">32</span>))</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    payload, err = maker.VerifyToken(token)</span><br><span class="line">    require.Error(t, err)</span><br><span class="line">    require.EqualError(t, err, ErrInvalidToken.Error())</span><br><span class="line">    require.Nil(t, payload)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现PASETO-Maker">实现PASETO Maker</h3>
<p>接下来我们使用相同的token maker接口来实现PASETO。我们去到<a target="_blank" rel="noopener" href="https://github.com/o1egl/paseto">paseto golang github page</a>,使用go get获取这个包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/o1egl/paseto</span><br></pre></td></tr></table></figure>
<p>接着我回到项目中，创建一个<code>paseto_maker.go</code>文件在<code>token</code>包中，与我们刚才做的类似，我们声明一个<code>PasetoMaker</code>结构体，用于实现相同的<code>token.Maker</code>接口。我们在这里会使用paseto的版本2，所以该结构体中应当有一个指定版本的字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PasetoMaker <span class="keyword">struct</span> &#123;</span><br><span class="line">    paseto       *paseto.V2</span><br><span class="line">    symmetricKey []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们只是想在银行api内部使用token，我们将会使用对称加密方法对token payload进行加密，因此我们需要symmetricKey字段存储密钥。</p>
<p>接下来我们增加一个函数，<code>NewPasetoMaker</code>创建一个新的PasetoMaker实例。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPasetoMaker</span><span class="params">(symmetricKey <span class="keyword">string</span>)</span> <span class="params">(Maker, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(symmetricKey) != chacha20poly1305.KeySize &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;invalid key size: must be exactly %d characters&quot;</span>, chacha20poly1305.KeySize)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    maker := &amp;PasetoMaker&#123;</span><br><span class="line">        paseto:       paseto.NewV2(),</span><br><span class="line">        symmetricKey: []<span class="keyword">byte</span>(symmetricKey),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maker, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为version2使用的是<code>Chacha20 Poly1305</code>算法来加密，所以我们需要在函数中先检查对称密钥的长度。</p>
<p>同样我们发现在返回的maker下面有红线提示错误，这是因为我们还没有实现<code>token.Maker</code>接口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(maker *PasetoMaker)</span> <span class="title">CreateToken</span><span class="params">(username <span class="keyword">string</span>, duration time.Duration)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(maker *PasetoMaker)</span> <span class="title">VerifyToken</span><span class="params">(token <span class="keyword">string</span>)</span> <span class="params">(*Payload, error)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现paseto-CreateToken方法">实现paseto CreateToken方法</h3>
<p>我们首先需要去创建一个新的<code>payload</code>用<code>username</code>和<code>duration</code>。然后我们返回<code>maker.paseto.Encrypt()</code>并且传入我们的密钥和payload对象。最后一个参数是可选的footer部分，我们不需要，所以设置为nil。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(maker *PasetoMaker)</span> <span class="title">CreateToken</span><span class="params">(username <span class="keyword">string</span>, duration time.Duration)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">    payload, err := NewPayload(username, duration)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maker.paseto.Encrypt(maker.symmetricKey, payload, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现paseto-VerifyToken-方法">实现paseto VerifyToken 方法</h3>
<p>我们只需要定义一个空的payload，然后调用decrypt来解密token就可以了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(maker *PasetoMaker)</span> <span class="title">VerifyToken</span><span class="params">(token <span class="keyword">string</span>)</span> <span class="params">(*Payload, error)</span></span> &#123;</span><br><span class="line">    payload := &amp;Payload&#123;&#125;</span><br><span class="line"></span><br><span class="line">    err := maker.paseto.Decrypt(token, maker.symmetricKey, payload, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrInvalidToken</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = payload.Valid()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个的测试和前面是相同的，因为他们是同样的接口。</p>
<h2 id="实现用户登录API，返回PASETO或者JWT通行证">实现用户登录API，返回PASETO或者JWT通行证</h2>
<h3 id="将token-maker添加到服务器">将token maker添加到服务器</h3>
<p>我们打开<code>api.server.go</code>文件，在其中的Server结构体中增加一个<code>tokenMaker</code>字段。然后我们在<code>NewServer()</code>中对这个字段进行初始化。我们这里选用PASETO作为我们的token maker。这需要调用<code>token.NewPasetoMaker()</code>，他需要一个对称密钥字符串作为输入，所以我们需要加载环境变量。目前的话我们可以先放一个空字符串在这里占个位置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(store db.Store)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line">    tokenMaker, err := token.NewPasetoMaker(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;cannot create token maker: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server := &amp;Server&#123;</span><br><span class="line">        store:      store,</span><br><span class="line">        tokenMaker: tokenMaker,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> server, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们需要增加一个环境变量到<code>app.env</code>里面，我们把他命名为<code>TOKEN_SYMMETRIC_KEY</code>。由于我们用的paseto v2,这个密钥的长度应该为32。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TOKEN_SYMMETRIC_KEY=12345678901234567890123456789012</span><br><span class="line">ACCESS_TOKEN_DURATION=15m</span><br></pre></td></tr></table></figure>
<p>此外我们还加入了一个控制token的生命周期的变量，我们设置它为15min。接下来我们需要更新我们的config结构体来包含我们刚刚增加的两个变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    TokenSymmetricKey   <span class="keyword">string</span>        <span class="string">`mapstructure:&quot;TOKEN_SYMMETRIC_KEY&quot;`</span></span><br><span class="line">    AccessTokenDuration time.Duration <span class="string">`mapstructure:&quot;ACCESS_TOKEN_DURATION&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，我们定义time.Duration类型的环境变量的时候可以用我们人类方便理解的15m作为duration。</p>
<p>然后我们需要在<code>NewServer()</code>中增加一个参数config，用它来加载我们的环境变量。我们同样需要将这个config字段增加到Server结构体中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    config     util.Config</span><br><span class="line">    store      db.Store</span><br><span class="line">    tokenMaker token.Maker</span><br><span class="line">    router     *gin.Engine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(config util.Config, store db.Store)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line">    tokenMaker, err := token.NewPasetoMaker(config.TokenSymmetricKey)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;cannot create token maker: %w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server := &amp;Server&#123;</span><br><span class="line">        config:     config,</span><br><span class="line">        store:      store,</span><br><span class="line">        tokenMaker: tokenMaker,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class="line">        v.RegisterValidation(<span class="string">&quot;currency&quot;</span>, validCurrency)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.setupRouter()</span><br><span class="line">    <span class="keyword">return</span> server, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里由于我们改变了这个函数的输入输出，所以我们需要对之前的单元测试中用到这个函数的地方进行修改。</p>
<h3 id="修复受影响的单元测试">修复受影响的单元测试</h3>
<p>在<code>api/main_test.go</code>文件中，我们要定义一个函数<code>newTestServer()</code>，它会创建一个新的server用于测试。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newTestServer</span><span class="params">(t *testing.T, store db.Store)</span> *<span class="title">Server</span></span> &#123;</span><br><span class="line">    config := util.Config&#123;</span><br><span class="line">        TokenSymmetricKey:   util.RandomString(<span class="number">32</span>),</span><br><span class="line">        AccessTokenDuration: time.Minute,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server, err := NewServer(config, store)</span><br><span class="line">    require.NoError(t, err)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> server</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们去到<code>api/transfer_test.go</code>文件中，这里我们将<code>NewServer()</code>换成<code>newTestServer()</code>。其他测试文件中我们也做同样的修改。</p>
<p>但是还有一个非常重要的地方我们要去更新，服务器的主入口<code>main.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    config, err := util.LoadConfig(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot load config:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    conn, err := sql.Open(config.DBDriver, config.DBSource)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot connect to db:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    store := db.NewStore(conn)</span><br><span class="line">    server, err := api.NewServer(config, store)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot create server:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = server.Start(config.ServerAddress)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;cannot start server:&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现login-user的handler">实现login user的handler</h3>
<p>打开<code>api/user.go</code>文件，login api必须要包含用户名和密码，这和创建user的api相类似。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> loginUserRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    Username <span class="keyword">string</span> <span class="string">`json:&quot;username&quot; binding:&quot;required,alphanum&quot;`</span></span><br><span class="line">    Password <span class="keyword">string</span> <span class="string">`json:&quot;password&quot; binding:&quot;required,min=6&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们需要定义这个api的返回结构体，其中最重要的应该是<code>AccessToken</code>字符串</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> loginUserResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">    AccessToken <span class="keyword">string</span>       <span class="string">`json:&quot;access_token&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，我们还希望能够返回一部分登陆账户的相关信息，就像我们创建用户api中返回的那样。为了能将这个结构体进行重用，我们将它的名字改为<code>userResponse</code>，它会作为我们login api返回结构体中的一个字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> userResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">    Username          <span class="keyword">string</span>    <span class="string">`json:&quot;username&quot;`</span></span><br><span class="line">    FullName          <span class="keyword">string</span>    <span class="string">`json:&quot;full_name&quot;`</span></span><br><span class="line">    Email             <span class="keyword">string</span>    <span class="string">`json:&quot;email&quot;`</span></span><br><span class="line">    PasswordChangedAt time.Time <span class="string">`json:&quot;password_changed_at&quot;`</span></span><br><span class="line">    CreatedAt         time.Time <span class="string">`json:&quot;created_at&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loginUserResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">    AccessToken <span class="keyword">string</span>       <span class="string">`json:&quot;access_token&quot;`</span></span><br><span class="line">    User        userResponse <span class="string">`json:&quot;user&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们从<code>createUser()</code>的handler中复制出来，并且定义一个<code>newUserResponse()</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newUserResponse</span><span class="params">(user db.User)</span> <span class="title">userResponse</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userResponse&#123;</span><br><span class="line">        Username:          user.Username,</span><br><span class="line">        FullName:          user.FullName,</span><br><span class="line">        Email:             user.Email,</span><br><span class="line">        PasswordChangedAt: user.PasswordChangedAt,</span><br><span class="line">        CreatedAt:         user.CreatedAt,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的作用是将输入的<code>db.User</code>转换为<code>userResponse</code>。这样做的原因是在<code>db.User</code>结构体中的部分信息比较敏感的数据<code>hashed_password</code>，这是我们不希望暴露给客户端的。</p>
<p>所以在<code>createUser()</code>的handler中，我们能够只调用<code>newUserResponse()</code>函数来创建返回对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">createUser</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    user, err := server.store.CreateUser(ctx, arg)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    rsp := newUserResponse(user)</span><br><span class="line">    ctx.JSON(http.StatusOK, rsp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数同样对物品们的loginUser()的handler也有用。现在我们给服务器结构体:<code>loginUser()</code>,和其他的API handler相类似，这个函数以gin.Contest()作为输入。在里面，我们声明了一个<code>request</code>对象，并且我们调用<code>ctx.ShouldBindJSON</code>函数。这会绑定API的所有输入参数到<code>request</code>对象中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">loginUser</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> req loginUserRequest</span><br><span class="line">    <span class="keyword">if</span> err := ctx.ShouldBindJSON(&amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx.JSON(http.StatusBadRequest, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有错误的话，我们将要在数据库中查找这个用户。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">loginUser</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    user, err := server.store.GetUser(ctx, req.Username)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err == sql.ErrNoRows &#123;</span><br><span class="line">            ctx.JSON(http.StatusNotFound, errorResponse(err))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一切正常的话，我们就需要检查客户端提供的密码是正确的还是错误的。因此我们调用函数来检查密码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">loginUser</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    err = util.CheckPassword(req.Password, user.HashedPassword)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx.JSON(http.StatusUnauthorized, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有当密码正确的时候我们彩绘创建一个通行令牌。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">loginUser</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    accessToken, err := server.tokenMaker.CreateToken(</span><br><span class="line">        user.Username,</span><br><span class="line">        server.config.AccessTokenDuration,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        ctx.JSON(http.StatusInternalServerError, errorResponse(err))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rsp := loginUserResponse&#123;</span><br><span class="line">        AccessToken: accessToken,</span><br><span class="line">        User:        newUserResponse(user),</span><br><span class="line">    &#125;</span><br><span class="line">    ctx.JSON(http.StatusOK, rsp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们处理login接口的handler就写好了。</p>
<h3 id="将login-api的route添加到服务器上">将login api的route添加到服务器上</h3>
<p>我们接下来需要将一个新的终端添加到服务器上，并且以loginUser()作为handler。我将会把它放到创建用户的route旁边。所以<code>route.POST()</code>，路径应当为<code>/user/login</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewServer</span><span class="params">(config util.Config, store db.Store)</span> <span class="params">(*Server, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    router.POST(<span class="string">&quot;/users&quot;</span>, server.createUser)</span><br><span class="line">    router.POST(<span class="string">&quot;/users/login&quot;</span>, server.loginUser)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以了。但是<code>NewServer()</code>函数太常了，这使得它很难阅读，所以我们要把它的功能部分分开。把路径设置部分单独拿出来做成<code>setupRouter()</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(server *Server)</span> <span class="title">setupRouter</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line"></span><br><span class="line">    router.POST(<span class="string">&quot;/users&quot;</span>, server.createUser)</span><br><span class="line">    router.POST(<span class="string">&quot;/users/login&quot;</span>, server.loginUser)</span><br><span class="line"></span><br><span class="line">    router.POST(<span class="string">&quot;/accounts&quot;</span>, server.createAccount)</span><br><span class="line">    router.GET(<span class="string">&quot;/accounts/:id&quot;</span>, server.getAccount)</span><br><span class="line">    router.GET(<span class="string">&quot;/accounts&quot;</span>, server.listAccounts)</span><br><span class="line"></span><br><span class="line">    router.POST(<span class="string">&quot;/transfers&quot;</span>, server.createTransfer)</span><br><span class="line"></span><br><span class="line">    server.router = router</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现验证中间件和授权规则">实现验证中间件和授权规则</h2>
<p>目前为止我们的API都可以让任何人调用，不需要验证身份信息，这样做显然是不安全的。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/sql-docker/" rel="tag"># sql,docker</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/01/26/%E5%88%A9%E7%94%A8GPU%E8%BF%9B%E8%A1%8C%E8%AE%AD%E7%BB%83%E7%9A%84%E6%96%B9%E6%B3%95/" rel="prev" title="利用GPU进行训练的方法">
                  <i class="fa fa-chevron-left"></i> 利用GPU进行训练的方法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/16/%E4%BD%BF%E7%94%A8ssh%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9/" rel="next" title="使用ssh传输文件/文件夹">
                  使用ssh传输文件/文件夹 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weirdo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"weirdoblog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
