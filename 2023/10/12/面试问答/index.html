<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="-jCet6qPD7nML4-W6IY2HZwfSblJyWta_Jx7_AGHgIk">
  <meta name="baidu-site-verification" content="f349dc627a72ee616d62ed513574025d">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/orange/pace-theme-center-circle.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"weirdozz.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="设计模式三大分类创建型模式 单例模式：一个类只有一个实例，并且提供一个访问该实例的全局节点  实现方式：默认构造函数设为私有；新建一个静态构建方法作为构造函数；首次调用时创建新对象，并存储，之后的调用都返回存储的对象； 生成器模式：能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。  优点: 对于成员变量较多的类，无需在构造函数中全部列出，而是用那些初始化哪些  实">
<meta property="og:type" content="article">
<meta property="og:title" content="面试问答">
<meta property="og:url" content="https://weirdozz.github.io/2023/10/12/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/index.html">
<meta property="og:site_name" content="Weirdo">
<meta property="og:description" content="设计模式三大分类创建型模式 单例模式：一个类只有一个实例，并且提供一个访问该实例的全局节点  实现方式：默认构造函数设为私有；新建一个静态构建方法作为构造函数；首次调用时创建新对象，并存储，之后的调用都返回存储的对象； 生成器模式：能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。  优点: 对于成员变量较多的类，无需在构造函数中全部列出，而是用那些初始化哪些  实">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-12T03:46:47.000Z">
<meta property="article:modified_time" content="2024-01-05T09:09:03.746Z">
<meta property="article:author" content="Weirdo">
<meta property="article:tag" content="WeirdoBlog">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://weirdozz.github.io/2023/10/12/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://weirdozz.github.io/2023/10/12/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/","path":"2023/10/12/面试问答/","title":"面试问答"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>面试问答 | Weirdo</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Weirdo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-movies"><a href="/movies/" rel="section"><i class="fa fa-film fa-fw"></i>电影</a></li>
        <li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书籍</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">三大分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">创建型模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.2.</span> <span class="nav-text">结构型模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.3.</span> <span class="nav-text">行为模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">2.1.</span> <span class="nav-text">类加载过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99"><span class="nav-number">2.2.</span> <span class="nav-text">加载规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%B1%BB%E5%88%AB"><span class="nav-number">2.3.</span> <span class="nav-text">加载器类别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.4.</span> <span class="nav-text">双亲委派模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">新生代和老年代的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3"><span class="nav-number">3.1.</span> <span class="nav-text">新生代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">3.2.</span> <span class="nav-text">老年代</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">标记算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">三色标记算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%A0%87%E4%B8%8E%E6%BC%8F%E6%A0%87"><span class="nav-number">4.4.</span> <span class="nav-text">多标与漏标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BC%8F%E6%A0%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">4.5.</span> <span class="nav-text">漏标解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">4.5.1.</span> <span class="nav-text">CMS解决方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">数据库存储过程和触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">5.1.</span> <span class="nav-text">存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">5.2.</span> <span class="nav-text">触发器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E9%94%81"><span class="nav-number">6.</span> <span class="nav-text">线程安全和锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">6.1.</span> <span class="nav-text">线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">6.1.1.</span> <span class="nav-text">实现方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E4%BC%98%E5%8C%96"><span class="nav-number">6.2.</span> <span class="nav-text">锁优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">7.</span> <span class="nav-text">红黑树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">加密算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-number">8.1.</span> <span class="nav-text">对称加密算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-number">8.2.</span> <span class="nav-text">非对称加密算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%BE%E5%90%8D%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.</span> <span class="nav-text">签名加密算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MD5"><span class="nav-number">8.3.1.</span> <span class="nav-text">MD5</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SHA1"><span class="nav-number">8.3.2.</span> <span class="nav-text">SHA1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HMAC%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.3.</span> <span class="nav-text">HMAC算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RSA%E7%AE%97%E6%B3%95"><span class="nav-number">8.3.4.</span> <span class="nav-text">RSA算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1"><span class="nav-number">9.</span> <span class="nav-text">TCP建立连接为什么要三次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">10.</span> <span class="nav-text">应用层协议有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%AE%E4%BB%B6%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">11.</span> <span class="nav-text">邮件的正则表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#xml%E8%BD%ACjson"><span class="nav-number">12.</span> <span class="nav-text">xml转json</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%8C%96sql%EF%BC%8C%E8%AE%A9%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E8%B5%B0%E7%B4%A2%E5%BC%95"><span class="nav-number">13.</span> <span class="nav-text">优化sql，让模糊查询走索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">14.</span> <span class="nav-text">启动线程的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC%E5%8C%85-java-util-concurrent"><span class="nav-number">15.</span> <span class="nav-text">JUC包(java.util.concurrent)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">16.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">16.1.</span> <span class="nav-text">数据类型和使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">16.1.1.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">16.2.</span> <span class="nav-text">Redis线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">16.3.</span> <span class="nav-text">Redis持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E9%9B%86%E7%BE%A4"><span class="nav-number">16.4.</span> <span class="nav-text">Redis集群</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="nav-number">16.4.1.</span> <span class="nav-text">如何实现服务高可用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">16.5.</span> <span class="nav-text">如何避免缓存雪崩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">16.6.</span> <span class="nav-text">如何避免缓存击穿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E5%8A%A8%E6%80%81%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="nav-number">16.7.</span> <span class="nav-text">热点数据动态缓存策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E9%80%89%E5%8F%96%E6%96%B0%E7%9A%84master%E7%9A%84%E6%A0%87%E5%87%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">16.8.</span> <span class="nav-text">故障转移选取新的master的标准是什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98"><span class="nav-number">17.</span> <span class="nav-text">分布式问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E6%BB%A1%E8%B6%B3%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">17.1.</span> <span class="nav-text">需要满足的特性</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Weirdo"
      src="/images/weirdo.jpg">
  <p class="site-author-name" itemprop="name">Weirdo</p>
  <div class="site-description" itemprop="description">怕什么真理无穷，进一步有进一步的欢喜</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weirdozz.github.io/2023/10/12/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/weirdo.jpg">
      <meta itemprop="name" content="Weirdo">
      <meta itemprop="description" content="怕什么真理无穷，进一步有进一步的欢喜">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Weirdo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试问答
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-12 11:46:47" itemprop="dateCreated datePublished" datetime="2023-10-12T11:46:47+08:00">2023-10-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-05 17:09:03" itemprop="dateModified" datetime="2024-01-05T17:09:03+08:00">2024-01-05</time>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2023/10/12/%E9%9D%A2%E8%AF%95%E9%97%AE%E7%AD%94/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/10/12/面试问答/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="三大分类"><a href="#三大分类" class="headerlink" title="三大分类"></a>三大分类</h3><h4 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h4><ul>
<li>单例模式：一个类只有一个实例，并且提供一个访问该实例的全局节点<br>  实现方式：默认构造函数设为私有；新建一个静态构建方法作为构造函数；首次调用时创建新对象，并存储，之后的调用都返回存储的对象；</li>
<li>生成器模式：能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。<br>  优点: 对于成员变量较多的类，无需在构造函数中全部列出，而是用那些初始化哪些<br>  实现方式：其实就和@Builder的原理一样</li>
<li>工厂方法模式：定义一个创建对象的抽象方法，由子类决定要实例化的类。<br>  优点：新增功能的时候，只需要新建一个类，让这个类自己决定要实例化哪些类<br>  缺点：每个产品都要有一个对应的创建类，太多冗余了<br>  实现方式：让所有产品都实现同一个接口；创建类中添加空的工厂方法，返回类型为产品的接口；为每个产品写一个创建者子类；</li>
<li>抽象工厂模式：能创建一系列相关对象，无需指定其具体类<br>  优点：同一工厂类的产品互相匹配<br>  缺点：需要引入众多的接口<br>  实现方式：对所有产品声明接口（椅子，桌子）；所有的该产品变体实现这个接口（红木椅子，桃木椅子，红木桌子，桃木桌子）；声明抽象工厂，包含所有产品创建的方法，返回值为接口类型（造椅子，造桌子）；变体产品的工厂类继承抽象工厂（桃木工厂，红木工厂）；</li>
<li>原型模式：使你能够复制已有对象， 而又无需使代码依赖它们所属的类。<br>  实现方式：将对象实现一个克隆接口，将克隆的过程交给该对象本身进行</li>
</ul>
<span id="more"></span>

<h4 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h4><ul>
<li>适配器模式：使接口不兼容的对象能够相互合作。<br>  实现方式：声明客户端接口，描述客户端如何与服务交互；创建遵循客户端接口的适配器类；类中添加一个成员变量保存对于服务对象的引用；适配器的方法中将实际的服务内容由服务对象执行，自己只负责转换数据格式。</li>
<li>桥接模式：将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。</li>
<li>装饰模式：将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。<br>  实现方式：找出基本组件和可选层次的通用方法。 创建一个组件接口并在其中声明这些方法；创建一个具体组件类， 并定义其基础行为；创建装饰基类， 使用一个成员变量存储指向被封装对象的引用；将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为；</li>
</ul>
<h4 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h4><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>加载 $\rightarrow$ 连接 $\rightarrow$ 初始化。其中连接分为三步：验证 $\rightarrow$ 准备 $\rightarrow$ 解析。</p>
<p>加载主要完成三件事：</p>
<ol>
<li>通过全类名获取类的二进制字节流</li>
<li>将字节流代表的静态存储结构转换为方法区运行时的数据结构</li>
<li>内存中生成一个该类对象，作为其中方法的访问入口</li>
</ol>
<h3 id="加载规则"><a href="#加载规则" class="headerlink" title="加载规则"></a>加载规则</h3><p>对于已经加载的类会被放在 ClassLoader 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</p>
<h3 id="加载器类别"><a href="#加载器类别" class="headerlink" title="加载器类别"></a>加载器类别</h3><ul>
<li>BootstrapClassLoader(启动类加载器)：加载lib下的包和类。顶层加载器，没有父级，加载JDK内部核心类库</li>
<li>ExternalClassLoader(扩展类加载器)：加载lib&#x2F;ext下的包和类</li>
<li>AppClassLoader(应用程序类加载器)：加载用户的类</li>
</ul>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul>
<li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li>
<li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 loadClass()方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 BootstrapClassLoader 中。</li>
<li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 findClass() 方法来加载类）。</li>
<li>如果子类加载器也无法加载这个类，那么它会抛出一个 ClassNotFoundException 异常。</li>
</ul>
<p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p>
<h2 id="新生代和老年代的区别"><a href="#新生代和老年代的区别" class="headerlink" title="新生代和老年代的区别"></a>新生代和老年代的区别</h2><p>在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old)。新生代 ( Young ) 又被划分为三个区域：Eden、S0、S1。 这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。</p>
<h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>特点是产生大量的死亡对象,并且要是产生连续可用的空间, 所以使用复制清除算法和并行收集器进行垃圾回收.对年轻代的垃圾回收称作初级回收 (minor gc)。</p>
<p>初级回收将年轻代分为三个区域, 一个新生代 , 2个大小相同的复活代, 应用程序只能使用一个新生代和一个复活代, 当发生初级垃圾回收的时候,gc挂起程序, 然后将新生代和复活代中的存活对象复制到另外一个非活动的复活代中,然后一次性清除新生代和复活代，将原来的非复活代标记成为活动复活代。将在指定次数回收后仍然存在的对象移动到老年代中，初级回收后，得到一个空的可用的新生代。</p>
<h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。</p>
<h2 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h2><h3 id="计数法"><a href="#计数法" class="headerlink" title="计数法"></a>计数法</h3><p>每个对象都有一个计数器，被引用了加一，移除引用减一。但这种方法比较麻烦，而且也会有循环依赖的问题，因此并不被广泛使用。第二种是根可达算法，即以 GCRoots 为基础去扫描整个引用链，从而找到所有的可达对象，那剩下的其他对象就是不可达的垃圾对象了。</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>这种实现方案分为两个阶段，分别是：标记阶段、清除阶段。在标记阶段，它从 GCRoots 节点开始扫描整个引用链，找到所有可达的对象。在清除阶段，扫描整个引用链的不可达对象，然后将垃圾对象清除掉。</p>
<p>但这种方式有一个很大的缺点：整个过程必须「Stop the World」。这就导致整个应用程序必须停止，不能做任何改变，这是非常不友好的。 CMS 回收器出现之前的所有回收器，都是用这种方式实现的，因此 GC 停顿时间都比轿长。</p>
<h3 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h3><p>三色标记算法指的是将所有对象分为白色、黑色和灰色三种类型。黑色表示从 GCRoots 开始，已扫描过它全部引用的对象，灰色指的是扫描过对象本身，还没完全扫描过它全部引用的对象，白色指的是还没扫描过的对象。</p>
<ul>
<li>初始标记阶段，指的是标记 GCRoots 直接引用的节点，将它们标记为灰色，这个阶段需要 「Stop the World」。</li>
<li>并发标记阶段，指的是从灰色节点开始，去扫描整个引用链，然后将它们标记为黑色，这个阶段不需要「Stop the World」。</li>
<li>重新标记阶段，指的是去校正并发标记阶段的错误，这个阶段需要「Stop the World」。</li>
<li>并发清除，指的是将已经确定为垃圾的对象清除掉，这个阶段不需要「Stop the World」。</li>
</ul>
<h3 id="多标与漏标"><a href="#多标与漏标" class="headerlink" title="多标与漏标"></a>多标与漏标</h3><p>多标问题指的是原本应该回收的对象，被多余地标记为黑色存活对象，从而导致该垃圾对象没有被回收。 多标问题会出现，是因为在并发标记阶段，有可能之前已经被标记为存活的对象，其引用被删除，从而变成了不可达对象。</p>
<p>漏标问题指的是原本应该被标记为存活的对象，被遗漏标记为黑色，从而导致该垃圾对象被错误回收。</p>
<p>漏标问题就非常严重了，其会导致存活对象被回收，会严重影响程序功能。</p>
<p>那么我们的垃圾回收器是怎么解决这个问题的呢？</p>
<p>答案是：增加一个「重新标记」阶段。无论是在 CMS 回收器还是 G1 回收器，它们都在并发标记阶段之后，新增了一个「重新标记」阶段来校正「并发标记」阶段出现的问题。</p>
<h3 id="漏标解决方案"><a href="#漏标解决方案" class="headerlink" title="漏标解决方案"></a>漏标解决方案</h3><h4 id="CMS解决方案"><a href="#CMS解决方案" class="headerlink" title="CMS解决方案"></a>CMS解决方案</h4><p>既然有黑色对象在自己标记后，又重新指向了白色对象。那么我就把这个黑色对象的引用记录下来，在后续「重新标记」阶段再以这个黑色对象为根，对其引用进行重新扫描。通过这种方式，被黑色对象引用的白色对象就会变成灰色，从而变为存活状态。</p>
<p>既然灰色对象在扫描完成前删除了对白色对象的引用，那么我是否能在灰色对象取消引用之前，先将灰色对象引用的白色对象记录下来。随后在「重新标记」阶段再以白色对象为根，对它的引用进行扫描，从而避免了漏标的问题。通过这种方式，原本漏标的对象就会被重新扫描变成灰色，从而变为存活状态。</p>
<h2 id="数据库存储过程和触发器"><a href="#数据库存储过程和触发器" class="headerlink" title="数据库存储过程和触发器"></a>数据库存储过程和触发器</h2><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用 “CALL 存储过程名字” 即可自动完成</p>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>MySQL 的触发器和存储过程一样，都是嵌入到 MySQL 中的一段程序，是 MySQL 中管理数据的有力工具。不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行不需要使用 CALL 语句来调用，也不需要手工启动，而是通过对数据表的相关操作来触发、激活从而实现执行。比如当对 student 表进行操作（INSERT，DELETE 或 UPDATE）时就会激活它执行。</p>
<h2 id="线程安全和锁"><a href="#线程安全和锁" class="headerlink" title="线程安全和锁"></a>线程安全和锁</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul>
<li>不可变对象一定线程安全</li>
<li>绝对线程安全：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象是线程安全的。</li>
<li>相对线程安全：是通常意义上的线程安全，它需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保证措施。</li>
<li>线程兼容：线程兼容是指对象本身不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中是可以安全使用的。Java API中的大部分的类都是属于线程兼容的，如ArrayList和HashMap等。</li>
<li>线程对立：线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中使用的代码。</li>
</ul>
<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><ul>
<li>互斥同步：互斥同步是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。</li>
<li>非阻塞同步：一种基于冲突检测的乐观并发策略的同步操作：先进行操作，如果没有其他线程争用共享数据，那操作就成功；如果共享数据有争用，产生了冲突，就在采取其他的补偿措施（比如不断的重试，直到成功）。这种乐观并发策略的很多实现都不需要把线程挂起，因此称为非阻塞同步。</li>
</ul>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><ul>
<li>自适应自旋：互斥同步最大的性能问题在于阻塞，线程的阻塞与唤醒需要内核态参与。因此，加入自旋（忙循环），即让线程不挂起，而执行一段无操作循环，等待有锁线程释放锁。利用自适应自旋，通过前一次在同一锁上的自旋时间接锁的拥有者状态决定自旋时间。</li>
<li>锁消除：虚拟机（JVM）即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判断依据来源于逃逸分析的数据支持。</li>
<li>锁粗化：原则上需要将同步块的作用方位限制得尽量小——只在共享数据的实际作用域进行同步。但如果一系列连续操作都对同一个对象反复加锁和解锁，甚至加锁出现在循环体中，频繁进行互斥同步操作会导致不必要的性能消耗。因此，可以将加锁同步的范围扩展（粗化）到整个操作序列外部。</li>
<li>轻量级锁：相对于传统锁机制而言，其本意是在没有多线程竞争的前提下，减少传统的重量级锁使用系统互斥量产生的性能消耗。</li>
</ul>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>又称为 共享密钥加密算法。在 对称加密算法 中，使用的密钥只有一个，发送 和 接收 双方都使用这个密钥对数据进行 加密 和 解密。</p>
<h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><p>又称为 公开密钥加密算法。它需要两个密钥，一个称为 公开密钥 (public key)，即 公钥，另一个称为 私有密钥 (private key)，即 私钥。</p>
<h3 id="签名加密算法"><a href="#签名加密算法" class="headerlink" title="签名加密算法"></a>签名加密算法</h3><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><p>MD5 用的是 哈希函数，它的典型应用是对一段信息产生 信息摘要，以 防止被篡改。严格来说，MD5 不是一种 加密算法 而是 摘要算法。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串</p>
<h4 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h4><p>SHA1 是和 MD5 一样流行的 消息摘要算法，然而 SHA1 比 MD5 的 安全性更强。对于长度小于 2 ^ 64 位的消息，SHA1 会产生一个 160 位的 消息摘要。基于 MD5、SHA1 的信息摘要特性以及 不可逆 (一般而言)，可以被应用在检查 文件完整性 以及 数字签名 等场景。</p>
<h4 id="HMAC算法"><a href="#HMAC算法" class="headerlink" title="HMAC算法"></a>HMAC算法</h4><p>HMAC 是密钥相关的 哈希运算消息认证码（Hash-based Message Authentication Code），HMAC 运算利用 哈希算法 (MD5、SHA1 等)，以 一个密钥 和 一个消息 为输入，生成一个 消息摘要 作为 输出。</p>
<p>HMAC 发送方 和 接收方 都有的 key 进行计算，而没有这把 key 的第三方，则是 无法计算 出正确的 散列值的，这样就可以 防止数据被篡改。</p>
<h4 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h4><p>RSA 是第一个能同时用于 加密 和 数字签名 的算法，它能够 抵抗 到目前为止已知的 所有密码攻击，已被 ISO 推荐为公钥数据加密标准。</p>
<p>RSA 加密算法 基于一个十分简单的数论事实：将两个大 素数 相乘十分容易，但想要对其乘积进行 因式分解 却极其困难，因此可以将 乘积 公开作为 加密密钥。</p>
<h2 id="TCP建立连接为什么要三次"><a href="#TCP建立连接为什么要三次" class="headerlink" title="TCP建立连接为什么要三次"></a>TCP建立连接为什么要三次</h2><p>三次握手的目的，是为了防止A端已经失效的连接请求突然又传到B端，被误认为是A端再次发出的一个新的连接请求，如果B端这时又再次向A发出确认报文，表示同意建立连接，就会产生错误。</p>
<p>四次挥手的本质原因是tcp是全双公的，通信是双向的， A到B是一个通道，B到A又是另一个通道。</p>
<p>四次挥手释放连接时，等待2MSL的意义：第 一，为了保证A发送的最有一个ACK报文段能够到达B。第二，就是防止上面提到的已失效的连接请求报文段出现在本连接中。</p>
<h2 id="应用层协议有哪些"><a href="#应用层协议有哪些" class="headerlink" title="应用层协议有哪些"></a>应用层协议有哪些</h2><ol>
<li>DNS(域名系统)：DNS 是互联网使用的命名系统，用来把人们使用的机器名字（域名）转换为 IP 地址。</li>
<li>FTP(文件传输协议)：FTP 是使用得最广泛的文件传送协议。FTP 提供交互式的访问，常用于局域网的文件存储服务器。</li>
<li>Telnet（远程终端协议）： telnet 是一个简单的远程终端协议，结合端口使用，常用于服务探测。</li>
<li>HTTP（超文本传送协议）：HTTP 是面向事务的应用层协议，它是互联网能够可靠地交换文件的重要基础。</li>
<li>SMTP（电子邮件协议）：SMTP 是简单邮件传送协议。SMTP规定了在两个相互通信的 SMTP 进程之间应如何交换信息。</li>
<li>POP3（邮件读取协议）：POP3，全称是 Post Office Protocol 3，该协议通常被用来接收电子邮件。</li>
<li>SNMP（简单网络管理协议）：SNMP 协议由三部分组成，包括：SNMP本身、管理信息结构 SMI 和管理信息 MIB。SNMP 定义了管理站和代理之间所交换的分组格式。SMI 定义了命名对象类型的通用规则，以及把对象和对象的值进行编码。MIB 在被管理的实体中创建了命名对象，并规定类型。</li>
<li>TFTP（简单文件传送协议）：TFTP是TCP&#x2F;IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，它基于UDP协议而实现的，提供不复杂、开销不大的文件传输服务。默认端口号是 69。</li>
</ol>
<h2 id="邮件的正则表达式"><a href="#邮件的正则表达式" class="headerlink" title="邮件的正则表达式"></a>邮件的正则表达式</h2><p>^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+. [a-zA-Z]{2,}$</p>
<h2 id="xml转json"><a href="#xml转json" class="headerlink" title="xml转json"></a>xml转json</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">xmlToJson</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//使用DOM4j</span></span><br><span class="line">        SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        Document read = saxReader.read(<span class="string">&quot;G:\\IDEAProjects\\JavaStudy\\Mooc\\src\\main\\resources\\score.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//使用json的xml转json方法</span></span><br><span class="line">        JSONObject jsonObject = XML.toJSONObject(read.asXML());</span><br><span class="line">        <span class="comment">//设置缩进转为字符串</span></span><br><span class="line">        System.out.println(jsonObject.toString(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">return</span> jsonObject.toString(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化sql，让模糊查询走索引"><a href="#优化sql，让模糊查询走索引" class="headerlink" title="优化sql，让模糊查询走索引"></a>优化sql，让模糊查询走索引</h2><p>%匹配符不能在字符前面</p>
<p>原本语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `<span class="keyword">column</span>` <span class="keyword">FROM</span> `<span class="keyword">table</span>` <span class="keyword">WHERE</span> `field` <span class="keyword">like</span> <span class="string">&#x27;%keyword%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>优化语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `<span class="keyword">column</span>` <span class="keyword">FROM</span> `<span class="keyword">table</span>` <span class="keyword">WHERE</span> `field` <span class="keyword">like</span> <span class="string">&#x27;keyword%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>再优化</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `<span class="keyword">column</span>` <span class="keyword">FROM</span> `<span class="keyword">table</span>` <span class="keyword">WHERE</span> LOCATE(<span class="string">&#x27;keyword&#x27;</span>, `field`)<span class="operator">&gt;</span><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="启动线程的方式"><a href="#启动线程的方式" class="headerlink" title="启动线程的方式"></a>启动线程的方式</h2><ol>
<li>继承Thread类，重写run方法（不推荐）</li>
<li>实现runable接口，或者匿名内部类(new Thread(new Runable(){}))</li>
<li>实现callable接口</li>
<li>创建线程池</li>
</ol>
<h2 id="JUC包-java-util-concurrent"><a href="#JUC包-java-util-concurrent" class="headerlink" title="JUC包(java.util.concurrent)"></a>JUC包(java.util.concurrent)</h2><ol>
<li>locks部分：在java.util.concurrent.locks包中，提供更加强大的显式锁，比如 重入锁ReentrantLock、读写锁ReadWriteLock；</li>
<li>collections部分：在java.util.concurrent包中，提供一系列高性能的并发容器，比如ConcurrentHashMap、CopyOnWriteArrayList等；</li>
<li>atomic部分：在java.util.concurrent.atomic包中，提供原子变量类相关的功能，是构建非阻塞算法CAS的基础，比如AtomicInteger</li>
<li>executor部分：在java.util.concurrent包中，提供线程池相关的功能，用于批量创建、管理线程，比如ThreadPoolExecutor等，以及对线程任务的加强，比如Callable等</li>
<li>tools部分：在java.util.concurrent包中，提供简单高效的同步工具类，如信号量Semaphore、闭锁CountDownLatch、栅栏CyclicBarrier等；</li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="数据类型和使用场景"><a href="#数据类型和使用场景" class="headerlink" title="数据类型和使用场景"></a>数据类型和使用场景</h3><p>Redis 提供了丰富的数据类型，常见的有五种数据类型：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。</p>
<p>随着 Redis 版本的更新，后面又支持了四种数据类型： BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</li>
<li>List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li>
<li>Hash 类型：缓存对象、购物车等。</li>
<li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li>
<li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li>
<li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li>
<li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li>
<li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li>
<li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。</li>
</ul>
<h3 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h3><p>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」这个过程是由一个线程（主线程）来完成的</p>
<h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><ul>
<li>AOF 日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li>
<li>RDB 快照：将某一时刻的内存数据，以二进制的方式写入磁盘；</li>
<li>混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；</li>
</ul>
<h3 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h3><h4 id="如何实现服务高可用"><a href="#如何实现服务高可用" class="headerlink" title="如何实现服务高可用"></a>如何实现服务高可用</h4><ul>
<li>主从复制：主从复制是 Redis 高可用服务的最基础的保证，实现方案就是将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式，且主从服务器之间采用的是「读写分离」的方式。主服务器可以进行读写操作，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。</li>
<li>哨兵模式：在使用 Redis 主从服务的时候，会有一个问题，就是当 Redis 的主从服务器出现故障宕机时，需要手动进行恢复。为了解决这个问题，Redis 增加了哨兵模式（Redis Sentinel），因为哨兵模式做到了可以监控主从服务器，并且提供主从节点故障转移的功能。</li>
<li>切片集群模式：当 Redis 缓存数据量大到一台服务器无法缓存时，就需要使用 Redis 切片集群（Redis Cluster ）方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</li>
</ul>
<h3 id="如何避免缓存雪崩"><a href="#如何避免缓存雪崩" class="headerlink" title="如何避免缓存雪崩"></a>如何避免缓存雪崩</h3><ul>
<li>将缓存失效时间随机打散： 我们可以在原有的失效时间基础上增加一个随机值（比如 1 到 10 分钟）这样每个缓存的过期时间都不重复了，也就降低了缓存集体失效的概率。</li>
<li>设置缓存不过期： 我们可以通过后台服务来更新缓存数据，从而避免因为缓存失效造成的缓存雪崩，也可以在一定程度上避免缓存并发问题。</li>
</ul>
<h3 id="如何避免缓存击穿"><a href="#如何避免缓存击穿" class="headerlink" title="如何避免缓存击穿"></a>如何避免缓存击穿</h3><ul>
<li>互斥锁方案（Redis 中使用 setNX 方法设置一个状态位，表示这是一种锁定状态），保证同一时间只有一个业务线程请求缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li>
<li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li>
</ul>
<h3 id="热点数据动态缓存策略"><a href="#热点数据动态缓存策略" class="headerlink" title="热点数据动态缓存策略"></a>热点数据动态缓存策略</h3><p>热点数据动态缓存的策略总体思路：通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据。</p>
<h3 id="故障转移选取新的master的标准是什么"><a href="#故障转移选取新的master的标准是什么" class="headerlink" title="故障转移选取新的master的标准是什么"></a>故障转移选取新的master的标准是什么</h3><ul>
<li>与master断开的时常：slave与master的断开时长超过了down-after-milliseconds的10倍</li>
<li>slave优先级：优先级高的先被选</li>
<li>优先级相同: slave复制数据多的作为master</li>
<li>以上都相同，选择run id小的</li>
</ul>
<h2 id="分布式问题"><a href="#分布式问题" class="headerlink" title="分布式问题"></a>分布式问题</h2><h3 id="需要满足的特性"><a href="#需要满足的特性" class="headerlink" title="需要满足的特性"></a>需要满足的特性</h3><ul>
<li>互斥性：对同一条数据，智能有一台应用能够拿到锁</li>
<li>高可用性：分布式锁的服务以集群的方式部署</li>
<li>防止锁超时：用户不主动释放，则过一段时间就自动释放，防止死锁</li>
<li>独占性：加锁和解锁必须由一台服务器进行，谁加的锁，谁解</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/10/11/spring-security-%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/" rel="prev" title="spring security 开发过程记录">
                  <i class="fa fa-chevron-left"></i> spring security 开发过程记录
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/12/27/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93/" rel="next" title="多智能体">
                  多智能体 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Weirdo</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"weirdoblog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
